//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_c "archive/zip";_ee "bytes";_efa "errors";_fc "fmt";_a "github.com/unidoc/unioffice";_be "github.com/unidoc/unioffice/chart";_de "github.com/unidoc/unioffice/color";_fe "github.com/unidoc/unioffice/common";_cca "github.com/unidoc/unioffice/common/tempstorage";_dd "github.com/unidoc/unioffice/internal/license";_bb "github.com/unidoc/unioffice/measurement";_deb "github.com/unidoc/unioffice/schema/soo/dml";_cd "github.com/unidoc/unioffice/schema/soo/dml/chart";_cg "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_ga "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_cdc "github.com/unidoc/unioffice/schema/soo/sml";_dfd "github.com/unidoc/unioffice/spreadsheet/format";_bf "github.com/unidoc/unioffice/spreadsheet/formula";_gc "github.com/unidoc/unioffice/spreadsheet/reference";_ge "github.com/unidoc/unioffice/spreadsheet/update";_cf "github.com/unidoc/unioffice/vmldrawing";_dc "github.com/unidoc/unioffice/zippkg";_g "image";_ae "image/jpeg";_b "io";_ac "log";_ef "math";_cab "math/big";_gd "os";_df "path";_db "path/filepath";_eb "regexp";_e "sort";_cc "strconv";_f "strings";_ca "time";);func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_aeea :=NumberFormat {_dcf :_cdc .NewCT_NumFmt ()};_aeea ._dcf .NumFmtIdAttr =uint32 (id );_aeea ._dcf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_aeea ._dcf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_aeea ._dcf .FormatCodeAttr ="\u0030";case StandardFormat2 :_aeea ._dcf .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_aeea ._dcf .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_aeea ._dcf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_aeea ._dcf .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_aeea ._dcf .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_aeea ._dcf .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_aeea ._dcf .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_aeea ._dcf .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_aeea ._dcf .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_aeea ._dcf .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_aeea ._dcf .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_aeea ._dcf .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_aeea ._dcf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_aeea ._dcf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_aeea ._dcf .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_aeea ._dcf .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_aeea ._dcf .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_aeea ._dcf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_aeea ._dcf .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_aeea ._dcf .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_aeea ._dcf .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_aeea ._dcf .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_aeea ._dcf .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_aeea ._dcf .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_aeea ._dcf .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_aeea ._dcf .FormatCodeAttr ="\u0040";};return _aeea ;};

// DataValidation controls cell validation
type DataValidation struct{_bcc *_cdc .CT_DataValidation };

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_bfgd CellStyle )GetVerticalAlignment ()_cdc .ST_VerticalAlignment {if _bfgd ._eae .Alignment ==nil {return _cdc .ST_VerticalAlignmentUnset ;};return _bfgd ._eae .Alignment .VerticalAttr ;};

// GetFilename returns the filename of the context's workbook.
func (_dfcd *evalContext )GetFilename ()string {return _dfcd ._dbe ._bbfc .GetFilename ()};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_dba *_cg .CT_AbsoluteAnchor };

// X returns the inner wrapped XML type.
func (_bbad Comment )X ()*_cdc .CT_Comment {return _bbad ._cgce };func NewFills ()Fills {return Fills {_cdc .NewCT_Fills ()}};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_efca *Sheet )AddNumberedRow (rowNum uint32 )Row {_caac :=_cdc .NewCT_Row ();_caac .RAttr =_a .Uint32 (rowNum );_efca ._gaec .SheetData .Row =append (_efca ._gaec .SheetData .Row ,_caac );_e .Slice (_efca ._gaec .SheetData .Row ,func (_acf ,_aggf int )bool {_cae :=_efca ._gaec .SheetData .Row [_acf ].RAttr ;_fcbg :=_efca ._gaec .SheetData .Row [_aggf ].RAttr ;if _cae ==nil {return true ;};if _fcbg ==nil {return true ;};return *_cae < *_fcbg ;});return Row {_efca ._bbfc ,_efca ,_caac };};func (_eeg CellStyle )Index ()uint32 {for _dbd ,_aef :=range _eeg ._gfg .Xf {if _eeg ._eae ==_aef {return uint32 (_dbd );};};return 0;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetAllowBlank controls if blank values are accepted.
func (_bdg DataValidation )SetAllowBlank (b bool ){if !b {_bdg ._bcc .AllowBlankAttr =nil ;}else {_bdg ._bcc .AllowBlankAttr =_a .Bool (true );};};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_gafe *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_f .Replace (rangeRef ,"\u0024","",-1);_gafe ._gaec .AutoFilter =_cdc .NewCT_AutoFilter ();_gafe ._gaec .AutoFilter .RefAttr =_a .String (rangeRef );_fcdd :="\u0027"+_gafe .Name ()+"\u0027\u0021";var _ffdf DefinedName ;for _ ,_gca :=range _gafe ._bbfc .DefinedNames (){if _gca .Name ()==_faaa {if _f .HasPrefix (_gca .Content (),_fcdd ){_ffdf =_gca ;_ffdf .SetContent (_gafe .RangeReference (rangeRef ));break ;};};};if _ffdf .X ()==nil {_ffdf =_gafe ._bbfc .AddDefinedName (_faaa ,_gafe .RangeReference (rangeRef ));};for _daeb ,_gcac :=range _gafe ._bbfc ._gbfaa {if _gcac ==_gafe ._gaec {_ffdf .SetLocalSheetID (uint32 (_daeb ));};};};

// SetHeightCells is a no-op.
func (_aaea OneCellAnchor )SetHeightCells (int32 ){};func (_fge Font )SetName (name string ){_fge ._bgag .Name =[]*_cdc .CT_FontName {{ValAttr :name }}};

// GetFont gets a Font from a cell style.
func (_ddd CellStyle )GetFont ()*_cdc .CT_Font {if _gccg :=_ddd ._eae .FontIdAttr ;_gccg !=nil {_efc :=_ddd ._ceg .StyleSheet .Fonts ();if int (*_gccg )< len (_efc ){return _efc [int (*_gccg )].X ();};};return nil ;};type PatternFill struct{_gffg *_cdc .CT_PatternFill ;_bcec *_cdc .CT_Fill ;};func (_agbd Fill )Index ()uint32 {if _agbd ._ccf ==nil {return 0;};for _ebe ,_dbaf :=range _agbd ._ccf .Fill {if _agbd ._cbec ==_dbaf {return uint32 (_ebe );};};return 0;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_abe Cell )GetValueAsTime ()(_ca .Time ,error ){if _abe ._eeb .TAttr !=_cdc .ST_CellTypeUnset {return _ca .Time {},_efa .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _abe ._eeb .V ==nil {return _ca .Time {},_efa .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_edg ,_ ,_bee :=_cab .ParseFloat (*_abe ._eeb .V ,10,128,_cab .ToNearestEven );if _bee !=nil {return _ca .Time {},_bee ;};_ebg :=new (_cab .Float );_ebg .SetUint64 (uint64 (24*_ca .Hour ));_edg .Mul (_edg ,_ebg );_bcg ,_ :=_edg .Uint64 ();_aee :=_abe ._ffb .Epoch ().Add (_ca .Duration (_bcg ));return _afea (_aee ),nil ;};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_ccef StyleSheet )AddCellStyle ()CellStyle {_acdf :=_cdc .NewCT_Xf ();_ccef ._ccbbd .CellXfs .Xf =append (_ccef ._ccbbd .CellXfs .Xf ,_acdf );_ccef ._ccbbd .CellXfs .CountAttr =_a .Uint32 (uint32 (len (_ccef ._ccbbd .CellXfs .Xf )));return CellStyle {_ccef ._gcbf ,_acdf ,_ccef ._ccbbd .CellXfs };};

// ClearBorder clears any border configuration from the cell style.
func (_egf CellStyle )ClearBorder (){_egf ._eae .BorderIdAttr =nil ;_egf ._eae .ApplyBorderAttr =nil };func (_dbageg *Sheet )removeColumnFromNamedRanges (_cdeaf uint32 )error {for _ ,_ffce :=range _dbageg ._bbfc .DefinedNames (){_agfc :=_ffce .Name ();_becb :=_ffce .Content ();_bbca :=_f .Split (_becb ,"\u0021");if len (_bbca )!=2{return _efa .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_becb );};_dagef :=_bbca [0];if _dbageg .Name ()==_dagef {_fecfd :=_dbageg ._bbfc .RemoveDefinedName (_ffce );if _fecfd !=nil {return _fecfd ;};_dgdf :=_abda (_bbca [1],_cdeaf ,true );if _dgdf !=""{_caea :=_dagef +"\u0021"+_dgdf ;_dbageg ._bbfc .AddDefinedName (_agfc ,_caea );};};};_eecdg :=0;if _dbageg ._gaec .TableParts !=nil &&_dbageg ._gaec .TableParts .TablePart !=nil {_eecdg =len (_dbageg ._gaec .TableParts .TablePart );};if _eecdg !=0{_dcga :=0;for _ ,_adec :=range _dbageg ._bbfc .Sheets (){if _adec .Name ()==_dbageg .Name (){break ;}else {if _adec ._gaec .TableParts !=nil &&_adec ._gaec .TableParts .TablePart !=nil {_dcga +=len (_adec ._gaec .TableParts .TablePart );};};};_eacb :=_dbageg ._bbfc ._bgea [_dcga :_dcga +_eecdg ];for _eade ,_cdad :=range _eacb {_bcfa :=_cdad ;_bcfa .RefAttr =_abda (_bcfa .RefAttr ,_cdeaf ,false );_dbageg ._bbfc ._bgea [_dcga +_eade ]=_bcfa ;};};return nil ;};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_egdb StyleSheet )Fills ()Fills {return Fills {_egdb ._ccbbd .Fills }};

// SetFill applies a fill to a cell style. The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_bba CellStyle )SetFill (f Fill ){_bba ._eae .FillIdAttr =_a .Uint32 (f .Index ());_bba ._eae .ApplyFillAttr =_a .Bool (true );};func (_bfag Border )SetRight (style _cdc .ST_BorderStyle ,c _de .Color ){if _bfag ._eca .Right ==nil {_bfag ._eca .Right =_cdc .NewCT_BorderPr ();};_bfag ._eca .Right .Color =_cdc .NewCT_Color ();_bfag ._eca .Right .Color .RgbAttr =c .AsRGBAString ();_bfag ._eca .Right .StyleAttr =style ;};

// X returns the inner wrapped XML type.
func (_cedb Drawing )X ()*_cg .WsDr {return _cedb ._efcc };

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_eda ConditionalFormattingRule )SetDataBar ()DataBarScale {_eda .clear ();_eda .SetType (_cdc .ST_CfTypeDataBar );_eda ._aca .DataBar =_cdc .NewCT_DataBar ();_dda :=DataBarScale {_eda ._aca .DataBar };_dda .SetShowValue (true );_dda .SetMinLength (10);_dda .SetMaxLength (90);return _dda ;};

// Cell is a single cell within a sheet.
type Cell struct{_ffb *Workbook ;_fd *Sheet ;_dgc *_cdc .CT_Row ;_eeb *_cdc .CT_Cell ;};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_agde *Sheet )InsertRow (rowNum int )Row {_ddbc :=uint32 (rowNum );for _ ,_dabb :=range _agde .Rows (){if _dabb ._gdgc .RAttr !=nil &&*_dabb ._gdgc .RAttr >=_ddbc {*_dabb ._gdgc .RAttr ++;for _ ,_cced :=range _dabb .Cells (){_gfda ,_cfca :=_gc .ParseCellReference (_cced .Reference ());if _cfca !=nil {continue ;};_gfda .RowIdx ++;_cced ._eeb .RAttr =_a .String (_gfda .String ());};};};for _ ,_gbfd :=range _agde .MergedCells (){_cgcd ,_fceg ,_agdb :=_gc .ParseRangeReference (_gbfd .Reference ());if _agdb !=nil {continue ;};if int (_cgcd .RowIdx )>=rowNum {_cgcd .RowIdx ++;};if int (_fceg .RowIdx )>=rowNum {_fceg .RowIdx ++;};_gcfe :=_fc .Sprintf ("\u0025\u0073\u003a%\u0073",_cgcd ,_fceg );_gbfd .SetReference (_gcfe );};return _agde .AddNumberedRow (_ddbc );};

// GetValueAsNumber retrieves the cell's value as a number
func (_fecg Cell )GetValueAsNumber ()(float64 ,error ){if _fecg ._eeb .V ==nil &&_fecg ._eeb .Is ==nil {return 0,nil ;};if _fecg ._eeb .TAttr ==_cdc .ST_CellTypeS ||!_dfd .IsNumber (*_fecg ._eeb .V ){return _ef .NaN (),_efa .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _cc .ParseFloat (*_fecg ._eeb .V ,64);};func (_gcgb Sheet )validateRowCellNumbers ()error {_efdc :=map[uint32 ]struct{}{};for _ ,_bdgg :=range _gcgb ._gaec .SheetData .Row {if _bdgg .RAttr !=nil {if _ ,_eabg :=_efdc [*_bdgg .RAttr ];_eabg {return _fc .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_gcgb .Name (),*_bdgg .RAttr );};_efdc [*_bdgg .RAttr ]=struct{}{};};_fefg :=map[string ]struct{}{};for _ ,_abfae :=range _bdgg .C {if _abfae .RAttr ==nil {continue ;};if _ ,_bace :=_fefg [*_abfae .RAttr ];_bace {return _fc .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_gcgb .Name (),*_abfae .RAttr );};_fefg [*_abfae .RAttr ]=struct{}{};};};return nil ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_dgbc *Workbook )DefinedNames ()[]DefinedName {if _dgbc ._gfdg .DefinedNames ==nil {return nil ;};_ffaae :=[]DefinedName {};for _ ,_dgfb :=range _dgbc ._gfdg .DefinedNames .DefinedName {_ffaae =append (_ffaae ,DefinedName {_dgfb });};return _ffaae ;};

// IsNumber returns true if the cell is a number type cell.
func (_cag Cell )IsNumber ()bool {switch _cag ._eeb .TAttr {case _cdc .ST_CellTypeN :return true ;case _cdc .ST_CellTypeS ,_cdc .ST_CellTypeB :return false ;};return _cag ._eeb .V !=nil &&_dfd .IsNumber (*_cag ._eeb .V );};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_eee Cell )SetTime (d _ca .Time ){_eee .clearValue ();d =_edff (d );_cebc :=_eee ._ffb .Epoch ();if d .Before (_cebc ){_a .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_ege :=d .Sub (_cebc );_agb :=new (_cab .Float );_bbeg :=new (_cab .Float );_bbeg .SetPrec (128);_bbeg .SetUint64 (uint64 (_ege ));_geb :=new (_cab .Float );_geb .SetUint64 (24*60*60*1e9);_agb .Quo (_bbeg ,_geb );_eee ._eeb .V =_a .String (_agb .Text ('g',20));};const (DVCompareTypeWholeNumber =DVCompareType (_cdc .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_cdc .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_cdc .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_cdc .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_cdc .ST_DataValidationTypeTextLength ););

// SetIcons sets the icon set to use for display.
func (_ggdc IconScale )SetIcons (t _cdc .ST_IconSetType ){_ggdc ._cbdd .IconSetAttr =t };

// SetMinLength sets the minimum bar length in percent.
func (_dab DataBarScale )SetMinLength (l uint32 ){_dab ._fga .MinLengthAttr =_a .Uint32 (l )};

// AddRule adds and returns a new rule that can be configured.
func (_cdf ConditionalFormatting )AddRule ()ConditionalFormattingRule {_beb :=_cdc .NewCT_CfRule ();_cdf ._afd .CfRule =append (_cdf ._afd .CfRule ,_beb );_fcef :=ConditionalFormattingRule {_beb };_fcef .InitializeDefaults ();_fcef .SetPriority (int32 (len (_cdf ._afd .CfRule )+1));return _fcef ;};

// SetName sets the sheet name.
func (_gafa *Sheet )SetName (name string ){_gafa ._abaa .NameAttr =name };

// Rows returns all of the rows in a sheet.
func (_ccgcc *Sheet )Rows ()[]Row {_afab :=[]Row {};for _ ,_eeeg :=range _ccgcc ._gaec .SheetData .Row {_afab =append (_afab ,Row {_ccgcc ._bbfc ,_ccgcc ,_eeeg });};return _afab ;};

// IsEmpty returns true if the cell is empty.
func (_ddc Cell )IsEmpty ()bool {return _ddc ._eeb .TAttr ==_cdc .ST_CellTypeUnset &&_ddc ._eeb .V ==nil &&_ddc ._eeb .F ==nil ;};

// SetPassword sets the password hash to a hash of the input password.
func (_dgcc SheetProtection )SetPassword (pw string ){_dgcc .SetPasswordHash (PasswordHash (pw ))};

// MoveTo is a no-op.
func (_ded AbsoluteAnchor )MoveTo (x ,y int32 ){};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_gda DataValidationCompare )SetValue (v string ){_gda ._fcfa .Formula1 =&v };func _daa ()*_cg .CT_TwoCellAnchor {_ccbb :=_cg .NewCT_TwoCellAnchor ();_ccbb .EditAsAttr =_cg .ST_EditAsOneCell ;_ccbb .From .Col =5;_ccbb .From .Row =0;_ccbb .From .ColOff .ST_CoordinateUnqualified =_a .Int64 (0);_ccbb .From .RowOff .ST_CoordinateUnqualified =_a .Int64 (0);_ccbb .To .Col =10;_ccbb .To .Row =20;_ccbb .To .ColOff .ST_CoordinateUnqualified =_a .Int64 (0);_ccbb .To .RowOff .ST_CoordinateUnqualified =_a .Int64 (0);return _ccbb ;};

// SetType sets the type of the rule.
func (_degd ConditionalFormattingRule )SetType (t _cdc .ST_CfType ){_degd ._aca .TypeAttr =t };

// Reference returns the region of cells that are merged.
func (_aaeb MergedCell )Reference ()string {return _aaeb ._aafa .RefAttr };

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ffd CellStyle )SetHorizontalAlignment (a _cdc .ST_HorizontalAlignment ){if _ffd ._eae .Alignment ==nil {_ffd ._eae .Alignment =_cdc .NewCT_CellAlignment ();};_ffd ._eae .Alignment .HorizontalAttr =a ;_ffd ._eae .ApplyAlignmentAttr =_a .Bool (true );};

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_abee Cell )SetStyle (cs CellStyle ){_abee .SetStyleIndex (cs .Index ())};

// X returns the inner wrapped XML type.
func (_gfgc DataBarScale )X ()*_cdc .CT_DataBar {return _gfgc ._fga };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_caeb TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_caeb ._bfage .To }};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gff Comment )SetCellReference (cellRef string ){_gff ._cgce .RefAttr =cellRef };

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_bacbd *Workbook )Close ()error {if _bacbd .TmpPath !=""{return _cca .RemoveAll (_bacbd .TmpPath );};return nil ;};

// Type returns the type of anchor
func (_fbf OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };func _edff (_bc _ca .Time )_ca .Time {_bc =_bc .Local ();return _ca .Date (_bc .Year (),_bc .Month (),_bc .Day (),_bc .Hour (),_bc .Minute (),_bc .Second (),_bc .Nanosecond (),_ca .UTC );};

// X returns the inner wrapped XML type.
func (_bcfd IconScale )X ()*_cdc .CT_IconSet {return _bcfd ._cbdd };

// X returns the inner wrapped XML type.
func (_fbad MergedCell )X ()*_cdc .CT_MergeCell {return _fbad ._aafa };

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_afg Comment )CellReference ()string {return _afg ._cgce .RefAttr };

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};const (_fdabb ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_bdgc ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_fgeg ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_cfae ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);func (_efea CellStyle )SetShrinkToFit (b bool ){if _efea ._eae .Alignment ==nil {_efea ._eae .Alignment =_cdc .NewCT_CellAlignment ();};_efea ._eae .ApplyAlignmentAttr =_a .Bool (true );if !b {_efea ._eae .Alignment .ShrinkToFitAttr =nil ;}else {_efea ._eae .Alignment .ShrinkToFitAttr =_a .Bool (b );};};

// SetWidth is a no-op.
func (_ecgfe TwoCellAnchor )SetWidth (w _bb .Distance ){};

// TopLeft is a no-op.
func (_ff AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// ExtractText returns text from the sheet as a SheetText object.
func (_ccbbe *Sheet )ExtractText ()*SheetText {_befd :=[]CellText {};for _ ,_aeg :=range _ccbbe .Rows (){for _ ,_gdge :=range _aeg .Cells (){if !_gdge .IsEmpty (){if _gebe :=_gdge .GetFormattedValue ();_gebe !=""{_befd =append (_befd ,CellText {Text :_gebe ,Cell :_gdge });};};};};return &SheetText {Cells :_befd };};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_dedb Row )RowNumber ()uint32 {if _dedb ._gdgc .RAttr !=nil {return *_dedb ._gdgc .RAttr ;};return 0;};func (_effc *evalContext )SetOffset (col ,row uint32 ){_effc ._gfa =col ;_effc ._agbc =row };

// X returns the inner wrapped XML type.
func (_eaff ConditionalFormatting )X ()*_cdc .CT_ConditionalFormatting {return _eaff ._afd };

// X returns the inner wrapped XML type.
func (_fce CellMarker )X ()*_cg .CT_Marker {return _fce ._cde };func (_bfe Cell )getLabelPrefix ()string {if _bfe ._eeb .SAttr ==nil {return "";};_bff :=*_bfe ._eeb .SAttr ;_eg :=_bfe ._ffb .StyleSheet .GetCellStyle (_bff );switch _eg ._eae .Alignment .HorizontalAttr {case _cdc .ST_HorizontalAlignmentLeft :return "\u0027";case _cdc .ST_HorizontalAlignmentRight :return "\u0022";case _cdc .ST_HorizontalAlignmentCenter :return "\u005e";case _cdc .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};func (_dbae Border )SetTop (style _cdc .ST_BorderStyle ,c _de .Color ){if _dbae ._eca .Top ==nil {_dbae ._eca .Top =_cdc .NewCT_BorderPr ();};_dbae ._eca .Top .Color =_cdc .NewCT_Color ();_dbae ._eca .Top .Color .RgbAttr =c .AsRGBAString ();_dbae ._eca .Top .StyleAttr =style ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_aad ,_bcff :=_gd .Open (filename );if _bcff !=nil {return nil ,_fc .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_bcff );};defer _aad .Close ();_adca ,_bcff :=_gd .Stat (filename );if _bcff !=nil {return nil ,_fc .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_bcff );};_dffb ,_bcff :=Read (_aad ,_adca .Size ());if _bcff !=nil {return nil ,_bcff ;};_fcac ,_ :=_db .Abs (_db .Dir (filename ));_dffb ._deff =_db .Join (_fcac ,filename );return _dffb ,nil ;};

// SetHidden controls the visibility of a column.
func (_bga Column )SetHidden (b bool ){if !b {_bga ._ebb .HiddenAttr =nil ;}else {_bga ._ebb .HiddenAttr =_a .Bool (true );};};

// SetColOffset sets the column offset of the two cell anchor.
func (_bcgg TwoCellAnchor )SetColOffset (m _bb .Distance ){_ffgb :=m -_bcgg .TopLeft ().ColOffset ();_bcgg .TopLeft ().SetColOffset (m );_bcgg .BottomRight ().SetColOffset (_bcgg .BottomRight ().ColOffset ()+_ffgb );};

// Type returns the type of anchor
func (_cbae TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_cfbc ConditionalFormattingRule )SetColorScale ()ColorScale {_cfbc .clear ();_cfbc .SetType (_cdc .ST_CfTypeColorScale );_cfbc ._aca .ColorScale =_cdc .NewCT_ColorScale ();return ColorScale {_cfbc ._aca .ColorScale };};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_ceg *Workbook ;_eae *_cdc .CT_Xf ;_gfg *_cdc .CT_CellXfs ;};func (_ggg PatternFill )X ()*_cdc .CT_PatternFill {return _ggg ._gffg };func (_fcce *evalContext )Cell (ref string ,ev _bf .Evaluator )_bf .Result {if !_efd (ref ){return _bf .MakeErrorResultType (_bf .ErrorTypeName ,"");};_dcd :=_fcce ._dbe .Name ()+"\u0021"+ref ;if _fbb ,_eeec :=ev .GetFromCache (_dcd );_eeec {return _fbb ;};_gae ,_dbg :=_gc .ParseCellReference (ref );if _dbg !=nil {return _bf .MakeErrorResult (_fc .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_dbg ));};if _fcce ._gfa !=0&&!_gae .AbsoluteColumn {_gae .ColumnIdx +=_fcce ._gfa ;_gae .Column =_gc .IndexToColumn (_gae .ColumnIdx );};if _fcce ._agbc !=0&&!_gae .AbsoluteRow {_gae .RowIdx +=_fcce ._agbc ;};_dbee :=_fcce ._dbe .Cell (_gae .String ());if _dbee .HasFormula (){if _ ,_dce :=_fcce ._caae [ref ];_dce {return _bf .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_fcce ._caae [ref ]=struct{}{};_edfa :=ev .Eval (_fcce ,_dbee .GetFormula ());delete (_fcce ._caae ,ref );ev .SetCache (_dcd ,_edfa );return _edfa ;};if _dbee .IsEmpty (){_dbbg :=_bf .MakeEmptyResult ();ev .SetCache (_dcd ,_dbbg );return _dbbg ;}else if _dbee .IsNumber (){_eecbg ,_ :=_dbee .GetValueAsNumber ();_egc :=_bf .MakeNumberResult (_eecbg );ev .SetCache (_dcd ,_egc );return _egc ;}else if _dbee .IsBool (){_fdgb ,_ :=_dbee .GetValueAsBool ();_cgd :=_bf .MakeBoolResult (_fdgb );ev .SetCache (_dcd ,_cgd );return _cgd ;};_ebdb ,_ :=_dbee .GetRawValue ();if _dbee .IsError (){_geg :=_bf .MakeErrorResult ("");_geg .ValueString =_ebdb ;ev .SetCache (_dcd ,_geg );return _geg ;};_bbfa :=_bf .MakeStringResult (_ebdb );ev .SetCache (_dcd ,_bbfa );return _bbfa ;};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_fegf PatternFill )SetFgColor (c _de .Color ){_fegf ._gffg .FgColor =_cdc .NewCT_Color ();_fegf ._gffg .FgColor .RgbAttr =c .AsRGBAString ();};func (_dbaff Font )SetSize (size float64 ){_dbaff ._bgag .Sz =[]*_cdc .CT_FontSize {{ValAttr :size }}};

// Cell returns the actual cell behind the merged region
func (_aecf MergedCell )Cell ()Cell {_bec :=_aecf .Reference ();if _ffaa :=_f .Index (_aecf .Reference (),"\u003a");_ffaa !=-1{_bec =_bec [0:_ffaa ];return _aecf ._fff .Cell (_bec );};return Cell {};};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_cage Sheet )Validate ()error {_edffe :=[]func ()error {_cage .validateRowCellNumbers ,_cage .validateMergedCells ,_cage .validateSheetNames };for _ ,_gdbf :=range _edffe {if _ffff :=_gdbf ();_ffff !=nil {return _ffff ;};};if _bgad :=_cage ._gaec .Validate ();_bgad !=nil {return _bgad ;};return _cage ._gaec .Validate ();};func _gbg (_aaab bool )int {if _aaab {return 1;};return 0;};

// Content returns the content of the defined range (the range in most cases)/
func (_eaa DefinedName )Content ()string {return _eaa ._cadb .Content };

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_bbgcb *Sheet )ClearCachedFormulaResults (){for _ ,_ece :=range _bbgcb .Rows (){for _ ,_gbfa :=range _ece .Cells (){if _gbfa .X ().F !=nil {_gbfa .X ().V =nil ;};};};};

// X returns the inner wrapped XML type.
func (_aeb Comments )X ()*_cdc .Comments {return _aeb ._aec };

// SetFont applies a font to a cell style. The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_agce CellStyle )SetFont (f Font ){_agce ._eae .FontIdAttr =_a .Uint32 (f .Index ());_agce ._eae .ApplyFontAttr =_a .Bool (true );};

// Operator returns the operator for the rule
func (_ddbe ConditionalFormattingRule )Operator ()_cdc .ST_ConditionalFormattingOperator {return _ddbe ._aca .OperatorAttr ;};

// GetFormat returns a cell data format.
func (_agee *evalContext )GetFormat (cellRef string )string {return _agee ._dbe .Cell (cellRef ).getFormat ();};

// IsWindowLocked returns whether the workbook windows are locked.
func (_geed WorkbookProtection )IsWindowLocked ()bool {return _geed ._bgdb .LockWindowsAttr !=nil &&*_geed ._bgdb .LockWindowsAttr ;};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_fccg ColorScale )AddFormatValue (t _cdc .ST_CfvoType ,val string ){_cfb :=_cdc .NewCT_Cfvo ();_cfb .TypeAttr =t ;_cfb .ValAttr =_a .String (val );_fccg ._cba .Cfvo =append (_fccg ._cba .Cfvo ,_cfb );};var _ffe []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};type Fills struct{_gga *_cdc .CT_Fills };func (_acbc *Sheet )removeColumnFromMergedCells (_aggeb uint32 )error {if _acbc ._gaec .MergeCells ==nil ||_acbc ._gaec .MergeCells .MergeCell ==nil {return nil ;};_dcac :=[]*_cdc .CT_MergeCell {};for _ ,_gdbde :=range _acbc .MergedCells (){_cccc :=_abda (_gdbde .Reference (),_aggeb ,true );if _cccc !=""{_gdbde .SetReference (_cccc );_dcac =append (_dcac ,_gdbde .X ());};};_acbc ._gaec .MergeCells .MergeCell =_dcac ;return nil ;};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_agbb *Workbook )RemoveSheetByName (name string )error {_bfaag :=-1;for _dbbd ,_gcfb :=range _agbb .Sheets (){if name ==_gcfb .Name (){_bfaag =_dbbd ;break ;};};if _bfaag ==-1{return ErrorNotFound ;};return _agbb .RemoveSheet (_bfaag );};func (_cfge Font )SetItalic (b bool ){if b {_cfge ._bgag .I =[]*_cdc .CT_BooleanProperty {{}};}else {_cfge ._bgag .I =nil ;};};

// X returns the inner wrapped XML type.
func (_cfe SharedStrings )X ()*_cdc .Sst {return _cfe ._faedb };

// SetHidden marks the defined name as hidden.
func (_afcf DefinedName )SetHidden (b bool ){_afcf ._cadb .HiddenAttr =_a .Bool (b )};func (_dbage PatternFill )SetBgColor (c _de .Color ){_dbage ._gffg .BgColor =_cdc .NewCT_Color ();_dbage ._gffg .BgColor .RgbAttr =c .AsRGBAString ();};

// X returns the inner wrapped XML type.
func (_ecdf DataValidation )X ()*_cdc .CT_DataValidation {return _ecdf ._bcc };

// SetInlineString adds a string inline instead of in the shared strings table.
func (_ebf Cell )SetInlineString (s string ){_ebf .clearValue ();_ebf ._eeb .Is =_cdc .NewCT_Rst ();_ebf ._eeb .Is .T =_a .String (s );_ebf ._eeb .TAttr =_cdc .ST_CellTypeInlineStr ;};

// SetPattern sets the pattern of the fill.
func (_afaf PatternFill )SetPattern (p _cdc .ST_PatternType ){_afaf ._gffg .PatternTypeAttr =p };func (_dff Cell )getLocked ()bool {if _dff ._eeb .SAttr ==nil {return false ;};_feca :=*_dff ._eeb .SAttr ;_cgf :=_dff ._ffb .StyleSheet .GetCellStyle (_feca );return *_cgf ._eae .Protection .LockedAttr ;};func (_edfc SortOrder )String ()string {if _edfc >=SortOrder (len (_gfde )-1){return _fc .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_edfc );};return _egfa [_gfde [_edfc ]:_gfde [_edfc +1]];};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_ffab *Sheet )ClearSheetViews (){_ffab ._gaec .SheetViews =nil };func (_bea DifferentialStyle )Fill ()Fill {if _bea ._bfde .Fill ==nil {_bea ._bfde .Fill =_cdc .NewCT_Fill ();};return Fill {_bea ._bfde .Fill ,nil };};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_edb *evalContext )LastRow (col string )int {_gdbd :=_edb ._dbe ;_bfagc :=int (_gc .ColumnToIndex (col ));_fdab :=1;for _ ,_cbde :=range _gdbd ._gaec .SheetData .Row {if _cbde .RAttr !=nil {_dbbea :=Row {_gdbd ._bbfc ,_gdbd ,_cbde };_gged :=len (_dbbea .Cells ());if _gged > _bfagc {_fdab =int (_dbbea .RowNumber ());};};};return _fdab ;};

// SetFormat sets the number format code.
func (_aagg NumberFormat )SetFormat (f string ){_aagg ._dcf .FormatCodeAttr =f };

// GetBorder gets a Border from a cell style.
func (_gbd CellStyle )GetBorder ()*_cdc .CT_Border {if _ccb :=_gbd ._eae .BorderIdAttr ;_ccb !=nil {_bae :=_gbd ._ceg .StyleSheet .Borders ();if int (*_ccb )< len (_bae ){return _bae [int (*_ccb )].X ();};};return nil ;};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_bccf *Sheet )GetDrawing ()(*_cg .WsDr ,_fe .Relationships ){if _ffdag :=_bccf ._gaec .Drawing ;_ffdag !=nil {_cbdbg :=0;for _ ,_gebc :=range _bccf ._bbfc ._gbfaa {if _faa :=_gebc .Drawing ;_faa !=nil {if _gebc ==_bccf ._gaec {return _bccf ._bbfc ._fddb [_cbdbg ],_bccf ._bbfc ._afegb [_cbdbg ];};_cbdbg ++;};};};return nil ,_fe .Relationships {};};

// Row is a row within a spreadsheet.
type Row struct{_ceaf *Workbook ;_dfg *Sheet ;_gdgc *_cdc .CT_Row ;};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_begg *Workbook )AddDefinedName (name ,ref string )DefinedName {if _begg ._gfdg .DefinedNames ==nil {_begg ._gfdg .DefinedNames =_cdc .NewCT_DefinedNames ();};_eeba :=_cdc .NewCT_DefinedName ();_eeba .Content =ref ;_eeba .NameAttr =name ;_begg ._gfdg .DefinedNames .DefinedName =append (_begg ._gfdg .DefinedNames .DefinedName ,_eeba );return DefinedName {_eeba };};func (_fgfc *Workbook )onNewRelationship (_dged *_dc .DecodeMap ,_cbcf ,_feae string ,_egde []*_c .File ,_fddg *_ga .Relationship ,_eed _dc .Target )error {_dbfa :=_a .DocTypeSpreadsheet ;switch _feae {case _a .OfficeDocumentType :_fgfc ._gfdg =_cdc .NewWorkbook ();_dged .AddTarget (_cbcf ,_fgfc ._gfdg ,_feae ,0);_fgfc ._bfec =_fe .NewRelationships ();_dged .AddTarget (_dc .RelationsPathFor (_cbcf ),_fgfc ._bfec .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .CorePropertiesType :_dged .AddTarget (_cbcf ,_fgfc .CoreProperties .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .CustomPropertiesType :_dged .AddTarget (_cbcf ,_fgfc .CustomProperties .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .ExtendedPropertiesType :_dged .AddTarget (_cbcf ,_fgfc .AppProperties .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .WorksheetType :_cbfab :=_cdc .NewWorksheet ();_efga :=uint32 (len (_fgfc ._gbfaa ));_fgfc ._gbfaa =append (_fgfc ._gbfaa ,_cbfab );_dged .AddTarget (_cbcf ,_cbfab ,_feae ,_efga );_defa :=_fe .NewRelationships ();_dged .AddTarget (_dc .RelationsPathFor (_cbcf ),_defa .X (),_feae ,0);_fgfc ._cdgb =append (_fgfc ._cdgb ,_defa );_fgfc ._acdc =append (_fgfc ._acdc ,nil );_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._gbfaa ));case _a .StylesType :_fgfc .StyleSheet =NewStyleSheet (_fgfc );_dged .AddTarget (_cbcf ,_fgfc .StyleSheet .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .ThemeType :_ebfd :=_deb .NewTheme ();_fgfc ._gbeg =append (_fgfc ._gbeg ,_ebfd );_dged .AddTarget (_cbcf ,_ebfd ,_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._gbeg ));case _a .SharedStringsType :_fgfc .SharedStrings =NewSharedStrings ();_dged .AddTarget (_cbcf ,_fgfc .SharedStrings .X (),_feae ,0);_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,0);case _a .ThumbnailType :for _efebb ,_fbdc :=range _egde {if _fbdc ==nil {continue ;};if _fbdc .Name ==_cbcf {_fbdf ,_dfgf :=_fbdc .Open ();if _dfgf !=nil {return _fc .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_dfgf );};_fgfc .Thumbnail ,_ ,_dfgf =_g .Decode (_fbdf );_fbdf .Close ();if _dfgf !=nil {return _fc .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_dfgf );};_egde [_efebb ]=nil ;};};case _a .ImageType :for _aafaa ,_edcb :=range _fgfc ._dceaa {_fgcb :=_df .Clean (_cbcf );if _fgcb ==_aafaa {_fddg .TargetAttr =_edcb ;return nil ;};};_deedc :=_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc .Images )+1);for _aadae ,_eba :=range _egde {if _eba ==nil {continue ;};if _eba .Name ==_df .Clean (_cbcf ){_bca ,_cgff :=_dc .ExtractToDiskTmp (_eba ,_fgfc .TmpPath );if _cgff !=nil {return _cgff ;};_fdcb ,_cgff :=_fe .ImageFromStorage (_bca );if _cgff !=nil {return _cgff ;};_cefc :=_fe .MakeImageRef (_fdcb ,&_fgfc .DocBase ,_fgfc ._bfec );_cefc .SetTarget (_deedc );_fgfc ._dceaa [_eba .Name ]=_deedc ;_fgfc .Images =append (_fgfc .Images ,_cefc );_egde [_aadae ]=nil ;};};_fddg .TargetAttr =_deedc ;case _a .DrawingType :_bgdc :=_cg .NewWsDr ();_abfg :=uint32 (len (_fgfc ._fddb ));_dged .AddTarget (_cbcf ,_bgdc ,_feae ,_abfg );_fgfc ._fddb =append (_fgfc ._fddb ,_bgdc );_gcfgg :=_fe .NewRelationships ();_dged .AddTarget (_dc .RelationsPathFor (_cbcf ),_gcfgg .X (),_feae ,_abfg );_fgfc ._afegb =append (_fgfc ._afegb ,_gcfgg );_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._fddb ));case _a .VMLDrawingType :_ecfae :=_cf .NewContainer ();_fgg :=uint32 (len (_fgfc ._egea ));_dged .AddTarget (_cbcf ,_ecfae ,_feae ,_fgg );_fgfc ._egea =append (_fgfc ._egea ,_ecfae );case _a .CommentsType :_fgfc ._acdc [_eed .Index ]=_cdc .NewComments ();_dged .AddTarget (_cbcf ,_fgfc ._acdc [_eed .Index ],_feae ,_eed .Index );_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._acdc ));case _a .ChartType :_dfgfb :=_cd .NewChartSpace ();_aaeec :=uint32 (len (_fgfc ._aefda ));_dged .AddTarget (_cbcf ,_dfgfb ,_feae ,_aaeec );_fgfc ._aefda =append (_fgfc ._aefda ,_dfgfb );_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._aefda ));_fgfc ._dbaee [_fddg .TargetAttr ]=_dfgfb ;case _a .TableType :_fdeb :=_cdc .NewTable ();_gcfgd :=uint32 (len (_fgfc ._bgea ));_dged .AddTarget (_cbcf ,_fdeb ,_feae ,_gcfgd );_fgfc ._bgea =append (_fgfc ._bgea ,_fdeb );_fddg .TargetAttr =_a .RelativeFilename (_dbfa ,_eed .Typ ,_feae ,len (_fgfc ._bgea ));default:_a .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_cbcf ,_feae );};return nil ;};

// SetWidthCells is a no-op.
func (_fee OneCellAnchor )SetWidthCells (int32 ){};

// IsEmpty checks if the cell style contains nothing.
func (_ecdd CellStyle )IsEmpty ()bool {return _ecdd ._ceg ==nil ||_ecdd ._eae ==nil ||_ecdd ._gfg ==nil ||_ecdd ._gfg .Xf ==nil ;};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_gce Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _debe ,_eecf Cell ;for _ ,_egec :=range lhs .Cells (){_fda ,_ :=_gc .ParseCellReference (_egec .Reference ());if _fda .Column ==column {_debe =_egec ;break ;};};for _ ,_edfd :=range rhs .Cells (){_befc ,_ :=_gc .ParseCellReference (_edfd .Reference ());if _befc .Column ==column {_eecf =_edfd ;break ;};};return _gce .LessCells (_debe ,_eecf );};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_dbb Cell )SetCachedFormulaResult (s string ){_dbb ._eeb .V =&s };

// Comment is a single comment within a sheet.
type Comment struct{_fecag *Workbook ;_cgce *_cdc .CT_Comment ;_edd *_cdc .Comments ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_gcca *evalContext )GetLabelPrefix (cellRef string )string {return _gcca ._dbe .Cell (cellRef ).getLabelPrefix ();};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_dcba *Workbook )AddDrawing ()Drawing {_bcda :=_cg .NewWsDr ();_dcba ._fddb =append (_dcba ._fddb ,_bcda );_dddf :=_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .DrawingType ,len (_dcba ._fddb ));_dcba .ContentTypes .AddOverride (_dddf ,_a .DrawingContentType );_dcba ._afegb =append (_dcba ._afegb ,_fe .NewRelationships ());return Drawing {_dcba ,_bcda };};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_bed Cell )SetStringByID (id int ){_bed ._ffb .ensureSharedStringsRelationships ();_bed .clearValue ();_bed ._eeb .V =_a .String (_cc .Itoa (id ));_bed ._eeb .TAttr =_cdc .ST_CellTypeS ;};

// Protection controls the protection on an individual sheet.
func (_aebeg *Sheet )Protection ()SheetProtection {if _aebeg ._gaec .SheetProtection ==nil {_aebeg ._gaec .SheetProtection =_cdc .NewCT_SheetProtection ();};return SheetProtection {_aebeg ._gaec .SheetProtection };};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_ce ,_gg int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_gge _bb .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_cea int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_ba _bb .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_cee int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_cce _bb .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_dg _bb .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_gcbg Sheet )IsValid ()bool {return _gcbg ._gaec !=nil };

// SetPriority sets the rule priority
func (_faga ConditionalFormattingRule )SetPriority (p int32 ){_faga ._aca .PriorityAttr =p };

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_aaafd *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_gbaa :=_aaafd ._gaec .SheetData .Row ;_dffba :=_aaafd .Rows ();for _afga ,_egfff :=range _dffba {if _egfff .RowNumber ()==firstRow {_gbaa =_aaafd ._gaec .SheetData .Row [_afga :];break ;};};_aeda :=Comparer {Order :order };_e .Slice (_gbaa ,func (_fceeb ,_baebf int )bool {return _aeda .LessRows (column ,Row {_aaafd ._bbfc ,_aaafd ,_gbaa [_fceeb ]},Row {_aaafd ._bbfc ,_aaafd ,_gbaa [_baebf ]});});for _bdec ,_dgcdg :=range _aaafd .Rows (){_bbdg :=uint32 (_bdec +1);if _dgcdg .RowNumber ()!=_bbdg {_dgcdg .renumberAs (_bbdg );};};};func (_cefb RichTextRun )ensureRpr (){if _cefb ._bgf .RPr ==nil {_cefb ._bgf .RPr =_cdc .NewCT_RPrElt ();};};

// X returns the inner wrapped XML type.
func (_fedg DifferentialStyle )X ()*_cdc .CT_Dxf {return _fedg ._bfde };

// BottomRight is a no-op.
func (_ea AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Workbook returns sheet's parent workbook.
func (_efdf *Sheet )Workbook ()*Workbook {return _efdf ._bbfc };func (_caa Border )SetBottom (style _cdc .ST_BorderStyle ,c _de .Color ){if _caa ._eca .Bottom ==nil {_caa ._eca .Bottom =_cdc .NewCT_BorderPr ();};_caa ._eca .Bottom .Color =_cdc .NewCT_Color ();_caa ._eca .Bottom .Color .RgbAttr =c .AsRGBAString ();_caa ._eca .Bottom .StyleAttr =style ;};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_bgfaa *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_bedf :=range _bgfaa .Sheets (){if _bedf .Name ()==name {return _bedf ,nil ;};};return Sheet {},ErrorNotFound ;};

// SetHeightAuto sets the row height to be automatically determined.
func (_cdd Row )SetHeightAuto (){_cdd ._gdgc .HtAttr =nil ;_cdd ._gdgc .CustomHeightAttr =nil };

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_cdc .Comments )Comments {return Comments {w ,x }};

// TopLeft returns the top-left corner of the anchored object.
func (_ffgf OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_ffgf ._dbab .From }};

// PasswordHash returns the hash of the workbook password.
func (_dagb SheetProtection )PasswordHash ()string {if _dagb ._bacd .PasswordAttr ==nil {return "";};return *_dagb ._bacd .PasswordAttr ;};

// Clear clears the cell's value and type.
func (_fea Cell )Clear (){_fea .clearValue ();_fea ._eeb .TAttr =_cdc .ST_CellTypeUnset };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_abab *Workbook ;_dcf *_cdc .CT_NumFmt ;};

// X returns the inner wrapped XML type.
func (_deg ConditionalFormattingRule )X ()*_cdc .CT_CfRule {return _deg ._aca };

// AddRun adds a new run of text to the cell.
func (_ffda RichText )AddRun ()RichTextRun {_bcb :=_cdc .NewCT_RElt ();_ffda ._beed .R =append (_ffda ._beed .R ,_bcb );return RichTextRun {_bcb };};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};func (_aefd Font )SetBold (b bool ){if b {_aefd ._bgag .B =[]*_cdc .CT_BooleanProperty {{}};}else {_aefd ._bgag .B =nil ;};};

// SetCol set the column of the cell marker.
func (_gcfa CellMarker )SetCol (col int32 ){_gcfa ._cde .Col =col };func (_efdg StyleSheet )GetCellStyle (id uint32 )CellStyle {for _bdcf ,_aabba :=range _efdg ._ccbbd .CellXfs .Xf {if uint32 (_bdcf )==id {return CellStyle {_efdg ._gcbf ,_aabba ,_efdg ._ccbbd .CellXfs };};};return CellStyle {};};func (_ebgd DataValidation )clear (){_ebgd ._bcc .Formula1 =_a .String ("\u0030");_ebgd ._bcc .Formula2 =_a .String ("\u0030");};func _gbde ()*_cg .CT_OneCellAnchor {_bbb :=_cg .NewCT_OneCellAnchor ();return _bbb };

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_cdb Cell )SetBool (v bool ){_cdb .clearValue ();_cdb ._eeb .V =_a .String (_cc .Itoa (_gbg (v )));_cdb ._eeb .TAttr =_cdc .ST_CellTypeB ;};func NewPatternFill (fills *_cdc .CT_Fills )PatternFill {_bdc :=_cdc .NewCT_Fill ();_bdc .PatternFill =_cdc .NewCT_PatternFill ();return PatternFill {_bdc .PatternFill ,_bdc };};var ErrorNotFound =_efa .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// BottomRight is a no-op.
func (_bfdb OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_aecg *Sheet )SetBorder (cellRange string ,border Border )error {_bgc ,_gaga ,_abdf :=_gc .ParseRangeReference (cellRange );if _abdf !=nil {return _abdf ;};_cbfa :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_aecbc :=_aecg ._bbfc .StyleSheet .AddBorder ();_cbfa .SetBorder (_aecbc );_aecbc ._eca .Top =border ._eca .Top ;_aecbc ._eca .Left =border ._eca .Left ;_bdedb :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_gebg :=_aecg ._bbfc .StyleSheet .AddBorder ();_bdedb .SetBorder (_gebg );_gebg ._eca .Top =border ._eca .Top ;_gebg ._eca .Right =border ._eca .Right ;_gfbfc :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_cead :=_aecg ._bbfc .StyleSheet .AddBorder ();_gfbfc .SetBorder (_cead );_cead ._eca .Top =border ._eca .Top ;_cegc :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_gbe :=_aecg ._bbfc .StyleSheet .AddBorder ();_cegc .SetBorder (_gbe );_gbe ._eca .Left =border ._eca .Left ;_bbc :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_cabb :=_aecg ._bbfc .StyleSheet .AddBorder ();_bbc .SetBorder (_cabb );_cabb ._eca .Right =border ._eca .Right ;_bccff :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_efeab :=_aecg ._bbfc .StyleSheet .AddBorder ();_bccff .SetBorder (_efeab );_efeab ._eca .Bottom =border ._eca .Bottom ;_egcg :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_fecf :=_aecg ._bbfc .StyleSheet .AddBorder ();_egcg .SetBorder (_fecf );_fecf ._eca .Bottom =border ._eca .Bottom ;_fecf ._eca .Left =border ._eca .Left ;_cgcf :=_aecg ._bbfc .StyleSheet .AddCellStyle ();_ecbd :=_aecg ._bbfc .StyleSheet .AddBorder ();_cgcf .SetBorder (_ecbd );_ecbd ._eca .Bottom =border ._eca .Bottom ;_ecbd ._eca .Right =border ._eca .Right ;_fbfg :=_bgc .RowIdx ;_fbac :=_bgc .ColumnIdx ;_dacg :=_gaga .RowIdx ;_eebb :=_gaga .ColumnIdx ;for _gcded :=_fbfg ;_gcded <=_dacg ;_gcded ++{for _ffbg :=_fbac ;_ffbg <=_eebb ;_ffbg ++{_cdega :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_ffbg ),_gcded );switch {case _gcded ==_fbfg &&_ffbg ==_fbac :_aecg .Cell (_cdega ).SetStyle (_cbfa );case _gcded ==_fbfg &&_ffbg ==_eebb :_aecg .Cell (_cdega ).SetStyle (_bdedb );case _gcded ==_dacg &&_ffbg ==_fbac :_aecg .Cell (_cdega ).SetStyle (_egcg );case _gcded ==_dacg &&_ffbg ==_eebb :_aecg .Cell (_cdega ).SetStyle (_cgcf );case _gcded ==_fbfg :_aecg .Cell (_cdega ).SetStyle (_gfbfc );case _gcded ==_dacg :_aecg .Cell (_cdega ).SetStyle (_bccff );case _ffbg ==_fbac :_aecg .Cell (_cdega ).SetStyle (_cegc );case _ffbg ==_eebb :_aecg .Cell (_cdega ).SetStyle (_bbc );};};};return nil ;};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// AddDataValidation adds a data validation rule to a sheet.
func (_feff *Sheet )AddDataValidation ()DataValidation {if _feff ._gaec .DataValidations ==nil {_feff ._gaec .DataValidations =_cdc .NewCT_DataValidations ();};_fdeg :=_cdc .NewCT_DataValidation ();_fdeg .ShowErrorMessageAttr =_a .Bool (true );_feff ._gaec .DataValidations .DataValidation =append (_feff ._gaec .DataValidations .DataValidation ,_fdeg );_feff ._gaec .DataValidations .CountAttr =_a .Uint32 (uint32 (len (_feff ._gaec .DataValidations .DataValidation )));return DataValidation {_fdeg };};

// SetColOffset sets the column offset of the top-left anchor.
func (_efb OneCellAnchor )SetColOffset (m _bb .Distance ){_efb .TopLeft ().SetColOffset (m )};

// IsHidden returns whether the row is hidden or not.
func (_cdgc Row )IsHidden ()bool {return _cdgc ._gdgc .HiddenAttr !=nil &&*_cdgc ._gdgc .HiddenAttr };

// InitializeDefaults initializes a border to its defaulte empty values.
func (_af Border )InitializeDefaults (){_af ._eca .Left =_cdc .NewCT_BorderPr ();_af ._eca .Bottom =_cdc .NewCT_BorderPr ();_af ._eca .Right =_cdc .NewCT_BorderPr ();_af ._eca .Top =_cdc .NewCT_BorderPr ();_af ._eca .Diagonal =_cdc .NewCT_BorderPr ();};

// SetText sets the text to be displayed.
func (_fged RichTextRun )SetText (s string ){_fged ._bgf .T =s };var _dgd *_eb .Regexp =_eb .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// Name returns the sheet name
func (_ddbeb Sheet )Name ()string {return _ddbeb ._abaa .NameAttr };

// MaxColumnIdx returns the max used column of the sheet.
func (_fdga Sheet )MaxColumnIdx ()uint32 {_gage :=uint32 (0);for _ ,_gacd :=range _fdga .Rows (){_cegf :=_gacd ._gdgc .C ;if len (_cegf )> 0{_aeae :=_cegf [len (_cegf )-1];_aaef ,_ :=_gc .ParseCellReference (*_aeae .RAttr );if _gage < _aaef .ColumnIdx {_gage =_aaef .ColumnIdx ;};};};return _gage ;};func (_gdf Cell )setLocked (_gdb bool ){_fcg :=_gdf ._eeb .SAttr ;if _fcg !=nil {_dad :=_gdf ._ffb .StyleSheet .GetCellStyle (*_fcg );if _dad ._eae .Protection ==nil {_dad ._eae .Protection =_cdc .NewCT_CellProtection ();};_dad ._eae .Protection .LockedAttr =&_gdb ;};};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;func (_cdbc StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_gaac :=range _cdbc ._ccbbd .NumFmts .NumFmt {if _gaac .NumFmtIdAttr ==id {return NumberFormat {_cdbc ._gcbf ,_gaac };};};return NumberFormat {};};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_beba Sheet )ValidateWithPath (path string )error {return _beba ._gaec .ValidateWithPath (path )};

// SetRowOffset sets a column offset in absolute distance.
func (_fba CellMarker )SetRowOffset (m _bb .Distance ){_fba ._cde .RowOff .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_bb .EMU ));};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_cfgg *Sheet )SetDrawing (d Drawing ){var _eaaf _fe .Relationships ;for _aedb ,_ebbg :=range _cfgg ._bbfc ._gbfaa {if _ebbg ==_cfgg ._gaec {_eaaf =_cfgg ._bbfc ._cdgb [_aedb ];break ;};};var _becf string ;for _adea ,_afeb :=range d ._adc ._fddb {if _afeb ==d ._efcc {_cdbf :=_eaaf .AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,_adea +1,_a .DrawingType );_becf =_cdbf .ID ();break ;};};_cfgg ._gaec .Drawing =_cdc .NewCT_Drawing ();_cfgg ._gaec .Drawing .IdAttr =_becf ;};

// SetHidden marks the defined name as hidden.
func (_gaea DefinedName )SetLocalSheetID (id uint32 ){_gaea ._cadb .LocalSheetIdAttr =_a .Uint32 (id )};

// GetEpoch returns a workbook's time epoch.
func (_aeeb *evalContext )GetEpoch ()_ca .Time {return _aeeb ._dbe ._bbfc .Epoch ()};

// SetShowValue controls if the cell value is displayed.
func (_cbeb DataBarScale )SetShowValue (b bool ){_cbeb ._fga .ShowValueAttr =_a .Bool (b )};

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// Wrapped returns true if the cell will wrap text.
func (_cdcd CellStyle )Wrapped ()bool {if _cdcd ._eae .Alignment ==nil {return false ;};if _cdcd ._eae .Alignment .WrapTextAttr ==nil {return false ;};return *_cdcd ._eae .Alignment .WrapTextAttr ;};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_ggcd Row )Cell (col string )Cell {_gfdc :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",col ,_ggcd .RowNumber ());for _ ,_egb :=range _ggcd ._gdgc .C {if _egb .RAttr !=nil &&*_egb .RAttr ==_gfdc {return Cell {_ggcd ._ceaf ,_ggcd ._dfg ,_ggcd ._gdgc ,_egb };};};return _ggcd .AddNamedCell (col );};

// ClearProtection removes any protections applied to teh sheet.
func (_cagcc *Sheet )ClearProtection (){_cagcc ._gaec .SheetProtection =nil };func (_fade Fill )SetPatternFill ()PatternFill {_fade ._cbec .GradientFill =nil ;_fade ._cbec .PatternFill =_cdc .NewCT_PatternFill ();_fade ._cbec .PatternFill .PatternTypeAttr =_cdc .ST_PatternTypeSolid ;return PatternFill {_fade ._cbec .PatternFill ,_fade ._cbec };};

// GetWidth returns a worksheet's column width.
func (_eab *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_baf :=range _eab ._dbe .X ().Cols [0].Col {if int (_baf .MinAttr )<=colIdx &&colIdx <=int (_baf .MaxAttr ){return float64 (int (*_baf .WidthAttr ));};};return 0;};func (_gfge Sheet )validateMergedCells ()error {_beg :=map[uint64 ]struct{}{};for _ ,_gef :=range _gfge .MergedCells (){_bdbe ,_egbf ,_fagf :=_gc .ParseRangeReference (_gef .Reference ());if _fagf !=nil {return _fc .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_gfge .Name (),_gef .Reference ());};for _cdae :=_bdbe .RowIdx ;_cdae <=_egbf .RowIdx ;_cdae ++{for _bgfa :=_bdbe .ColumnIdx ;_bgfa <=_egbf .ColumnIdx ;_bgfa ++{_aggc :=uint64 (_cdae )<<32|uint64 (_bgfa );if _ ,_dgge :=_beg [_aggc ];_dgge {return _fc .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_gfge .Name ());};_beg [_aggc ]=struct{}{};};};};return nil ;};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_fcd Comparer )LessCells (lhs ,rhs Cell )bool {if _fcd .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_deed ,_fgc :=lhs .getRawSortValue ();_gdc ,_fcbb :=rhs .getRawSortValue ();switch {case _fgc &&_fcbb :_aeaf ,_ :=_cc .ParseFloat (_deed ,64);_afbf ,_ :=_cc .ParseFloat (_gdc ,64);return _aeaf < _afbf ;case _fgc :return true ;case _fcbb :return false ;};_deed =lhs .GetFormattedValue ();_gdc =rhs .GetFormattedValue ();return _deed < _gdc ;};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_aabb *_cdc .CT_DataValidation };

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_edf Cell )GetFormattedValue ()string {_ffcf :=_edf .getFormat ();switch _edf ._eeb .TAttr {case _cdc .ST_CellTypeB :_dbag ,_ :=_edf .GetValueAsBool ();if _dbag {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _cdc .ST_CellTypeN :_fg ,_ :=_edf .GetValueAsNumber ();return _dfd .Number (_fg ,_ffcf );case _cdc .ST_CellTypeE :if _edf ._eeb .V !=nil {return *_edf ._eeb .V ;};return "";case _cdc .ST_CellTypeS ,_cdc .ST_CellTypeInlineStr :return _dfd .String (_edf .GetString (),_ffcf );case _cdc .ST_CellTypeStr :_acg :=_edf .GetString ();if _dfd .IsNumber (_acg ){_afc ,_ :=_cc .ParseFloat (_acg ,64);return _dfd .Number (_afc ,_ffcf );};return _dfd .String (_acg ,_ffcf );case _cdc .ST_CellTypeUnset :fallthrough;default:_afe ,_ :=_edf .GetRawValue ();if len (_afe )==0{return "";};_cbd ,_bbf :=_edf .GetValueAsNumber ();if _bbf ==nil {return _dfd .Number (_cbd ,_ffcf );};return _dfd .String (_afe ,_ffcf );};};

// SetRowOffset sets the row offset of the top-left anchor.
func (_gagc OneCellAnchor )SetRowOffset (m _bb .Distance ){_gagc .TopLeft ().SetRowOffset (m )};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_egdf Sheet )Extents ()string {_gegc ,_agge ,_gbba ,_deec :=_egdf .ExtentsIndex ();return _fc .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gegc ,_agge ,_gbba ,_deec );};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_bgf *_cdc .CT_RElt };func (_acdg *Sheet )setList (_eaaba string ,_fdee _bf .Result )error {_dfba ,_fcdg :=_gc .ParseCellReference (_eaaba );if _fcdg !=nil {return _fcdg ;};_aedbg :=_acdg .Row (_dfba .RowIdx );for _fdda ,_gedaf :=range _fdee .ValueList {_degg :=_aedbg .Cell (_gc .IndexToColumn (_dfba .ColumnIdx +uint32 (_fdda )));if _gedaf .Type !=_bf .ResultTypeEmpty {if _gedaf .IsBoolean {_degg .SetBool (_gedaf .ValueNumber !=0);}else {_degg .SetCachedFormulaResult (_gedaf .String ());};};};return nil ;};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_edcd CellStyle )HasNumberFormat ()bool {return _edcd ._eae .NumFmtIdAttr !=nil &&_edcd ._eae .ApplyNumberFormatAttr !=nil &&*_edcd ._eae .ApplyNumberFormatAttr ;};func (_fgdc Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _aaaf ,_fdbg ,_bfaaa ,_bfc uint32 =1,1,0,0;for _ ,_cdea :=range _fgdc .Rows (){if _cdea .RowNumber ()< _aaaf {_aaaf =_cdea .RowNumber ();}else if _cdea .RowNumber ()> _fdbg {_fdbg =_cdea .RowNumber ();};for _ ,_aaad :=range _cdea .Cells (){_gbb ,_gbdc :=_gc .ParseCellReference (_aaad .Reference ());if _gbdc ==nil {if _gbb .ColumnIdx < _bfaaa {_bfaaa =_gbb .ColumnIdx ;}else if _gbb .ColumnIdx > _bfc {_bfc =_gbb .ColumnIdx ;};};};};return _gc .IndexToColumn (_bfaaa ),_aaaf ,_gc .IndexToColumn (_bfc ),_fdbg ;};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);func (_bfd Cell )getFormat ()string {if _bfd ._eeb .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_cgc :=*_bfd ._eeb .SAttr ;_beda :=_bfd ._ffb .StyleSheet .GetCellStyle (_cgc );_bdb :=_bfd ._ffb .StyleSheet .GetNumberFormat (_beda .NumberFormat ());return _bdb .GetFormat ();};

// SetColor sets teh color of the databar.
func (_fcbf DataBarScale )SetColor (c _de .Color ){_fcbf ._fga .Color =_cdc .NewCT_Color ();_fcbf ._fga .Color .RgbAttr =c .AsRGBAString ();};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_ddb Comment )SetAuthor (author string ){_ddb ._cgce .AuthorIdAttr =Comments {_ddb ._fecag ,_ddb ._edd }.getOrCreateAuthor (author );};var _fdad =_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .SharedStringsType ,0);

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_gaaf *Sheet )RemoveMergedCell (mc MergedCell ){for _acc ,_fcbge :=range _gaaf ._gaec .MergeCells .MergeCell {if _fcbge ==mc .X (){copy (_gaaf ._gaec .MergeCells .MergeCell [_acc :],_gaaf ._gaec .MergeCells .MergeCell [_acc +1:]);_gaaf ._gaec .MergeCells .MergeCell [len (_gaaf ._gaec .MergeCells .MergeCell )-1]=nil ;_gaaf ._gaec .MergeCells .MergeCell =_gaaf ._gaec .MergeCells .MergeCell [:len (_gaaf ._gaec .MergeCells .MergeCell )-1];};};};

// SetHyperlink sets a hyperlink on a cell.
func (_eff Cell )SetHyperlink (hl _fe .Hyperlink ){_feg :=_eff ._fd ._gaec ;if _feg .Hyperlinks ==nil {_feg .Hyperlinks =_cdc .NewCT_Hyperlinks ();};_agd :=_fe .Relationship (hl );_cef :=_cdc .NewCT_Hyperlink ();_cef .RefAttr =_eff .Reference ();_cef .IdAttr =_a .String (_agd .ID ());_feg .Hyperlinks .Hyperlink =append (_feg .Hyperlinks .Hyperlink ,_cef );};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_gcef Sheet )RangeReference (n string )string {_cgfbd :=_f .Split (n ,"\u003a");_ebfe ,_ :=_gc .ParseCellReference (_cgfbd [0]);_dfgc :=_fc .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_ebfe .Column ,_ebfe .RowIdx );if len (_cgfbd )==1{return _fc .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_gcef .Name (),_dfgc );};_cfeb ,_ :=_gc .ParseCellReference (_cgfbd [1]);_caf :=_fc .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cfeb .Column ,_cfeb .RowIdx );return _fc .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_gcef .Name (),_dfgc ,_caf );};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_afa Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_afa .SetNumber (v );_afa .SetStyle (_afa ._ffb .StyleSheet .GetOrCreateStandardNumberFormat (f ));};func (_beab SheetView )ensurePane (){if _beab ._bfagf .Pane ==nil {_beab ._bfagf .Pane =_cdc .NewCT_Pane ();_beab ._bfagf .Pane .ActivePaneAttr =_cdc .ST_PaneBottomLeft ;};};

// CellStyles returns the list of defined cell styles
func (_ceda StyleSheet )CellStyles ()[]CellStyle {_gbcd :=[]CellStyle {};for _ ,_cdfcfd :=range _ceda ._ccbbd .CellXfs .Xf {_gbcd =append (_gbcd ,CellStyle {_ceda ._gcbf ,_cdfcfd ,_ceda ._ccbbd .CellXfs });};return _gbcd ;};

// PasswordHash returns the hash of the workbook password.
func (_afbd WorkbookProtection )PasswordHash ()string {if _afbd ._bgdb .WorkbookPasswordAttr ==nil {return "";};return *_afbd ._bgdb .WorkbookPasswordAttr ;};

// Fonts returns the list of fonts defined in the stylesheet.
func (_edgg StyleSheet )Fonts ()[]Font {_cada :=[]Font {};for _ ,_gdaa :=range _edgg ._ccbbd .Fonts .Font {_cada =append (_cada ,Font {_gdaa ,_edgg ._ccbbd });};return _cada ;};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ecec TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_ecec ._bfage .From }};

// AnchorType is the type of anchor.
type AnchorType byte ;

// ClearAutoFilter removes the autofilters from the sheet.
func (_egac *Sheet )ClearAutoFilter (){_egac ._gaec .AutoFilter =nil ;_cedbd :="\u0027"+_egac .Name ()+"\u0027\u0021";for _ ,_cgbf :=range _egac ._bbfc .DefinedNames (){if _cgbf .Name ()==_faaa {if _f .HasPrefix (_cgbf .Content (),_cedbd ){_egac ._bbfc .RemoveDefinedName (_cgbf );break ;};};};};func (_fcea *evalContext )Sheet (name string )_bf .Context {for _ ,_gea :=range _fcea ._dbe ._bbfc .Sheets (){if _gea .Name ()==name {return _gea .FormulaContext ();};};return _bf .InvalidReferenceContext ;};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_aadc *Sheet )AddHyperlink (url string )_fe .Hyperlink {for _ecda ,_ddbec :=range _aadc ._bbfc ._gbfaa {if _ddbec ==_aadc ._gaec {return _aadc ._bbfc ._cdgb [_ecda ].AddHyperlink (url );};};return _fe .Hyperlink {};};func (_ada *Sheet )setShared (_agea string ,_edba ,_gaba _gc .CellReference ,_add string ){_efgd :=_ada .FormulaContext ();_eac :=_bf .NewEvaluator ();for _fcefa :=_edba .RowIdx ;_fcefa <=_gaba .RowIdx ;_fcefa ++{for _bfda :=_edba .ColumnIdx ;_bfda <=_gaba .ColumnIdx ;_bfda ++{_bdbc :=_fcefa -_edba .RowIdx ;_agdc :=_bfda -_edba .ColumnIdx ;_efgd .SetOffset (_agdc ,_bdbc );_bafdd :=_eac .Eval (_efgd ,_add );_aaec :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_bfda ),_fcefa );_dabe :=_ada .Cell (_aaec );if _bafdd .Type ==_bf .ResultTypeNumber {_dabe .X ().TAttr =_cdc .ST_CellTypeN ;}else {_dabe .X ().TAttr =_cdc .ST_CellTypeInlineStr ;};_dabe .X ().V =_a .String (_bafdd .Value ());};};_ =_eac ;_ =_efgd ;};

// X returns the inner wrapped XML type.
func (_baca *Workbook )X ()*_cdc .Workbook {return _baca ._gfdg };

// Protection allows control over the workbook protections.
func (_aaeac *Workbook )Protection ()WorkbookProtection {if _aaeac ._gfdg .WorkbookProtection ==nil {_aaeac ._gfdg .WorkbookProtection =_cdc .NewCT_WorkbookProtection ();};return WorkbookProtection {_aaeac ._gfdg .WorkbookProtection };};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_cafb :=_cdc .NewStyleSheet ();_cafb .CellStyleXfs =_cdc .NewCT_CellStyleXfs ();_cafb .CellXfs =_cdc .NewCT_CellXfs ();_cafb .CellStyles =_cdc .NewCT_CellStyles ();_ebcf :=_cdc .NewCT_CellStyle ();_ebcf .NameAttr =_a .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_ebcf .XfIdAttr =0;_ebcf .BuiltinIdAttr =_a .Uint32 (0);_cafb .CellStyles .CellStyle =append (_cafb .CellStyles .CellStyle ,_ebcf );_cafb .CellStyles .CountAttr =_a .Uint32 (uint32 (len (_cafb .CellStyles .CellStyle )));_dge :=_cdc .NewCT_Xf ();_dge .NumFmtIdAttr =_a .Uint32 (0);_dge .FontIdAttr =_a .Uint32 (0);_dge .FillIdAttr =_a .Uint32 (0);_dge .BorderIdAttr =_a .Uint32 (0);_cafb .CellStyleXfs .Xf =append (_cafb .CellStyleXfs .Xf ,_dge );_cafb .CellStyleXfs .CountAttr =_a .Uint32 (uint32 (len (_cafb .CellStyleXfs .Xf )));_bgd :=NewFills ();_cafb .Fills =_bgd .X ();_feac :=_bgd .AddFill ().SetPatternFill ();_feac .SetPattern (_cdc .ST_PatternTypeNone );_feac =_bgd .AddFill ().SetPatternFill ();_feac .SetPattern (_cdc .ST_PatternTypeGray125 );_cafb .Fonts =_cdc .NewCT_Fonts ();_cafb .Borders =_cdc .NewCT_Borders ();_gbdg :=StyleSheet {wb ,_cafb };_gbdg .AddBorder ().InitializeDefaults ();_cgbd :=_gbdg .AddFont ();_cgbd .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cgbd .SetSize (11);_ecbg :=_cdc .NewCT_Xf ();*_ecbg =*_dge ;_ecbg .XfIdAttr =_a .Uint32 (0);_cafb .CellXfs .Xf =append (_cafb .CellXfs .Xf ,_ecbg );_cafb .CellXfs .CountAttr =_a .Uint32 (uint32 (len (_cafb .CellXfs .Xf )));return _gbdg ;};

// SetFont sets the font name for a rich text run.
func (_caaec RichTextRun )SetFont (s string ){_caaec .ensureRpr ();_caaec ._bgf .RPr .RFont =_cdc .NewCT_FontName ();_caaec ._bgf .RPr .RFont .ValAttr =s ;};func (_cfd Cell )GetRawValue ()(string ,error ){switch _cfd ._eeb .TAttr {case _cdc .ST_CellTypeInlineStr :if _cfd ._eeb .Is ==nil ||_cfd ._eeb .Is .T ==nil {return "",nil ;};return *_cfd ._eeb .Is .T ,nil ;case _cdc .ST_CellTypeS :if _cfd ._eeb .V ==nil {return "",nil ;};_ffa ,_bde :=_cc .Atoi (*_cfd ._eeb .V );if _bde !=nil {return "",_bde ;};return _cfd ._ffb .SharedStrings .GetString (_ffa );case _cdc .ST_CellTypeStr :if _cfd ._eeb .F !=nil {return _cfd ._eeb .F .Content ,nil ;};};if _cfd ._eeb .V ==nil {return "",nil ;};return *_cfd ._eeb .V ,nil ;};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_faedb *_cdc .Sst ;_gfe map[string ]int ;};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_ggf Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_gagcf :=[]Cell {};for _dcee :=uint32 (0);_dcee <=lastColIdx ;_dcee ++{_abdc :=_ggf .Cell (_gc .IndexToColumn (_dcee ));_gagcf =append (_gagcf ,_abdc );};return _gagcf ;};

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_ggeaa Row )Cells ()[]Cell {_fccea :=[]Cell {};_bbab :=-1;_ffga :=append ([]*_cdc .CT_Cell {},_ggeaa ._gdgc .C ...);for _ ,_aecca :=range _ffga {if _aecca .RAttr ==nil {_a .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_afgb ,_fedf :=_gc .ParseCellReference (*_aecca .RAttr );if _fedf !=nil {_a .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_aecca .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_dcea :=int (_afgb .ColumnIdx );if _dcea -_bbab > 1{for _efccf :=_bbab +1;_efccf < _dcea ;_efccf ++{_fccea =append (_fccea ,_ggeaa .Cell (_gc .IndexToColumn (uint32 (_efccf ))));};};_bbab =_dcea ;_fccea =append (_fccea ,Cell {_ggeaa ._ceaf ,_ggeaa ._dfg ,_ggeaa ._gdgc ,_aecca });};return _fccea ;};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_dedc StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_dcacf :=range _dedc .CellStyles (){if _dcacf .HasNumberFormat ()&&_dcacf .NumberFormat ()==uint32 (f ){return _dcacf ;};};_cadfd :=_dedc .AddCellStyle ();_cadfd .SetNumberFormatStandard (f );return _cadfd ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_fga *_cdc .CT_DataBar };

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_afad Cell )SetStyleIndex (idx uint32 ){_afad ._eeb .SAttr =_a .Uint32 (idx )};

// SetHeight sets the height of the anchored object.
func (_edgd OneCellAnchor )SetHeight (h _bb .Distance ){_edgd ._dbab .Ext .CyAttr =int64 (h /_bb .EMU )};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// Tables returns a slice of all defined tables in the workbook.
func (_bacb *Workbook )Tables ()[]Table {if _bacb ._bgea ==nil {return nil ;};_dccbb :=[]Table {};for _ ,_gfbgb :=range _bacb ._bgea {_dccbb =append (_dccbb ,Table {_gfbgb });};return _dccbb ;};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_ag Cell )SetRichTextString ()RichText {_ag .clearValue ();_ag ._eeb .Is =_cdc .NewCT_Rst ();_ag ._eeb .TAttr =_cdc .ST_CellTypeInlineStr ;return RichText {_ag ._eeb .Is };};

// SetReference sets the regin of cells that the merged cell applies to.
func (_cceb MergedCell )SetReference (ref string ){_cceb ._aafa .RefAttr =ref };

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_fcfa *_cdc .CT_DataValidation };

// Index returns the index of the border for use with a cell style.
func (_fa Border )Index ()uint32 {for _cb ,_cda :=range _fa ._gb .Border {if _cda ==_fa ._eca {return uint32 (_cb );};};return 0;};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_faedb :_cdc .NewSst (),_gfe :make (map[string ]int )};};var _ageac =false ;func (_caad *Sheet )setArray (_fgec string ,_aada _bf .Result )error {_aafgg ,_dgbf :=_gc .ParseCellReference (_fgec );if _dgbf !=nil {return _dgbf ;};for _bcecc ,_dbbc :=range _aada .ValueArray {_ddfe :=_caad .Row (_aafgg .RowIdx +uint32 (_bcecc ));for _baceb ,_eacc :=range _dbbc {_cacg :=_ddfe .Cell (_gc .IndexToColumn (_aafgg .ColumnIdx +uint32 (_baceb )));if _eacc .Type !=_bf .ResultTypeEmpty {if _eacc .IsBoolean {_cacg .SetBool (_eacc .ValueNumber !=0);}else {_cacg .SetCachedFormulaResult (_eacc .String ());};};};};return nil ;};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_fae CellStyle )NumberFormat ()uint32 {if _fae ._eae .NumFmtIdAttr ==nil {return 0;};return *_fae ._eae .NumFmtIdAttr ;};

// Type returns the type of anchor
func (_fcc AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// SetWidth controls the width of a column.
func (_fcge Column )SetWidth (w _bb .Distance ){_fcge ._ebb .WidthAttr =_a .Float64 (float64 (w /_bb .Character ));};

// Text returns text from the sheet as one string separated with line breaks.
func (_ebge *SheetText )Text ()string {_ecg :=_ee .NewBuffer ([]byte {});for _ ,_fbbd :=range _ebge .Cells {if _fbbd .Text !=""{_ecg .WriteString (_fbbd .Text );_ecg .WriteString ("\u000a");};};return _ecg .String ();};

// SetDateWithStyle sets a date with the default date style applied.
func (_dgb Cell )SetDateWithStyle (d _ca .Time ){_dgb .SetDate (d );for _ ,_gfb :=range _dgb ._ffb .StyleSheet .CellStyles (){if _gfb .HasNumberFormat ()&&_gfb .NumberFormat ()==uint32 (StandardFormatDate ){_dgb .SetStyle (_gfb );return ;};};_cebf :=_dgb ._ffb .StyleSheet .AddCellStyle ();_cebf .SetNumberFormatStandard (StandardFormatDate );_dgb .SetStyle (_cebf );};func (_cede ConditionalFormattingRule )clear (){_cede ._aca .OperatorAttr =_cdc .ST_ConditionalFormattingOperatorUnset ;_cede ._aca .ColorScale =nil ;_cede ._aca .IconSet =nil ;_cede ._aca .Formula =nil ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_agdea StyleSheet )RemoveFont (f Font )error {for _gaab ,_aafc :=range _agdea ._ccbbd .Fonts .Font {if _aafc ==f .X (){_agdea ._ccbbd .Fonts .Font =append (_agdea ._ccbbd .Fonts .Font [:_gaab ],_agdea ._ccbbd .Fonts .Font [_gaab +1:]...);return nil ;};};return _efa .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// Border is a cell border configuraton.
type Border struct{_eca *_cdc .CT_Border ;_gb *_cdc .CT_Borders ;};func (_afdgg *Sheet )addNumberedRowFast (_dfda uint32 )Row {_adba :=_cdc .NewCT_Row ();_adba .RAttr =_a .Uint32 (_dfda );_afdgg ._gaec .SheetData .Row =append (_afdgg ._gaec .SheetData .Row ,_adba );return Row {_afdgg ._bbfc ,_afdgg ,_adba };};

// LockStructure controls the locking of the workbook structure.
func (_dgff WorkbookProtection )LockStructure (b bool ){if !b {_dgff ._bgdb .LockStructureAttr =nil ;}else {_dgff ._bgdb .LockStructureAttr =_a .Bool (true );};};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_ccd Cell )SetDate (d _ca .Time ){_ccd .clearValue ();d =_edff (d );_aag :=_ccd ._ffb .Epoch ();if d .Before (_aag ){_a .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_fdgg :=d .Sub (_aag );_eef :=new (_cab .Float );_bfg :=new (_cab .Float );_bfg .SetPrec (128);_bfg .SetUint64 (uint64 (_fdgg ));_dgcd :=new (_cab .Float );_dgcd .SetUint64 (24*60*60*1e9);_eef .Quo (_bfg ,_dgcd );_aed ,_ :=_eef .Uint64 ();_ccd ._eeb .V =_a .Stringf ("\u0025\u0064",_aed );};func _abda (_cbda string ,_cdgg uint32 ,_ecac bool )string {_gcdff ,_fgba ,_cdde :=_gc .ParseRangeReference (_cbda );if _cdde ==nil {_bge ,_ecgf :=_gcdff .ColumnIdx ,_fgba .ColumnIdx ;if _cdgg >=_bge &&_cdgg <=_ecgf {if _bge ==_ecgf {if _ecac {return "";}else {return _cbda ;};}else {_gaae :=_fgba .Update (_ge .UpdateActionRemoveColumn );return _fc .Sprintf ("\u0025\u0073\u003a%\u0073",_gcdff .String (),_gaae .String ());};}else if _cdgg < _bge {_eebg :=_gcdff .Update (_ge .UpdateActionRemoveColumn );_ggfa :=_fgba .Update (_ge .UpdateActionRemoveColumn );return _fc .Sprintf ("\u0025\u0073\u003a%\u0073",_eebg .String (),_ggfa .String ());};}else {_gadfe ,_cdfe ,_acgg :=_gc .ParseColumnRangeReference (_cbda );if _acgg !=nil {return "";};_gcgag ,_efefb :=_gadfe .ColumnIdx ,_cdfe .ColumnIdx ;if _cdgg >=_gcgag &&_cdgg <=_efefb {if _gcgag ==_efefb {if _ecac {return "";}else {return _cbda ;};}else {_aegf :=_cdfe .Update (_ge .UpdateActionRemoveColumn );return _fc .Sprintf ("\u0025\u0073\u003a%\u0073",_gadfe .String (),_aegf .String ());};}else if _cdgg < _gcgag {_afae :=_gadfe .Update (_ge .UpdateActionRemoveColumn );_faf :=_cdfe .Update (_ge .UpdateActionRemoveColumn );return _fc .Sprintf ("\u0025\u0073\u003a%\u0073",_afae .String (),_faf .String ());};};return "";};

// New constructs a new workbook.
func New ()*Workbook {_cadbd :=&Workbook {};_cadbd ._gfdg =_cdc .NewWorkbook ();_cadbd .AppProperties =_fe .NewAppProperties ();_cadbd .CoreProperties =_fe .NewCoreProperties ();_cadbd .StyleSheet =NewStyleSheet (_cadbd );_cadbd .Rels =_fe .NewRelationships ();_cadbd ._bfec =_fe .NewRelationships ();_cadbd .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .ExtendedPropertiesType ,0),_a .ExtendedPropertiesType );_cadbd .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .CorePropertiesType ,0),_a .CorePropertiesType );_cadbd .Rels .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,"",_a .OfficeDocumentType ,0),_a .OfficeDocumentType );_cadbd ._bfec .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .StylesType ,0),_a .StylesType );_cadbd .ContentTypes =_fe .NewContentTypes ();_cadbd .ContentTypes .AddDefault ("\u0076\u006d\u006c",_a .VMLDrawingContentType );_cadbd .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_cadbd .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .StylesType ,0),_a .SMLStyleSheetContentType );_cadbd .SharedStrings =NewSharedStrings ();_cadbd .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .SharedStringsType ,0),_a .SharedStringsContentType );_cadbd ._bfec .AddRelationship (_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .OfficeDocumentType ,_a .SharedStringsType ,0),_a .SharedStringsType );_cadbd ._dceaa =map[string ]string {};return _cadbd ;};func (_aaa Border )SetDiagonal (style _cdc .ST_BorderStyle ,c _de .Color ,up ,down bool ){if _aaa ._eca .Diagonal ==nil {_aaa ._eca .Diagonal =_cdc .NewCT_BorderPr ();};_aaa ._eca .Diagonal .Color =_cdc .NewCT_Color ();_aaa ._eca .Diagonal .Color .RgbAttr =c .AsRGBAString ();_aaa ._eca .Diagonal .StyleAttr =style ;if up {_aaa ._eca .DiagonalUpAttr =_a .Bool (true );};if down {_aaa ._eca .DiagonalDownAttr =_a .Bool (true );};};

// Col returns the column of the cell marker.
func (_eebf CellMarker )Col ()int32 {return _eebf ._cde .Col };

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_cadc Row )AddNamedCell (col string )Cell {_dcec :=_cdc .NewCT_Cell ();_dcec .RAttr =_a .Stringf ("\u0025\u0073\u0025\u0064",col ,_cadc .RowNumber ());_efec :=-1;_ffcd :=_gc .ColumnToIndex (col );for _cbbf ,_bfgdb :=range _cadc ._gdgc .C {_dag ,_acb :=_gc .ParseCellReference (*_bfgdb .RAttr );if _acb !=nil {return Cell {};};if _ffcd < _dag .ColumnIdx {_efec =_cbbf ;break ;};};if _efec ==-1{_cadc ._gdgc .C =append (_cadc ._gdgc .C ,_dcec );}else {_cadc ._gdgc .C =append (_cadc ._gdgc .C [:_efec ],append ([]*_cdc .CT_Cell {_dcec },_cadc ._gdgc .C [_efec :]...)...);};return Cell {_cadc ._ceaf ,_cadc ._dfg ,_cadc ._gdgc ,_dcec };};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_defe *Workbook )GetChartByTargetId (targetAttr string )*_cd .ChartSpace {return _defe ._dbaee [targetAttr ];};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_bfagf *_cdc .CT_SheetView };

// Column returns the cell column
func (_ed Cell )Column ()(string ,error ){_cec ,_ceb :=_gc .ParseCellReference (_ed .Reference ());if _ceb !=nil {return "",_ceb ;};return _cec .Column ,nil ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_dfdd AbsoluteAnchor )SetColOffset (m _bb .Distance ){_dfdd ._dba .Pos .XAttr .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_bb .EMU ));};

// AddView adds a sheet view.
func (_fadcg *Sheet )AddView ()SheetView {if _fadcg ._gaec .SheetViews ==nil {_fadcg ._gaec .SheetViews =_cdc .NewCT_SheetViews ();};_fccff :=_cdc .NewCT_SheetView ();_fadcg ._gaec .SheetViews .SheetView =append (_fadcg ._gaec .SheetViews .SheetView ,_fccff );return SheetView {_fccff };};

// SetXSplit sets the column split point
func (_dadd SheetView )SetXSplit (v float64 ){_dadd .ensurePane ();_dadd ._bfagf .Pane .XSplitAttr =_a .Float64 (v );};func (_baag Fills )X ()*_cdc .CT_Fills {return _baag ._gga };

// LockObject controls the locking of the sheet objects.
func (_cbea SheetProtection )LockObject (b bool ){if !b {_cbea ._bacd .ObjectsAttr =nil ;}else {_cbea ._bacd .ObjectsAttr =_a .Bool (true );};};

// ClearFont clears any font configuration from the cell style.
func (_efae CellStyle )ClearFont (){_efae ._eae .FontIdAttr =nil ;_efae ._eae .ApplyFontAttr =nil };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_ged Cell )GetCachedFormulaResult ()string {if _ged ._eeb .V !=nil {return *_ged ._eeb .V ;};return "";};

// Name returns the name of the table
func (_dedd Table )Name ()string {if _dedd ._ffgfd .NameAttr !=nil {return *_dedd ._ffgfd .NameAttr ;};return "";};

// SheetCount returns the number of sheets in the workbook.
func (_ddaf Workbook )SheetCount ()int {return len (_ddaf ._gbfaa )};

// X returns the inner wrapped XML type.
func (_cbfg RichTextRun )X ()*_cdc .CT_RElt {return _cbfg ._bgf };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_gcf Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_bd :=_bf .ParseString (formulaStr );if _bd ==nil {return _efa .New (_fc .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));};_gcf .clearValue ();_gcf ._eeb .TAttr =_cdc .ST_CellTypeStr ;_gcf ._eeb .F =_cdc .NewCT_CellFormula ();_gcf ._eeb .F .TAttr =_cdc .ST_CellFormulaTypeShared ;_gcf ._eeb .F .Content =formulaStr ;_fdg ,_aaf :=_gc .ParseCellReference (_gcf .Reference ());if _aaf !=nil {return _aaf ;};_abd :=uint32 (0);for _ ,_gf :=range _gcf ._fd .Rows (){for _ ,_eaf :=range _gf ._gdgc .C {if _eaf .F !=nil &&_eaf .F .SiAttr !=nil &&*_eaf .F .SiAttr >=_abd {_abd =*_eaf .F .SiAttr ;};};};_abd ++;_ebd :=_fc .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_fdg .Column ,_fdg .RowIdx ,_gc .IndexToColumn (_fdg .ColumnIdx +cols ),_fdg .RowIdx +rows );_gcf ._eeb .F .RefAttr =_a .String (_ebd );_gcf ._eeb .F .SiAttr =_a .Uint32 (_abd );_gcc :=Sheet {_gcf ._ffb ,_gcf ._fd ._abaa ,_gcf ._fd ._gaec };for _abg :=_fdg .RowIdx ;_abg <=_fdg .RowIdx +rows ;_abg ++{for _ggea :=_fdg .ColumnIdx ;_ggea <=_fdg .ColumnIdx +cols ;_ggea ++{if _abg ==_fdg .RowIdx &&_ggea ==_fdg .ColumnIdx {continue ;};_fcb :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_ggea ),_abg );_gcc .Cell (_fcb ).Clear ();_gcc .Cell (_fcb ).X ().F =_cdc .NewCT_CellFormula ();_gcc .Cell (_fcb ).X ().F .TAttr =_cdc .ST_CellFormulaTypeShared ;_gcc .Cell (_fcb ).X ().F .SiAttr =_a .Uint32 (_abd );};};return nil ;};func (_ceee PatternFill )ClearFgColor (){_ceee ._gffg .FgColor =nil };type evalContext struct{_dbe *Sheet ;_gfa ,_agbc uint32 ;_caae map[string ]struct{};};

// SetStyle sets the cell style for an entire column.
func (_afcc Column )SetStyle (cs CellStyle ){_afcc ._ebb .StyleAttr =_a .Uint32 (cs .Index ())};

// SetHeight is a nop-op.
func (_dfcc TwoCellAnchor )SetHeight (h _bb .Distance ){};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_ebb *_cdc .CT_Col };

// AddCommentWithStyle adds a new comment styled in a default way
func (_faed Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_cggd :=_faed .AddComment (cellRef ,author );_cbe :=_cggd .AddRun ();_cbe .SetBold (true );_cbe .SetSize (10);_cbe .SetColor (_de .Black );_cbe .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cbe .SetText (author +"\u003a");_cbe =_cggd .AddRun ();_cbe .SetSize (10);_cbe .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_cbe .SetColor (_de .Black );_cbe .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_fca ,_gaf :=_gc .ParseCellReference (cellRef );if _gaf !=nil {return _gaf ;};_faed ._abec ._egea [0].Shape =append (_faed ._abec ._egea [0].Shape ,_cf .NewCommentShape (int64 (_fca .ColumnIdx ),int64 (_fca .RowIdx -1)));return nil ;};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bgfg *Workbook )GetFilename ()string {return _bgfg ._deff };

// GetString retrieves a string from the shared strings table by index.
func (_fbca SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_fc .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_fbca ._faedb .Si ){return "",_fc .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_fbca ._faedb .Si ));};_gcdf :=_fbca ._faedb .Si [id ];if _gcdf .T !=nil {return *_gcdf .T ,nil ;};return "",nil ;};

// GetFill gets a Fill from a cell style.
func (_ffg CellStyle )GetFill ()*_cdc .CT_Fill {if _bbfe :=_ffg ._eae .FillIdAttr ;_bbfe !=nil {_ega :=_ffg ._ceg .StyleSheet .Fills ().X ().Fill ;if int (*_bbfe )< len (_ega ){return _ega [int (*_bbfe )];};};return nil ;};

// X returns the inner wrapped XML type.
func (_cac RichText )X ()*_cdc .CT_Rst {return _cac ._beed };

// Priority returns the rule priority
func (_cbcc ConditionalFormattingRule )Priority ()int32 {return _cbcc ._aca .PriorityAttr };

// AddBorder creates a new empty border that can be applied to a cell style.
func (_baee StyleSheet )AddBorder ()Border {_abgcd :=_cdc .NewCT_Border ();_baee ._ccbbd .Borders .Border =append (_baee ._ccbbd .Borders .Border ,_abgcd );_baee ._ccbbd .Borders .CountAttr =_a .Uint32 (uint32 (len (_baee ._ccbbd .Borders .Border )));return Border {_abgcd ,_baee ._ccbbd .Borders };};func (_adb PatternFill )ClearBgColor (){_adb ._gffg .BgColor =nil };func (_gcea Font )Index ()uint32 {for _fbd ,_bcgf :=range _gcea ._cefd .Fonts .Font {if _gcea ._bgag ==_bcgf {return uint32 (_fbd );};};return 0;};

// GetLocked returns true if the cell is locked.
func (_aab *evalContext )GetLocked (cellRef string )bool {return _aab ._dbe .Cell (cellRef ).getLocked ()};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_baeb *evalContext )IsDBCS ()bool {_fed :=_baeb ._dbe ._bbfc .CoreProperties .X ().Language ;if _fed ==nil {return false ;};_cgdc :=string (_fed .Data );for _ ,_cfcg :=range _ffe {if _cgdc ==_cfcg {return true ;};};return false ;};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_fdbe *Workbook )RemoveSheet (ind int )error {if _fdbe .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_aedd :=range _fdbe ._bfec .Relationships (){if _aedd .ID ()==_fdbe ._gfdg .Sheets .Sheet [ind ].IdAttr {_fdbe ._bfec .Remove (_aedd );break ;};};_fdbe .ContentTypes .RemoveOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,ind +1));copy (_fdbe ._gbfaa [ind :],_fdbe ._gbfaa [ind +1:]);_fdbe ._gbfaa =_fdbe ._gbfaa [:len (_fdbe ._gbfaa )-1];_fdbeb :=_fdbe ._gfdg .Sheets .Sheet [ind ];copy (_fdbe ._gfdg .Sheets .Sheet [ind :],_fdbe ._gfdg .Sheets .Sheet [ind +1:]);_fdbe ._gfdg .Sheets .Sheet =_fdbe ._gfdg .Sheets .Sheet [:len (_fdbe ._gfdg .Sheets .Sheet )-1];for _bcfc :=range _fdbe ._gfdg .Sheets .Sheet {if _fdbe ._gfdg .Sheets .Sheet [_bcfc ].SheetIdAttr > _fdbeb .SheetIdAttr {_fdbe ._gfdg .Sheets .Sheet [_bcfc ].SheetIdAttr --;};};copy (_fdbe ._cdgb [ind :],_fdbe ._cdgb [ind +1:]);_fdbe ._cdgb =_fdbe ._cdgb [:len (_fdbe ._cdgb )-1];copy (_fdbe ._acdc [ind :],_fdbe ._acdc [ind +1:]);_fdbe ._acdc =_fdbe ._acdc [:len (_fdbe ._acdc )-1];return nil ;};func _dfe (_dade *Sheet )*evalContext {return &evalContext {_dbe :_dade ,_caae :make (map[string ]struct{})};};

// GetFormula returns the formula for a cell.
func (_gbfg Cell )GetFormula ()string {if _gbfg ._eeb .F !=nil {return _gbfg ._eeb .F .Content ;};return "";};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_dgcbe *Workbook )SetActiveSheetIndex (idx uint32 ){if _dgcbe ._gfdg .BookViews ==nil {_dgcbe ._gfdg .BookViews =_cdc .NewCT_BookViews ();};if len (_dgcbe ._gfdg .BookViews .WorkbookView )==0{_dgcbe ._gfdg .BookViews .WorkbookView =append (_dgcbe ._gfdg .BookViews .WorkbookView ,_cdc .NewCT_BookView ());};_dgcbe ._gfdg .BookViews .WorkbookView [0].ActiveTabAttr =_a .Uint32 (idx );};func _afea (_gac _ca .Time )_ca .Time {_gac =_gac .UTC ();return _ca .Date (_gac .Year (),_gac .Month (),_gac .Day (),_gac .Hour (),_gac .Minute (),_gac .Second (),_gac .Nanosecond (),_ca .Local );};

// SetRowOffset sets the row offset of the two cell anchor
func (_adcf TwoCellAnchor )SetRowOffset (m _bb .Distance ){_bfdc :=m -_adcf .TopLeft ().RowOffset ();_adcf .TopLeft ().SetRowOffset (m );_adcf .BottomRight ().SetRowOffset (_adcf .BottomRight ().RowOffset ()+_bfdc );};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_bfb *Sheet )AddRow ()Row {_caaef :=uint32 (0);_gcga :=uint32 (len (_bfb ._gaec .SheetData .Row ));if _gcga > 0&&_bfb ._gaec .SheetData .Row [_gcga -1].RAttr !=nil &&*_bfb ._gaec .SheetData .Row [_gcga -1].RAttr ==_gcga {return _bfb .addNumberedRowFast (_gcga +1);};for _ ,_edag :=range _bfb ._gaec .SheetData .Row {if _edag .RAttr !=nil &&*_edag .RAttr > _caaef {_caaef =*_edag .RAttr ;};};return _bfb .AddNumberedRow (_caaef +1);};

// Author returns the author of the comment
func (_cbf Comment )Author ()string {if _cbf ._cgce .AuthorIdAttr < uint32 (len (_cbf ._edd .Authors .Author )){return _cbf ._edd .Authors .Author [_cbf ._cgce .AuthorIdAttr ];};return "";};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_fddd *Workbook )RemoveCalcChain (){var _bdge string ;for _ ,_cebcb :=range _fddd ._bfec .Relationships (){if _cebcb .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_bdge ="\u0078\u006c\u002f"+_cebcb .Target ();_fddd ._bfec .Remove (_cebcb );break ;};};if _bdge ==""{return ;};_fddd .ContentTypes .RemoveOverride (_bdge );for _ceeee ,_cffc :=range _fddd .ExtraFiles {if _cffc .ZipPath ==_bdge {_fddd .ExtraFiles [_ceeee ]=_fddd .ExtraFiles [len (_fddd .ExtraFiles )-1];_fddd .ExtraFiles =_fddd .ExtraFiles [:len (_fddd .ExtraFiles )-1];return ;};};};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_da Cell )SetString (s string )int {_da ._ffb .ensureSharedStringsRelationships ();_da .clearValue ();_bef :=_da ._ffb .SharedStrings .AddString (s );_da ._eeb .V =_a .String (_cc .Itoa (_bef ));_da ._eeb .TAttr =_cdc .ST_CellTypeS ;return _bef ;};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_adc *Workbook ;_efcc *_cg .WsDr ;};func (_eaca *Sheet )slideCellsLeft (_eabf []*_cdc .CT_Cell )[]*_cdc .CT_Cell {for _ ,_daag :=range _eabf {_aaee ,_fbe :=_gc .ParseCellReference (*_daag .RAttr );if _fbe !=nil {return _eabf ;};_accf :=_aaee .ColumnIdx -1;_eeee :=_gc .IndexToColumn (_accf )+_fc .Sprintf ("\u0025\u0064",_aaee .RowIdx );_daag .RAttr =&_eeee ;};return _eabf ;};

// SetMaxLength sets the maximum bar length in percent.
func (_egd DataBarScale )SetMaxLength (l uint32 ){_egd ._fga .MaxLengthAttr =_a .Uint32 (l )};

// AddFont adds a new empty font to the stylesheet.
func (_gegg StyleSheet )AddFont ()Font {_afag :=_cdc .NewCT_Font ();_gegg ._ccbbd .Fonts .Font =append (_gegg ._ccbbd .Fonts .Font ,_afag );_gegg ._ccbbd .Fonts .CountAttr =_a .Uint32 (uint32 (len (_gegg ._ccbbd .Fonts .Font )));return Font {_afag ,_gegg ._ccbbd };};type WorkbookProtection struct{_bgdb *_cdc .CT_WorkbookProtection };

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_ccgd *Sheet )InitialView ()SheetView {if _ccgd ._gaec .SheetViews ==nil ||len (_ccgd ._gaec .SheetViews .SheetView )==0{return _ccgd .AddView ();};return SheetView {_ccgd ._gaec .SheetViews .SheetView [0]};};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_gcdfe *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_fcgg :=-1;for _ebgef ,_feddd :=range _gcdfe .Sheets (){if name ==_feddd .Name (){_fcgg =_ebgef ;break ;};};if _fcgg ==-1{return Sheet {},ErrorNotFound ;};return _gcdfe .CopySheet (_fcgg ,copiedSheetName );};

// Borders returns the list of borders defined in the stylesheet.
func (_cfaa StyleSheet )Borders ()[]Border {_abgb :=[]Border {};for _ ,_cfef :=range _cfaa ._ccbbd .Borders .Border {_abgb =append (_abgb ,Border {_eca :_cfef });};return _abgb ;};

// LockWindow controls the locking of the workbook windows.
func (_geba WorkbookProtection )LockWindow (b bool ){if !b {_geba ._bgdb .LockWindowsAttr =nil ;}else {_geba ._bgdb .LockWindowsAttr =_a .Bool (true );};};

// StyleSheet is a document style sheet.
type StyleSheet struct{_gcbf *Workbook ;_ccbbd *_cdc .StyleSheet ;};

// LockSheet controls the locking of the sheet.
func (_baea SheetProtection )LockSheet (b bool ){if !b {_baea ._bacd .SheetAttr =nil ;}else {_baea ._bacd .SheetAttr =_a .Bool (true );};};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_dbab *_cg .CT_OneCellAnchor };type Table struct{_ffgfd *_cdc .Table };var _feec =_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .SharedStringsType ,0);

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_eabb DataValidationList )SetRange (cellRange string ){_eabb ._aabb .Formula1 =_a .String (cellRange );_eabb ._aabb .Formula2 =_a .String ("\u0030");};func (_eccd StandardFormat )String ()string {switch {case 0<=_eccd &&_eccd <=4:return _fdabb [_bbbg [_eccd ]:_bbbg [_eccd +1]];case 9<=_eccd &&_eccd <=22:_eccd -=9;return _bdgc [_dbcb [_eccd ]:_dbcb [_eccd +1]];case 37<=_eccd &&_eccd <=40:_eccd -=37;return _fgeg [_dcgg [_eccd ]:_dcgg [_eccd +1]];case 45<=_eccd &&_eccd <=49:_eccd -=45;return _cfae [_geaea [_eccd ]:_geaea [_eccd +1]];default:return _fc .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_eccd );};};

// SetNumber sets the cell type to number, and the value to the given number
func (_agg Cell )SetNumber (v float64 ){_agg .clearValue ();if _ef .IsNaN (v )||_ef .IsInf (v ,0){_agg ._eeb .TAttr =_cdc .ST_CellTypeE ;_agg ._eeb .V =_a .String ("\u0023\u004e\u0055M\u0021");return ;};_agg ._eeb .TAttr =_cdc .ST_CellTypeN ;_agg ._eeb .V =_a .String (_cc .FormatFloat (v ,'f',-1,64));};

// X returns the inner wrapped XML type.
func (_caag Table )X ()*_cdc .Table {return _caag ._ffgfd };

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_egca Drawing )AddChart (at AnchorType )(_be .Chart ,Anchor ){_bda :=_cd .NewChartSpace ();_egca ._adc ._aefda =append (_egca ._adc ._aefda ,_bda );_gbfc :=_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .ChartContentType ,len (_egca ._adc ._aefda ));_egca ._adc .ContentTypes .AddOverride (_gbfc ,_a .ChartContentType );var _dcbe string ;for _cgb ,_eegf :=range _egca ._adc ._fddb {if _eegf ==_egca ._efcc {_aebe :=_a .RelativeFilename (_a .DocTypeSpreadsheet ,_a .DrawingType ,_a .ChartType ,len (_egca ._adc ._aefda ));_bcdd :=_egca ._adc ._afegb [_cgb ].AddRelationship (_aebe ,_a .ChartType );_dcbe =_bcdd .ID ();break ;};};var _gbgb Anchor ;var _gab *_cg .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_cfcf :=_aecb ();_egca ._efcc .EG_Anchor =append (_egca ._efcc .EG_Anchor ,&_cg .EG_Anchor {AbsoluteAnchor :_cfcf });_cfcf .Choice =&_cg .EG_ObjectChoicesChoice {};_cfcf .Choice .GraphicFrame =_cg .NewCT_GraphicalObjectFrame ();_gab =_cfcf .Choice .GraphicFrame ;_gbgb =AbsoluteAnchor {_cfcf };case AnchorTypeOneCell :_ecb :=_gbde ();_egca ._efcc .EG_Anchor =append (_egca ._efcc .EG_Anchor ,&_cg .EG_Anchor {OneCellAnchor :_ecb });_ecb .Choice =&_cg .EG_ObjectChoicesChoice {};_ecb .Choice .GraphicFrame =_cg .NewCT_GraphicalObjectFrame ();_gab =_ecb .Choice .GraphicFrame ;_gbgb =OneCellAnchor {_ecb };case AnchorTypeTwoCell :_fdd :=_daa ();_egca ._efcc .EG_Anchor =append (_egca ._efcc .EG_Anchor ,&_cg .EG_Anchor {TwoCellAnchor :_fdd });_fdd .Choice =&_cg .EG_ObjectChoicesChoice {};_fdd .Choice .GraphicFrame =_cg .NewCT_GraphicalObjectFrame ();_gab =_fdd .Choice .GraphicFrame ;_gbgb =TwoCellAnchor {_fdd };};_gab .NvGraphicFramePr =_cg .NewCT_GraphicalObjectFrameNonVisual ();_gab .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_egca ._efcc .EG_Anchor ));_gab .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_gab .Graphic =_deb .NewGraphic ();_gab .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_ceae :=_cd .NewChart ();_ceae .IdAttr =_dcbe ;_gab .Graphic .GraphicData .Any =[]_a .Any {_ceae };_fadc :=_be .MakeChart (_bda );_fadc .Properties ().SetSolidFill (_de .White );_fadc .SetDisplayBlanksAs (_cd .ST_DispBlanksAsGap );return _fadc ,_gbgb ;};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_gbc ConditionalFormattingRule )SetConditionValue (v string ){_gbc ._aca .Formula =[]string {v }};

// IsSheetLocked returns whether the sheet objects are locked.
func (_ggb SheetProtection )IsObjectLocked ()bool {return _ggb ._bacd .ObjectsAttr !=nil &&*_ggb ._bacd .ObjectsAttr ;};

// X returns the inner wrapped XML type.
func (_bbg DefinedName )X ()*_cdc .CT_DefinedName {return _bbg ._cadb };func (_dfa CellStyle )SetNumberFormat (s string ){_abga :=_dfa ._ceg .StyleSheet .AddNumberFormat ();_abga .SetFormat (s );_dfa ._eae .ApplyNumberFormatAttr =_a .Bool (true );_dfa ._eae .NumFmtIdAttr =_a .Uint32 (_abga .ID ());};

// SetBold causes the text to be displayed in bold.
func (_afdg RichTextRun )SetBold (b bool ){_afdg .ensureRpr ();_afdg ._bgf .RPr .B =_cdc .NewCT_BooleanProperty ();_afdg ._bgf .RPr .B .ValAttr =_a .Bool (b );};

// SetUnderline controls if the run is underlined.
func (_def RichTextRun )SetUnderline (u _cdc .ST_UnderlineValues ){_def .ensureRpr ();_def ._bgf .RPr .U =_cdc .NewCT_UnderlineProperty ();_def ._bgf .RPr .U .ValAttr =u ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_beed *_cdc .CT_Rst };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_bfceb *Sheet )RecalculateFormulas (){_aebf :=_bf .NewEvaluator ();_fdf :=_bfceb .FormulaContext ();for _ ,_fadcd :=range _bfceb .Rows (){for _ ,_bagc :=range _fadcd .Cells (){if _bagc .X ().F !=nil {_ecc :=_bagc .X ().F .Content ;if _bagc .X ().F .TAttr ==_cdc .ST_CellFormulaTypeShared &&len (_ecc )==0{continue ;};_dgcbd :=_aebf .Eval (_fdf ,_ecc ).AsString ();if _dgcbd .Type ==_bf .ResultTypeError {_a .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_ecc ,_dgcbd .ErrorMessage );_bagc .X ().V =nil ;}else {if _dgcbd .Type ==_bf .ResultTypeNumber {_bagc .X ().TAttr =_cdc .ST_CellTypeN ;}else {_bagc .X ().TAttr =_cdc .ST_CellTypeInlineStr ;};_bagc .X ().V =_a .String (_dgcbd .Value ());if _bagc .X ().F .TAttr ==_cdc .ST_CellFormulaTypeArray {if _dgcbd .Type ==_bf .ResultTypeArray {_bfceb .setArray (_bagc .Reference (),_dgcbd );}else if _dgcbd .Type ==_bf .ResultTypeList {_bfceb .setList (_bagc .Reference (),_dgcbd );};}else if _bagc .X ().F .TAttr ==_cdc .ST_CellFormulaTypeShared &&_bagc .X ().F .RefAttr !=nil {_ffcg ,_gfbg ,_ecff :=_gc .ParseRangeReference (*_bagc .X ().F .RefAttr );if _ecff !=nil {_ac .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_ecff );continue ;};_bfceb .setShared (_bagc .Reference (),_ffcg ,_gfbg ,_ecc );};};};};};};

// X returns the inner wrapped XML type.
func (_ddg Column )X ()*_cdc .CT_Col {return _ddg ._ebb };

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_fbcf *Workbook )Uses1904Dates ()bool {if _fbcf ._gfdg .WorkbookPr ==nil ||_fbcf ._gfdg .WorkbookPr .Date1904Attr ==nil {return false ;};return *_fbcf ._gfdg .WorkbookPr .Date1904Attr ;};

// AddCell adds a cell to a spreadsheet.
func (_decd Row )AddCell ()Cell {_efef :=uint32 (len (_decd ._gdgc .C ));var _fbc *string ;if _efef > 0{_agf :=_a .Stringf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_efef -1),_decd .RowNumber ());if _decd ._gdgc .C [_efef -1].RAttr !=nil &&*_decd ._gdgc .C [_efef -1].RAttr ==*_agf {_fbc =_a .Stringf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_efef ),_decd .RowNumber ());};};_fcee :=_cdc .NewCT_Cell ();_decd ._gdgc .C =append (_decd ._gdgc .C ,_fcee );if _fbc ==nil {_gdce :=uint32 (0);for _ ,_gaa :=range _decd ._gdgc .C {if _gaa .RAttr !=nil {_gffd ,_ :=_gc .ParseCellReference (*_gaa .RAttr );if _gffd .ColumnIdx >=_gdce {_gdce =_gffd .ColumnIdx +1;};};};_fbc =_a .Stringf ("\u0025\u0073\u0025\u0064",_gc .IndexToColumn (_gdce ),_decd .RowNumber ());};_fcee .RAttr =_fbc ;return Cell {_decd ._ceaf ,_decd ._dfg ,_decd ._gdgc ,_fcee };};const _egfa ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_cbcd *Sheet )SheetViews ()[]SheetView {if _cbcd ._gaec .SheetViews ==nil {return nil ;};_gedd :=[]SheetView {};for _ ,_aadb :=range _cbcd ._gaec .SheetViews .SheetView {_gedd =append (_gedd ,SheetView {_aadb });};return _gedd ;};

// Comments is the container for comments for a single sheet.
type Comments struct{_abec *Workbook ;_aec *_cdc .Comments ;};

// Text returns text from the workbook as one string separated with line breaks.
func (_acgf *WorkbookText )Text ()string {_acd :=_ee .NewBuffer ([]byte {});for _ ,_cgfd :=range _acgf .Sheets {_acd .WriteString (_cgfd .Text ());};return _acd .String ();};

// SetWrapped configures the cell to wrap text.
func (_ead CellStyle )SetWrapped (b bool ){if _ead ._eae .Alignment ==nil {_ead ._eae .Alignment =_cdc .NewCT_CellAlignment ();};if !b {_ead ._eae .Alignment .WrapTextAttr =nil ;}else {_ead ._eae .Alignment .WrapTextAttr =_a .Bool (true );_ead ._eae .ApplyAlignmentAttr =_a .Bool (true );};};

// SetStyle sets the style to be used for conditional rules
func (_cff ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_cff ._aca .DxfIdAttr =_a .Uint32 (d .Index ());};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cbb Drawing )AddImage (img _fe .ImageRef ,at AnchorType )Anchor {_afbb :=0;for _bbgc ,_dgcb :=range _cbb ._adc .Images {if _dgcb ==img {_afbb =_bbgc +1;break ;};};var _cdfc string ;for _bafd ,_bad :=range _cbb ._adc ._fddb {if _bad ==_cbb ._efcc {_cfda :=_fc .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_afbb ,img .Format ());_fbg :=_cbb ._adc ._afegb [_bafd ].AddRelationship (_cfda ,_a .ImageType );_cdfc =_fbg .ID ();break ;};};var _bab Anchor ;var _afcff *_cg .CT_Picture ;switch at {case AnchorTypeAbsolute :_ccba :=_aecb ();_cbb ._efcc .EG_Anchor =append (_cbb ._efcc .EG_Anchor ,&_cg .EG_Anchor {AbsoluteAnchor :_ccba });_ccba .Choice =&_cg .EG_ObjectChoicesChoice {};_ccba .Choice .Pic =_cg .NewCT_Picture ();_ccba .Pos .XAttr .ST_CoordinateUnqualified =_a .Int64 (0);_ccba .Pos .YAttr .ST_CoordinateUnqualified =_a .Int64 (0);_afcff =_ccba .Choice .Pic ;_bab =AbsoluteAnchor {_ccba };case AnchorTypeOneCell :_dfb :=_gbde ();_cbb ._efcc .EG_Anchor =append (_cbb ._efcc .EG_Anchor ,&_cg .EG_Anchor {OneCellAnchor :_dfb });_dfb .Choice =&_cg .EG_ObjectChoicesChoice {};_dfb .Choice .Pic =_cg .NewCT_Picture ();_afcff =_dfb .Choice .Pic ;_bab =OneCellAnchor {_dfb };case AnchorTypeTwoCell :_dgg :=_daa ();_cbb ._efcc .EG_Anchor =append (_cbb ._efcc .EG_Anchor ,&_cg .EG_Anchor {TwoCellAnchor :_dgg });_dgg .Choice =&_cg .EG_ObjectChoicesChoice {};_dgg .Choice .Pic =_cg .NewCT_Picture ();_afcff =_dgg .Choice .Pic ;_bab =TwoCellAnchor {_dgg };};_afcff .NvPicPr .CNvPr .IdAttr =uint32 (len (_cbb ._efcc .EG_Anchor ));_afcff .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_afcff .BlipFill .Blip =_deb .NewCT_Blip ();_afcff .BlipFill .Blip .EmbedAttr =_a .String (_cdfc );_afcff .BlipFill .Stretch =_deb .NewCT_StretchInfoProperties ();_afcff .SpPr =_deb .NewCT_ShapeProperties ();_afcff .SpPr .Xfrm =_deb .NewCT_Transform2D ();_afcff .SpPr .Xfrm .Off =_deb .NewCT_Point2D ();_afcff .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_a .Int64 (0);_afcff .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_a .Int64 (0);_afcff .SpPr .Xfrm .Ext =_deb .NewCT_PositiveSize2D ();_afcff .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_bb .Pixel72 )/_bb .EMU );_afcff .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_bb .Pixel72 )/_bb .EMU );_afcff .SpPr .PrstGeom =_deb .NewCT_PresetGeometry2D ();_afcff .SpPr .PrstGeom .PrstAttr =_deb .ST_ShapeTypeRect ;_afcff .SpPr .Ln =_deb .NewCT_LineProperties ();_afcff .SpPr .Ln .NoFill =_deb .NewCT_NoFillProperties ();return _bab ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_cdbb IconScale )AddFormatValue (t _cdc .ST_CfvoType ,val string ){_ecga :=_cdc .NewCT_Cfvo ();_ecga .TypeAttr =t ;_ecga .ValAttr =_a .String (val );_cdbb ._cbdd .Cfvo =append (_cdbb ._cbdd .Cfvo ,_ecga );};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_bfage *_cg .CT_TwoCellAnchor };

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_ecgg *Sheet )FormulaContext ()_bf .Context {return _dfe (_ecgg )};

// ClearFill clears any fill configuration from the cell style.
func (_ebdd CellStyle )ClearFill (){_ebdd ._eae .FillIdAttr =nil ;_ebdd ._eae .ApplyFillAttr =nil };

// SetError sets the cell type to error and the value to the given error message.
func (_dac Cell )SetError (msg string ){_dac .clearValue ();_dac ._eeb .V =_a .String (msg );_dac ._eeb .TAttr =_cdc .ST_CellTypeE ;};

// AddGradientStop adds a color gradient stop.
func (_bcf ColorScale )AddGradientStop (color _de .Color ){_age :=_cdc .NewCT_Color ();_age .RgbAttr =color .AsRGBAString ();_bcf ._cba .Color =append (_bcf ._cba .Color ,_age );};func (_fcgef Fills )AddFill ()Fill {_gde :=_cdc .NewCT_Fill ();_fcgef ._gga .Fill =append (_fcgef ._gga .Fill ,_gde );_fcgef ._gga .CountAttr =_a .Uint32 (uint32 (len (_fcgef ._gga .Fill )));return Fill {_gde ,_fcgef ._gga };};

// X returns the inner wrapped XML type.
func (_fec Border )X ()*_cdc .CT_Border {return _fec ._eca };

// CellMarker represents a cell position
type CellMarker struct{_cde *_cg .CT_Marker };

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_dga *evalContext )LastColumn (rowFrom ,rowTo int )string {_dbc :=_dga ._dbe ;_efeb :=1;for _eebfd :=rowFrom ;_eebfd <=rowTo ;_eebfd ++{_fgca :=len (_dbc .Row (uint32 (_eebfd )).Cells ());if _fgca > _efeb {_efeb =_fgca ;};};return _gc .IndexToColumn (uint32 (_efeb -1));};func (_aede Comments )getOrCreateAuthor (_ebddc string )uint32 {for _aea ,_ced :=range _aede ._aec .Authors .Author {if _ced ==_ebddc {return uint32 (_aea );};};_afac :=uint32 (len (_aede ._aec .Authors .Author ));_aede ._aec .Authors .Author =append (_aede ._aec .Authors .Author ,_ebddc );return _afac ;};func (_ffdc *evalContext )NamedRange (ref string )_bf .Reference {for _ ,_ccgc :=range _ffdc ._dbe ._bbfc .DefinedNames (){if _ccgc .Name ()==ref {return _bf .MakeRangeReference (_ccgc .Content ());};};for _ ,_efg :=range _ffdc ._dbe ._bbfc .Tables (){if _efg .Name ()==ref {return _bf .MakeRangeReference (_fc .Sprintf ("\u0025\u0073\u0021%\u0073",_ffdc ._dbe .Name (),_efg .Reference ()));};};return _bf .ReferenceInvalid ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_agcc DataValidation )SetRange (cellRange string ){_agcc ._bcc .SqrefAttr =_cdc .ST_Sqref {cellRange };};

// X returns the inner XML entity for a stylesheet.
func (_efee StyleSheet )X ()*_cdc .StyleSheet {return _efee ._ccbbd };

// SetBorder applies a border to a cell style. The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_fde CellStyle )SetBorder (b Border ){_fde ._eae .BorderIdAttr =_a .Uint32 (b .Index ());_fde ._eae .ApplyBorderAttr =_a .Bool (true );};

// SetShowRuler controls the visibility of the ruler
func (_ceag SheetView )SetShowRuler (b bool ){if !b {_ceag ._bfagf .ShowRulerAttr =_a .Bool (false );}else {_ceag ._bfagf .ShowRulerAttr =nil ;};};

// X returns the inner wrapped XML type.
func (_dfge Row )X ()*_cdc .CT_Row {return _dfge ._gdgc };

// SetPassword sets the password hash to a hash of the input password.
func (_cceff WorkbookProtection )SetPassword (pw string ){_cceff .SetPasswordHash (PasswordHash (pw ))};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_ab Cell )SetFormulaRaw (s string ){_eec :=_bf .ParseString (s );if _eec ==nil {return ;};_ab .clearValue ();_ab ._eeb .TAttr =_cdc .ST_CellTypeStr ;_ab ._eeb .F =_cdc .NewCT_CellFormula ();_ab ._eeb .F .Content =s ;};

// Index returns the index of the differential style.
func (_ggc DifferentialStyle )Index ()uint32 {for _bfad ,_dcdd :=range _ggc ._gdcb .Dxf {if _ggc ._bfde ==_dcdd {return uint32 (_bfad );};};return 0;};type SheetProtection struct{_bacd *_cdc .CT_SheetProtection };

// SetTopLeft sets the top left visible cell after the split.
func (_aedfe SheetView )SetTopLeft (cellRef string ){_aedfe .ensurePane ();_aedfe ._bfagf .Pane .TopLeftCellAttr =&cellRef ;};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_ecf Cell )AddHyperlink (url string ){for _bac ,_aeec :=range _ecf ._ffb ._gbfaa {if _aeec ==_ecf ._fd ._gaec {_ecf .SetHyperlink (_ecf ._ffb ._cdgb [_bac ].AddHyperlink (url ));return ;};};};

// SetWidthCells is a no-op.
func (_ec AbsoluteAnchor )SetWidthCells (int32 ){};

// SetColor sets the text color.
func (_cga RichTextRun )SetColor (c _de .Color ){_cga .ensureRpr ();_cga ._bgf .RPr .Color =_cdc .NewCT_Color ();_cbbc :="\u0066\u0066"+*c .AsRGBString ();_cga ._bgf .RPr .Color .RgbAttr =&_cbbc ;};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_gee NumberFormat )ID ()uint32 {return _gee ._dcf .NumFmtIdAttr };func (_gag ConditionalFormattingRule )InitializeDefaults (){_gag .SetType (_cdc .ST_CfTypeCellIs );_gag .SetOperator (_cdc .ST_ConditionalFormattingOperatorGreaterThan );_gag .SetPriority (1);};

// Name returns the name of the defined name.
func (_aabbd DefinedName )Name ()string {return _aabbd ._cadb .NameAttr };var _gfde =[...]uint8 {0,18,37};

// ClearProtection clears all workbook protections.
func (_geeb *Workbook )ClearProtection (){_geeb ._gfdg .WorkbookProtection =nil };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_bebag *Sheet )Column (idx uint32 )Column {for _ ,_agdef :=range _bebag ._gaec .Cols {for _ ,_beaa :=range _agdef .Col {if idx >=_beaa .MinAttr &&idx <=_beaa .MaxAttr {return Column {_beaa };};};};var _ccgg *_cdc .CT_Cols ;if len (_bebag ._gaec .Cols )==0{_ccgg =_cdc .NewCT_Cols ();_bebag ._gaec .Cols =append (_bebag ._gaec .Cols ,_ccgg );}else {_ccgg =_bebag ._gaec .Cols [0];};_bbbd :=_cdc .NewCT_Col ();_bbbd .MinAttr =idx ;_bbbd .MaxAttr =idx ;_ccgg .Col =append (_ccgg .Col ,_bbbd );return Column {_bbbd };};

// HasFormula returns true if the cell has an asoociated formula.
func (_cfa Cell )HasFormula ()bool {return _cfa ._eeb .F !=nil };

// SetPasswordHash sets the password hash to the input.
func (_fbef SheetProtection )SetPasswordHash (pwHash string ){_fbef ._bacd .PasswordAttr =_a .String (pwHash );};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_fcf Cell )SetFormulaArray (s string ){_bg :=_bf .ParseString (s );if _bg ==nil {return ;};_fcf .clearValue ();_fcf ._eeb .TAttr =_cdc .ST_CellTypeStr ;_fcf ._eeb .F =_cdc .NewCT_CellFormula ();_fcf ._eeb .F .TAttr =_cdc .ST_CellFormulaTypeArray ;_fcf ._eeb .F .Content =s ;};

// Themes returns the array of workbook dml.Theme.
func (_aga *Workbook )Themes ()[]*_deb .Theme {return _aga ._gbeg };

// SetColOffset sets a column offset in absolute distance.
func (_fb CellMarker )SetColOffset (m _bb .Distance ){_fb ._cde .ColOff .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_bb .EMU ));};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_cadgf *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_dgaa :=_cdc .NewCT_ConditionalFormatting ();_cadgf ._gaec .ConditionalFormatting =append (_cadgf ._gaec .ConditionalFormatting ,_dgaa );_beff :=make (_cdc .ST_Sqref ,0,0);_dgaa .SqrefAttr =&_beff ;for _ ,_dgba :=range cellRanges {*_dgaa .SqrefAttr =append (*_dgaa .SqrefAttr ,_dgba );};return ConditionalFormatting {_dgaa };};

// SetSize sets the text size for a rich text run.
func (_aecc RichTextRun )SetSize (m _bb .Distance ){_aecc .ensureRpr ();_aecc ._bgf .RPr .Sz =_cdc .NewCT_FontSize ();_aecc ._bgf .RPr .Sz .ValAttr =float64 (m /_bb .Point );};func (_dcfc *Sheet )updateAfterRemove (_fac uint32 ,_aggb _ge .UpdateAction )error {_fdde :=_dcfc .Name ();_dbbf :=&_ge .UpdateQuery {UpdateType :_aggb ,ColumnIdx :_fac ,SheetToUpdate :_fdde };for _ ,_agbdf :=range _dcfc ._bbfc .Sheets (){_dbbf .UpdateCurrentSheet =_fdde ==_agbdf .Name ();for _ ,_effg :=range _agbdf .Rows (){for _ ,_adbf :=range _effg .Cells (){if _adbf .X ().F !=nil {_dgde :=_adbf .X ().F .Content ;_egg :=_bf .ParseString (_dgde );if _egg ==nil {_adbf .SetError ("\u0023\u0052\u0045F\u0021");}else {_bdad :=_egg .Update (_dbbf );_adbf .X ().F .Content =_fc .Sprintf ("\u003d\u0025\u0073",_bdad .String ());};};};};};return nil ;};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_gdg CellStyle )SetVerticalAlignment (a _cdc .ST_VerticalAlignment ){if _gdg ._eae .Alignment ==nil {_gdg ._eae .Alignment =_cdc .NewCT_CellAlignment ();};_gdg ._eae .ApplyAlignmentAttr =_a .Bool (true );_gdg ._eae .Alignment .VerticalAttr =a ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_fegd :=uint16 (0);if len (s )> 0{for _eaab :=len (s )-1;_eaab >=0;_eaab --{_bbd :=s [_eaab ];_fegd =((_fegd >>14)&0x01)|((_fegd <<1)&0x7fff);_fegd ^=uint16 (_bbd );};_fegd =((_fegd >>14)&0x01)|((_fegd <<1)&0x7fff);_fegd ^=uint16 (len (s ));_fegd ^=(0x8000|('N'<<8)|'K');};return _fc .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_fegd ));};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_fbff *Workbook )Epoch ()_ca .Time {if _fbff .Uses1904Dates (){_ca .Date (1904,1,1,0,0,0,0,_ca .UTC );};return _ca .Date (1899,12,30,0,0,0,0,_ca .UTC );};

// X returns the inner wrapped XML type.
func (_acae WorkbookProtection )X ()*_cdc .CT_WorkbookProtection {return _acae ._bgdb };func (_gadf DataValidationCompare )SetValue2 (v string ){_gadf ._fcfa .Formula2 =&v };

// MoveTo repositions the anchor without changing the objects size.
func (_gcba TwoCellAnchor )MoveTo (col ,row int32 ){_bfbf :=_gcba .TopLeft ();_cedad :=_gcba .BottomRight ();_caead :=_cedad .Col ()-_bfbf .Col ();_gbfde :=_cedad .Row ()-_bfbf .Row ();_bfbf .SetCol (col );_bfbf .SetRow (row );_cedad .SetCol (col +_caead );_cedad .SetRow (row +_gbfde );};

// AddMergedCells merges cells within a sheet.
func (_agfd *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _agfd ._gaec .MergeCells ==nil {_agfd ._gaec .MergeCells =_cdc .NewCT_MergeCells ();};_begf :=_cdc .NewCT_MergeCell ();_begf .RefAttr =_fc .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_agfd ._gaec .MergeCells .MergeCell =append (_agfd ._gaec .MergeCells .MergeCell ,_begf );_agfd ._gaec .MergeCells .CountAttr =_a .Uint32 (uint32 (len (_agfd ._gaec .MergeCells .MergeCell )));return MergedCell {_agfd ._bbfc ,_agfd ,_begf };};func (_fcfb Row )renumberAs (_bcce uint32 ){_fcfb ._gdgc .RAttr =_a .Uint32 (_bcce );for _ ,_bbag :=range _fcfb .Cells (){_dbec ,_ffge :=_gc .ParseCellReference (_bbag .Reference ());if _ffge ==nil {_gcde :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",_dbec .Column ,_bcce );_bbag ._eeb .RAttr =_a .String (_gcde );};};};

// AddSheet adds a new sheet to a workbook.
func (_bfed *Workbook )AddSheet ()Sheet {_cefbf :=_cdc .NewCT_Sheet ();_cefbf .SheetIdAttr =1;for _ ,_dedbe :=range _bfed ._gfdg .Sheets .Sheet {if _cefbf .SheetIdAttr <=_dedbe .SheetIdAttr {_cefbf .SheetIdAttr =_dedbe .SheetIdAttr +1;};};_bfed ._gfdg .Sheets .Sheet =append (_bfed ._gfdg .Sheets .Sheet ,_cefbf );_cefbf .NameAttr =_fc .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_cefbf .SheetIdAttr );_afabg :=_cdc .NewWorksheet ();_afabg .Dimension =_cdc .NewCT_SheetDimension ();_afabg .Dimension .RefAttr ="\u0041\u0031";_bfed ._gbfaa =append (_bfed ._gbfaa ,_afabg );_ddgbd :=_fe .NewRelationships ();_bfed ._cdgb =append (_bfed ._cdgb ,_ddgbd );_afabg .SheetData =_cdc .NewCT_SheetData ();_bfed ._acdc =append (_bfed ._acdc ,nil );_efab :=_a .DocTypeSpreadsheet ;_abeef :=_bfed ._bfec .AddAutoRelationship (_efab ,_a .OfficeDocumentType ,len (_bfed ._gfdg .Sheets .Sheet ),_a .WorksheetType );_cefbf .IdAttr =_abeef .ID ();_bfed .ContentTypes .AddOverride (_a .AbsoluteFilename (_efab ,_a .WorksheetContentType ,len (_bfed ._gfdg .Sheets .Sheet )),_a .WorksheetContentType );return Sheet {_bfed ,_cefbf ,_afabg };};

// Type returns the type of the rule
func (_effb ConditionalFormattingRule )Type ()_cdc .ST_CfType {return _effb ._aca .TypeAttr };

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_bfa AbsoluteAnchor )SetRowOffset (m _bb .Distance ){_bfa ._dba .Pos .YAttr .ST_CoordinateUnqualified =_a .Int64 (int64 (m /_bb .EMU ));};

// IsSheetLocked returns whether the sheet is locked.
func (_gdbff SheetProtection )IsSheetLocked ()bool {return _gdbff ._bacd .SheetAttr !=nil &&*_gdbff ._bacd .SheetAttr ;};const (DVCompareOpEqual =DVCompareOp (_cdc .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_cdc .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_cdc .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_cdc .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_cdc .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_cdc .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_cdc .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_cdc .ST_DataValidationOperatorLessThanOrEqual ););

// X returns the inner wrapped XML type.
func (_dcbea SheetProtection )X ()*_cdc .CT_SheetProtection {return _dcbea ._bacd };

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_adead StyleSheet )AddNumberFormat ()NumberFormat {if _adead ._ccbbd .NumFmts ==nil {_adead ._ccbbd .NumFmts =_cdc .NewCT_NumFmts ();};_bdd :=_cdc .NewCT_NumFmt ();_bdd .NumFmtIdAttr =uint32 (200+len (_adead ._ccbbd .NumFmts .NumFmt ));_adead ._ccbbd .NumFmts .NumFmt =append (_adead ._ccbbd .NumFmts .NumFmt ,_bdd );_adead ._ccbbd .NumFmts .CountAttr =_a .Uint32 (uint32 (len (_adead ._ccbbd .NumFmts .NumFmt )));return NumberFormat {_adead ._gcbf ,_bdd };};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_eafa *Sheet )Row (rowNum uint32 )Row {for _ ,_dbcg :=range _eafa ._gaec .SheetData .Row {if _dbcg .RAttr !=nil &&*_dbcg .RAttr ==rowNum {return Row {_eafa ._bbfc ,_eafa ,_dbcg };};};return _eafa .AddNumberedRow (rowNum );};

// X returns the inner wrapped XML type.
func (_ceba SheetView )X ()*_cdc .CT_SheetView {return _ceba ._bfagf };

// X returns the inner wrapped XML type.
func (_cegb NumberFormat )X ()*_cdc .CT_NumFmt {return _cegb ._dcf };

// SetHeight sets the row height in points.
func (_geae Row )SetHeight (d _bb .Distance ){_geae ._gdgc .HtAttr =_a .Float64 (float64 (d ));_geae ._gdgc .CustomHeightAttr =_a .Bool (true );};func _aecb ()*_cg .CT_AbsoluteAnchor {_dbdb :=_cg .NewCT_AbsoluteAnchor ();return _dbdb };const (DVOpGreater =_cdc .ST_DataValidationOperatorGreaterThanOrEqual ;);

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_adf CellStyle )SetProtection (protected bool ,hidden bool ){_adf ._eae .Protection =&_cdc .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// IsBool returns true if the cell is a boolean type cell.
func (_efe Cell )IsBool ()bool {return _efe ._eeb .TAttr ==_cdc .ST_CellTypeB };

// SetRotation configures the cell to be rotated.
func (_fef CellStyle )SetRotation (deg uint8 ){if _fef ._eae .Alignment ==nil {_fef ._eae .Alignment =_cdc .NewCT_CellAlignment ();};_fef ._eae .ApplyAlignmentAttr =_a .Bool (true );_fef ._eae .Alignment .TextRotationAttr =_a .Uint8 (deg );};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_ebbc ConditionalFormattingRule )SetIcons ()IconScale {_ebbc .clear ();_ebbc .SetType (_cdc .ST_CfTypeIconSet );_ebbc ._aca .IconSet =_cdc .NewCT_IconSet ();_egff :=IconScale {_ebbc ._aca .IconSet };_egff .SetIcons (_cdc .ST_IconSetType3TrafficLights1 );return _egff ;};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_dgf SheetView )SetState (st _cdc .ST_PaneState ){_dgf .ensurePane ();_dgf ._bfagf .Pane .StateAttr =st ;};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_cba *_cdc .CT_ColorScale };

// ExtractText returns text from the workbook as a WorkbookText object.
func (_gcg *Workbook )ExtractText ()*WorkbookText {_efeaf :=[]*SheetText {};for _ ,_eecd :=range _gcg .Sheets (){_efeaf =append (_efeaf ,&SheetText {Cells :_eecd .ExtractText ().Cells });};return &WorkbookText {Sheets :_efeaf };};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_fe .DocBase ;_gfdg *_cdc .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_acdc []*_cdc .Comments ;_gbfaa []*_cdc .Worksheet ;_cdgb []_fe .Relationships ;_bfec _fe .Relationships ;_gbeg []*_deb .Theme ;_fddb []*_cg .WsDr ;_afegb []_fe .Relationships ;_egea []*_cf .Container ;_aefda []*_cd .ChartSpace ;_bgea []*_cdc .Table ;_deff string ;_dceaa map[string ]string ;_dbaee map[string ]*_cd .ChartSpace ;_eegc string ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// SetHeight sets the height of the anchored object.
func (_cgg AbsoluteAnchor )SetHeight (h _bb .Distance ){_cgg ._dba .Ext .CyAttr =int64 (h /_bb .EMU )};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_egcd *Sheet )Cell (cellRef string )Cell {_aafb ,_edgc :=_gc .ParseCellReference (cellRef );if _edgc !=nil {_a .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_edgc );return _egcd .AddRow ().AddCell ();};return _egcd .Row (_aafb .RowIdx ).Cell (_aafb .Column );};func (_cdee Sheet )validateSheetNames ()error {if len (_cdee .Name ())> 31{return _fc .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_cdee .Name (),len (_cdee .Name ()));};return nil ;};

// ClearNumberFormat removes any number formatting from the style.
func (_baa CellStyle )ClearNumberFormat (){_baa ._eae .NumFmtIdAttr =nil ;_baa ._eae .ApplyNumberFormatAttr =nil ;};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_fad DataValidationList )SetValues (values []string ){_fad ._aabb .Formula1 =_a .String ("\u0022"+_f .Join (values ,"\u002c")+"\u0022");_fad ._aabb .Formula2 =_a .String ("\u0030");};

// SetOperator sets the operator for the rule.
func (_cfgb ConditionalFormattingRule )SetOperator (t _cdc .ST_ConditionalFormattingOperator ){_cfgb ._aca .OperatorAttr =t ;};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_afd *_cdc .CT_ConditionalFormatting ;};

// SaveToFile writes the workbook out to a file.
func (_ffgd *Workbook )SaveToFile (path string )error {_ecea ,_cbab :=_gd .Create (path );if _cbab !=nil {return _cbab ;};defer _ecea .Close ();return _ffgd .Save (_ecea );};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_bcdc *Workbook )RecalculateFormulas (){for _ ,_gdag :=range _bcdc .Sheets (){_gdag .RecalculateFormulas ();};};

// Comments returns the list of comments for this sheet
func (_cagc Comments )Comments ()[]Comment {_aefb :=[]Comment {};for _ ,_gfd :=range _cagc ._aec .CommentList .Comment {_aefb =append (_aefb ,Comment {_cagc ._abec ,_gfd ,_cagc ._aec });};return _aefb ;};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_bebc TwoCellAnchor )SetWidthCells (w int32 ){_fcdc :=_bebc .TopLeft ();_fbcb :=_bebc .BottomRight ();_fbcb .SetCol (_fcdc .Col ()+w );};func (_abdfb *Sheet )getAllCellsInFormulaArrays (_gada bool )(map[string ]bool ,error ){_ffed :=_bf .NewEvaluator ();_beae :=_abdfb .FormulaContext ();_ccga :=map[string ]bool {};for _ ,_dea :=range _abdfb .Rows (){for _ ,_fcbc :=range _dea .Cells (){if _fcbc .X ().F !=nil {_gfgg :=_fcbc .X ().F .Content ;if _fcbc .X ().F .TAttr ==_cdc .ST_CellFormulaTypeArray {_aedf :=_ffed .Eval (_beae ,_gfgg ).AsString ();if _aedf .Type ==_bf .ResultTypeError {_a .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_gfgg ,_aedf .ErrorMessage );_fcbc .X ().V =nil ;};if _aedf .Type ==_bf .ResultTypeArray {_bdac ,_fgfd :=_gc .ParseCellReference (_fcbc .Reference ());if _fgfd !=nil {return map[string ]bool {},_fgfd ;};if (_gada &&len (_aedf .ValueArray )==1)||(!_gada &&len (_aedf .ValueArray [0])==1){continue ;};for _bbecc ,_bffa :=range _aedf .ValueArray {_agdg :=_bdac .RowIdx +uint32 (_bbecc );for _baba :=range _bffa {_ddacd :=_gc .IndexToColumn (_bdac .ColumnIdx +uint32 (_baba ));_ccga [_fc .Sprintf ("\u0025\u0073\u0025\u0064",_ddacd ,_agdg )]=true ;};};}else if _aedf .Type ==_bf .ResultTypeList {_cbcg ,_acgd :=_gc .ParseCellReference (_fcbc .Reference ());if _acgd !=nil {return map[string ]bool {},_acgd ;};if _gada ||len (_aedf .ValueList )==1{continue ;};_aebec :=_cbcg .RowIdx ;for _fbaf :=range _aedf .ValueList {_efde :=_gc .IndexToColumn (_cbcg .ColumnIdx +uint32 (_fbaf ));_ccga [_fc .Sprintf ("\u0025\u0073\u0025\u0064",_efde ,_aebec )]=true ;};};};};};};return _ccga ,nil ;};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_abge SheetView )SetZoom (pct uint32 ){_abge ._bfagf .ZoomScaleAttr =&pct };func (_ccaa *Workbook )ensureSharedStringsRelationships (){_ccbe :=false ;for _ ,_dggf :=range _ccaa .ContentTypes .X ().Override {if _dggf .ContentTypeAttr ==_a .SharedStringsContentType {_ccbe =true ;break ;};};if !_ccbe {_ccaa .ContentTypes .AddOverride (_feec ,_a .SharedStringsContentType );};_cfad :=false ;for _ ,_fbadd :=range _ccaa ._bfec .Relationships (){if _fbadd .X ().TargetAttr ==_fdad {_cfad =true ;break ;};};if !_cfad {_ccaa ._bfec .AddRelationship (_fdad ,_a .SharedStringsType );};};

// SetHeightCells is a no-op.
func (_aa AbsoluteAnchor )SetHeightCells (int32 ){};

// HasFormula returns true if the cell contains formula.
func (_gacc *evalContext )HasFormula (cellRef string )bool {return _gacc ._dbe .Cell (cellRef ).HasFormula ();};type Fill struct{_cbec *_cdc .CT_Fill ;_ccf *_cdc .CT_Fills ;};const _fag ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_ffcc *Workbook )AddImage (i _fe .Image )(_fe .ImageRef ,error ){_caee :=_fe .MakeImageRef (i ,&_ffcc .DocBase ,_ffcc ._bfec );if i .Data ==nil &&i .Path ==""{return _caee ,_efa .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _caee ,_efa .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _caee ,_efa .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_ceeea :=_cca .Add (i .Path );if _ceeea !=nil {return _caee ,_ceeea ;};};_ffcc .Images =append (_ffcc .Images ,_caee );return _caee ,nil ;};

// Validate attempts to validate the structure of a workbook.
func (_adacd *Workbook )Validate ()error {if _adacd ==nil ||_adacd ._gfdg ==nil {return _efa .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_ebfc :=uint32 (0);for _ ,_acbf :=range _adacd ._gfdg .Sheets .Sheet {if _acbf .SheetIdAttr > _ebfc {_ebfc =_acbf .SheetIdAttr ;};};if _ebfc !=uint32 (len (_adacd ._gbfaa )){return _fc .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_ebfc ,len (_adacd ._gbfaa ));};_aagfe :=map[string ]struct{}{};for _bfca ,_fefb :=range _adacd ._gfdg .Sheets .Sheet {_ebeg :=Sheet {_adacd ,_fefb ,_adacd ._gbfaa [_bfca ]};if _ ,_cccg :=_aagfe [_ebeg .Name ()];_cccg {return _fc .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_bfca ,_ebeg .Name ());};_aagfe [_ebeg .Name ()]=struct{}{};if _cdef :=_ebeg .ValidateWithPath (_fc .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_bfca ));_cdef !=nil {return _cdef ;};if _ggfc :=_ebeg .Validate ();_ggfc !=nil {return _ggfc ;};};return nil ;};

// GetValueAsBool retrieves the cell's value as a boolean
func (_gbf Cell )GetValueAsBool ()(bool ,error ){if _gbf ._eeb .TAttr !=_cdc .ST_CellTypeB {return false ,_efa .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _gbf ._eeb .V ==nil {return false ,_efa .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _cc .ParseBool (*_gbf ._eeb .V );};

// SetContent sets the defined name content.
func (_ddcb DefinedName )SetContent (s string ){_ddcb ._cadb .Content =s };func (_ecddf DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_ecddf .clear ();_ecddf ._bcc .TypeAttr =_cdc .ST_DataValidationType (t );_ecddf ._bcc .OperatorAttr =_cdc .ST_DataValidationOperator (op );return DataValidationCompare {_ecddf ._bcc };};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_ggdd TwoCellAnchor )SetHeightCells (h int32 ){_ggdd .SetHeight (0);_adee :=_ggdd .TopLeft ();_ecbdb :=_ggdd .BottomRight ();_ecbdb .SetRow (_adee .Row ()+h );};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_afb CellStyle )GetHorizontalAlignment ()_cdc .ST_HorizontalAlignment {if _afb ._eae .Alignment ==nil {return _cdc .ST_HorizontalAlignmentUnset ;};return _afb ._eae .Alignment .HorizontalAttr ;};func (_fgbd *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _fgbd .getAllCellsInFormulaArrays (false );};type ConditionalFormattingRule struct{_aca *_cdc .CT_CfRule };func (_bbe Cell )clearValue (){_bbe ._eeb .F =nil ;_bbe ._eeb .Is =nil ;_bbe ._eeb .V =nil ;_bbe ._eeb .TAttr =_cdc .ST_CellTypeUnset ;};const _faaa ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// RemoveDefinedName removes an existing defined name.
func (_dfdc *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _efa .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _bceg ,_acfd :=range _dfdc ._gfdg .DefinedNames .DefinedName {if _acfd ==dn .X (){copy (_dfdc ._gfdg .DefinedNames .DefinedName [_bceg :],_dfdc ._gfdg .DefinedNames .DefinedName [_bceg +1:]);_dfdc ._gfdg .DefinedNames .DefinedName [len (_dfdc ._gfdg .DefinedNames .DefinedName )-1]=nil ;_dfdc ._gfdg .DefinedNames .DefinedName =_dfdc ._gfdg .DefinedNames .DefinedName [:len (_dfdc ._gfdg .DefinedNames .DefinedName )-1];return nil ;};};return _efa .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// Sheets returns the sheets from the workbook.
func (_ccfd *Workbook )Sheets ()[]Sheet {_fdfe :=[]Sheet {};for _dedf ,_ggeb :=range _ccfd ._gbfaa {_bfdbd :=_ccfd ._gfdg .Sheets .Sheet [_dedf ];_ecggb :=Sheet {_ccfd ,_bfdbd ,_ggeb };_fdfe =append (_fdfe ,_ecggb );};return _fdfe ;};

// SetHidden hides or unhides the row
func (_ecfa Row )SetHidden (hidden bool ){if !hidden {_ecfa ._gdgc .HiddenAttr =nil ;}else {_ecfa ._gdgc .HiddenAttr =_a .Bool (true );};};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_cadb *_cdc .CT_DefinedName };

// SetItalic causes the text to be displayed in italic.
func (_efgc RichTextRun )SetItalic (b bool ){_efgc .ensureRpr ();_efgc ._bgf .RPr .I =_cdc .NewCT_BooleanProperty ();_efgc ._bgf .RPr .I .ValAttr =_a .Bool (b );};var (_bbbg =[...]uint8 {0,21,46,61,76,91};_dbcb =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_dcgg =[...]uint8 {0,16,32,48,64};_geaea =[...]uint8 {0,16,32,48,64,80};);

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_daea *Sheet )SetFrozen (firstRow ,firstCol bool ){_daea ._gaec .SheetViews =nil ;_geab :=_daea .AddView ();_geab .SetState (_cdc .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_geab .SetYSplit (1);_geab .SetXSplit (1);_geab .SetTopLeft ("\u0042\u0032");case firstRow :_geab .SetYSplit (1);_geab .SetTopLeft ("\u0041\u0032");case firstCol :_geab .SetXSplit (1);_geab .SetTopLeft ("\u0042\u0031");};};

// SetWidth sets the width of the anchored object.
func (_cfc AbsoluteAnchor )SetWidth (w _bb .Distance ){_cfc ._dba .Ext .CxAttr =int64 (w /_bb .EMU )};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_beca *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _beca .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _becab _fe .Relationship ;for _ ,_gebb :=range _beca ._bfec .Relationships (){if _gebb .ID ()==_beca ._gfdg .Sheets .Sheet [ind ].IdAttr {var _bdf bool ;if _becab ,_bdf =_beca ._bfec .CopyRelationship (_gebb .ID ());!_bdf {return Sheet {},ErrorNotFound ;};break ;};};_beca .ContentTypes .CopyOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,ind +1),_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .WorksheetContentType ,len (_beca .ContentTypes .X ().Override )));_deddd :=*_beca ._gbfaa [ind ];_beca ._gbfaa =append (_beca ._gbfaa ,&_deddd );var _cgbde uint32 =0;for _ ,_gccbb :=range _beca ._gfdg .Sheets .Sheet {if _gccbb .SheetIdAttr > _cgbde {_cgbde =_gccbb .SheetIdAttr ;};};_cgbde ++;_egfd :=*_beca ._gfdg .Sheets .Sheet [ind ];_egfd .IdAttr =_becab .ID ();_egfd .NameAttr =copiedSheetName ;_egfd .SheetIdAttr =_cgbde ;_beca ._gfdg .Sheets .Sheet =append (_beca ._gfdg .Sheets .Sheet ,&_egfd );_eaccg :=_fe .NewRelationshipsCopy (_beca ._cdgb [ind ]);_beca ._cdgb =append (_beca ._cdgb ,_eaccg );_cgbc :=_beca ._acdc [ind ];if _cgbc ==nil {_beca ._acdc =append (_beca ._acdc ,nil );}else {_ebce :=*_cgbc ;_beca ._acdc =append (_beca ._acdc ,&_ebce );};_ffdb :=Sheet {_beca ,&_egfd ,&_deddd };return _ffdb ,nil ;};

// ColOffset returns the offset from the row cell.
func (_ad CellMarker )ColOffset ()_bb .Distance {if _ad ._cde .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _bb .Distance (float64 (*_ad ._cde .ColOff .ST_CoordinateUnqualified )*_bb .EMU );};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_aeebe *Workbook )ClearCachedFormulaResults (){for _ ,_fdabg :=range _aeebe .Sheets (){_fdabg .ClearCachedFormulaResults ();};};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_ceac *Workbook )Save (w _b .Writer )error {const _cge ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_dd .GetLicenseKey ().IsLicensed ()&&!_ageac {_fc .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_fc .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _efa .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_ceac ._eegc )==0{_adac ,_aaefd :=_dd .GenRefId ("\u0073\u0077");if _aaefd !=nil {_a .Log ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_aaefd );return _aaefd ;};_ceac ._eegc =_adac ;};if _dcdb :=_dd .Track (_ceac ._eegc ,_cge );_dcdb !=nil {_fc .Printf ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_dcdb );return _dcdb ;};_bagf :=_c .NewWriter (w );defer _bagf .Close ();_gcfbc :=_a .DocTypeSpreadsheet ;if _facf :=_dc .MarshalXML (_bagf ,_a .BaseRelsFilename ,_ceac .Rels .X ());_facf !=nil {return _facf ;};if _cgaea :=_dc .MarshalXMLByType (_bagf ,_gcfbc ,_a .ExtendedPropertiesType ,_ceac .AppProperties .X ());_cgaea !=nil {return _cgaea ;};if _dcff :=_dc .MarshalXMLByType (_bagf ,_gcfbc ,_a .CorePropertiesType ,_ceac .CoreProperties .X ());_dcff !=nil {return _dcff ;};_cbdedf :=_a .AbsoluteFilename (_gcfbc ,_a .OfficeDocumentType ,0);if _egfec :=_dc .MarshalXML (_bagf ,_cbdedf ,_ceac ._gfdg );_egfec !=nil {return _egfec ;};if _dfbad :=_dc .MarshalXML (_bagf ,_dc .RelationsPathFor (_cbdedf ),_ceac ._bfec .X ());_dfbad !=nil {return _dfbad ;};if _aafbd :=_dc .MarshalXMLByType (_bagf ,_gcfbc ,_a .StylesType ,_ceac .StyleSheet .X ());_aafbd !=nil {return _aafbd ;};for _bdgb ,_cgdcg :=range _ceac ._gbeg {if _efbc :=_dc .MarshalXMLByTypeIndex (_bagf ,_gcfbc ,_a .ThemeType ,_bdgb +1,_cgdcg );_efbc !=nil {return _efbc ;};};for _dceaae ,_gbcf :=range _ceac ._gbfaa {_gbcf .Dimension .RefAttr =Sheet {_ceac ,nil ,_gbcf }.Extents ();_bafe :=_a .AbsoluteFilename (_gcfbc ,_a .WorksheetType ,_dceaae +1);_dc .MarshalXML (_bagf ,_bafe ,_gbcf );_dc .MarshalXML (_bagf ,_dc .RelationsPathFor (_bafe ),_ceac ._cdgb [_dceaae ].X ());};if _abcd :=_dc .MarshalXMLByType (_bagf ,_gcfbc ,_a .SharedStringsType ,_ceac .SharedStrings .X ());_abcd !=nil {return _abcd ;};if _ceac .CustomProperties .X ()!=nil {if _eea :=_dc .MarshalXMLByType (_bagf ,_gcfbc ,_a .CustomPropertiesType ,_ceac .CustomProperties .X ());_eea !=nil {return _eea ;};};if _ceac .Thumbnail !=nil {_gbbg :=_a .AbsoluteFilename (_gcfbc ,_a .ThumbnailType ,0);_gcgc ,_ddbb :=_bagf .Create (_gbbg );if _ddbb !=nil {return _ddbb ;};if _edbd :=_ae .Encode (_gcgc ,_ceac .Thumbnail ,nil );_edbd !=nil {return _edbd ;};};for _aagf ,_fdc :=range _ceac ._aefda {_bccfg :=_a .AbsoluteFilename (_gcfbc ,_a .ChartType ,_aagf +1);_dc .MarshalXML (_bagf ,_bccfg ,_fdc );};for _cgad ,_adgf :=range _ceac ._bgea {_fcfd :=_a .AbsoluteFilename (_gcfbc ,_a .TableType ,_cgad +1);_dc .MarshalXML (_bagf ,_fcfd ,_adgf );};for _ecaf ,_cegcb :=range _ceac ._fddb {_fcga :=_a .AbsoluteFilename (_gcfbc ,_a .DrawingType ,_ecaf +1);_dc .MarshalXML (_bagf ,_fcga ,_cegcb );if !_ceac ._afegb [_ecaf ].IsEmpty (){_dc .MarshalXML (_bagf ,_dc .RelationsPathFor (_fcga ),_ceac ._afegb [_ecaf ].X ());};};for _ceacg ,_gbef :=range _ceac ._egea {_dc .MarshalXML (_bagf ,_a .AbsoluteFilename (_gcfbc ,_a .VMLDrawingType ,_ceacg +1),_gbef );};for _dfddd ,_ccce :=range _ceac .Images {if _cffg :=_fe .AddImageToZip (_bagf ,_ccce ,_dfddd +1,_a .DocTypeSpreadsheet );_cffg !=nil {return _cffg ;};};if _cedf :=_dc .MarshalXML (_bagf ,_a .ContentTypesFilename ,_ceac .ContentTypes .X ());_cedf !=nil {return _cedf ;};for _ffdd ,_agbbc :=range _ceac ._acdc {if _agbbc ==nil {continue ;};_dc .MarshalXML (_bagf ,_a .AbsoluteFilename (_gcfbc ,_a .CommentsType ,_ffdd +1),_agbbc );};if _dbef :=_ceac .WriteExtraFiles (_bagf );_dbef !=nil {return _dbef ;};return _bagf .Close ();};type DifferentialStyle struct{_bfde *_cdc .CT_Dxf ;_ccda *Workbook ;_gdcb *_cdc .CT_Dxfs ;};

// SetLocked sets cell locked or not.
func (_efag *evalContext )SetLocked (cellRef string ,locked bool ){_efag ._dbe .Cell (cellRef ).setLocked (locked );};

// X returns the inner wrapped XML type.
func (_cad Cell )X ()*_cdc .CT_Cell {return _cad ._eeb };

// X returns the inner wrapped XML type.
func (_aaag Sheet )X ()*_cdc .Worksheet {return _aaag ._gaec };

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_agbcf StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _agbcf ._ccbbd .Dxfs ==nil {_agbcf ._ccbbd .Dxfs =_cdc .NewCT_Dxfs ();};_geee :=_cdc .NewCT_Dxf ();_agbcf ._ccbbd .Dxfs .Dxf =append (_agbcf ._ccbbd .Dxfs .Dxf ,_geee );_agbcf ._ccbbd .Dxfs .CountAttr =_a .Uint32 (uint32 (len (_agbcf ._ccbbd .Dxfs .Dxf )));return DifferentialStyle {_geee ,_agbcf ._gcbf ,_agbcf ._ccbbd .Dxfs };};func (_cbdb DataValidation )SetList ()DataValidationList {_cbdb .clear ();_cbdb ._bcc .TypeAttr =_cdc .ST_DataValidationTypeList ;_cbdb ._bcc .OperatorAttr =_cdc .ST_DataValidationOperatorEqual ;return DataValidationList {_cbdb ._bcc };};

// SetWidth sets the width of the anchored object.
func (_dec OneCellAnchor )SetWidth (w _bb .Distance ){_dec ._dbab .Ext .CxAttr =int64 (w /_bb .EMU )};

// MoveTo moves the top-left of the anchored object.
func (_bebf OneCellAnchor )MoveTo (col ,row int32 ){_bebf .TopLeft ().SetCol (col );_bebf .TopLeft ().SetRow (row );};

// RowOffset returns the offset from the row cell.
func (_gcb CellMarker )RowOffset ()_bb .Distance {if _gcb ._cde .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _bb .Distance (float64 (*_gcb ._cde .RowOff .ST_CoordinateUnqualified )*_bb .EMU );};

// X returns the inner wrapped XML type.
func (_bcd ColorScale )X ()*_cdc .CT_ColorScale {return _bcd ._cba };

// Sheet is a single sheet within a workbook.
type Sheet struct{_bbfc *Workbook ;_abaa *_cdc .CT_Sheet ;_gaec *_cdc .Worksheet ;};

// IsStructureLocked returns whether the workbook structure is locked.
func (_fdcba WorkbookProtection )IsStructureLocked ()bool {return _fdcba ._bgdb .LockStructureAttr !=nil &&*_fdcba ._bgdb .LockStructureAttr ;};

// IsBool returns true if the cell boolean value.
func (_gfdf *evalContext )IsBool (cellRef string )bool {return _gfdf ._dbe .Cell (cellRef ).IsBool ()};

// Reference returns the table reference (the cells within the table)
func (_fdfd Table )Reference ()string {return _fdfd ._ffgfd .RefAttr };

// SetPasswordHash sets the password hash to the input.
func (_eafgc WorkbookProtection )SetPasswordHash (pwHash string ){_eafgc ._bgdb .WorkbookPasswordAttr =_a .String (pwHash );};func (_bbbc Font )SetColor (c _de .Color ){_bce :=_cdc .NewCT_Color ();_cadbf :="\u0066\u0066"+*c .AsRGBString ();_bce .RgbAttr =&_cadbf ;_bbbc ._bgag .Color =[]*_cdc .CT_Color {_bce };};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_aefa *Workbook )SetActiveSheet (s Sheet ){for _befe ,_fbed :=range _aefa ._gbfaa {if s ._gaec ==_fbed {_aefa .SetActiveSheetIndex (uint32 (_befe ));};};};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_agc CellStyle )SetNumberFormatStandard (s StandardFormat ){_agc ._eae .NumFmtIdAttr =_a .Uint32 (uint32 (s ));_agc ._eae .ApplyNumberFormatAttr =_a .Bool (true );};

// X returns the inner wrapped XML type.
func (_cdfcf Font )X ()*_cdc .CT_Font {return _cdfcf ._bgag };

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_ecd Cell )Reference ()string {if _ecd ._eeb .RAttr !=nil {return *_ecd ._eeb .RAttr ;};return "";};

// Row returns the row of the cell marker.
func (_dcc CellMarker )Row ()int32 {return _dcc ._cde .Row };func (_fccf Border )SetLeft (style _cdc .ST_BorderStyle ,c _de .Color ){if _fccf ._eca .Left ==nil {_fccf ._eca .Left =_cdc .NewCT_BorderPr ();};_fccf ._eca .Left .Color =_cdc .NewCT_Color ();_fccf ._eca .Left .Color .RgbAttr =c .AsRGBAString ();_fccf ._eca .Left .StyleAttr =style ;};

// IsError returns true if the cell is an error type cell.
func (_gbad Cell )IsError ()bool {return _gbad ._eeb .TAttr ==_cdc .ST_CellTypeE };type MergedCell struct{_fdb *Workbook ;_fff *Sheet ;_aafa *_cdc .CT_MergeCell ;};

// IconScale maps values to icons.
type IconScale struct{_cbdd *_cdc .CT_IconSet };

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_bgag *_cdc .CT_Font ;_cefd *_cdc .StyleSheet ;};

// SetYSplit sets the row split point
func (_gadad SheetView )SetYSplit (v float64 ){_gadad .ensurePane ();_gadad ._bfagf .Pane .YSplitAttr =_a .Float64 (v );};

// AddString adds a string to the shared string cache.
func (_fgd SharedStrings )AddString (v string )int {if _ade ,_fceec :=_fgd ._gfe [v ];_fceec {return _ade ;};_fgag :=_cdc .NewCT_Rst ();_fgag .T =_a .String (v );_fgd ._faedb .Si =append (_fgd ._faedb .Si ,_fgag );_cgbb :=len (_fgd ._faedb .Si )-1;_fgd ._gfe [v ]=_cgbb ;_fgd ._faedb .CountAttr =_a .Uint32 (uint32 (len (_fgd ._faedb .Si )));_fgd ._faedb .UniqueCountAttr =_fgd ._faedb .CountAttr ;return _cgbb ;};

// GetFormat sets the number format code.
func (_bgaf NumberFormat )GetFormat ()string {return _bgaf ._dcf .FormatCodeAttr };

// Comments returns the comments for a sheet.
func (_aafg *Sheet )Comments ()Comments {for _edgdd ,_badf :=range _aafg ._bbfc ._gbfaa {if _badf ==_aafg ._gaec {if _aafg ._bbfc ._acdc [_edgdd ]==nil {_aafg ._bbfc ._acdc [_edgdd ]=_cdc .NewComments ();_aafg ._bbfc ._cdgb [_edgdd ].AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,_edgdd +1,_a .CommentsType );_aafg ._bbfc .ContentTypes .AddOverride (_a .AbsoluteFilename (_a .DocTypeSpreadsheet ,_a .CommentsType ,_edgdd +1),_a .CommentsContentType );};if len (_aafg ._bbfc ._egea )==0{_aafg ._bbfc ._egea =append (_aafg ._bbfc ._egea ,_cf .NewCommentDrawing ());_bfce :=_aafg ._bbfc ._cdgb [_edgdd ].AddAutoRelationship (_a .DocTypeSpreadsheet ,_a .WorksheetType ,1,_a .VMLDrawingType );if _aafg ._gaec .LegacyDrawing ==nil {_aafg ._gaec .LegacyDrawing =_cdc .NewCT_LegacyDrawing ();};_aafg ._gaec .LegacyDrawing .IdAttr =_bfce .ID ();};return Comments {_aafg ._bbfc ,_aafg ._bbfc ._acdc [_edgdd ]};};};_a .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gdd Comments )AddComment (cellRef string ,author string )RichText {_cbdg :=_cdc .NewCT_Comment ();_gdd ._aec .CommentList .Comment =append (_gdd ._aec .CommentList .Comment ,_cbdg );_cbdg .RefAttr =cellRef ;_cbdg .AuthorIdAttr =_gdd .getOrCreateAuthor (author );_cbdg .Text =_cdc .NewCT_Rst ();return RichText {_cbdg .Text };};func (_dgbe Cell )getRawSortValue ()(string ,bool ){if _dgbe .HasFormula (){_bbfb :=_dgbe .GetCachedFormulaResult ();return _bbfb ,_dfd .IsNumber (_bbfb );};_abgc ,_ :=_dgbe .GetRawValue ();return _abgc ,_dfd .IsNumber (_abgc );};

// AddFormatValue adds a format value (databars require two).
func (_bfgg DataBarScale )AddFormatValue (t _cdc .ST_CfvoType ,val string ){_gdbb :=_cdc .NewCT_Cfvo ();_gdbb .TypeAttr =t ;_gdbb .ValAttr =_a .String (val );_bfgg ._fga .Cfvo =append (_bfgg ._fga .Cfvo ,_gdbb );};

// SetRow set the row of the cell marker.
func (_dcb CellMarker )SetRow (row int32 ){_dcb ._cde .Row =row };

// MergedCells returns the merged cell regions within the sheet.
func (_gccf *Sheet )MergedCells ()[]MergedCell {if _gccf ._gaec .MergeCells ==nil {return nil ;};_dca :=[]MergedCell {};for _ ,_ddgb :=range _gccf ._gaec .MergeCells .MergeCell {_dca =append (_dca ,MergedCell {_gccf ._bbfc ,_gccf ,_ddgb });};return _dca ;};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _b .ReaderAt ,size int64 )(*Workbook ,error ){const _cdbbe ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_dd .GetLicenseKey ().IsLicensed ()&&!_ageac {_fc .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_fc .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return nil ,_efa .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_geda :=New ();_egag ,_fecb :=_dd .GenRefId ("\u0073\u0072");if _fecb !=nil {_a .Log ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_fecb );return nil ,_fecb ;};_geda ._eegc =_egag ;if _abfa :=_dd .Track (_geda ._eegc ,_cdbbe );_abfa !=nil {_fc .Printf ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_abfa );return nil ,_abfa ;};_gcec ,_fecb :=_cca .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _fecb !=nil {return nil ,_fecb ;};_geda .TmpPath =_gcec ;_fdge ,_fecb :=_c .NewReader (r ,size );if _fecb !=nil {return nil ,_fc .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_fecb );};_eeeb :=[]*_c .File {};_eeeb =append (_eeeb ,_fdge .File ...);_ddf :=false ;for _ ,_gcd :=range _eeeb {if _gcd .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_ddf =true ;break ;};};if _ddf {_geda .CreateCustomProperties ();};_dbcc :=_dc .DecodeMap {};_dbcc .SetOnNewRelationshipFunc (_geda .onNewRelationship );_dbcc .AddTarget (_a .ContentTypesFilename ,_geda .ContentTypes .X (),"",0);_dbcc .AddTarget (_a .BaseRelsFilename ,_geda .Rels .X (),"",0);if _dae :=_dbcc .Decode (_eeeb );_dae !=nil {return nil ,_dae ;};for _ ,_fefe :=range _eeeb {if _fefe ==nil {continue ;};if _cdg :=_geda .AddExtraFileFromZip (_fefe );_cdg !=nil {return nil ,_cdg ;};};if _ddf {_gfdd :=false ;for _ ,_fbbg :=range _geda .Rels .X ().Relationship {if _fbbg .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_gfdd =true ;break ;};};if !_gfdd {_geda .AddCustomRelationships ();};};return _geda ,nil ;};func _efd (_cadd string )bool {_cadd =_f .Replace (_cadd ,"\u0024","",-1);if _aba :=_dgd .FindStringSubmatch (_f .ToLower (_cadd ));len (_aba )> 2{_bgab :=_aba [1];_bebg ,_fccd :=_cc .Atoi (_aba [2]);if _fccd !=nil {return false ;};return _bebg <=1048576&&_bgab <="\u007a\u007a";};return false ;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_dfcga *Sheet )RemoveColumn (column string )error {_baaf ,_bbec :=_dfcga .getAllCellsInFormulaArraysForColumn ();if _bbec !=nil {return _bbec ;};_aeab :=_gc .ColumnToIndex (column );for _ ,_afcfe :=range _dfcga .Rows (){_gfc :=_fc .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_afcfe .X ().RAttr );if _ ,_fgf :=_baaf [_gfc ];_fgf {return nil ;};};for _ ,_cedee :=range _dfcga .Rows (){_bfbb :=_cedee ._gdgc .C ;for _gccb ,_eefa :=range _bfbb {_cfcd ,_dbgc :=_gc .ParseCellReference (*_eefa .RAttr );if _dbgc !=nil {return _dbgc ;};if _cfcd .ColumnIdx ==_aeab {_cedee ._gdgc .C =append (_bfbb [:_gccb ],_dfcga .slideCellsLeft (_bfbb [_gccb +1:])...);break ;}else if _cfcd .ColumnIdx > _aeab {_cedee ._gdgc .C =append (_bfbb [:_gccb ],_dfcga .slideCellsLeft (_bfbb [_gccb :])...);break ;};};};_bbec =_dfcga .updateAfterRemove (_aeab ,_ge .UpdateActionRemoveColumn );if _bbec !=nil {return _bbec ;};_bbec =_dfcga .removeColumnFromNamedRanges (_aeab );if _bbec !=nil {return _bbec ;};_bbec =_dfcga .removeColumnFromMergedCells (_aeab );if _bbec !=nil {return _bbec ;};for _ ,_dcg :=range _dfcga ._bbfc .Sheets (){_dcg .RecalculateFormulas ();};return nil ;};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_gebd Cell )GetString ()string {switch _gebd ._eeb .TAttr {case _cdc .ST_CellTypeInlineStr :if _gebd ._eeb .Is !=nil &&_gebd ._eeb .Is .T !=nil {return *_gebd ._eeb .Is .T ;};if _gebd ._eeb .V !=nil {return *_gebd ._eeb .V ;};case _cdc .ST_CellTypeS :if _gebd ._eeb .V ==nil {return "";};_edc ,_cadg :=_cc .Atoi (*_gebd ._eeb .V );if _cadg !=nil {return "";};_ccg ,_cadg :=_gebd ._ffb .SharedStrings .GetString (_edc );if _cadg !=nil {return "";};return _ccg ;};if _gebd ._eeb .V ==nil {return "";};return *_gebd ._eeb .V ;};