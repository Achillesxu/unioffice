//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ag "archive/zip";_cd "bytes";_fa "errors";_fb "fmt";_f "github.com/unidoc/unioffice";_fcg "github.com/unidoc/unioffice/chart";_dc "github.com/unidoc/unioffice/color";_ad "github.com/unidoc/unioffice/common";_aa "github.com/unidoc/unioffice/common/logger";_gd "github.com/unidoc/unioffice/common/tempstorage";_cga "github.com/unidoc/unioffice/internal/license";_ff "github.com/unidoc/unioffice/measurement";_adg "github.com/unidoc/unioffice/schema/soo/dml";_df "github.com/unidoc/unioffice/schema/soo/dml/chart";_bgd "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_cef "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_bdd "github.com/unidoc/unioffice/schema/soo/sml";_bd "github.com/unidoc/unioffice/spreadsheet/format";_agb "github.com/unidoc/unioffice/spreadsheet/formula";_eg "github.com/unidoc/unioffice/spreadsheet/reference";_de "github.com/unidoc/unioffice/spreadsheet/update";_db "github.com/unidoc/unioffice/vmldrawing";_e "github.com/unidoc/unioffice/zippkg";_a "image";_b "image/jpeg";_cge "io";_bg "math";_g "math/big";_d "os";_cg "path";_cb "path/filepath";_bf "regexp";_fc "sort";_be "strconv";_ce "strings";_ca "time";);

// SetRotation configures the cell to be rotated.
func (_ega CellStyle )SetRotation (deg uint8 ){if _ega ._bgb .Alignment ==nil {_ega ._bgb .Alignment =_bdd .NewCT_CellAlignment ();};_ega ._bgb .ApplyAlignmentAttr =_f .Bool (true );_ega ._bgb .Alignment .TextRotationAttr =_f .Uint8 (deg );};func (_fdfe Row )renumberAs (_dcb uint32 ){_fdfe ._ceea .RAttr =_f .Uint32 (_dcb );for _ ,_cde :=range _fdfe .Cells (){_bdbd ,_dcbf :=_eg .ParseCellReference (_cde .Reference ());if _dcbf ==nil {_edg :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",_bdbd .Column ,_dcb );_cde ._egf .RAttr =_f .String (_edg );};};};

// Cell returns the actual cell behind the merged region
func (_dggg MergedCell )Cell ()Cell {_efbb :=_dggg .Reference ();if _cafdf :=_ce .Index (_dggg .Reference (),"\u003a");_cafdf !=-1{_efbb =_efbb [0:_cafdf ];return _dggg ._fcce .Cell (_efbb );};return Cell {};};

// SetHidden controls the visibility of a column.
func (_bef Column )SetHidden (b bool ){if !b {_bef ._ebe .HiddenAttr =nil ;}else {_bef ._ebe .HiddenAttr =_f .Bool (true );};};

// MoveTo moves the top-left of the anchored object.
func (_dggb OneCellAnchor )MoveTo (col ,row int32 ){_dggb .TopLeft ().SetCol (col );_dggb .TopLeft ().SetRow (row );};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;func (_ggbf RichTextRun )ensureRpr (){if _ggbf ._fabe .RPr ==nil {_ggbf ._fabe .RPr =_bdd .NewCT_RPrElt ();};};func (_ac Cell )clearValue (){_ac ._egf .F =nil ;_ac ._egf .Is =nil ;_ac ._egf .V =nil ;_ac ._egf .TAttr =_bdd .ST_CellTypeUnset ;};

// GetEpoch returns a workbook's time epoch.
func (_bebe *evalContext )GetEpoch ()_ca .Time {return _bebe ._agbd ._debfd .Epoch ()};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// X returns the inner wrapped XML type.
func (_gca Column )X ()*_bdd .CT_Col {return _gca ._ebe };

// MaxColumnIdx returns the max used column of the sheet.
func (_gadc Sheet )MaxColumnIdx ()uint32 {_bfcc :=uint32 (0);for _ ,_dfgg :=range _gadc .Rows (){_ggaac :=_dfgg ._ceea .C ;if len (_ggaac )> 0{_aaee :=_ggaac [len (_ggaac )-1];_dbcgb ,_ :=_eg .ParseCellReference (*_aaee .RAttr );if _bfcc < _dbcgb .ColumnIdx {_bfcc =_dbcgb .ColumnIdx ;};};};return _bfcc ;};func (_dce Cell )getFormat ()string {if _dce ._egf .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_ffc :=*_dce ._egf .SAttr ;_fcf :=_dce ._dac .StyleSheet .GetCellStyle (_ffc );_efa :=_dce ._dac .StyleSheet .GetNumberFormat (_fcf .NumberFormat ());return _efa .GetFormat ();};const (DVCompareOpEqual =DVCompareOp (_bdd .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_bdd .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_bdd .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_bdd .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_bdd .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_bdd .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_bdd .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_bdd .ST_DataValidationOperatorLessThanOrEqual ););

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_gfee *evalContext )LastRow (col string )int {_bee :=_gfee ._agbd ;_gacd :=int (_eg .ColumnToIndex (col ));_ddg :=1;for _ ,_bdae :=range _bee ._bcbe .SheetData .Row {if _bdae .RAttr !=nil {_adf :=Row {_bee ._debfd ,_bee ,_bdae };_cdc :=len (_adf .Cells ());if _cdc > _gacd {_ddg =int (_adf .RowNumber ());};};};return _ddg ;};

// Comments is the container for comments for a single sheet.
type Comments struct{_geca *Workbook ;_gae *_bdd .Comments ;};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_dad Cell )SetStringByID (id int ){_dad ._dac .ensureSharedStringsRelationships ();_dad .clearValue ();_dad ._egf .V =_f .String (_be .Itoa (id ));_dad ._egf .TAttr =_bdd .ST_CellTypeS ;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_fgfg *_bdd .CT_Font ;_aaa *_bdd .StyleSheet ;};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_gdd ConditionalFormattingRule )SetColorScale ()ColorScale {_gdd .clear ();_gdd .SetType (_bdd .ST_CfTypeColorScale );_gdd ._ggeg .ColorScale =_bdd .NewCT_ColorScale ();return ColorScale {_gdd ._ggeg .ColorScale };};

// IsStructureLocked returns whether the workbook structure is locked.
func (_aac WorkbookProtection )IsStructureLocked ()bool {return _aac ._fdfae .LockStructureAttr !=nil &&*_aac ._fdfae .LockStructureAttr ;};

// Type returns the type of the rule
func (_dcec ConditionalFormattingRule )Type ()_bdd .ST_CfType {return _dcec ._ggeg .TypeAttr };

// IsNumber returns true if the cell is a number type cell.
func (_ddc Cell )IsNumber ()bool {switch _ddc ._egf .TAttr {case _bdd .ST_CellTypeN :return true ;case _bdd .ST_CellTypeS ,_bdd .ST_CellTypeB :return false ;};return _ddc ._egf .V !=nil &&_bd .IsNumber (*_ddc ._egf .V );};

// SetHeightCells is a no-op.
func (_ed AbsoluteAnchor )SetHeightCells (int32 ){};

// Priority returns the rule priority
func (_dbf ConditionalFormattingRule )Priority ()int32 {return _dbf ._ggeg .PriorityAttr };

// AddGradientStop adds a color gradient stop.
func (_gedd ColorScale )AddGradientStop (color _dc .Color ){_gfeb :=_bdd .NewCT_Color ();_gfeb .RgbAttr =color .AsRGBAString ();_gedd ._gea .Color =append (_gedd ._gea .Color ,_gfeb );};

// GetString retrieves a string from the shared strings table by index.
func (_agd SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_fb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_agd ._gdgf .Si )-1{return "",_fb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_agd ._gdgf .Si ));};_aeec :=_agd ._gdgf .Si [id ];if _aeec .T !=nil {return *_aeec .T ,nil ;};_eee :="";for _ ,_fef :=range _aeec .R {if _fef .T !=""{_eee +=_fef .T ;};};return _eee ,nil ;};func (_fbcae *Sheet )setList (_fcb string ,_ebbf _agb .Result )error {_gccaa ,_fba :=_eg .ParseCellReference (_fcb );if _fba !=nil {return _fba ;};_beba :=_fbcae .Row (_gccaa .RowIdx );for _ebec ,_ffaed :=range _ebbf .ValueList {_efgg :=_beba .Cell (_eg .IndexToColumn (_gccaa .ColumnIdx +uint32 (_ebec )));if _ffaed .Type !=_agb .ResultTypeEmpty {if _ffaed .IsBoolean {_efgg .SetBool (_ffaed .ValueNumber !=0);}else {_efgg .SetCachedFormulaResult (_ffaed .String ());};};};return nil ;};

// X returns the inner wrapped XML type.
func (_cdg ColorScale )X ()*_bdd .CT_ColorScale {return _cdg ._gea };

// SetPasswordHash sets the password hash to the input.
func (_adcf SheetProtection )SetPasswordHash (pwHash string ){_adcf ._edbb .PasswordAttr =_f .String (pwHash );};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_agbf ConditionalFormattingRule )SetIcons ()IconScale {_agbf .clear ();_agbf .SetType (_bdd .ST_CfTypeIconSet );_agbf ._ggeg .IconSet =_bdd .NewCT_IconSet ();_bada :=IconScale {_agbf ._ggeg .IconSet };_bada .SetIcons (_bdd .ST_IconSetType3TrafficLights1 );return _bada ;};func (_ecb *Workbook )ensureSharedStringsRelationships (){_bfcf :=false ;for _ ,_egeg :=range _ecb .ContentTypes .X ().Override {if _egeg .ContentTypeAttr ==_f .SharedStringsContentType {_bfcf =true ;break ;};};if !_bfcf {_ecb .ContentTypes .AddOverride (_ffed ,_f .SharedStringsContentType );};_cfff :=false ;for _ ,_dedc :=range _ecb ._ggd .Relationships (){if _dedc .X ().TargetAttr ==_egec {_cfff =true ;break ;};};if !_cfff {_ecb ._ggd .AddRelationship (_egec ,_f .SharedStringsType );};};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_bfae *Sheet )GetDrawing ()(*_bgd .WsDr ,_ad .Relationships ){if _edaf :=_bfae ._bcbe .Drawing ;_edaf !=nil {_eagd :=0;for _ ,_dcfd :=range _bfae ._debfd ._acggg {if _dde :=_dcfd .Drawing ;_dde !=nil {if _dcfd ==_bfae ._bcbe {return _bfae ._debfd ._aeeg [_eagd ],_bfae ._debfd ._gefc [_eagd ];};_eagd ++;};};};return nil ,_ad .Relationships {};};

// Column returns the cell column
func (_aee Cell )Column ()(string ,error ){_gaa ,_eb :=_eg .ParseCellReference (_aee .Reference ());if _eb !=nil {return "",_eb ;};return _gaa .Column ,nil ;};

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_fca Cell )SetStyle (cs CellStyle ){_fca .SetStyleIndex (cs .Index ())};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_adedb *_bdd .CT_SheetView };

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// SetPattern sets the pattern of the fill.
func (_aab PatternFill )SetPattern (p _bdd .ST_PatternType ){_aab ._gegad .PatternTypeAttr =p };

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_gf Cell )SetBool (v bool ){_gf .clearValue ();_gf ._egf .V =_f .String (_be .Itoa (_fbca (v )));_gf ._egf .TAttr =_bdd .ST_CellTypeB ;};

// Author returns the author of the comment
func (_fgb Comment )Author ()string {if _fgb ._ffde .AuthorIdAttr < uint32 (len (_fgb ._afe .Authors .Author )){return _fgb ._afe .Authors .Author [_fgb ._ffde .AuthorIdAttr ];};return "";};

// CellStyles returns the list of defined cell styles
func (_dbfa StyleSheet )CellStyles ()[]CellStyle {_cbac :=[]CellStyle {};for _ ,_effc :=range _dbfa ._aecc .CellXfs .Xf {_cbac =append (_cbac ,CellStyle {_dbfa ._cfef ,_effc ,_dbfa ._aecc .CellXfs });};return _cbac ;};

// ClearBorder clears any border configuration from the cell style.
func (_agc CellStyle )ClearBorder (){_agc ._bgb .BorderIdAttr =nil ;_agc ._bgb .ApplyBorderAttr =nil };

// SetAllowBlank controls if blank values are accepted.
func (_abbd DataValidation )SetAllowBlank (b bool ){if !b {_abbd ._fed .AllowBlankAttr =nil ;}else {_abbd ._fed .AllowBlankAttr =_f .Bool (true );};};

// SetWrapped configures the cell to wrap text.
func (_fda CellStyle )SetWrapped (b bool ){if _fda ._bgb .Alignment ==nil {_fda ._bgb .Alignment =_bdd .NewCT_CellAlignment ();};if !b {_fda ._bgb .Alignment .WrapTextAttr =nil ;}else {_fda ._bgb .Alignment .WrapTextAttr =_f .Bool (true );_fda ._bgb .ApplyAlignmentAttr =_f .Bool (true );};};

// BottomRight is a no-op.
func (_gbc OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_effa *Workbook )Uses1904Dates ()bool {if _effa ._cecaf .WorkbookPr ==nil ||_effa ._cecaf .WorkbookPr .Date1904Attr ==nil {return false ;};return *_effa ._cecaf .WorkbookPr .Date1904Attr ;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_debfd *Workbook ;_abg *_bdd .CT_Sheet ;_bcbe *_bdd .Worksheet ;};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_af CellStyle )SetNumberFormatStandard (s StandardFormat ){_af ._bgb .NumFmtIdAttr =_f .Uint32 (uint32 (s ));_af ._bgb .ApplyNumberFormatAttr =_f .Bool (true );};

// SetXSplit sets the column split point
func (_gccaad SheetView )SetXSplit (v float64 ){_gccaad .ensurePane ();_gccaad ._adedb .Pane .XSplitAttr =_f .Float64 (v );};

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_dceb Cell )GetCachedFormulaResult ()string {if _dceb ._egf .V !=nil {return *_dceb ._egf .V ;};return "";};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_ccg Cell )SetInlineString (s string ){_ccg .clearValue ();_ccg ._egf .Is =_bdd .NewCT_Rst ();_ccg ._egf .Is .T =_f .String (s );_ccg ._egf .TAttr =_bdd .ST_CellTypeInlineStr ;};

// SheetCount returns the number of sheets in the workbook.
func (_bfgg Workbook )SheetCount ()int {return len (_bfgg ._acggg )};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_cc AbsoluteAnchor )SetRowOffset (m _ff .Distance ){_cc ._bb .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ff .EMU ));};

// SetColor sets the text color.
func (_ece RichTextRun )SetColor (c _dc .Color ){_ece .ensureRpr ();_ece ._fabe .RPr .Color =_bdd .NewCT_Color ();_acca :="\u0066\u0066"+*c .AsRGBString ();_ece ._fabe .RPr .Color .RgbAttr =&_acca ;};func _geeg (_dff _ca .Time )_ca .Time {_dff =_dff .Local ();return _ca .Date (_dff .Year (),_dff .Month (),_dff .Day (),_dff .Hour (),_dff .Minute (),_dff .Second (),_dff .Nanosecond (),_ca .UTC );};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_bfdd Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_ffbf :=[]Cell {};for _ggbba :=uint32 (0);_ggbba <=lastColIdx ;_ggbba ++{_dgcg :=_bfdd .Cell (_eg .IndexToColumn (_ggbba ));_ffbf =append (_ffbf ,_dgcg );};return _ffbf ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_aead *Sheet )RecalculateFormulas (){_adef :=_agb .NewEvaluator ();_dfca :=_aead .FormulaContext ();for _ ,_aedf :=range _aead .Rows (){for _ ,_edae :=range _aedf .Cells (){if _edae .X ().F !=nil {_gddf :=_edae .X ().F .Content ;if _edae .X ().F .TAttr ==_bdd .ST_CellFormulaTypeShared &&len (_gddf )==0{continue ;};_efgb :=_adef .Eval (_dfca ,_gddf ).AsString ();if _efgb .Type ==_agb .ResultTypeError {_aa .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_gddf ,_efgb .ErrorMessage );_edae .X ().V =nil ;}else {if _efgb .Type ==_agb .ResultTypeNumber {_edae .X ().TAttr =_bdd .ST_CellTypeN ;}else {_edae .X ().TAttr =_bdd .ST_CellTypeInlineStr ;};_edae .X ().V =_f .String (_efgb .Value ());if _edae .X ().F .TAttr ==_bdd .ST_CellFormulaTypeArray {if _efgb .Type ==_agb .ResultTypeArray {_aead .setArray (_edae .Reference (),_efgb );}else if _efgb .Type ==_agb .ResultTypeList {_aead .setList (_edae .Reference (),_efgb );};}else if _edae .X ().F .TAttr ==_bdd .ST_CellFormulaTypeShared &&_edae .X ().F .RefAttr !=nil {_cbfd ,_fbbc ,_bedf :=_eg .ParseRangeReference (*_edae .X ().F .RefAttr );if _bedf !=nil {_aa .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_bedf );continue ;};_aead .setShared (_edae .Reference (),_cbfd ,_fbbc ,_gddf );};};};};};};

// ClearFill clears any fill configuration from the cell style.
func (_edc CellStyle )ClearFill (){_edc ._bgb .FillIdAttr =nil ;_edc ._bgb .ApplyFillAttr =nil };

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_geff *Sheet )SheetViews ()[]SheetView {if _geff ._bcbe .SheetViews ==nil {return nil ;};_acdac :=[]SheetView {};for _ ,_gcad :=range _geff ._bcbe .SheetViews .SheetView {_acdac =append (_acdac ,SheetView {_gcad });};return _acdac ;};var _gcga *_bf .Regexp =_bf .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// SetType sets the type of the rule.
func (_gbe ConditionalFormattingRule )SetType (t _bdd .ST_CfType ){_gbe ._ggeg .TypeAttr =t };

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_bagd *Sheet )AddHyperlink (url string )_ad .Hyperlink {for _aabc ,_bbcb :=range _bagd ._debfd ._acggg {if _bbcb ==_bagd ._bcbe {return _bagd ._debfd ._bafe [_aabc ].AddHyperlink (url );};};return _ad .Hyperlink {};};

// Col returns the column of the cell marker.
func (_ddb CellMarker )Col ()int32 {return _ddb ._acg .Col };func _cgg ()*_bgd .CT_AbsoluteAnchor {_faed :=_bgd .NewCT_AbsoluteAnchor ();return _faed };

// AddHyperlink creates and sets a hyperlink on a cell.
func (_dea Cell )AddHyperlink (url string ){for _fe ,_cbdc :=range _dea ._dac ._acggg {if _cbdc ==_dea ._ea ._bcbe {_dea .SetHyperlink (_dea ._dac ._bafe [_fe ].AddHyperlink (url ));return ;};};};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_dgcd *_bdd .CT_DataBar };func (_cbd Cell )getLabelPrefix ()string {if _cbd ._egf .SAttr ==nil {return "";};_bcf :=*_cbd ._egf .SAttr ;_dadb :=_cbd ._dac .StyleSheet .GetCellStyle (_bcf );switch _dadb ._bgb .Alignment .HorizontalAttr {case _bdd .ST_HorizontalAlignmentLeft :return "\u0027";case _bdd .ST_HorizontalAlignmentRight :return "\u0022";case _bdd .ST_HorizontalAlignmentCenter :return "\u005e";case _bdd .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_gdbe *_bdd .CT_DataValidation };func (_agfg DataValidation )SetList ()DataValidationList {_agfg .clear ();_agfg ._fed .TypeAttr =_bdd .ST_DataValidationTypeList ;_agfg ._fed .OperatorAttr =_bdd .ST_DataValidationOperatorEqual ;return DataValidationList {_agfg ._fed };};func (_aaf Font )Index ()uint32 {for _eaff ,_ggfe :=range _aaf ._aaa .Fonts .Font {if _aaf ._fgfg ==_ggfe {return uint32 (_eaff );};};return 0;};

// AddView adds a sheet view.
func (_ddbg *Sheet )AddView ()SheetView {if _ddbg ._bcbe .SheetViews ==nil {_ddbg ._bcbe .SheetViews =_bdd .NewCT_SheetViews ();};_cabfg :=_bdd .NewCT_SheetView ();_ddbg ._bcbe .SheetViews .SheetView =append (_ddbg ._bcbe .SheetViews .SheetView ,_cabfg );return SheetView {_cabfg };};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_ccgb *Workbook )Close ()error {if _ccgb .TmpPath !=""{return _gd .RemoveAll (_ccgb .TmpPath );};return nil ;};func (_badb PatternFill )X ()*_bdd .CT_PatternFill {return _badb ._gegad };

// X returns the inner wrapped XML type.
func (_ffdf DataValidation )X ()*_bdd .CT_DataValidation {return _ffdf ._fed };

// X returns the inner wrapped XML type.
func (_ecga SharedStrings )X ()*_bdd .Sst {return _ecga ._gdgf };

// SetCol set the column of the cell marker.
func (_dba CellMarker )SetCol (col int32 ){_dba ._acg .Col =col };

// GetLocked returns true if the cell is locked.
func (_aff *evalContext )GetLocked (cellRef string )bool {return _aff ._agbd .Cell (cellRef ).getLocked ()};

// Validate attempts to validate the structure of a workbook.
func (_bfdcg *Workbook )Validate ()error {if _bfdcg ==nil ||_bfdcg ._cecaf ==nil {return _fa .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_cfec :=uint32 (0);for _ ,_gcfa :=range _bfdcg ._cecaf .Sheets .Sheet {if _gcfa .SheetIdAttr > _cfec {_cfec =_gcfa .SheetIdAttr ;};};if _cfec !=uint32 (len (_bfdcg ._acggg )){return _fb .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_cfec ,len (_bfdcg ._acggg ));};_gfbg :=map[string ]struct{}{};for _cebfd ,_gedb :=range _bfdcg ._cecaf .Sheets .Sheet {_cbgd :=Sheet {_bfdcg ,_gedb ,_bfdcg ._acggg [_cebfd ]};if _ ,_aag :=_gfbg [_cbgd .Name ()];_aag {return _fb .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_cebfd ,_cbgd .Name ());};_gfbg [_cbgd .Name ()]=struct{}{};if _egcc :=_cbgd .ValidateWithPath (_fb .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_cebfd ));_egcc !=nil {return _egcc ;};if _ccgf :=_cbgd .Validate ();_ccgf !=nil {return _ccgf ;};};return nil ;};

// Content returns the content of the defined range (the range in most cases)/
func (_afed DefinedName )Content ()string {return _afed ._afg .Content };const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_cbe Comment )SetAuthor (author string ){_cbe ._ffde .AuthorIdAttr =Comments {_cbe ._add ,_cbe ._afe }.getOrCreateAuthor (author );};

// DataValidation controls cell validation
type DataValidation struct{_fed *_bdd .CT_DataValidation };

// ColOffset returns the offset from the row cell.
func (_abd CellMarker )ColOffset ()_ff .Distance {if _abd ._acg .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ff .Distance (float64 (*_abd ._acg .ColOff .ST_CoordinateUnqualified )*_ff .EMU );};

// X returns the inner wrapped XML type.
func (_eea CellMarker )X ()*_bgd .CT_Marker {return _eea ._acg };

// AddDataValidation adds a data validation rule to a sheet.
func (_gagb *Sheet )AddDataValidation ()DataValidation {if _gagb ._bcbe .DataValidations ==nil {_gagb ._bcbe .DataValidations =_bdd .NewCT_DataValidations ();};_cdba :=_bdd .NewCT_DataValidation ();_cdba .ShowErrorMessageAttr =_f .Bool (true );_gagb ._bcbe .DataValidations .DataValidation =append (_gagb ._bcbe .DataValidations .DataValidation ,_cdba );_gagb ._bcbe .DataValidations .CountAttr =_f .Uint32 (uint32 (len (_gagb ._bcbe .DataValidations .DataValidation )));return DataValidation {_cdba };};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_ded Border )InitializeDefaults (){_ded ._adc .Left =_bdd .NewCT_BorderPr ();_ded ._adc .Bottom =_bdd .NewCT_BorderPr ();_ded ._adc .Right =_bdd .NewCT_BorderPr ();_ded ._adc .Top =_bdd .NewCT_BorderPr ();_ded ._adc .Diagonal =_bdd .NewCT_BorderPr ();};func (_decg Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _dfge ,_faee ,_cfdf ,_fdfg uint32 =1,1,0,0;for _ ,_agced :=range _decg .Rows (){if _agced .RowNumber ()< _dfge {_dfge =_agced .RowNumber ();}else if _agced .RowNumber ()> _faee {_faee =_agced .RowNumber ();};for _ ,_befb :=range _agced .Cells (){_ebac ,_bca :=_eg .ParseCellReference (_befb .Reference ());if _bca ==nil {if _ebac .ColumnIdx < _cfdf {_cfdf =_ebac .ColumnIdx ;}else if _ebac .ColumnIdx > _fdfg {_fdfg =_ebac .ColumnIdx ;};};};};return _eg .IndexToColumn (_cfdf ),_dfge ,_eg .IndexToColumn (_fdfg ),_faee ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_defb Row )RowNumber ()uint32 {if _defb ._ceea .RAttr !=nil {return *_defb ._ceea .RAttr ;};return 0;};func (_dfebd Sheet )validateSheetNames ()error {_dbgff :=len ([]rune (_dfebd .Name ()));if _dbgff > 31{return _fb .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_dfebd .Name (),_dbgff );};return nil ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_eabaa OneCellAnchor )SetColOffset (m _ff .Distance ){_eabaa .TopLeft ().SetColOffset (m )};func (_bbg Border )SetTop (style _bdd .ST_BorderStyle ,c _dc .Color ){if _bbg ._adc .Top ==nil {_bbg ._adc .Top =_bdd .NewCT_BorderPr ();};_bbg ._adc .Top .Color =_bdd .NewCT_Color ();_bbg ._adc .Top .Color .RgbAttr =c .AsRGBAString ();_bbg ._adc .Top .StyleAttr =style ;};func (_bgge Sheet )validateRowCellNumbers ()error {_dbeb :=map[uint32 ]struct{}{};for _ ,_dcge :=range _bgge ._bcbe .SheetData .Row {if _dcge .RAttr !=nil {if _ ,_dabc :=_dbeb [*_dcge .RAttr ];_dabc {return _fb .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_bgge .Name (),*_dcge .RAttr );};_dbeb [*_dcge .RAttr ]=struct{}{};};_egdf :=map[string ]struct{}{};for _ ,_ccbb :=range _dcge .C {if _ccbb .RAttr ==nil {continue ;};if _ ,_gag :=_egdf [*_ccbb .RAttr ];_gag {return _fb .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_bgge .Name (),*_ccbb .RAttr );};_egdf [*_ccbb .RAttr ]=struct{}{};};};return nil ;};func NewFills ()Fills {return Fills {_bdd .NewCT_Fills ()}};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_cfgb TwoCellAnchor )SetWidthCells (w int32 ){_fffe :=_cfgb .TopLeft ();_gege :=_cfgb .BottomRight ();_gege .SetCol (_fffe .Col ()+w );};func (_dedg *evalContext )Cell (ref string ,ev _agb .Evaluator )_agb .Result {if !_ccf (ref ){return _agb .MakeErrorResultType (_agb .ErrorTypeName ,"");};_bcfe :=_dedg ._agbd .Name ()+"\u0021"+ref ;if _dead ,_bgc :=ev .GetFromCache (_bcfe );_bgc {return _dead ;};_dfebb ,_fbbd :=_eg .ParseCellReference (ref );if _fbbd !=nil {return _agb .MakeErrorResult (_fb .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_fbbd ));};if _dedg ._dbcg !=0&&!_dfebb .AbsoluteColumn {_dfebb .ColumnIdx +=_dedg ._dbcg ;_dfebb .Column =_eg .IndexToColumn (_dfebb .ColumnIdx );};if _dedg ._cce !=0&&!_dfebb .AbsoluteRow {_dfebb .RowIdx +=_dedg ._cce ;};_gfa :=_dedg ._agbd .Cell (_dfebb .String ());if _gfa .HasFormula (){if _ ,_dcdg :=_dedg ._ddd [ref ];_dcdg {return _agb .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_dedg ._ddd [ref ]=struct{}{};_eff :=ev .Eval (_dedg ,_gfa .GetFormula ());delete (_dedg ._ddd ,ref );ev .SetCache (_bcfe ,_eff );return _eff ;};if _gfa .IsEmpty (){_daf :=_agb .MakeEmptyResult ();ev .SetCache (_bcfe ,_daf );return _daf ;}else if _gfa .IsNumber (){_fab ,_ :=_gfa .GetValueAsNumber ();_addc :=_agb .MakeNumberResult (_fab );ev .SetCache (_bcfe ,_addc );return _addc ;}else if _gfa .IsBool (){_ecc ,_ :=_gfa .GetValueAsBool ();_bbf :=_agb .MakeBoolResult (_ecc );ev .SetCache (_bcfe ,_bbf );return _bbf ;};_fffb ,_ :=_gfa .GetRawValue ();if _gfa .IsError (){_cdd :=_agb .MakeErrorResult ("");_cdd .ValueString =_fffb ;ev .SetCache (_bcfe ,_cdd );return _cdd ;};_dbfd :=_agb .MakeStringResult (_fffb );ev .SetCache (_bcfe ,_dbfd );return _dbfd ;};

// X returns the inner wrapped XML type.
func (_cgbf SheetView )X ()*_bdd .CT_SheetView {return _cgbf ._adedb };

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_bdec *Sheet )AddRow ()Row {_ffeac :=uint32 (0);_faag :=uint32 (len (_bdec ._bcbe .SheetData .Row ));if _faag > 0&&_bdec ._bcbe .SheetData .Row [_faag -1].RAttr !=nil &&*_bdec ._bcbe .SheetData .Row [_faag -1].RAttr ==_faag {return _bdec .addNumberedRowFast (_faag +1);};for _ ,_bfaf :=range _bdec ._bcbe .SheetData .Row {if _bfaf .RAttr !=nil &&*_bfaf .RAttr > _ffeac {_ffeac =*_bfaf .RAttr ;};};return _bdec .AddNumberedRow (_ffeac +1);};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;func (_cdfc Font )SetSize (size float64 ){_cdfc ._fgfg .Sz =[]*_bdd .CT_FontSize {{ValAttr :size }}};

// GetFormat returns a cell data format.
func (_ggb *evalContext )GetFormat (cellRef string )string {return _ggb ._agbd .Cell (cellRef ).getFormat ();};

// X returns the inner wrapped XML type.
func (_ced SheetProtection )X ()*_bdd .CT_SheetProtection {return _ced ._edbb };const (DVCompareTypeWholeNumber =DVCompareType (_bdd .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_bdd .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_bdd .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_bdd .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_bdd .ST_DataValidationTypeTextLength ););

// Wrapped returns true if the cell will wrap text.
func (_ede CellStyle )Wrapped ()bool {if _ede ._bgb .Alignment ==nil {return false ;};if _ede ._bgb .Alignment .WrapTextAttr ==nil {return false ;};return *_ede ._bgb .Alignment .WrapTextAttr ;};func _babe ()*_bgd .CT_OneCellAnchor {_gedg :=_bgd .NewCT_OneCellAnchor ();return _gedg };

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_eaae *evalContext )GetLabelPrefix (cellRef string )string {return _eaae ._agbd .Cell (cellRef ).getLabelPrefix ();};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_efgce StyleSheet )RemoveFont (f Font )error {for _bgfgc ,_bfbc :=range _efgce ._aecc .Fonts .Font {if _bfbc ==f .X (){_efgce ._aecc .Fonts .Font =append (_efgce ._aecc .Fonts .Font [:_bgfgc ],_efgce ._aecc .Fonts .Font [_bgfgc +1:]...);return nil ;};};return _fa .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// X returns the inner wrapped XML type.
func (_ge Cell )X ()*_bdd .CT_Cell {return _ge ._egf };

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_gfe Cell )GetValueAsTime ()(_ca .Time ,error ){if _gfe ._egf .TAttr !=_bdd .ST_CellTypeUnset {return _ca .Time {},_fa .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _gfe ._egf .V ==nil {return _ca .Time {},_fa .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_aea ,_ ,_cfc :=_g .ParseFloat (*_gfe ._egf .V ,10,128,_g .ToNearestEven );if _cfc !=nil {return _ca .Time {},_cfc ;};_faf :=new (_g .Float );_faf .SetUint64 (uint64 (24*_ca .Hour ));_aea .Mul (_aea ,_faf );_acd ,_ :=_aea .Uint64 ();_bcc :=_gfe ._dac .Epoch ().Add (_ca .Duration (_acd ));return _dd (_bcc ),nil ;};

// SetTopLeft sets the top left visible cell after the split.
func (_efba SheetView )SetTopLeft (cellRef string ){_efba .ensurePane ();_efba ._adedb .Pane .TopLeftCellAttr =&cellRef ;};

// Text returns text from the sheet as one string separated with line breaks.
func (_dggd *SheetText )Text ()string {_bea :=_cd .NewBuffer ([]byte {});for _ ,_gba :=range _dggd .Cells {if _gba .Text !=""{_bea .WriteString (_gba .Text );_bea .WriteString ("\u000a");};};return _bea .String ();};

// SetFont applies a font to a cell style. The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_aaegb CellStyle )SetFont (f Font ){_aaegb ._bgb .FontIdAttr =_f .Uint32 (f .Index ());_aaegb ._bgb .ApplyFontAttr =_f .Bool (true );};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_fabe *_bdd .CT_RElt };

// LockObject controls the locking of the sheet objects.
func (_dbda SheetProtection )LockObject (b bool ){if !b {_dbda ._edbb .ObjectsAttr =nil ;}else {_dbda ._edbb .ObjectsAttr =_f .Bool (true );};};

// MoveTo repositions the anchor without changing the objects size.
func (_efeb TwoCellAnchor )MoveTo (col ,row int32 ){_gfgf :=_efeb .TopLeft ();_fdd :=_efeb .BottomRight ();_dffa :=_fdd .Col ()-_gfgf .Col ();_deee :=_fdd .Row ()-_gfgf .Row ();_gfgf .SetCol (col );_gfgf .SetRow (row );_fdd .SetCol (col +_dffa );_fdd .SetRow (row +_deee );};

// HasFormula returns true if the cell contains formula.
func (_baefd *evalContext )HasFormula (cellRef string )bool {return _baefd ._agbd .Cell (cellRef ).HasFormula ();};func (_afd CellStyle )SetNumberFormat (s string ){_faeg :=_afd ._eaadf .StyleSheet .AddNumberFormat ();_faeg .SetFormat (s );_afd ._bgb .ApplyNumberFormatAttr =_f .Bool (true );_afd ._bgb .NumFmtIdAttr =_f .Uint32 (_faeg .ID ());};

// SetWidthCells is a no-op.
func (_afcfe OneCellAnchor )SetWidthCells (int32 ){};

// X returns the inner wrapped XML type.
func (_abf Comment )X ()*_bdd .CT_Comment {return _abf ._ffde };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_geab *Workbook ;_edf *_bdd .CT_NumFmt ;};const _eggd ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";func _dd (_deg _ca .Time )_ca .Time {_deg =_deg .UTC ();return _ca .Date (_deg .Year (),_deg .Month (),_deg .Day (),_deg .Hour (),_deg .Minute (),_deg .Second (),_deg .Nanosecond (),_ca .Local );};

// PasswordHash returns the hash of the workbook password.
func (_gbaf SheetProtection )PasswordHash ()string {if _gbaf ._edbb .PasswordAttr ==nil {return "";};return *_gbaf ._edbb .PasswordAttr ;};

// LockWindow controls the locking of the workbook windows.
func (_beeg WorkbookProtection )LockWindow (b bool ){if !b {_beeg ._fdfae .LockWindowsAttr =nil ;}else {_beeg ._fdfae .LockWindowsAttr =_f .Bool (true );};};type evalContext struct{_agbd *Sheet ;_dbcg ,_cce uint32 ;_ddd map[string ]struct{};};

// Operator returns the operator for the rule
func (_cdbe ConditionalFormattingRule )Operator ()_bdd .ST_ConditionalFormattingOperator {return _cdbe ._ggeg .OperatorAttr ;};

// SetBorder applies a border to a cell style. The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_bad CellStyle )SetBorder (b Border ){_bad ._bgb .BorderIdAttr =_f .Uint32 (b .Index ());_bad ._bgb .ApplyBorderAttr =_f .Bool (true );};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gga Comments )AddComment (cellRef string ,author string )RichText {_fbb :=_bdd .NewCT_Comment ();_gga ._gae .CommentList .Comment =append (_gga ._gae .CommentList .Comment ,_fbb );_fbb .RefAttr =cellRef ;_fbb .AuthorIdAttr =_gga .getOrCreateAuthor (author );_fbb .Text =_bdd .NewCT_Rst ();return RichText {_fbb .Text };};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_cgc Comment )SetCellReference (cellRef string ){_cgc ._ffde .RefAttr =cellRef };

// HasFormula returns true if the cell has an asoociated formula.
func (_debc Cell )HasFormula ()bool {return _debc ._egf .F !=nil };

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bagc *Workbook )GetFilename ()string {return _bagc ._eddc };

// SetHeight sets the row height in points.
func (_gfffe Row )SetHeight (d _ff .Distance ){_gfffe ._ceea .HtAttr =_f .Float64 (float64 (d ));_gfffe ._ceea .CustomHeightAttr =_f .Bool (true );};

// Index returns the index of the border for use with a cell style.
func (_ef Border )Index ()uint32 {for _cea ,_dfga :=range _ef ._dbd .Border {if _dfga ==_ef ._adc {return uint32 (_cea );};};return 0;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// AddMergedCells merges cells within a sheet.
func (_dgbd *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _dgbd ._bcbe .MergeCells ==nil {_dgbd ._bcbe .MergeCells =_bdd .NewCT_MergeCells ();};_agcc :=_bdd .NewCT_MergeCell ();_agcc .RefAttr =_fb .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_dgbd ._bcbe .MergeCells .MergeCell =append (_dgbd ._bcbe .MergeCells .MergeCell ,_agcc );_dgbd ._bcbe .MergeCells .CountAttr =_f .Uint32 (uint32 (len (_dgbd ._bcbe .MergeCells .MergeCell )));return MergedCell {_dgbd ._debfd ,_dgbd ,_agcc };};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};func (_dadf Sheet )validateMergedCells ()error {_bdcb :=map[uint64 ]struct{}{};for _ ,_afca :=range _dadf .MergedCells (){_gfef ,_egdg ,_dcebe :=_eg .ParseRangeReference (_afca .Reference ());if _dcebe !=nil {return _fb .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_dadf .Name (),_afca .Reference ());};for _ggbg :=_gfef .RowIdx ;_ggbg <=_egdg .RowIdx ;_ggbg ++{for _bacc :=_gfef .ColumnIdx ;_bacc <=_egdg .ColumnIdx ;_bacc ++{_gagf :=uint64 (_ggbg )<<32|uint64 (_bacc );if _ ,_cebee :=_bdcb [_gagf ];_cebee {return _fb .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_dadf .Name ());};_bdcb [_gagf ]=struct{}{};};};};return nil ;};func (_bga Border )SetDiagonal (style _bdd .ST_BorderStyle ,c _dc .Color ,up ,down bool ){if _bga ._adc .Diagonal ==nil {_bga ._adc .Diagonal =_bdd .NewCT_BorderPr ();};_bga ._adc .Diagonal .Color =_bdd .NewCT_Color ();_bga ._adc .Diagonal .Color .RgbAttr =c .AsRGBAString ();_bga ._adc .Diagonal .StyleAttr =style ;if up {_bga ._adc .DiagonalUpAttr =_f .Bool (true );};if down {_bga ._adc .DiagonalDownAttr =_f .Bool (true );};};

// SetYSplit sets the row split point
func (_cdcff SheetView )SetYSplit (v float64 ){_cdcff .ensurePane ();_cdcff ._adedb .Pane .YSplitAttr =_f .Float64 (v );};func (_bcgb Cell )setLocked (_dffg bool ){_ceaa :=_bcgb ._egf .SAttr ;if _ceaa !=nil {_bdbe :=_bcgb ._dac .StyleSheet .GetCellStyle (*_ceaa );if _bdbe ._bgb .Protection ==nil {_bdbe ._bgb .Protection =_bdd .NewCT_CellProtection ();};_bdbe ._bgb .Protection .LockedAttr =&_dffg ;};};

// SetStyle sets the cell style for an entire column.
func (_eabc Column )SetStyle (cs CellStyle ){_eabc ._ebe .StyleAttr =_f .Uint32 (cs .Index ())};

// SetMaxLength sets the maximum bar length in percent.
func (_fcff DataBarScale )SetMaxLength (l uint32 ){_fcff ._dgcd .MaxLengthAttr =_f .Uint32 (l )};

// X returns the inner wrapped XML type.
func (_debec *Workbook )X ()*_bdd .Workbook {return _debec ._cecaf };

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_accae *Workbook )AddDrawing ()Drawing {_cbdb :=_bgd .NewWsDr ();_accae ._aeeg =append (_accae ._aeeg ,_cbdb );_defed :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,len (_accae ._aeeg ));_accae .ContentTypes .AddOverride (_defed ,_f .DrawingContentType );_accae ._gefc =append (_accae ._gefc ,_ad .NewRelationships ());return Drawing {_accae ,_cbdb };};func (_cfa *evalContext )SetOffset (col ,row uint32 ){_cfa ._dbcg =col ;_cfa ._cce =row };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ffa ColorScale )AddFormatValue (t _bdd .ST_CfvoType ,val string ){_cbc :=_bdd .NewCT_Cfvo ();_cbc .TypeAttr =t ;_cbc .ValAttr =_f .String (val );_ffa ._gea .Cfvo =append (_ffa ._gea .Cfvo ,_cbc );};var _daaa []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// SetHeightAuto sets the row height to be automatically determined.
func (_aded Row )SetHeightAuto (){_aded ._ceea .HtAttr =nil ;_aded ._ceea .CustomHeightAttr =nil };

// Comments returns the comments for a sheet.
func (_edge *Sheet )Comments ()Comments {for _ebbd ,_gaagc :=range _edge ._debfd ._acggg {if _gaagc ==_edge ._bcbe {if _edge ._debfd ._eedb [_ebbd ]==nil {_edge ._debfd ._eedb [_ebbd ]=_bdd .NewComments ();_edge ._debfd ._bafe [_ebbd ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_ebbd +1,_f .CommentsType );_edge ._debfd .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .CommentsType ,_ebbd +1),_f .CommentsContentType );};if len (_edge ._debfd ._bdaaa )==0{_edge ._debfd ._bdaaa =append (_edge ._debfd ._bdaaa ,_db .NewCommentDrawing ());_cbff :=_edge ._debfd ._bafe [_ebbd ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,1,_f .VMLDrawingType );if _edge ._bcbe .LegacyDrawing ==nil {_edge ._bcbe .LegacyDrawing =_bdd .NewCT_LegacyDrawing ();};_edge ._bcbe .LegacyDrawing .IdAttr =_cbff .ID ();};return Comments {_edge ._debfd ,_edge ._debfd ._eedb [_ebbd ]};};};_aa .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_fegc StyleSheet )Fills ()Fills {return Fills {_fegc ._aecc .Fills }};func _ccf (_fabf string )bool {_fabf =_ce .Replace (_fabf ,"\u0024","",-1);if _bagf :=_gcga .FindStringSubmatch (_ce .ToLower (_fabf ));len (_bagf )> 2{_aeg :=_bagf [1];_gega ,_cgac :=_be .Atoi (_bagf [2]);if _cgac !=nil {return false ;};return _gega <=1048576&&_aeg <="\u007a\u007a";};return false ;};

// Reference returns the table reference (the cells within the table)
func (_gbaa Table )Reference ()string {return _gbaa ._bebg .RefAttr };

// X returns the inner wrapped XML type.
func (_ecg DataBarScale )X ()*_bdd .CT_DataBar {return _ecg ._dgcd };

// X returns the inner wrapped XML type.
func (_ga Border )X ()*_bdd .CT_Border {return _ga ._adc };

// Protection controls the protection on an individual sheet.
func (_gfga *Sheet )Protection ()SheetProtection {if _gfga ._bcbe .SheetProtection ==nil {_gfga ._bcbe .SheetProtection =_bdd .NewCT_SheetProtection ();};return SheetProtection {_gfga ._bcbe .SheetProtection };};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_fgff *Sheet )SetFrozen (firstRow ,firstCol bool ){_fgff ._bcbe .SheetViews =nil ;_gccdf :=_fgff .AddView ();_gccdf .SetState (_bdd .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_gccdf .SetYSplit (1);_gccdf .SetXSplit (1);_gccdf .SetTopLeft ("\u0042\u0032");case firstRow :_gccdf .SetYSplit (1);_gccdf .SetTopLeft ("\u0041\u0032");case firstCol :_gccdf .SetXSplit (1);_gccdf .SetTopLeft ("\u0042\u0031");};};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_feb *_bgd .CT_OneCellAnchor };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_dfd *Workbook ;_eag *_bgd .WsDr ;};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_bcfd NumberFormat )ID ()uint32 {return _bcfd ._edf .NumFmtIdAttr };

// ExtractText returns text from the workbook as a WorkbookText object.
func (_daff *Workbook )ExtractText ()*WorkbookText {_fdca :=[]*SheetText {};for _ ,_fga :=range _daff .Sheets (){_fdca =append (_fdca ,&SheetText {Cells :_fga .ExtractText ().Cells });};return &WorkbookText {Sheets :_fdca };};

// IsEmpty checks if the cell style contains nothing.
func (_gdgc CellStyle )IsEmpty ()bool {return _gdgc ._eaadf ==nil ||_gdgc ._bgb ==nil ||_gdgc ._bgaf ==nil ||_gdgc ._bgaf .Xf ==nil ;};

// IconScale maps values to icons.
type IconScale struct{_eaba *_bdd .CT_IconSet };

// PasswordHash returns the hash of the workbook password.
func (_gcge WorkbookProtection )PasswordHash ()string {if _gcge ._fdfae .WorkbookPasswordAttr ==nil {return "";};return *_gcge ._fdfae .WorkbookPasswordAttr ;};

// AddSheet adds a new sheet to a workbook.
func (_ffdff *Workbook )AddSheet ()Sheet {_aaae :=_bdd .NewCT_Sheet ();_aaae .SheetIdAttr =1;for _ ,_bbec :=range _ffdff ._cecaf .Sheets .Sheet {if _aaae .SheetIdAttr <=_bbec .SheetIdAttr {_aaae .SheetIdAttr =_bbec .SheetIdAttr +1;};};_ffdff ._cecaf .Sheets .Sheet =append (_ffdff ._cecaf .Sheets .Sheet ,_aaae );_aaae .NameAttr =_fb .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_aaae .SheetIdAttr );_eabbg :=_bdd .NewWorksheet ();_eabbg .Dimension =_bdd .NewCT_SheetDimension ();_eabbg .Dimension .RefAttr ="\u0041\u0031";_ffdff ._acggg =append (_ffdff ._acggg ,_eabbg );_cbaf :=_ad .NewRelationships ();_ffdff ._bafe =append (_ffdff ._bafe ,_cbaf );_eabbg .SheetData =_bdd .NewCT_SheetData ();_ffdff ._eedb =append (_ffdff ._eedb ,nil );_ggff :=_f .DocTypeSpreadsheet ;_dfb :=_ffdff ._ggd .AddAutoRelationship (_ggff ,_f .OfficeDocumentType ,len (_ffdff ._cecaf .Sheets .Sheet ),_f .WorksheetType );_aaae .IdAttr =_dfb .ID ();_ffdff .ContentTypes .AddOverride (_f .AbsoluteFilename (_ggff ,_f .WorksheetContentType ,len (_ffdff ._cecaf .Sheets .Sheet )),_f .WorksheetContentType );return Sheet {_ffdff ,_aaae ,_eabbg };};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_ggae *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_cead :=_ggae ._bcbe .SheetData .Row ;_dfcb :=_ggae .Rows ();for _agcab ,_aafg :=range _dfcb {if _aafg .RowNumber ()==firstRow {_cead =_ggae ._bcbe .SheetData .Row [_agcab :];break ;};};_cdcf :=Comparer {Order :order };_fc .Slice (_cead ,func (_dfee ,_effg int )bool {return _cdcf .LessRows (column ,Row {_ggae ._debfd ,_ggae ,_cead [_dfee ]},Row {_ggae ._debfd ,_ggae ,_cead [_effg ]});});for _bdea ,_gaec :=range _ggae .Rows (){_dcfg :=uint32 (_bdea +1);if _gaec .RowNumber ()!=_dcfg {_gaec .renumberAs (_dcfg );};};};

// X returns the inner wrapped XML type.
func (_gcbb RichText )X ()*_bdd .CT_Rst {return _gcbb ._gegc };

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_bb *_bgd .CT_AbsoluteAnchor };

// ClearFont clears any font configuration from the cell style.
func (_dab CellStyle )ClearFont (){_dab ._bgb .FontIdAttr =nil ;_dab ._bgb .ApplyFontAttr =nil };

// SetWidth sets the width of the anchored object.
func (_cgfdd OneCellAnchor )SetWidth (w _ff .Distance ){_cgfdd ._feb .Ext .CxAttr =int64 (w /_ff .EMU )};type WorkbookProtection struct{_fdfae *_bdd .CT_WorkbookProtection };func (_cbdd Comments )getOrCreateAuthor (_bab string )uint32 {for _daa ,_daga :=range _cbdd ._gae .Authors .Author {if _daga ==_bab {return uint32 (_daa );};};_bce :=uint32 (len (_cbdd ._gae .Authors .Author ));_cbdd ._gae .Authors .Author =append (_cbdd ._gae .Authors .Author ,_bab );return _bce ;};

// GetFont gets a Font from a cell style.
func (_efb CellStyle )GetFont ()*_bdd .CT_Font {if _gbg :=_efb ._bgb .FontIdAttr ;_gbg !=nil {_cdb :=_efb ._eaadf .StyleSheet .Fonts ();if int (*_gbg )< len (_cdb ){return _cdb [int (*_gbg )].X ();};};return nil ;};func (_gbca SortOrder )String ()string {if _gbca >=SortOrder (len (_dadce )-1){return _fb .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_gbca );};return _cggb [_dadce [_gbca ]:_dadce [_gbca +1]];};

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_dbegg *Workbook )RemoveCalcChain (){var _gbcad string ;for _ ,_efee :=range _dbegg ._ggd .Relationships (){if _efee .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_gbcad ="\u0078\u006c\u002f"+_efee .Target ();_dbegg ._ggd .Remove (_efee );break ;};};if _gbcad ==""{return ;};_dbegg .ContentTypes .RemoveOverride (_gbcad );for _cagg ,_aaaec :=range _dbegg .ExtraFiles {if _aaaec .ZipPath ==_gbcad {_dbegg .ExtraFiles [_cagg ]=_dbegg .ExtraFiles [len (_dbegg .ExtraFiles )-1];_dbegg .ExtraFiles =_dbegg .ExtraFiles [:len (_dbegg .ExtraFiles )-1];return ;};};};

// MergedCells returns the merged cell regions within the sheet.
func (_egdgb *Sheet )MergedCells ()[]MergedCell {if _egdgb ._bcbe .MergeCells ==nil {return nil ;};_ccgg :=[]MergedCell {};for _ ,_dcad :=range _egdgb ._bcbe .MergeCells .MergeCell {_ccgg =append (_ccgg ,MergedCell {_egdgb ._debfd ,_egdgb ,_dcad });};return _ccgg ;};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_ccb CellStyle )HasNumberFormat ()bool {return _ccb ._bgb .NumFmtIdAttr !=nil &&_ccb ._bgb .ApplyNumberFormatAttr !=nil &&*_ccb ._bgb .ApplyNumberFormatAttr ;};func (_gdgbf Sheet )IsValid ()bool {return _gdgbf ._bcbe !=nil };

// IsBool returns true if the cell is a boolean type cell.
func (_dag Cell )IsBool ()bool {return _dag ._egf .TAttr ==_bdd .ST_CellTypeB };const (DVOpGreater =_bdd .ST_DataValidationOperatorGreaterThanOrEqual ;);

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_gab *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_ce .Replace (rangeRef ,"\u0024","",-1);_gab ._bcbe .AutoFilter =_bdd .NewCT_AutoFilter ();_gab ._bcbe .AutoFilter .RefAttr =_f .String (rangeRef );_bba :="\u0027"+_gab .Name ()+"\u0027\u0021";var _gcag DefinedName ;for _ ,_bfg :=range _gab ._debfd .DefinedNames (){if _bfg .Name ()==_eggd {if _ce .HasPrefix (_bfg .Content (),_bba ){_gcag =_bfg ;_gcag .SetContent (_gab .RangeReference (rangeRef ));break ;};};};if _gcag .X ()==nil {_gcag =_gab ._debfd .AddDefinedName (_eggd ,_gab .RangeReference (rangeRef ));};for _gegce ,_gbcd :=range _gab ._debfd ._acggg {if _gbcd ==_gab ._bcbe {_gcag .SetLocalSheetID (uint32 (_gegce ));};};};

// SetWidthCells is a no-op.
func (_beb AbsoluteAnchor )SetWidthCells (int32 ){};

// AddFont adds a new empty font to the stylesheet.
func (_ggbe StyleSheet )AddFont ()Font {_cegc :=_bdd .NewCT_Font ();_ggbe ._aecc .Fonts .Font =append (_ggbe ._aecc .Fonts .Font ,_cegc );_ggbe ._aecc .Fonts .CountAttr =_f .Uint32 (uint32 (len (_ggbe ._aecc .Fonts .Font )));return Font {_cegc ,_ggbe ._aecc };};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_dda *Sheet )Cell (cellRef string )Cell {_aaag ,_beed :=_eg .ParseCellReference (cellRef );if _beed !=nil {_aa .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_beed );return _dda .AddRow ().AddCell ();};return _dda .Row (_aaag .RowIdx ).Cell (_aaag .Column );};func (_aeeb CellStyle )SetShrinkToFit (b bool ){if _aeeb ._bgb .Alignment ==nil {_aeeb ._bgb .Alignment =_bdd .NewCT_CellAlignment ();};_aeeb ._bgb .ApplyAlignmentAttr =_f .Bool (true );if !b {_aeeb ._bgb .Alignment .ShrinkToFitAttr =nil ;}else {_aeeb ._bgb .Alignment .ShrinkToFitAttr =_f .Bool (b );};};

// Rows returns all of the rows in a sheet.
func (_eaafd *Sheet )Rows ()[]Row {_afcb :=[]Row {};for _ ,_gefe :=range _eaafd ._bcbe .SheetData .Row {_afcb =append (_afcb ,Row {_eaafd ._debfd ,_eaafd ,_gefe });};return _afcb ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gdcg *Workbook )RecalculateFormulas (){for _ ,_aagg :=range _gdcg .Sheets (){_aagg .RecalculateFormulas ();};};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_ffad :=_bdd .NewStyleSheet ();_ffad .CellStyleXfs =_bdd .NewCT_CellStyleXfs ();_ffad .CellXfs =_bdd .NewCT_CellXfs ();_ffad .CellStyles =_bdd .NewCT_CellStyles ();_cdbdg :=_bdd .NewCT_CellStyle ();_cdbdg .NameAttr =_f .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_cdbdg .XfIdAttr =0;_cdbdg .BuiltinIdAttr =_f .Uint32 (0);_ffad .CellStyles .CellStyle =append (_ffad .CellStyles .CellStyle ,_cdbdg );_ffad .CellStyles .CountAttr =_f .Uint32 (uint32 (len (_ffad .CellStyles .CellStyle )));_aggd :=_bdd .NewCT_Xf ();_aggd .NumFmtIdAttr =_f .Uint32 (0);_aggd .FontIdAttr =_f .Uint32 (0);_aggd .FillIdAttr =_f .Uint32 (0);_aggd .BorderIdAttr =_f .Uint32 (0);_ffad .CellStyleXfs .Xf =append (_ffad .CellStyleXfs .Xf ,_aggd );_ffad .CellStyleXfs .CountAttr =_f .Uint32 (uint32 (len (_ffad .CellStyleXfs .Xf )));_gbcf :=NewFills ();_ffad .Fills =_gbcf .X ();_gabe :=_gbcf .AddFill ().SetPatternFill ();_gabe .SetPattern (_bdd .ST_PatternTypeNone );_gabe =_gbcf .AddFill ().SetPatternFill ();_gabe .SetPattern (_bdd .ST_PatternTypeGray125 );_ffad .Fonts =_bdd .NewCT_Fonts ();_ffad .Borders =_bdd .NewCT_Borders ();_ccec :=StyleSheet {wb ,_ffad };_ccec .AddBorder ().InitializeDefaults ();_bcdc :=_ccec .AddFont ();_bcdc .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_bcdc .SetSize (11);_cbdce :=_bdd .NewCT_Xf ();*_cbdce =*_aggd ;_cbdce .XfIdAttr =_f .Uint32 (0);_ffad .CellXfs .Xf =append (_ffad .CellXfs .Xf ,_cbdce );_ffad .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_ffad .CellXfs .Xf )));return _ccec ;};func (_gbde DataValidationCompare )SetValue2 (v string ){_gbde ._gdbe .Formula2 =&v };

// SetShowValue controls if the cell value is displayed.
func (_dbde DataBarScale )SetShowValue (b bool ){_dbde ._dgcd .ShowValueAttr =_f .Bool (b )};func (_fea Fills )X ()*_bdd .CT_Fills {return _fea ._bfeb };func (_cee Font )SetName (name string ){_cee ._fgfg .Name =[]*_bdd .CT_FontName {{ValAttr :name }}};type ConditionalFormattingRule struct{_ggeg *_bdd .CT_CfRule };

// X returns the inner wrapped XML type.
func (_acae Drawing )X ()*_bgd .WsDr {return _acae ._eag };

// Cell is a single cell within a sheet.
type Cell struct{_dac *Workbook ;_ea *Sheet ;_bgg *_bdd .CT_Row ;_egf *_bdd .CT_Cell ;};func (_bdgg Font )SetItalic (b bool ){if b {_bdgg ._fgfg .I =[]*_bdd .CT_BooleanProperty {{}};}else {_bdgg ._fgfg .I =nil ;};};

// SetIcons sets the icon set to use for display.
func (_eac IconScale )SetIcons (t _bdd .ST_IconSetType ){_eac ._eaba .IconSetAttr =t };

// AddCell adds a cell to a spreadsheet.
func (_fcea Row )AddCell ()Cell {_aggc :=uint32 (len (_fcea ._ceea .C ));var _fdad *string ;if _aggc > 0{_dbca :=_f .Stringf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_aggc -1),_fcea .RowNumber ());if _fcea ._ceea .C [_aggc -1].RAttr !=nil &&*_fcea ._ceea .C [_aggc -1].RAttr ==*_dbca {_fdad =_f .Stringf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_aggc ),_fcea .RowNumber ());};};_ddbc :=_bdd .NewCT_Cell ();_fcea ._ceea .C =append (_fcea ._ceea .C ,_ddbc );if _fdad ==nil {_ecd :=uint32 (0);for _ ,_dca :=range _fcea ._ceea .C {if _dca .RAttr !=nil {_ada ,_ :=_eg .ParseCellReference (*_dca .RAttr );if _ada .ColumnIdx >=_ecd {_ecd =_ada .ColumnIdx +1;};};};_fdad =_f .Stringf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_ecd ),_fcea .RowNumber ());};_ddbc .RAttr =_fdad ;return Cell {_fcea ._dcga ,_fcea ._beea ,_fcea ._ceea ,_ddbc };};func (_aef Font )SetBold (b bool ){if b {_aef ._fgfg .B =[]*_bdd .CT_BooleanProperty {{}};}else {_aef ._fgfg .B =nil ;};};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_fgc Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _fff ,_bgbb Cell ;for _ ,_baad :=range lhs .Cells (){_gcce ,_ :=_eg .ParseCellReference (_baad .Reference ());if _gcce .Column ==column {_fff =_baad ;break ;};};for _ ,_geg :=range rhs .Cells (){_afdf ,_ :=_eg .ParseCellReference (_geg .Reference ());if _afdf .Column ==column {_bgbb =_geg ;break ;};};return _fgc .LessCells (_fff ,_bgbb );};

// X returns the inner wrapped XML type.
func (_acag Sheet )X ()*_bdd .Worksheet {return _acag ._bcbe };

// X returns the inner wrapped XML type.
func (_aeee Font )X ()*_bdd .CT_Font {return _aeee ._fgfg };type Fill struct{_fcc *_bdd .CT_Fill ;_dfc *_bdd .CT_Fills ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_aecg DataValidation )SetRange (cellRange string ){_aecg ._fed .SqrefAttr =_bdd .ST_Sqref {cellRange };};

// RemoveDefinedName removes an existing defined name.
func (_daed *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _fa .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _ggag ,_gbag :=range _daed ._cecaf .DefinedNames .DefinedName {if _gbag ==dn .X (){copy (_daed ._cecaf .DefinedNames .DefinedName [_ggag :],_daed ._cecaf .DefinedNames .DefinedName [_ggag +1:]);_daed ._cecaf .DefinedNames .DefinedName [len (_daed ._cecaf .DefinedNames .DefinedName )-1]=nil ;_daed ._cecaf .DefinedNames .DefinedName =_daed ._cecaf .DefinedNames .DefinedName [:len (_daed ._cecaf .DefinedNames .DefinedName )-1];return nil ;};};return _fa .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_ecgae *Sheet )FormulaContext ()_agb .Context {return _ffg (_ecgae )};

// Row is a row within a spreadsheet.
type Row struct{_dcga *Workbook ;_beea *Sheet ;_ceea *_bdd .CT_Row ;};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gafd *evalContext )LastColumn (rowFrom ,rowTo int )string {_fcfb :=_gafd ._agbd ;_gbga :=1;for _gfgd :=rowFrom ;_gfgd <=rowTo ;_gfgd ++{_fabc :=len (_fcfb .Row (uint32 (_gfgd )).Cells ());if _fabc > _gbga {_gbga =_fabc ;};};return _eg .IndexToColumn (uint32 (_gbga -1));};func (_gb Border )SetBottom (style _bdd .ST_BorderStyle ,c _dc .Color ){if _gb ._adc .Bottom ==nil {_gb ._adc .Bottom =_bdd .NewCT_BorderPr ();};_gb ._adc .Bottom .Color =_bdd .NewCT_Color ();_gb ._adc .Bottom .Color .RgbAttr =c .AsRGBAString ();_gb ._adc .Bottom .StyleAttr =style ;};

// Border is a cell border configuraton.
type Border struct{_adc *_bdd .CT_Border ;_dbd *_bdd .CT_Borders ;};

// X returns the inner wrapped XML type.
func (_bff Comments )X ()*_bdd .Comments {return _bff ._gae };

// ClearNumberFormat removes any number formatting from the style.
func (_acda CellStyle )ClearNumberFormat (){_acda ._bgb .NumFmtIdAttr =nil ;_acda ._bgb .ApplyNumberFormatAttr =nil ;};func (_gecc Cell )GetRawValue ()(string ,error ){switch _gecc ._egf .TAttr {case _bdd .ST_CellTypeInlineStr :if _gecc ._egf .Is ==nil ||_gecc ._egf .Is .T ==nil {return "",nil ;};return *_gecc ._egf .Is .T ,nil ;case _bdd .ST_CellTypeS :if _gecc ._egf .V ==nil {return "",nil ;};_ebgg ,_dced :=_be .Atoi (*_gecc ._egf .V );if _dced !=nil {return "",_dced ;};return _gecc ._dac .SharedStrings .GetString (_ebgg );case _bdd .ST_CellTypeStr :if _gecc ._egf .F !=nil {return _gecc ._egf .F .Content ,nil ;};};if _gecc ._egf .V ==nil {return "",nil ;};return *_gecc ._egf .V ,nil ;};func (_gce StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_fbab :=range _gce ._aecc .NumFmts .NumFmt {if _fbab .NumFmtIdAttr ==id {return NumberFormat {_gce ._cfef ,_fbab };};};return NumberFormat {};};

// Clear clears the cell's value and type.
func (_gdf Cell )Clear (){_gdf .clearValue ();_gdf ._egf .TAttr =_bdd .ST_CellTypeUnset };

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_aaeg Cell )SetFormulaArray (s string ){_ffd :=_agb .ParseString (s );if _ffd ==nil {return ;};_aaeg .clearValue ();_aaeg ._egf .TAttr =_bdd .ST_CellTypeStr ;_aaeg ._egf .F =_bdd .NewCT_CellFormula ();_aaeg ._egf .F .TAttr =_bdd .ST_CellFormulaTypeArray ;_aaeg ._egf .F .Content =s ;};

// SetColOffset sets a column offset in absolute distance.
func (_eba CellMarker )SetColOffset (m _ff .Distance ){_eba ._acg .ColOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ff .EMU ));};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_gdc CellStyle )NumberFormat ()uint32 {if _gdc ._bgb .NumFmtIdAttr ==nil {return 0;};return *_gdc ._bgb .NumFmtIdAttr ;};

// MoveTo is a no-op.
func (_bdb AbsoluteAnchor )MoveTo (x ,y int32 ){};func (_ebdg *Sheet )getAllCellsInFormulaArrays (_afb bool )(map[string ]bool ,error ){_eabb :=_agb .NewEvaluator ();_fdba :=_ebdg .FormulaContext ();_effd :=map[string ]bool {};for _ ,_adgg :=range _ebdg .Rows (){for _ ,_fbaf :=range _adgg .Cells (){if _fbaf .X ().F !=nil {_bbae :=_fbaf .X ().F .Content ;if _fbaf .X ().F .TAttr ==_bdd .ST_CellFormulaTypeArray {_fefd :=_eabb .Eval (_fdba ,_bbae ).AsString ();if _fefd .Type ==_agb .ResultTypeError {_aa .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bbae ,_fefd .ErrorMessage );_fbaf .X ().V =nil ;};if _fefd .Type ==_agb .ResultTypeArray {_cdga ,_bcfc :=_eg .ParseCellReference (_fbaf .Reference ());if _bcfc !=nil {return map[string ]bool {},_bcfc ;};if (_afb &&len (_fefd .ValueArray )==1)||(!_afb &&len (_fefd .ValueArray [0])==1){continue ;};for _dbcaf ,_fgcg :=range _fefd .ValueArray {_acgg :=_cdga .RowIdx +uint32 (_dbcaf );for _cgfb :=range _fgcg {_gfefaa :=_eg .IndexToColumn (_cdga .ColumnIdx +uint32 (_cgfb ));_effd [_fb .Sprintf ("\u0025\u0073\u0025\u0064",_gfefaa ,_acgg )]=true ;};};}else if _fefd .Type ==_agb .ResultTypeList {_fffc ,_gdfd :=_eg .ParseCellReference (_fbaf .Reference ());if _gdfd !=nil {return map[string ]bool {},_gdfd ;};if _afb ||len (_fefd .ValueList )==1{continue ;};_beg :=_fffc .RowIdx ;for _eeeb :=range _fefd .ValueList {_bcfg :=_eg .IndexToColumn (_fffc .ColumnIdx +uint32 (_eeeb ));_effd [_fb .Sprintf ("\u0025\u0073\u0025\u0064",_bcfg ,_beg )]=true ;};};};};};};return _effd ,nil ;};func (_baade Fill )Index ()uint32 {if _baade ._dfc ==nil {return 0;};for _efcbf ,_cebe :=range _baade ._dfc .Fill {if _baade ._fcc ==_cebe {return uint32 (_efcbf );};};return 0;};type Table struct{_bebg *_bdd .Table };

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_gegc *_bdd .CT_Rst };

// X returns the inner wrapped XML type.
func (_ebba Row )X ()*_bdd .CT_Row {return _ebba ._ceea };func (_aeab ConditionalFormattingRule )InitializeDefaults (){_aeab .SetType (_bdd .ST_CfTypeCellIs );_aeab .SetOperator (_bdd .ST_ConditionalFormattingOperatorGreaterThan );_aeab .SetPriority (1);};func (_ebab *Sheet )removeColumnFromNamedRanges (_abace uint32 )error {for _ ,_fbefe :=range _ebab ._debfd .DefinedNames (){_eacd :=_fbefe .Name ();_bcff :=_fbefe .Content ();_debcf :=_ce .Split (_bcff ,"\u0021");if len (_debcf )!=2{return _fa .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_bcff );};_ffge :=_debcf [0];if _ebab .Name ()==_ffge {_cbdg :=_ebab ._debfd .RemoveDefinedName (_fbefe );if _cbdg !=nil {return _cbdg ;};_gffe :=_dcca (_debcf [1],_abace ,true );if _gffe !=""{_ceca :=_ffge +"\u0021"+_gffe ;_ebab ._debfd .AddDefinedName (_eacd ,_ceca );};};};_fegd :=0;if _ebab ._bcbe .TableParts !=nil &&_ebab ._bcbe .TableParts .TablePart !=nil {_fegd =len (_ebab ._bcbe .TableParts .TablePart );};if _fegd !=0{_bbca :=0;for _ ,_fcdf :=range _ebab ._debfd .Sheets (){if _fcdf .Name ()==_ebab .Name (){break ;}else {if _fcdf ._bcbe .TableParts !=nil &&_fcdf ._bcbe .TableParts .TablePart !=nil {_bbca +=len (_fcdf ._bcbe .TableParts .TablePart );};};};_edb :=_ebab ._debfd ._cafc [_bbca :_bbca +_fegd ];for _cfea ,_geb :=range _edb {_debe :=_geb ;_debe .RefAttr =_dcca (_debe .RefAttr ,_abace ,false );_ebab ._debfd ._cafc [_bbca +_cfea ]=_debe ;};};return nil ;};var _ffed =_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0);

// SetBold causes the text to be displayed in bold.
func (_gecd RichTextRun )SetBold (b bool ){_gecd .ensureRpr ();_gecd ._fabe .RPr .B =_bdd .NewCT_BooleanProperty ();_gecd ._fabe .RPr .B .ValAttr =_f .Bool (b );};

// LockSheet controls the locking of the sheet.
func (_aeef SheetProtection )LockSheet (b bool ){if !b {_aeef ._edbb .SheetAttr =nil ;}else {_aeef ._edbb .SheetAttr =_f .Bool (true );};};

// IsBool returns true if the cell boolean value.
func (_fged *evalContext )IsBool (cellRef string )bool {return _fged ._agbd .Cell (cellRef ).IsBool ()};

// Sheets returns the sheets from the workbook.
func (_dbba *Workbook )Sheets ()[]Sheet {_gffd :=[]Sheet {};for _aaafg ,_fcge :=range _dbba ._acggg {_bdeg :=_dbba ._cecaf .Sheets .Sheet [_aaafg ];_gcaf :=Sheet {_dbba ,_bdeg ,_fcge };_gffd =append (_gffd ,_gcaf );};return _gffd ;};func (_ffaa Font )SetColor (c _dc .Color ){_afcf :=_bdd .NewCT_Color ();_edcb :="\u0066\u0066"+*c .AsRGBString ();_afcf .RgbAttr =&_edcb ;_ffaa ._fgfg .Color =[]*_bdd .CT_Color {_afcf };};func (_cbfbd StyleSheet )GetCellStyle (id uint32 )CellStyle {for _dabca ,_ccfd :=range _cbfbd ._aecc .CellXfs .Xf {if uint32 (_dabca )==id {return CellStyle {_cbfbd ._cfef ,_ccfd ,_cbfbd ._aecc .CellXfs };};};return CellStyle {};};

// SetName sets the sheet name.
func (_fgbb *Sheet )SetName (name string ){_fgbb ._abg .NameAttr =name };

// DefinedName is a named range, formula, etc.
type DefinedName struct{_afg *_bdd .CT_DefinedName };

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_bbc Cell )GetString ()string {switch _bbc ._egf .TAttr {case _bdd .ST_CellTypeInlineStr :if _bbc ._egf .Is !=nil &&_bbc ._egf .Is .T !=nil {return *_bbc ._egf .Is .T ;};if _bbc ._egf .V !=nil {return *_bbc ._egf .V ;};case _bdd .ST_CellTypeS :if _bbc ._egf .V ==nil {return "";};_bcg ,_ccc :=_be .Atoi (*_bbc ._egf .V );if _ccc !=nil {return "";};_gad ,_ccc :=_bbc ._dac .SharedStrings .GetString (_bcg );if _ccc !=nil {return "";};return _gad ;};if _bbc ._egf .V ==nil {return "";};return *_bbc ._egf .V ;};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_fdfd *Sheet )Column (idx uint32 )Column {for _ ,_gdfb :=range _fdfd ._bcbe .Cols {for _ ,_eef :=range _gdfb .Col {if idx >=_eef .MinAttr &&idx <=_eef .MaxAttr {return Column {_eef };};};};var _dgcb *_bdd .CT_Cols ;if len (_fdfd ._bcbe .Cols )==0{_dgcb =_bdd .NewCT_Cols ();_fdfd ._bcbe .Cols =append (_fdfd ._bcbe .Cols ,_dgcb );}else {_dgcb =_fdfd ._bcbe .Cols [0];};_fede :=_bdd .NewCT_Col ();_fede .MinAttr =idx ;_fede .MaxAttr =idx ;_dgcb .Col =append (_dgcb .Col ,_fede );return Column {_fede };};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _cge .ReaderAt ,size int64 )(*Workbook ,error ){const _cgae ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_cga .GetLicenseKey ().IsLicensed ()&&!_cdcd {_fb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_fb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return nil ,_fa .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_gdga :=New ();_gbf ,_edea :=_cga .GenRefId ("\u0073\u0072");if _edea !=nil {_aa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_edea );return nil ,_edea ;};_gdga ._bfgc =_gbf ;if _cgcd :=_cga .Track (_gdga ._bfgc ,_cgae );_cgcd !=nil {_aa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_cgcd );return nil ,_cgcd ;};_geag ,_edea :=_gd .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _edea !=nil {return nil ,_edea ;};_gdga .TmpPath =_geag ;_degc ,_edea :=_ag .NewReader (r ,size );if _edea !=nil {return nil ,_fb .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_edea );};_baba :=[]*_ag .File {};_baba =append (_baba ,_degc .File ...);_aafd :=false ;for _ ,_degg :=range _baba {if _degg .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_aafd =true ;break ;};};if _aafd {_gdga .CreateCustomProperties ();};_cgd :=_e .DecodeMap {};_cgd .SetOnNewRelationshipFunc (_gdga .onNewRelationship );_cgd .AddTarget (_f .ContentTypesFilename ,_gdga .ContentTypes .X (),"",0);_cgd .AddTarget (_f .BaseRelsFilename ,_gdga .Rels .X (),"",0);if _accb :=_cgd .Decode (_baba );_accb !=nil {return nil ,_accb ;};for _ ,_gfge :=range _baba {if _gfge ==nil {continue ;};if _cbgf :=_gdga .AddExtraFileFromZip (_gfge );_cbgf !=nil {return nil ,_cbgf ;};};if _aafd {_aaaf :=false ;for _ ,_aeeee :=range _gdga .Rels .X ().Relationship {if _aeeee .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_aaaf =true ;break ;};};if !_aaaf {_gdga .AddCustomRelationships ();};};return _gdga ,nil ;};

// SetFont sets the font name for a rich text run.
func (_aega RichTextRun )SetFont (s string ){_aega .ensureRpr ();_aega ._fabe .RPr .RFont =_bdd .NewCT_FontName ();_aega ._fabe .RPr .RFont .ValAttr =s ;};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_dbgf ConditionalFormattingRule )SetConditionValue (v string ){_dbgf ._ggeg .Formula =[]string {v }};

// X returns the inner XML entity for a stylesheet.
func (_eafa StyleSheet )X ()*_bdd .StyleSheet {return _eafa ._aecc };

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_ceegb Sheet )Validate ()error {_fde :=[]func ()error {_ceegb .validateRowCellNumbers ,_ceegb .validateMergedCells ,_ceegb .validateSheetNames };for _ ,_dgd :=range _fde {if _bge :=_dgd ();_bge !=nil {return _bge ;};};if _acfd :=_ceegb ._bcbe .Validate ();_acfd !=nil {return _acfd ;};return _ceegb ._bcbe .Validate ();};

// Type returns the type of anchor
func (_dcc AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_cbg Cell )SetFormulaRaw (s string ){_dccb :=_agb .ParseString (s );if _dccb ==nil {return ;};_cbg .clearValue ();_cbg ._egf .TAttr =_bdd .ST_CellTypeStr ;_cbg ._egf .F =_bdd .NewCT_CellFormula ();_cbg ._egf .F .Content =s ;};

// GetValueAsBool retrieves the cell's value as a boolean
func (_cba Cell )GetValueAsBool ()(bool ,error ){if _cba ._egf .TAttr !=_bdd .ST_CellTypeB {return false ,_fa .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _cba ._egf .V ==nil {return false ,_fa .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _be .ParseBool (*_cba ._egf .V );};

// GetWidth returns a worksheet's column width.
func (_bdeb *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_eecb :=range _bdeb ._agbd .X ().Cols [0].Col {if int (_eecb .MinAttr )<=colIdx &&colIdx <=int (_eecb .MaxAttr ){return float64 (int (*_eecb .WidthAttr ));};};return 0;};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_fgdf SheetView )SetState (st _bdd .ST_PaneState ){_fgdf .ensurePane ();_fgdf ._adedb .Pane .StateAttr =st ;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_daaaf *Sheet )RemoveColumn (column string )error {_defe ,_dceg :=_daaaf .getAllCellsInFormulaArraysForColumn ();if _dceg !=nil {return _dceg ;};_ffeb :=_eg .ColumnToIndex (column );for _ ,_ggfc :=range _daaaf .Rows (){_aaff :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_ggfc .X ().RAttr );if _ ,_gbgaa :=_defe [_aaff ];_gbgaa {return nil ;};};for _ ,_fggb :=range _daaaf .Rows (){_afce :=_fggb ._ceea .C ;for _cage ,_cabg :=range _afce {_fedc ,_ceeb :=_eg .ParseCellReference (*_cabg .RAttr );if _ceeb !=nil {return _ceeb ;};if _fedc .ColumnIdx ==_ffeb {_fggb ._ceea .C =append (_afce [:_cage ],_daaaf .slideCellsLeft (_afce [_cage +1:])...);break ;}else if _fedc .ColumnIdx > _ffeb {_fggb ._ceea .C =append (_afce [:_cage ],_daaaf .slideCellsLeft (_afce [_cage :])...);break ;};};};_dceg =_daaaf .updateAfterRemove (_ffeb ,_de .UpdateActionRemoveColumn );if _dceg !=nil {return _dceg ;};_dceg =_daaaf .removeColumnFromNamedRanges (_ffeb );if _dceg !=nil {return _dceg ;};_dceg =_daaaf .removeColumnFromMergedCells (_ffeb );if _dceg !=nil {return _dceg ;};for _ ,_adcg :=range _daaaf ._debfd .Sheets (){_adcg .RecalculateFormulas ();};return nil ;};

// Type returns the type of anchor
func (_cff OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_ffcd Cell )SetTime (d _ca .Time ){_ffcd .clearValue ();d =_geeg (d );_gcc :=_ffcd ._dac .Epoch ();if d .Before (_gcc ){_aa .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_bcb :=d .Sub (_gcc );_eaa :=new (_g .Float );_dcd :=new (_g .Float );_dcd .SetPrec (128);_dcd .SetUint64 (uint64 (_bcb ));_debf :=new (_g .Float );_debf .SetUint64 (24*60*60*1e9);_eaa .Quo (_dcd ,_debf );_ffcd ._egf .V =_f .String (_eaa .Text ('g',20));};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_ggaf *Workbook )Save (w _cge .Writer )error {const _gcced ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_cga .GetLicenseKey ().IsLicensed ()&&!_cdcd {_fb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_fb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _fa .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_ggaf ._bfgc )==0{_bcdcf ,_ffdgc :=_cga .GenRefId ("\u0073\u0077");if _ffdgc !=nil {_aa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ffdgc );return _ffdgc ;};_ggaf ._bfgc =_bcdcf ;};if _eccb :=_cga .Track (_ggaf ._bfgc ,_gcced );_eccb !=nil {_aa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_eccb );return _eccb ;};_fgedc :=_ag .NewWriter (w );defer _fgedc .Close ();_cfed :=_f .DocTypeSpreadsheet ;if _bafd :=_e .MarshalXML (_fgedc ,_f .BaseRelsFilename ,_ggaf .Rels .X ());_bafd !=nil {return _bafd ;};if _bcee :=_e .MarshalXMLByType (_fgedc ,_cfed ,_f .ExtendedPropertiesType ,_ggaf .AppProperties .X ());_bcee !=nil {return _bcee ;};if _fbgae :=_e .MarshalXMLByType (_fgedc ,_cfed ,_f .CorePropertiesType ,_ggaf .CoreProperties .X ());_fbgae !=nil {return _fbgae ;};_bfea :=_f .AbsoluteFilename (_cfed ,_f .OfficeDocumentType ,0);if _dbad :=_e .MarshalXML (_fgedc ,_bfea ,_ggaf ._cecaf );_dbad !=nil {return _dbad ;};if _cccf :=_e .MarshalXML (_fgedc ,_e .RelationsPathFor (_bfea ),_ggaf ._ggd .X ());_cccf !=nil {return _cccf ;};if _begg :=_e .MarshalXMLByType (_fgedc ,_cfed ,_f .StylesType ,_ggaf .StyleSheet .X ());_begg !=nil {return _begg ;};for _fafe ,_cggd :=range _ggaf ._ffdc {if _gecac :=_e .MarshalXMLByTypeIndex (_fgedc ,_cfed ,_f .ThemeType ,_fafe +1,_cggd );_gecac !=nil {return _gecac ;};};for _agdf ,_gafa :=range _ggaf ._acggg {_gafa .Dimension .RefAttr =Sheet {_ggaf ,nil ,_gafa }.Extents ();_ecac :=_f .AbsoluteFilename (_cfed ,_f .WorksheetType ,_agdf +1);_e .MarshalXML (_fgedc ,_ecac ,_gafa );_e .MarshalXML (_fgedc ,_e .RelationsPathFor (_ecac ),_ggaf ._bafe [_agdf ].X ());};if _bagg :=_e .MarshalXMLByType (_fgedc ,_cfed ,_f .SharedStringsType ,_ggaf .SharedStrings .X ());_bagg !=nil {return _bagg ;};if _ggaf .CustomProperties .X ()!=nil {if _dgfc :=_e .MarshalXMLByType (_fgedc ,_cfed ,_f .CustomPropertiesType ,_ggaf .CustomProperties .X ());_dgfc !=nil {return _dgfc ;};};if _ggaf .Thumbnail !=nil {_caeb :=_f .AbsoluteFilename (_cfed ,_f .ThumbnailType ,0);_cedb ,_ecea :=_fgedc .Create (_caeb );if _ecea !=nil {return _ecea ;};if _edeb :=_b .Encode (_cedb ,_ggaf .Thumbnail ,nil );_edeb !=nil {return _edeb ;};};for _cbbe ,_fee :=range _ggaf ._fbdg {_fgdcg :=_f .AbsoluteFilename (_cfed ,_f .ChartType ,_cbbe +1);_e .MarshalXML (_fgedc ,_fgdcg ,_fee );};for _aede ,_cdgg :=range _ggaf ._cafc {_cffg :=_f .AbsoluteFilename (_cfed ,_f .TableType ,_aede +1);_e .MarshalXML (_fgedc ,_cffg ,_cdgg );};for _gebg ,_befa :=range _ggaf ._aeeg {_egegf :=_f .AbsoluteFilename (_cfed ,_f .DrawingType ,_gebg +1);_e .MarshalXML (_fgedc ,_egegf ,_befa );if !_ggaf ._gefc [_gebg ].IsEmpty (){_e .MarshalXML (_fgedc ,_e .RelationsPathFor (_egegf ),_ggaf ._gefc [_gebg ].X ());};};for _eabba ,_egfa :=range _ggaf ._bdaaa {_e .MarshalXML (_fgedc ,_f .AbsoluteFilename (_cfed ,_f .VMLDrawingType ,_eabba +1),_egfa );};for _dgbe ,_deea :=range _ggaf .Images {if _feef :=_ad .AddImageToZip (_fgedc ,_deea ,_dgbe +1,_f .DocTypeSpreadsheet );_feef !=nil {return _feef ;};};if _efgd :=_e .MarshalXML (_fgedc ,_f .ContentTypesFilename ,_ggaf .ContentTypes .X ());_efgd !=nil {return _efgd ;};for _ffdd ,_fffeb :=range _ggaf ._eedb {if _fffeb ==nil {continue ;};_e .MarshalXML (_fgedc ,_f .AbsoluteFilename (_cfed ,_f .CommentsType ,_ffdd +1),_fffeb );};if _ddfe :=_ggaf .WriteExtraFiles (_fgedc );_ddfe !=nil {return _ddfe ;};return _fgedc .Close ();};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_ee ,_cf int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_fbf _ff .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_aae int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_dcf _ff .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_dg int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_ba _ff .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_gdg _ff .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_bag ConditionalFormattingRule )clear (){_bag ._ggeg .OperatorAttr =_bdd .ST_ConditionalFormattingOperatorUnset ;_bag ._ggeg .ColorScale =nil ;_bag ._ggeg .IconSet =nil ;_bag ._ggeg .Formula =nil ;};var _dadce =[...]uint8 {0,18,37};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_dbdf Cell )SetStyleIndex (idx uint32 ){_dbdf ._egf .SAttr =_f .Uint32 (idx )};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_dcag Row )AddNamedCell (col string )Cell {_fgad :=_bdd .NewCT_Cell ();_fgad .RAttr =_f .Stringf ("\u0025\u0073\u0025\u0064",col ,_dcag .RowNumber ());_fdfc :=-1;_bcbb :=_eg .ColumnToIndex (col );for _cgcf ,_gedda :=range _dcag ._ceea .C {_egab ,_gdba :=_eg .ParseCellReference (*_gedda .RAttr );if _gdba !=nil {return Cell {};};if _bcbb < _egab .ColumnIdx {_fdfc =_cgcf ;break ;};};if _fdfc ==-1{_dcag ._ceea .C =append (_dcag ._ceea .C ,_fgad );}else {_dcag ._ceea .C =append (_dcag ._ceea .C [:_fdfc ],append ([]*_bdd .CT_Cell {_fgad },_dcag ._ceea .C [_fdfc :]...)...);};return Cell {_dcag ._dcga ,_dcag ._beea ,_dcag ._ceea ,_fgad };};var _cdcd =false ;

// GetFilename returns the filename of the context's workbook.
func (_dgb *evalContext )GetFilename ()string {return _dgb ._agbd ._debfd .GetFilename ()};var (_fcde =[...]uint8 {0,21,46,61,76,91};_agcec =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_egff =[...]uint8 {0,16,32,48,64};_gbgc =[...]uint8 {0,16,32,48,64,80};);

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_bade Row )Cells ()[]Cell {_ebef :=[]Cell {};_afgf :=-1;_bbcf :=append ([]*_bdd .CT_Cell {},_bade ._ceea .C ...);for _ ,_abbf :=range _bbcf {if _abbf .RAttr ==nil {_aa .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_bfa ,_dgfd :=_eg .ParseCellReference (*_abbf .RAttr );if _dgfd !=nil {_aa .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_abbf .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_cdfcd :=int (_bfa .ColumnIdx );if _cdfcd -_afgf > 1{for _cbb :=_afgf +1;_cbb < _cdfcd ;_cbb ++{_ebef =append (_ebef ,_bade .Cell (_eg .IndexToColumn (uint32 (_cbb ))));};};_afgf =_cdfcd ;_ebef =append (_ebef ,Cell {_bade ._dcga ,_bade ._beea ,_bade ._ceea ,_abbf });};return _ebef ;};

// GetFormula returns the formula for a cell.
func (_ccaf Cell )GetFormula ()string {if _ccaf ._egf .F !=nil {return _ccaf ._egf .F .Content ;};return "";};

// SetText sets the text to be displayed.
func (_eeb RichTextRun )SetText (s string ){_eeb ._fabe .T =s };

// SetHidden hides or unhides the row
func (_dfgb Row )SetHidden (hidden bool ){if !hidden {_dfgb ._ceea .HiddenAttr =nil ;}else {_dfgb ._ceea .HiddenAttr =_f .Bool (true );};};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_bacf Cell )SetDate (d _ca .Time ){_bacf .clearValue ();d =_geeg (d );_dbg :=_bacf ._dac .Epoch ();if d .Before (_dbg ){_aa .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_bec :=d .Sub (_dbg );_dfeb :=new (_g .Float );_fgf :=new (_g .Float );_fgf .SetPrec (128);_fgf .SetUint64 (uint64 (_bec ));_fae :=new (_g .Float );_fae .SetUint64 (24*60*60*1e9);_dfeb .Quo (_fgf ,_fae );_dgc ,_ :=_dfeb .Uint64 ();_bacf ._egf .V =_f .Stringf ("\u0025\u0064",_dgc );};

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_gdb Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_fbc :=_agb .ParseString (formulaStr );if _fbc ==nil {return _fa .New (_fb .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));};_gdb .clearValue ();_gdb ._egf .TAttr =_bdd .ST_CellTypeStr ;_gdb ._egf .F =_bdd .NewCT_CellFormula ();_gdb ._egf .F .TAttr =_bdd .ST_CellFormulaTypeShared ;_gdb ._egf .F .Content =formulaStr ;_gc ,_gee :=_eg .ParseCellReference (_gdb .Reference ());if _gee !=nil {return _gee ;};_bgf :=uint32 (0);for _ ,_ae :=range _gdb ._ea .Rows (){for _ ,_baa :=range _ae ._ceea .C {if _baa .F !=nil &&_baa .F .SiAttr !=nil &&*_baa .F .SiAttr >=_bgf {_bgf =*_baa .F .SiAttr ;};};};_bgf ++;_cca :=_fb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_gc .Column ,_gc .RowIdx ,_eg .IndexToColumn (_gc .ColumnIdx +cols ),_gc .RowIdx +rows );_gdb ._egf .F .RefAttr =_f .String (_cca );_gdb ._egf .F .SiAttr =_f .Uint32 (_bgf );_eed :=Sheet {_gdb ._dac ,_gdb ._ea ._abg ,_gdb ._ea ._bcbe };for _dbc :=_gc .RowIdx ;_dbc <=_gc .RowIdx +rows ;_dbc ++{for _gg :=_gc .ColumnIdx ;_gg <=_gc .ColumnIdx +cols ;_gg ++{if _dbc ==_gc .RowIdx &&_gg ==_gc .ColumnIdx {continue ;};_cgf :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_gg ),_dbc );_eed .Cell (_cgf ).Clear ();_eed .Cell (_cgf ).X ().F =_bdd .NewCT_CellFormula ();_eed .Cell (_cgf ).X ().F .TAttr =_bdd .ST_CellFormulaTypeShared ;_eed .Cell (_cgf ).X ().F .SiAttr =_f .Uint32 (_bgf );};};return nil ;};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_ddf Sheet )ValidateWithPath (path string )error {return _ddf ._bcbe .ValidateWithPath (path )};

// StyleSheet is a document style sheet.
type StyleSheet struct{_cfef *Workbook ;_aecc *_bdd .StyleSheet ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_gebf *Workbook )SetActiveSheetIndex (idx uint32 ){if _gebf ._cecaf .BookViews ==nil {_gebf ._cecaf .BookViews =_bdd .NewCT_BookViews ();};if len (_gebf ._cecaf .BookViews .WorkbookView )==0{_gebf ._cecaf .BookViews .WorkbookView =append (_gebf ._cecaf .BookViews .WorkbookView ,_bdd .NewCT_BookView ());};_gebf ._cecaf .BookViews .WorkbookView [0].ActiveTabAttr =_f .Uint32 (idx );};

// ClearProtection clears all workbook protections.
func (_eegb *Workbook )ClearProtection (){_eegb ._cecaf .WorkbookProtection =nil };

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_ccbed *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_cgbfg :=-1;for _dgaa ,_bggbc :=range _ccbed .Sheets (){if name ==_bggbc .Name (){_cgbfg =_dgaa ;break ;};};if _cgbfg ==-1{return Sheet {},ErrorNotFound ;};return _ccbed .CopySheet (_cgbfg ,copiedSheetName );};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_gaag CellStyle )SetProtection (protected bool ,hidden bool ){_gaag ._bgb .Protection =&_bdd .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// SetRow set the row of the cell marker.
func (_gff CellMarker )SetRow (row int32 ){_gff ._acg .Row =row };

// Workbook returns sheet's parent workbook.
func (_egdfe *Sheet )Workbook ()*Workbook {return _egdfe ._debfd };func _fbca (_bggb bool )int {if _bggb {return 1;};return 0;};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_gdfc Drawing )AddImage (img _ad .ImageRef ,at AnchorType )Anchor {_gbed :=0;for _bfb ,_cddc :=range _gdfc ._dfd .Images {if _cddc ==img {_gbed =_bfb +1;break ;};};var _faa string ;for _ddgc ,_eda :=range _gdfc ._dfd ._aeeg {if _eda ==_gdfc ._eag {_cfac :=_fb .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_gbed ,img .Format ());_bfee :=_gdfc ._dfd ._gefc [_ddgc ].AddRelationship (_cfac ,_f .ImageType );_faa =_bfee .ID ();break ;};};var _ggf Anchor ;var _fecd *_bgd .CT_Picture ;switch at {case AnchorTypeAbsolute :_fgcd :=_cgg ();_gdfc ._eag .EG_Anchor =append (_gdfc ._eag .EG_Anchor ,&_bgd .EG_Anchor {AbsoluteAnchor :_fgcd });_fgcd .Choice =&_bgd .EG_ObjectChoicesChoice {};_fgcd .Choice .Pic =_bgd .NewCT_Picture ();_fgcd .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_fgcd .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_fecd =_fgcd .Choice .Pic ;_ggf =AbsoluteAnchor {_fgcd };case AnchorTypeOneCell :_caa :=_babe ();_gdfc ._eag .EG_Anchor =append (_gdfc ._eag .EG_Anchor ,&_bgd .EG_Anchor {OneCellAnchor :_caa });_caa .Choice =&_bgd .EG_ObjectChoicesChoice {};_caa .Choice .Pic =_bgd .NewCT_Picture ();_fecd =_caa .Choice .Pic ;_ggf =OneCellAnchor {_caa };case AnchorTypeTwoCell :_eaga :=_fgcde ();_gdfc ._eag .EG_Anchor =append (_gdfc ._eag .EG_Anchor ,&_bgd .EG_Anchor {TwoCellAnchor :_eaga });_eaga .Choice =&_bgd .EG_ObjectChoicesChoice {};_eaga .Choice .Pic =_bgd .NewCT_Picture ();_fecd =_eaga .Choice .Pic ;_ggf =TwoCellAnchor {_eaga };};_fecd .NvPicPr .CNvPr .IdAttr =uint32 (len (_gdfc ._eag .EG_Anchor ));_fecd .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_fecd .BlipFill .Blip =_adg .NewCT_Blip ();_fecd .BlipFill .Blip .EmbedAttr =_f .String (_faa );_fecd .BlipFill .Stretch =_adg .NewCT_StretchInfoProperties ();_fecd .SpPr =_adg .NewCT_ShapeProperties ();_fecd .SpPr .Xfrm =_adg .NewCT_Transform2D ();_fecd .SpPr .Xfrm .Off =_adg .NewCT_Point2D ();_fecd .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_fecd .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_fecd .SpPr .Xfrm .Ext =_adg .NewCT_PositiveSize2D ();_fecd .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ff .Pixel72 )/_ff .EMU );_fecd .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ff .Pixel72 )/_ff .EMU );_fecd .SpPr .PrstGeom =_adg .NewCT_PresetGeometry2D ();_fecd .SpPr .PrstGeom .PrstAttr =_adg .ST_ShapeTypeRect ;_fecd .SpPr .Ln =_adg .NewCT_LineProperties ();_fecd .SpPr .Ln .NoFill =_adg .NewCT_NoFillProperties ();return _ggf ;};

// X returns the inner wrapped XML type.
func (_fced ConditionalFormatting )X ()*_bdd .CT_ConditionalFormatting {return _fced ._baadb };func (_aedb DifferentialStyle )Fill ()Fill {if _aedb ._ebc .Fill ==nil {_aedb ._ebc .Fill =_bdd .NewCT_Fill ();};return Fill {_aedb ._ebc .Fill ,nil };};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_aebg *Workbook )SetActiveSheet (s Sheet ){for _eaaa ,_ceda :=range _aebg ._acggg {if s ._bcbe ==_ceda {_aebg .SetActiveSheetIndex (uint32 (_eaaa ));};};};type PatternFill struct{_gegad *_bdd .CT_PatternFill ;_fege *_bdd .CT_Fill ;};

// SetWidth sets the width of the anchored object.
func (_fg AbsoluteAnchor )SetWidth (w _ff .Distance ){_fg ._bb .Ext .CxAttr =int64 (w /_ff .EMU )};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_bebf *_bdd .CT_DataValidation };

// SetItalic causes the text to be displayed in italic.
func (_bfc RichTextRun )SetItalic (b bool ){_bfc .ensureRpr ();_bfc ._fabe .RPr .I =_bdd .NewCT_BooleanProperty ();_bfc ._fabe .RPr .I .ValAttr =_f .Bool (b );};

// AnchorType is the type of anchor.
type AnchorType byte ;

// IsDBCS returns if a workbook's default language is among DBCS.
func (_fad *evalContext )IsDBCS ()bool {_gddc :=_fad ._agbd ._debfd .CoreProperties .X ().Language ;if _gddc ==nil {return false ;};_bbb :=string (_gddc .Data );for _ ,_dga :=range _daaa {if _bbb ==_dga {return true ;};};return false ;};

// GetFormat sets the number format code.
func (_fbe NumberFormat )GetFormat ()string {return _fbe ._edf .FormatCodeAttr };

// AddString adds a string to the shared string cache.
func (_abfa SharedStrings )AddString (v string )int {if _fbbe ,_gbegf :=_abfa ._gbeg [v ];_gbegf {return _fbbe ;};_ffaf :=_bdd .NewCT_Rst ();_ffaf .T =_f .String (v );_abfa ._gdgf .Si =append (_abfa ._gdgf .Si ,_ffaf );_ceba :=len (_abfa ._gdgf .Si )-1;_abfa ._gbeg [v ]=_ceba ;_abfa ._gdgf .CountAttr =_f .Uint32 (uint32 (len (_abfa ._gdgf .Si )));_abfa ._gdgf .UniqueCountAttr =_abfa ._gdgf .CountAttr ;return _ceba ;};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_gea *_bdd .CT_ColorScale };

// Comments returns the list of comments for this sheet
func (_aed Comments )Comments ()[]Comment {_fegg :=[]Comment {};for _ ,_def :=range _aed ._gae .CommentList .Comment {_fegg =append (_fegg ,Comment {_aed ._geca ,_def ,_aed ._gae });};return _fegg ;};

// X returns the inner wrapped XML type.
func (_egea DifferentialStyle )X ()*_bdd .CT_Dxf {return _egea ._ebc };

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_agf AbsoluteAnchor )SetColOffset (m _ff .Distance ){_agf ._bb .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ff .EMU ));};

// TopLeft is a no-op.
func (_fd AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// Themes returns the array of workbook dml.Theme.
func (_addcb *Workbook )Themes ()[]*_adg .Theme {return _addcb ._ffdc };

// X returns the inner wrapped XML type.
func (_dcdf DefinedName )X ()*_bdd .CT_DefinedName {return _dcdf ._afg };func _dcca (_eca string ,_fcbc uint32 ,_ffec bool )string {_bfbe ,_gegab ,_daab :=_eg .ParseRangeReference (_eca );if _daab ==nil {_cebc ,_gabc :=_bfbe .ColumnIdx ,_gegab .ColumnIdx ;if _fcbc >=_cebc &&_fcbc <=_gabc {if _cebc ==_gabc {if _ffec {return "";}else {return _eca ;};}else {_gbfc :=_gegab .Update (_de .UpdateActionRemoveColumn );return _fb .Sprintf ("\u0025\u0073\u003a%\u0073",_bfbe .String (),_gbfc .String ());};}else if _fcbc < _cebc {_fgeb :=_bfbe .Update (_de .UpdateActionRemoveColumn );_gagd :=_gegab .Update (_de .UpdateActionRemoveColumn );return _fb .Sprintf ("\u0025\u0073\u003a%\u0073",_fgeb .String (),_gagd .String ());};}else {_ddee ,_ffcac ,_bcga :=_eg .ParseColumnRangeReference (_eca );if _bcga !=nil {return "";};_facb ,_agbfb :=_ddee .ColumnIdx ,_ffcac .ColumnIdx ;if _fcbc >=_facb &&_fcbc <=_agbfb {if _facb ==_agbfb {if _ffec {return "";}else {return _eca ;};}else {_gdec :=_ffcac .Update (_de .UpdateActionRemoveColumn );return _fb .Sprintf ("\u0025\u0073\u003a%\u0073",_ddee .String (),_gdec .String ());};}else if _fcbc < _facb {_faaf :=_ddee .Update (_de .UpdateActionRemoveColumn );_dffb :=_ffcac .Update (_de .UpdateActionRemoveColumn );return _fb .Sprintf ("\u0025\u0073\u003a%\u0073",_faaf .String (),_dffb .String ());};};return "";};

// SetRowOffset sets the row offset of the two cell anchor
func (_fgdc TwoCellAnchor )SetRowOffset (m _ff .Distance ){_fbddf :=m -_fgdc .TopLeft ().RowOffset ();_fgdc .TopLeft ().SetRowOffset (m );_fgdc .BottomRight ().SetRowOffset (_fgdc .BottomRight ().RowOffset ()+_fbddf );};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_gdgf :_bdd .NewSst (),_gbeg :make (map[string ]int )};};

// SetDateWithStyle sets a date with the default date style applied.
func (_acf Cell )SetDateWithStyle (d _ca .Time ){_acf .SetDate (d );for _ ,_gdgb :=range _acf ._dac .StyleSheet .CellStyles (){if _gdgb .HasNumberFormat ()&&_gdgb .NumberFormat ()==uint32 (StandardFormatDate ){_acf .SetStyle (_gdgb );return ;};};_ebg :=_acf ._dac .StyleSheet .AddCellStyle ();_ebg .SetNumberFormatStandard (StandardFormatDate );_acf .SetStyle (_ebg );};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_dgfdda *Workbook )AddImage (i _ad .Image )(_ad .ImageRef ,error ){_egde :=_ad .MakeImageRef (i ,&_dgfdda .DocBase ,_dgfdda ._ggd );if i .Data ==nil &&i .Path ==""{return _egde ,_fa .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _egde ,_fa .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _egde ,_fa .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_fgba :=_gd .Add (i .Path );if _fgba !=nil {return _egde ,_fgba ;};};_dgfdda .Images =append (_dgfdda .Images ,_egde );return _egde ,nil ;};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_bdce Drawing )AddChart (at AnchorType )(_fcg .Chart ,Anchor ){_aeea :=_df .NewChartSpace ();_bdce ._dfd ._fbdg =append (_bdce ._dfd ._fbdg ,_aeea );_acdg :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .ChartContentType ,len (_bdce ._dfd ._fbdg ));_bdce ._dfd .ContentTypes .AddOverride (_acdg ,_f .ChartContentType );var _ccbe string ;for _ceg ,_fcd :=range _bdce ._dfd ._aeeg {if _fcd ==_bdce ._eag {_bfde :=_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,_f .ChartType ,len (_bdce ._dfd ._fbdg ));_dbgb :=_bdce ._dfd ._gefc [_ceg ].AddRelationship (_bfde ,_f .ChartType );_ccbe =_dbgb .ID ();break ;};};var _affa Anchor ;var _cfeg *_bgd .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_gcb :=_cgg ();_bdce ._eag .EG_Anchor =append (_bdce ._eag .EG_Anchor ,&_bgd .EG_Anchor {AbsoluteAnchor :_gcb });_gcb .Choice =&_bgd .EG_ObjectChoicesChoice {};_gcb .Choice .GraphicFrame =_bgd .NewCT_GraphicalObjectFrame ();_cfeg =_gcb .Choice .GraphicFrame ;_affa =AbsoluteAnchor {_gcb };case AnchorTypeOneCell :_gdcf :=_babe ();_bdce ._eag .EG_Anchor =append (_bdce ._eag .EG_Anchor ,&_bgd .EG_Anchor {OneCellAnchor :_gdcf });_gdcf .Choice =&_bgd .EG_ObjectChoicesChoice {};_gdcf .Choice .GraphicFrame =_bgd .NewCT_GraphicalObjectFrame ();_cfeg =_gdcf .Choice .GraphicFrame ;_affa =OneCellAnchor {_gdcf };case AnchorTypeTwoCell :_cgfe :=_fgcde ();_bdce ._eag .EG_Anchor =append (_bdce ._eag .EG_Anchor ,&_bgd .EG_Anchor {TwoCellAnchor :_cgfe });_cgfe .Choice =&_bgd .EG_ObjectChoicesChoice {};_cgfe .Choice .GraphicFrame =_bgd .NewCT_GraphicalObjectFrame ();_cfeg =_cgfe .Choice .GraphicFrame ;_affa =TwoCellAnchor {_cgfe };};_cfeg .NvGraphicFramePr =_bgd .NewCT_GraphicalObjectFrameNonVisual ();_cfeg .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_bdce ._eag .EG_Anchor ));_cfeg .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_cfeg .Graphic =_adg .NewGraphic ();_cfeg .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_fgbc :=_df .NewChart ();_fgbc .IdAttr =_ccbe ;_cfeg .Graphic .GraphicData .Any =[]_f .Any {_fgbc };_cbfb :=_fcg .MakeChart (_aeea );_cbfb .Properties ().SetSolidFill (_dc .White );_cbfb .SetDisplayBlanksAs (_df .ST_DispBlanksAsGap );return _cbfb ,_affa ;};func (_ggaa PatternFill )ClearFgColor (){_ggaa ._gegad .FgColor =nil };

// SetHeightCells is a no-op.
func (_fedf OneCellAnchor )SetHeightCells (int32 ){};

// ClearProtection removes any protections applied to teh sheet.
func (_aeabg *Sheet )ClearProtection (){_aeabg ._bcbe .SheetProtection =nil };var _egec =_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0);

// IsSheetLocked returns whether the sheet is locked.
func (_cdbab SheetProtection )IsSheetLocked ()bool {return _cdbab ._edbb .SheetAttr !=nil &&*_cdbab ._edbb .SheetAttr ;};func (_gaef *Sheet )removeColumnFromMergedCells (_gbb uint32 )error {if _gaef ._bcbe .MergeCells ==nil ||_gaef ._bcbe .MergeCells .MergeCell ==nil {return nil ;};_efbba :=[]*_bdd .CT_MergeCell {};for _ ,_addg :=range _gaef .MergedCells (){_acga :=_dcca (_addg .Reference (),_gbb ,true );if _acga !=""{_addg .SetReference (_acga );_efbba =append (_efbba ,_addg .X ());};};_gaef ._bcbe .MergeCells .MergeCell =_efbba ;return nil ;};func (_fgec PatternFill )ClearBgColor (){_fgec ._gegad .BgColor =nil };

// Protection allows control over the workbook protections.
func (_afefc *Workbook )Protection ()WorkbookProtection {if _afefc ._cecaf .WorkbookProtection ==nil {_afefc ._cecaf .WorkbookProtection =_bdd .NewCT_WorkbookProtection ();};return WorkbookProtection {_afefc ._cecaf .WorkbookProtection };};

// SetNumber sets the cell type to number, and the value to the given number
func (_eab Cell )SetNumber (v float64 ){_eab .clearValue ();if _bg .IsNaN (v )||_bg .IsInf (v ,0){_eab ._egf .TAttr =_bdd .ST_CellTypeE ;_eab ._egf .V =_f .String ("\u0023\u004e\u0055M\u0021");return ;};_eab ._egf .TAttr =_bdd .ST_CellTypeN ;_eab ._egf .V =_f .String (_be .FormatFloat (v ,'f',-1,64));};

// SetRowOffset sets the row offset of the top-left anchor.
func (_bcfdg OneCellAnchor )SetRowOffset (m _ff .Distance ){_bcfdg .TopLeft ().SetRowOffset (m )};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_agbc SheetView )SetZoom (pct uint32 ){_agbc ._adedb .ZoomScaleAttr =&pct };

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_ebe *_bdd .CT_Col };

// SetLocked sets cell locked or not.
func (_bdg *evalContext )SetLocked (cellRef string ,locked bool ){_bdg ._agbd .Cell (cellRef ).setLocked (locked );};

// RowOffset returns the offset from the row cell.
func (_eaad CellMarker )RowOffset ()_ff .Distance {if _eaad ._acg .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ff .Distance (float64 (*_eaad ._acg .RowOff .ST_CoordinateUnqualified )*_ff .EMU );};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_gfca Row )Cell (col string )Cell {_fdbb :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",col ,_gfca .RowNumber ());for _ ,_beff :=range _gfca ._ceea .C {if _beff .RAttr !=nil &&*_beff .RAttr ==_fdbb {return Cell {_gfca ._dcga ,_gfca ._beea ,_gfca ._ceea ,_beff };};};return _gfca .AddNamedCell (col );};

// X returns the inner wrapped XML type.
func (_bdbc Table )X ()*_bdd .Table {return _bdbc ._bebg };func (_fdfdc SheetView )ensurePane (){if _fdfdc ._adedb .Pane ==nil {_fdfdc ._adedb .Pane =_bdd .NewCT_Pane ();_fdfdc ._adedb .Pane .ActivePaneAttr =_bdd .ST_PaneBottomLeft ;};};func (_gefa *Sheet )addNumberedRowFast (_bcd uint32 )Row {_efab :=_bdd .NewCT_Row ();_efab .RAttr =_f .Uint32 (_bcd );_gefa ._bcbe .SheetData .Row =append (_gefa ._bcbe .SheetData .Row ,_efab );return Row {_gefa ._debfd ,_gefa ,_efab };};

// IsSheetLocked returns whether the sheet objects are locked.
func (_dacg SheetProtection )IsObjectLocked ()bool {return _dacg ._edbb .ObjectsAttr !=nil &&*_dacg ._edbb .ObjectsAttr ;};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_fgea *Workbook )RemoveSheet (ind int )error {if _fgea .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_fbcc :=range _fgea ._ggd .Relationships (){if _fbcc .ID ()==_fgea ._cecaf .Sheets .Sheet [ind ].IdAttr {_fgea ._ggd .Remove (_fbcc );break ;};};_fgea .ContentTypes .RemoveOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1));copy (_fgea ._acggg [ind :],_fgea ._acggg [ind +1:]);_fgea ._acggg =_fgea ._acggg [:len (_fgea ._acggg )-1];_fdfag :=_fgea ._cecaf .Sheets .Sheet [ind ];copy (_fgea ._cecaf .Sheets .Sheet [ind :],_fgea ._cecaf .Sheets .Sheet [ind +1:]);_fgea ._cecaf .Sheets .Sheet =_fgea ._cecaf .Sheets .Sheet [:len (_fgea ._cecaf .Sheets .Sheet )-1];for _gagbf :=range _fgea ._cecaf .Sheets .Sheet {if _fgea ._cecaf .Sheets .Sheet [_gagbf ].SheetIdAttr > _fdfag .SheetIdAttr {_fgea ._cecaf .Sheets .Sheet [_gagbf ].SheetIdAttr --;};};copy (_fgea ._bafe [ind :],_fgea ._bafe [ind +1:]);_fgea ._bafe =_fgea ._bafe [:len (_fgea ._bafe )-1];copy (_fgea ._eedb [ind :],_fgea ._eedb [ind +1:]);_fgea ._eedb =_fgea ._eedb [:len (_fgea ._eedb )-1];return nil ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_gacab StyleSheet )AddNumberFormat ()NumberFormat {if _gacab ._aecc .NumFmts ==nil {_gacab ._aecc .NumFmts =_bdd .NewCT_NumFmts ();};_bebd :=_bdd .NewCT_NumFmt ();_bebd .NumFmtIdAttr =uint32 (200+len (_gacab ._aecc .NumFmts .NumFmt ));_gacab ._aecc .NumFmts .NumFmt =append (_gacab ._aecc .NumFmts .NumFmt ,_bebd );_gacab ._aecc .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_gacab ._aecc .NumFmts .NumFmt )));return NumberFormat {_gacab ._cfef ,_bebd };};

// SetWidth controls the width of a column.
func (_aeb Column )SetWidth (w _ff .Distance ){_aeb ._ebe .WidthAttr =_f .Float64 (float64 (w /_ff .Character ));};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_ffe Cell )SetString (s string )int {_ffe ._dac .ensureSharedStringsRelationships ();_ffe .clearValue ();_deb :=_ffe ._dac .SharedStrings .AddString (s );_ffe ._egf .V =_f .String (_be .Itoa (_deb ));_ffe ._egf .TAttr =_bdd .ST_CellTypeS ;return _deb ;};func (_eagb StandardFormat )String ()string {switch {case 0<=_eagb &&_eagb <=4:return _ccage [_fcde [_eagb ]:_fcde [_eagb +1]];case 9<=_eagb &&_eagb <=22:_eagb -=9;return _cega [_agcec [_eagb ]:_agcec [_eagb +1]];case 37<=_eagb &&_eagb <=40:_eagb -=37;return _adga [_egff [_eagb ]:_egff [_eagb +1]];case 45<=_eagb &&_eagb <=49:_eagb -=45;return _cfbd [_gbgc [_eagb ]:_gbgc [_eagb +1]];default:return _fb .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_eagb );};};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_ccbec *Sheet )ClearSheetViews (){_ccbec ._bcbe .SheetViews =nil };

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_gafde PatternFill )SetFgColor (c _dc .Color ){_gafde ._gegad .FgColor =_bdd .NewCT_Color ();_gafde ._gegad .FgColor .RgbAttr =c .AsRGBAString ();};func (_adca *evalContext )NamedRange (ref string )_agb .Reference {for _ ,_efae :=range _adca ._agbd ._debfd .DefinedNames (){if _efae .Name ()==ref {return _agb .MakeRangeReference (_efae .Content ());};};for _ ,_agce :=range _adca ._agbd ._debfd .Tables (){if _agce .Name ()==ref {return _agb .MakeRangeReference (_fb .Sprintf ("\u0025\u0073\u0021%\u0073",_adca ._agbd .Name (),_agce .Reference ()));};};return _agb .ReferenceInvalid ;};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_acfb *Sheet )AddNumberedRow (rowNum uint32 )Row {_egef :=_bdd .NewCT_Row ();_egef .RAttr =_f .Uint32 (rowNum );_acfb ._bcbe .SheetData .Row =append (_acfb ._bcbe .SheetData .Row ,_egef );_fc .Slice (_acfb ._bcbe .SheetData .Row ,func (_ccgc ,_eaaee int )bool {_bfec :=_acfb ._bcbe .SheetData .Row [_ccgc ].RAttr ;_babf :=_acfb ._bcbe .SheetData .Row [_eaaee ].RAttr ;if _bfec ==nil {return true ;};if _babf ==nil {return true ;};return *_bfec < *_babf ;});return Row {_acfb ._debfd ,_acfb ,_egef };};

// Reference returns the region of cells that are merged.
func (_ceeg MergedCell )Reference ()string {return _ceeg ._ead .RefAttr };

// SetPriority sets the rule priority
func (_fdc ConditionalFormattingRule )SetPriority (p int32 ){_fdc ._ggeg .PriorityAttr =p };

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_fega *Workbook )Epoch ()_ca .Time {if _fega .Uses1904Dates (){_ca .Date (1904,1,1,0,0,0,0,_ca .UTC );};return _ca .Date (1899,12,30,0,0,0,0,_ca .UTC );};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_gagg *_bgd .CT_TwoCellAnchor };func (_cfde *Sheet )setShared (_efgc string ,_bcef ,_ccag _eg .CellReference ,_fbddc string ){_bffb :=_cfde .FormulaContext ();_agfa :=_agb .NewEvaluator ();for _febb :=_bcef .RowIdx ;_febb <=_ccag .RowIdx ;_febb ++{for _bceg :=_bcef .ColumnIdx ;_bceg <=_ccag .ColumnIdx ;_bceg ++{_fbef :=_febb -_bcef .RowIdx ;_fdbbe :=_bceg -_bcef .ColumnIdx ;_bffb .SetOffset (_fdbbe ,_fbef );_ffca :=_agfa .Eval (_bffb ,_fbddc );_fgaf :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_bceg ),_febb );_dbce :=_cfde .Cell (_fgaf );if _ffca .Type ==_agb .ResultTypeNumber {_dbce .X ().TAttr =_bdd .ST_CellTypeN ;}else {_dbce .X ().TAttr =_bdd .ST_CellTypeInlineStr ;};_dbce .X ().V =_f .String (_ffca .Value ());};};_ =_agfa ;_ =_bffb ;};

// Borders returns the list of borders defined in the stylesheet.
func (_gaca StyleSheet )Borders ()[]Border {_dadcd :=[]Border {};for _ ,_bebc :=range _gaca ._aecc .Borders .Border {_dadcd =append (_dadcd ,Border {_adc :_bebc });};return _dadcd ;};

// IsWindowLocked returns whether the workbook windows are locked.
func (_fefa WorkbookProtection )IsWindowLocked ()bool {return _fefa ._fdfae .LockWindowsAttr !=nil &&*_fefa ._fdfae .LockWindowsAttr ;};func (_dadc PatternFill )SetBgColor (c _dc .Color ){_dadc ._gegad .BgColor =_bdd .NewCT_Color ();_dadc ._gegad .BgColor .RgbAttr =c .AsRGBAString ();};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_gdgcf *Sheet )SetDrawing (d Drawing ){var _cab _ad .Relationships ;for _eada ,_fbfeg :=range _gdgcf ._debfd ._acggg {if _fbfeg ==_gdgcf ._bcbe {_cab =_gdgcf ._debfd ._bafe [_eada ];break ;};};var _cace string ;for _cad ,_dcde :=range d ._dfd ._aeeg {if _dcde ==d ._eag {_dabb :=_cab .AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_cad +1,_f .DrawingType );_cace =_dabb .ID ();break ;};};_gdgcf ._bcbe .Drawing =_bdd .NewCT_Drawing ();_gdgcf ._bcbe .Drawing .IdAttr =_cace ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_gaeb Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_aba :=_gaeb .AddComment (cellRef ,author );_ccgd :=_aba .AddRun ();_ccgd .SetBold (true );_ccgd .SetSize (10);_ccgd .SetColor (_dc .Black );_ccgd .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ccgd .SetText (author +"\u003a");_ccgd =_aba .AddRun ();_ccgd .SetSize (10);_ccgd .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_ccgd .SetColor (_dc .Black );_ccgd .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_ceb ,_geaa :=_eg .ParseCellReference (cellRef );if _geaa !=nil {return _geaa ;};_gaeb ._geca ._bdaaa [0].Shape =append (_gaeb ._geca ._bdaaa [0].Shape ,_db .NewCommentShape (int64 (_ceb .ColumnIdx ),int64 (_ceb .RowIdx -1)));return nil ;};

// SetHeight sets the height of the anchored object.
func (_eaaf OneCellAnchor )SetHeight (h _ff .Distance ){_eaaf ._feb .Ext .CyAttr =int64 (h /_ff .EMU )};

// SetUnderline controls if the run is underlined.
func (_abe RichTextRun )SetUnderline (u _bdd .ST_UnderlineValues ){_abe .ensureRpr ();_abe ._fabe .RPr .U =_bdd .NewCT_UnderlineProperty ();_abe ._fabe .RPr .U .ValAttr =u ;};func (_efcc *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _efcc .getAllCellsInFormulaArrays (false );};

// CellMarker represents a cell position
type CellMarker struct{_acg *_bgd .CT_Marker };

// Name returns the sheet name
func (_ccee Sheet )Name ()string {return _ccee ._abg .NameAttr };

// TopLeft returns the top-left corner of the anchored object.
func (_ebd OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_ebd ._feb .From }};

// Type returns the type of anchor
func (_feda TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };

// GetBorder gets a Border from a cell style.
func (_gac CellStyle )GetBorder ()*_bdd .CT_Border {if _efbd :=_gac ._bgb .BorderIdAttr ;_efbd !=nil {_fec :=_gac ._eaadf .StyleSheet .Borders ();if int (*_efbd )< len (_fec ){return _fec [int (*_efbd )].X ();};};return nil ;};

// SetHidden marks the defined name as hidden.
func (_ggbb DefinedName )SetHidden (b bool ){_ggbb ._afg .HiddenAttr =_f .Bool (b )};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_eae IconScale )AddFormatValue (t _bdd .ST_CfvoType ,val string ){_abab :=_bdd .NewCT_Cfvo ();_abab .TypeAttr =t ;_abab .ValAttr =_f .String (val );_eae ._eaba .Cfvo =append (_eae ._eaba .Cfvo ,_abab );};

// ExtractText returns text from the sheet as a SheetText object.
func (_cac *Sheet )ExtractText ()*SheetText {_faaa :=[]CellText {};for _ ,_ebb :=range _cac .Rows (){for _ ,_ecfa :=range _ebb .Cells (){if !_ecfa .IsEmpty (){if _gcf :=_ecfa .GetFormattedValue ();_gcf !=""{_faaa =append (_faaa ,CellText {Text :_gcf ,Cell :_ecfa });};};};};return &SheetText {Cells :_faaa };};func (_feg Cell )getRawSortValue ()(string ,bool ){if _feg .HasFormula (){_efga :=_feg .GetCachedFormulaResult ();return _efga ,_bd .IsNumber (_efga );};_bae ,_ :=_feg .GetRawValue ();return _bae ,_bd .IsNumber (_bae );};

// X returns the inner wrapped XML type.
func (_gdgad RichTextRun )X ()*_bdd .CT_RElt {return _gdgad ._fabe };type SheetProtection struct{_edbb *_bdd .CT_SheetProtection };

// X returns the inner wrapped XML type.
func (_bcgc IconScale )X ()*_bdd .CT_IconSet {return _bcgc ._eaba };

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_ecf Cell )SetCachedFormulaResult (s string ){_ecf ._egf .V =&s };

// SetHeight sets the height of the anchored object.
func (_dfg AbsoluteAnchor )SetHeight (h _ff .Distance ){_dfg ._bb .Ext .CyAttr =int64 (h /_ff .EMU )};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_caca StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_cggc :=range _caca .CellStyles (){if _cggc .HasNumberFormat ()&&_cggc .NumberFormat ()==uint32 (f ){return _cggc ;};};_dcdab :=_caca .AddCellStyle ();_dcdab .SetNumberFormatStandard (f );return _dcdab ;};func (_da Border )SetRight (style _bdd .ST_BorderStyle ,c _dc .Color ){if _da ._adc .Right ==nil {_da ._adc .Right =_bdd .NewCT_BorderPr ();};_da ._adc .Right .Color =_bdd .NewCT_Color ();_da ._adc .Right .Color .RgbAttr =c .AsRGBAString ();_da ._adc .Right .StyleAttr =style ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cffe *Sheet )ClearCachedFormulaResults (){for _ ,_ccdb :=range _cffe .Rows (){for _ ,_efadg :=range _ccdb .Cells (){if _efadg .X ().F !=nil {_efadg .X ().V =nil ;};};};};

// Tables returns a slice of all defined tables in the workbook.
func (_dgdg *Workbook )Tables ()[]Table {if _dgdg ._cafc ==nil {return nil ;};_deab :=[]Table {};for _ ,_debee :=range _dgdg ._cafc {_deab =append (_deab ,Table {_debee });};return _deab ;};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_dece StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _dece ._aecc .Dxfs ==nil {_dece ._aecc .Dxfs =_bdd .NewCT_Dxfs ();};_gbgad :=_bdd .NewCT_Dxf ();_dece ._aecc .Dxfs .Dxf =append (_dece ._aecc .Dxfs .Dxf ,_gbgad );_dece ._aecc .Dxfs .CountAttr =_f .Uint32 (uint32 (len (_dece ._aecc .Dxfs .Dxf )));return DifferentialStyle {_gbgad ,_dece ._cfef ,_dece ._aecc .Dxfs };};

// IsEmpty returns true if the cell is empty.
func (_cdf Cell )IsEmpty ()bool {return _cdf ._egf .TAttr ==_bdd .ST_CellTypeUnset &&_cdf ._egf .V ==nil &&_cdf ._egf .F ==nil ;};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_efc CellStyle )SetHorizontalAlignment (a _bdd .ST_HorizontalAlignment ){if _efc ._bgb .Alignment ==nil {_efc ._bgb .Alignment =_bdd .NewCT_CellAlignment ();};_efc ._bgb .Alignment .HorizontalAttr =a ;_efc ._bgb .ApplyAlignmentAttr =_f .Bool (true );};

// SetFormat sets the number format code.
func (_ebce NumberFormat )SetFormat (f string ){_ebce ._edf .FormatCodeAttr =f };

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_abda :=uint16 (0);if len (s )> 0{for _abac :=len (s )-1;_abac >=0;_abac --{_dcg :=s [_abac ];_abda =((_abda >>14)&0x01)|((_abda <<1)&0x7fff);_abda ^=uint16 (_dcg );};_abda =((_abda >>14)&0x01)|((_abda <<1)&0x7fff);_abda ^=uint16 (len (s ));_abda ^=(0x8000|('N'<<8)|'K');};return _fb .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_abda ));};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_bfe CellStyle )GetVerticalAlignment ()_bdd .ST_VerticalAlignment {if _bfe ._bgb .Alignment ==nil {return _bdd .ST_VerticalAlignmentUnset ;};return _bfe ._bgb .Alignment .VerticalAttr ;};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_dge :=NumberFormat {_edf :_bdd .NewCT_NumFmt ()};_dge ._edf .NumFmtIdAttr =uint32 (id );_dge ._edf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_dge ._edf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_dge ._edf .FormatCodeAttr ="\u0030";case StandardFormat2 :_dge ._edf .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_dge ._edf .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_dge ._edf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_dge ._edf .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_dge ._edf .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_dge ._edf .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_dge ._edf .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_dge ._edf .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_dge ._edf .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_dge ._edf .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_dge ._edf .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_dge ._edf .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_dge ._edf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_dge ._edf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_dge ._edf .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_dge ._edf .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_dge ._edf .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_dge ._edf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_dge ._edf .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_dge ._edf .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_dge ._edf .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_dge ._edf .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_dge ._edf .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_dge ._edf .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_dge ._edf .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_dge ._edf .FormatCodeAttr ="\u0040";};return _dge ;};func (_bde CellStyle )Index ()uint32 {for _badg ,_cgbc :=range _bde ._bgaf .Xf {if _bde ._bgb ==_cgbc {return uint32 (_badg );};};return 0;};

// Index returns the index of the differential style.
func (_cgfd DifferentialStyle )Index ()uint32 {for _gbgb ,_efad :=range _cgfd ._afc .Dxf {if _cgfd ._ebc ==_efad {return uint32 (_gbgb );};};return 0;};func (_cebf *Sheet )setArray (_fcgc string ,_ababa _agb .Result )error {_gcd ,_bgec :=_eg .ParseCellReference (_fcgc );if _bgec !=nil {return _bgec ;};for _cebd ,_egac :=range _ababa .ValueArray {_ffaaf :=_cebf .Row (_gcd .RowIdx +uint32 (_cebd ));for _cabd ,_bdcc :=range _egac {_eafe :=_ffaaf .Cell (_eg .IndexToColumn (_gcd .ColumnIdx +uint32 (_cabd )));if _bdcc .Type !=_agb .ResultTypeEmpty {if _bdcc .IsBoolean {_eafe .SetBool (_bdcc .ValueNumber !=0);}else {_eafe .SetCachedFormulaResult (_bdcc .String ());};};};};return nil ;};

// AddFormatValue adds a format value (databars require two).
func (_ade DataBarScale )AddFormatValue (t _bdd .ST_CfvoType ,val string ){_ffea :=_bdd .NewCT_Cfvo ();_ffea .TypeAttr =t ;_ffea .ValAttr =_f .String (val );_ade ._dgcd .Cfvo =append (_ade ._dgcd .Cfvo ,_ffea );};

// SetPassword sets the password hash to a hash of the input password.
func (_afbd SheetProtection )SetPassword (pw string ){_afbd .SetPasswordHash (PasswordHash (pw ))};type DifferentialStyle struct{_ebc *_bdd .CT_Dxf ;_agba *Workbook ;_afc *_bdd .CT_Dxfs ;};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_fcec *Workbook )GetChartByTargetId (targetAttr string )*_df .ChartSpace {return _fcec ._fbga [targetAttr ];};

// SetError sets the cell type to error and the value to the given error message.
func (_debg Cell )SetError (msg string ){_debg .clearValue ();_debg ._egf .V =_f .String (msg );_debg ._egf .TAttr =_bdd .ST_CellTypeE ;};

// SetHyperlink sets a hyperlink on a cell.
func (_cbf Cell )SetHyperlink (hl _ad .Hyperlink ){_dae :=_cbf ._ea ._bcbe ;if _dae .Hyperlinks ==nil {_dae .Hyperlinks =_bdd .NewCT_Hyperlinks ();};_eaf :=_ad .Relationship (hl );_efag :=_bdd .NewCT_Hyperlink ();_efag .RefAttr =_cbf .Reference ();_efag .IdAttr =_f .String (_eaf .ID ());_dae .Hyperlinks .Hyperlink =append (_dae .Hyperlinks .Hyperlink ,_efag );};

// SetRowOffset sets a column offset in absolute distance.
func (_fbd CellMarker )SetRowOffset (m _ff .Distance ){_fbd ._acg .RowOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_ff .EMU ));};

// DefinedNames returns a slice of all defined names in the workbook.
func (_bedbg *Workbook )DefinedNames ()[]DefinedName {if _bedbg ._cecaf .DefinedNames ==nil {return nil ;};_aedbf :=[]DefinedName {};for _ ,_bffc :=range _bedbg ._cecaf .DefinedNames .DefinedName {_aedbf =append (_aedbf ,DefinedName {_bffc });};return _aedbf ;};

// X returns the inner wrapped XML type.
func (_geee WorkbookProtection )X ()*_bdd .CT_WorkbookProtection {return _geee ._fdfae };

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_agfe Cell )Reference ()string {if _agfe ._egf .RAttr !=nil {return *_agfe ._egf .RAttr ;};return "";};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_dcfdg TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_dcfdg ._gagg .To }};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_dfdg *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _dfdg .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _fade _ad .Relationship ;for _ ,_cbfa :=range _dfdg ._ggd .Relationships (){if _cbfa .ID ()==_dfdg ._cecaf .Sheets .Sheet [ind ].IdAttr {var _ggfac bool ;if _fade ,_ggfac =_dfdg ._ggd .CopyRelationship (_cbfa .ID ());!_ggfac {return Sheet {},ErrorNotFound ;};break ;};};_dfdg .ContentTypes .CopyOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1),_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,len (_dfdg .ContentTypes .X ().Override )));_fgab :=*_dfdg ._acggg [ind ];_dfdg ._acggg =append (_dfdg ._acggg ,&_fgab );var _fggf uint32 =0;for _ ,_dbee :=range _dfdg ._cecaf .Sheets .Sheet {if _dbee .SheetIdAttr > _fggf {_fggf =_dbee .SheetIdAttr ;};};_fggf ++;_dgff :=*_dfdg ._cecaf .Sheets .Sheet [ind ];_dgff .IdAttr =_fade .ID ();_dgff .NameAttr =copiedSheetName ;_dgff .SheetIdAttr =_fggf ;_dfdg ._cecaf .Sheets .Sheet =append (_dfdg ._cecaf .Sheets .Sheet ,&_dgff );_efca :=_ad .NewRelationshipsCopy (_dfdg ._bafe [ind ]);_dfdg ._bafe =append (_dfdg ._bafe ,_efca );_dgfdd :=_dfdg ._eedb [ind ];if _dgfdd ==nil {_dfdg ._eedb =append (_dfdg ._eedb ,nil );}else {_ecbd :=*_dgfdd ;_dfdg ._eedb =append (_dfdg ._eedb ,&_ecbd );};_daac :=Sheet {_dfdg ,&_dgff ,&_fgab };return _daac ,nil ;};

// SetMinLength sets the minimum bar length in percent.
func (_bdaa DataBarScale )SetMinLength (l uint32 ){_bdaa ._dgcd .MinLengthAttr =_f .Uint32 (l )};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_eec Cell )SetRichTextString ()RichText {_eec .clearValue ();_eec ._egf .Is =_bdd .NewCT_Rst ();_eec ._egf .TAttr =_bdd .ST_CellTypeInlineStr ;return RichText {_eec ._egf .Is };};

// X returns the inner wrapped XML type.
func (_bdef ConditionalFormattingRule )X ()*_bdd .CT_CfRule {return _bdef ._ggeg };

// SetPassword sets the password hash to a hash of the input password.
func (_cfdc WorkbookProtection )SetPassword (pw string ){_cfdc .SetPasswordHash (PasswordHash (pw ))};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_ceae *Sheet )InsertRow (rowNum int )Row {_abdg :=uint32 (rowNum );for _ ,_cfb :=range _ceae .Rows (){if _cfb ._ceea .RAttr !=nil &&*_cfb ._ceea .RAttr >=_abdg {*_cfb ._ceea .RAttr ++;for _ ,_eabd :=range _cfb .Cells (){_bfba ,_baf :=_eg .ParseCellReference (_eabd .Reference ());if _baf !=nil {continue ;};_bfba .RowIdx ++;_eabd ._egf .RAttr =_f .String (_bfba .String ());};};};for _ ,_eeg :=range _ceae .MergedCells (){_cgda ,_bfca ,_dbb :=_eg .ParseRangeReference (_eeg .Reference ());if _dbb !=nil {continue ;};if int (_cgda .RowIdx )>=rowNum {_cgda .RowIdx ++;};if int (_bfca .RowIdx )>=rowNum {_bfca .RowIdx ++;};_fefb :=_fb .Sprintf ("\u0025\u0073\u003a%\u0073",_cgda ,_bfca );_eeg .SetReference (_fefb );};return _ceae .AddNumberedRow (_abdg );};const _bc ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// SetOperator sets the operator for the rule.
func (_fdf ConditionalFormattingRule )SetOperator (t _bdd .ST_ConditionalFormattingOperator ){_fdf ._ggeg .OperatorAttr =t ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gffb *Workbook )ClearCachedFormulaResults (){for _ ,_aegff :=range _gffb .Sheets (){_aegff .ClearCachedFormulaResults ();};};

// SetPasswordHash sets the password hash to the input.
func (_dcdeg WorkbookProtection )SetPasswordHash (pwHash string ){_dcdeg ._fdfae .WorkbookPasswordAttr =_f .String (pwHash );};func (_efaa *Sheet )slideCellsLeft (_bebb []*_bdd .CT_Cell )[]*_bdd .CT_Cell {for _ ,_dcda :=range _bebb {_dbcc ,_eaadg :=_eg .ParseCellReference (*_dcda .RAttr );if _eaadg !=nil {return _bebb ;};_afef :=_dbcc .ColumnIdx -1;_eade :=_eg .IndexToColumn (_afef )+_fb .Sprintf ("\u0025\u0064",_dbcc .RowIdx );_dcda .RAttr =&_eade ;};return _bebb ;};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_eddbe *Sheet )Row (rowNum uint32 )Row {for _ ,_ggfa :=range _eddbe ._bcbe .SheetData .Row {if _ggfa .RAttr !=nil &&*_ggfa .RAttr ==rowNum {return Row {_eddbe ._debfd ,_eddbe ,_ggfa };};};return _eddbe .AddNumberedRow (rowNum );};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_dede ,_gfea :=_d .Open (filename );if _gfea !=nil {return nil ,_fb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gfea );};defer _dede .Close ();_gde ,_gfea :=_d .Stat (filename );if _gfea !=nil {return nil ,_fb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_gfea );};_dabd ,_gfea :=Read (_dede ,_gde .Size ());if _gfea !=nil {return nil ,_gfea ;};_ebgc ,_ :=_cb .Abs (_cb .Dir (filename ));_dabd ._eddc =_cb .Join (_ebgc ,filename );return _dabd ,nil ;};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_dbdc Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_dbdc .SetNumber (v );_dbdc .SetStyle (_dbdc ._dac .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_gda Cell )GetFormattedValue ()string {_gcg :=_gda .getFormat ();switch _gda ._egf .TAttr {case _bdd .ST_CellTypeB :_fce ,_ :=_gda .GetValueAsBool ();if _fce {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _bdd .ST_CellTypeN :_fdb ,_ :=_gda .GetValueAsNumber ();return _bd .Number (_fdb ,_gcg );case _bdd .ST_CellTypeE :if _gda ._egf .V !=nil {return *_gda ._egf .V ;};return "";case _bdd .ST_CellTypeS ,_bdd .ST_CellTypeInlineStr :return _bd .String (_gda .GetString (),_gcg );case _bdd .ST_CellTypeStr :_gdbf :=_gda .GetString ();if _bd .IsNumber (_gdbf ){_agff ,_ :=_be .ParseFloat (_gdbf ,64);return _bd .Number (_agff ,_gcg );};return _bd .String (_gdbf ,_gcg );case _bdd .ST_CellTypeUnset :fallthrough;default:_efg ,_ :=_gda .GetRawValue ();if len (_efg )==0{return "";};_gbd ,_abb :=_gda .GetValueAsNumber ();if _abb ==nil {return _bd .Number (_gbd ,_gcg );};return _bd .String (_efg ,_gcg );};};

// SetHeight is a nop-op.
func (_gabca TwoCellAnchor )SetHeight (h _ff .Distance ){};func _ffg (_acdd *Sheet )*evalContext {return &evalContext {_agbd :_acdd ,_ddd :make (map[string ]struct{})};};func _fgcde ()*_bgd .CT_TwoCellAnchor {_degd :=_bgd .NewCT_TwoCellAnchor ();_degd .EditAsAttr =_bgd .ST_EditAsOneCell ;_degd .From .Col =5;_degd .From .Row =0;_degd .From .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_degd .From .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);_degd .To .Col =10;_degd .To .Row =20;_degd .To .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_degd .To .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);return _degd ;};

// X returns the inner wrapped XML type.
func (_fgg MergedCell )X ()*_bdd .CT_MergeCell {return _fgg ._ead };

// LockStructure controls the locking of the workbook structure.
func (_cbefe WorkbookProtection )LockStructure (b bool ){if !b {_cbefe ._fdfae .LockStructureAttr =nil ;}else {_cbefe ._fdfae .LockStructureAttr =_f .Bool (true );};};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_agca ConditionalFormattingRule )SetDataBar ()DataBarScale {_agca .clear ();_agca .SetType (_bdd .ST_CfTypeDataBar );_agca ._ggeg .DataBar =_bdd .NewCT_DataBar ();_egd :=DataBarScale {_agca ._ggeg .DataBar };_egd .SetShowValue (true );_egd .SetMinLength (10);_egd .SetMaxLength (90);return _egd ;};

// Name returns the name of the table
func (_gceg Table )Name ()string {if _gceg ._bebg .NameAttr !=nil {return *_gceg ._bebg .NameAttr ;};return "";};

// GetFill gets a Fill from a cell style.
func (_gge CellStyle )GetFill ()*_bdd .CT_Fill {if _bdc :=_gge ._bgb .FillIdAttr ;_bdc !=nil {_afa :=_gge ._eaadf .StyleSheet .Fills ().X ().Fill ;if int (*_bdc )< len (_afa ){return _afa [int (*_bdc )];};};return nil ;};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_febc StyleSheet )AddCellStyle ()CellStyle {_dbab :=_bdd .NewCT_Xf ();_febc ._aecc .CellXfs .Xf =append (_febc ._aecc .CellXfs .Xf ,_dbab );_febc ._aecc .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_febc ._aecc .CellXfs .Xf )));return CellStyle {_febc ._cfef ,_dbab ,_febc ._aecc .CellXfs };};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_aec Comment )CellReference ()string {return _aec ._ffde .RefAttr };

// SetShowRuler controls the visibility of the ruler
func (_gccf SheetView )SetShowRuler (b bool ){if !b {_gccf ._adedb .ShowRulerAttr =_f .Bool (false );}else {_gccf ._adedb .ShowRulerAttr =nil ;};};

// GetValueAsNumber retrieves the cell's value as a number
func (_cbgb Cell )GetValueAsNumber ()(float64 ,error ){if _cbgb ._egf .V ==nil &&_cbgb ._egf .Is ==nil {return 0,nil ;};if _cbgb ._egf .TAttr ==_bdd .ST_CellTypeS ||!_bd .IsNumber (*_cbgb ._egf .V ){return _bg .NaN (),_fa .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _be .ParseFloat (*_cbgb ._egf .V ,64);};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_baadb *_bdd .CT_ConditionalFormatting ;};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_adb TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_adb ._gagg .From }};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_fafgb *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_fcee :=_bdd .NewCT_ConditionalFormatting ();_fafgb ._bcbe .ConditionalFormatting =append (_fafgb ._bcbe .ConditionalFormatting ,_fcee );_bbde :=make (_bdd .ST_Sqref ,0,0);_fcee .SqrefAttr =&_bbde ;for _ ,_ccfg :=range cellRanges {*_fcee .SqrefAttr =append (*_fcee .SqrefAttr ,_ccfg );};return ConditionalFormatting {_fcee };};

// SetColOffset sets the column offset of the two cell anchor.
func (_geaad TwoCellAnchor )SetColOffset (m _ff .Distance ){_cgdb :=m -_geaad .TopLeft ().ColOffset ();_geaad .TopLeft ().SetColOffset (m );_geaad .BottomRight ().SetColOffset (_geaad .BottomRight ().ColOffset ()+_cgdb );};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_fag *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_dcgg :=range _fag .Sheets (){if _dcgg .Name ()==name {return _dcgg ,nil ;};};return Sheet {},ErrorNotFound ;};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_gdgf *_bdd .Sst ;_gbeg map[string ]int ;};const (_ccage ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_cega ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_adga ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_cfbd ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);

// Fonts returns the list of fonts defined in the stylesheet.
func (_dgea StyleSheet )Fonts ()[]Font {_dagaf :=[]Font {};for _ ,_defg :=range _dgea ._aecc .Fonts .Font {_dagaf =append (_dagaf ,Font {_defg ,_dgea ._aecc });};return _dagaf ;};

// SetWidth is a no-op.
func (_deec TwoCellAnchor )SetWidth (w _ff .Distance ){};func (_bgfg Fill )SetPatternFill ()PatternFill {_bgfg ._fcc .GradientFill =nil ;_bgfg ._fcc .PatternFill =_bdd .NewCT_PatternFill ();_bgfg ._fcc .PatternFill .PatternTypeAttr =_bdd .ST_PatternTypeSolid ;return PatternFill {_bgfg ._fcc .PatternFill ,_bgfg ._fcc };};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_gfefa *Sheet )SetBorder (cellRange string ,border Border )error {_febe ,_fbgf ,_gdaf :=_eg .ParseRangeReference (cellRange );if _gdaf !=nil {return _gdaf ;};_fffg :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_gccec :=_gfefa ._debfd .StyleSheet .AddBorder ();_fffg .SetBorder (_gccec );_gccec ._adc .Top =border ._adc .Top ;_gccec ._adc .Left =border ._adc .Left ;_ggc :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_edcg :=_gfefa ._debfd .StyleSheet .AddBorder ();_ggc .SetBorder (_edcg );_edcg ._adc .Top =border ._adc .Top ;_edcg ._adc .Right =border ._adc .Right ;_fceab :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_efcbfe :=_gfefa ._debfd .StyleSheet .AddBorder ();_fceab .SetBorder (_efcbfe );_efcbfe ._adc .Top =border ._adc .Top ;_ebf :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_bcge :=_gfefa ._debfd .StyleSheet .AddBorder ();_ebf .SetBorder (_bcge );_bcge ._adc .Left =border ._adc .Left ;_gfb :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_fcdg :=_gfefa ._debfd .StyleSheet .AddBorder ();_gfb .SetBorder (_fcdg );_fcdg ._adc .Right =border ._adc .Right ;_cfcd :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_gdab :=_gfefa ._debfd .StyleSheet .AddBorder ();_cfcd .SetBorder (_gdab );_gdab ._adc .Bottom =border ._adc .Bottom ;_bccb :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_fabd :=_gfefa ._debfd .StyleSheet .AddBorder ();_bccb .SetBorder (_fabd );_fabd ._adc .Bottom =border ._adc .Bottom ;_fabd ._adc .Left =border ._adc .Left ;_aegf :=_gfefa ._debfd .StyleSheet .AddCellStyle ();_dbgg :=_gfefa ._debfd .StyleSheet .AddBorder ();_aegf .SetBorder (_dbgg );_dbgg ._adc .Bottom =border ._adc .Bottom ;_dbgg ._adc .Right =border ._adc .Right ;_cag :=_febe .RowIdx ;_fgag :=_febe .ColumnIdx ;_cabf :=_fbgf .RowIdx ;_eacg :=_fbgf .ColumnIdx ;for _dacd :=_cag ;_dacd <=_cabf ;_dacd ++{for _ebaa :=_fgag ;_ebaa <=_eacg ;_ebaa ++{_bdba :=_fb .Sprintf ("\u0025\u0073\u0025\u0064",_eg .IndexToColumn (_ebaa ),_dacd );switch {case _dacd ==_cag &&_ebaa ==_fgag :_gfefa .Cell (_bdba ).SetStyle (_fffg );case _dacd ==_cag &&_ebaa ==_eacg :_gfefa .Cell (_bdba ).SetStyle (_ggc );case _dacd ==_cabf &&_ebaa ==_fgag :_gfefa .Cell (_bdba ).SetStyle (_bccb );case _dacd ==_cabf &&_ebaa ==_eacg :_gfefa .Cell (_bdba ).SetStyle (_aegf );case _dacd ==_cag :_gfefa .Cell (_bdba ).SetStyle (_fceab );case _dacd ==_cabf :_gfefa .Cell (_bdba ).SetStyle (_cfcd );case _ebaa ==_fgag :_gfefa .Cell (_bdba ).SetStyle (_ebf );case _ebaa ==_eacg :_gfefa .Cell (_bdba ).SetStyle (_gfb );};};};return nil ;};type MergedCell struct{_gef *Workbook ;_fcce *Sheet ;_ead *_bdd .CT_MergeCell ;};

// IsError returns true if the cell is an error type cell.
func (_acc Cell )IsError ()bool {return _acc ._egf .TAttr ==_bdd .ST_CellTypeE };

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_fadb TwoCellAnchor )SetHeightCells (h int32 ){_fadb .SetHeight (0);_bfbd :=_fadb .TopLeft ();_bcdg :=_fadb .BottomRight ();_bcdg .SetRow (_bfbd .Row ()+h );};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// Row returns the row of the cell marker.
func (_cgb CellMarker )Row ()int32 {return _cgb ._acg .Row };

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_cfg *Sheet )InitialView ()SheetView {if _cfg ._bcbe .SheetViews ==nil ||len (_cfg ._bcbe .SheetViews .SheetView )==0{return _cfg .AddView ();};return SheetView {_cfg ._bcbe .SheetViews .SheetView [0]};};

// New constructs a new workbook.
func New ()*Workbook {_ace :=&Workbook {};_ace ._cecaf =_bdd .NewWorkbook ();_ace .AppProperties =_ad .NewAppProperties ();_ace .CoreProperties =_ad .NewCoreProperties ();_ace .StyleSheet =NewStyleSheet (_ace );_ace .Rels =_ad .NewRelationships ();_ace ._ggd =_ad .NewRelationships ();_ace .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .ExtendedPropertiesType ,0),_f .ExtendedPropertiesType );_ace .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .CorePropertiesType ,0),_f .CorePropertiesType );_ace .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .OfficeDocumentType ,0),_f .OfficeDocumentType );_ace ._ggd .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .StylesType ,0),_f .StylesType );_ace .ContentTypes =_ad .NewContentTypes ();_ace .ContentTypes .AddDefault ("\u0076\u006d\u006c",_f .VMLDrawingContentType );_ace .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_ace .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .StylesType ,0),_f .SMLStyleSheetContentType );_ace .SharedStrings =NewSharedStrings ();_ace .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0),_f .SharedStringsContentType );_ace ._ggd .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0),_f .SharedStringsType );_ace ._fbcg =map[string ]string {};return _ace ;};

// ClearAutoFilter removes the autofilters from the sheet.
func (_daae *Sheet )ClearAutoFilter (){_daae ._bcbe .AutoFilter =nil ;_acccf :="\u0027"+_daae .Name ()+"\u0027\u0021";for _ ,_ffef :=range _daae ._debfd .DefinedNames (){if _ffef .Name ()==_eggd {if _ce .HasPrefix (_ffef .Content (),_acccf ){_daae ._debfd .RemoveDefinedName (_ffef );break ;};};};};func (_cddf *Sheet )updateAfterRemove (_bcgg uint32 ,_efbcd _de .UpdateAction )error {_cbbg :=_cddf .Name ();_edgb :=&_de .UpdateQuery {UpdateType :_efbcd ,ColumnIdx :_bcgg ,SheetToUpdate :_cbbg };for _ ,_aeed :=range _cddf ._debfd .Sheets (){_edgb .UpdateCurrentSheet =_cbbg ==_aeed .Name ();for _ ,_gecbg :=range _aeed .Rows (){for _ ,_acfa :=range _gecbg .Cells (){if _acfa .X ().F !=nil {_cae :=_acfa .X ().F .Content ;_daeg :=_agb .ParseString (_cae );if _daeg ==nil {_acfa .SetError ("\u0023\u0052\u0045F\u0021");}else {_edcgc :=_daeg .Update (_edgb );_acfa .X ().F .Content =_fb .Sprintf ("\u003d\u0025\u0073",_edcgc .String ());};};};};};return nil ;};

// SetHidden marks the defined name as hidden.
func (_dbe DefinedName )SetLocalSheetID (id uint32 ){_dbe ._afg .LocalSheetIdAttr =_f .Uint32 (id )};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_accc DataValidationCompare )SetValue (v string ){_accc ._gdbe .Formula1 =&v };

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_gffc DataValidationList )SetRange (cellRange string ){_gffc ._bebf .Formula1 =_f .String (cellRange );_gffc ._bebf .Formula2 =_f .String ("\u0030");};

// SetFill applies a fill to a cell style. The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_bed CellStyle )SetFill (f Fill ){_bed ._bgb .FillIdAttr =_f .Uint32 (f .Index ());_bed ._bgb .ApplyFillAttr =_f .Bool (true );};

// BottomRight is a no-op.
func (_ec AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_bdd .Comments )Comments {return Comments {w ,x }};func (_gfff DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_gfff .clear ();_gfff ._fed .TypeAttr =_bdd .ST_DataValidationType (t );_gfff ._fed .OperatorAttr =_bdd .ST_DataValidationOperator (op );return DataValidationCompare {_gfff ._fed };};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gfed CellStyle )GetHorizontalAlignment ()_bdd .ST_HorizontalAlignment {if _gfed ._bgb .Alignment ==nil {return _bdd .ST_HorizontalAlignmentUnset ;};return _gfed ._bgb .Alignment .HorizontalAttr ;};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_egc CellStyle )SetVerticalAlignment (a _bdd .ST_VerticalAlignment ){if _egc ._bgb .Alignment ==nil {_egc ._bgb .Alignment =_bdd .NewCT_CellAlignment ();};_egc ._bgb .ApplyAlignmentAttr =_f .Bool (true );_egc ._bgb .Alignment .VerticalAttr =a ;};

// X returns the inner wrapped XML type.
func (_dffc NumberFormat )X ()*_bdd .CT_NumFmt {return _dffc ._edf };func (_ege Cell )getLocked ()bool {if _ege ._egf .SAttr ==nil {return false ;};_dgg :=*_ege ._egf .SAttr ;_ged :=_ege ._dac .StyleSheet .GetCellStyle (_dgg );return *_ged ._bgb .Protection .LockedAttr ;};

// SaveToFile writes the workbook out to a file.
func (_bfgd *Workbook )SaveToFile (path string )error {_ffbe ,_fdec :=_d .Create (path );if _fdec !=nil {return _fdec ;};defer _ffbe .Close ();return _bfgd .Save (_ffbe );};

// Text returns text from the workbook as one string separated with line breaks.
func (_bgcc *WorkbookText )Text ()string {_adfa :=_cd .NewBuffer ([]byte {});for _ ,_bfdc :=range _bgcc .Sheets {_adfa .WriteString (_bfdc .Text ());};return _adfa .String ();};

// SetSize sets the text size for a rich text run.
func (_eddb RichTextRun )SetSize (m _ff .Distance ){_eddb .ensureRpr ();_eddb ._fabe .RPr .Sz =_bdd .NewCT_FontSize ();_eddb ._fabe .RPr .Sz .ValAttr =float64 (m /_ff .Point );};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_degb StyleSheet )AddBorder ()Border {_ebge :=_bdd .NewCT_Border ();_degb ._aecc .Borders .Border =append (_degb ._aecc .Borders .Border ,_ebge );_degb ._aecc .Borders .CountAttr =_f .Uint32 (uint32 (len (_degb ._aecc .Borders .Border )));return Border {_ebge ,_degb ._aecc .Borders };};func (_fbdd DataValidation )clear (){_fbdd ._fed .Formula1 =_f .String ("\u0030");_fbdd ._fed .Formula2 =_f .String ("\u0030");};

// SetReference sets the regin of cells that the merged cell applies to.
func (_gfc MergedCell )SetReference (ref string ){_gfc ._ead .RefAttr =ref };

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_gcdg *Workbook )RemoveSheetByName (name string )error {_degdf :=-1;for _agbb ,_bced :=range _gcdg .Sheets (){if name ==_bced .Name (){_degdf =_agbb ;break ;};};if _degdf ==-1{return ErrorNotFound ;};return _gcdg .RemoveSheet (_degdf );};

// Name returns the name of the defined name.
func (_fbfe DefinedName )Name ()string {return _fbfe ._afg .NameAttr };

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_eaadf *Workbook ;_bgb *_bdd .CT_Xf ;_bgaf *_bdd .CT_CellXfs ;};

// AddRule adds and returns a new rule that can be configured.
func (_efd ConditionalFormatting )AddRule ()ConditionalFormattingRule {_egba :=_bdd .NewCT_CfRule ();_efd ._baadb .CfRule =append (_efd ._baadb .CfRule ,_egba );_cafa :=ConditionalFormattingRule {_egba };_cafa .InitializeDefaults ();_cafa .SetPriority (int32 (len (_efd ._baadb .CfRule )+1));return _cafa ;};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_bbd Comparer )LessCells (lhs ,rhs Cell )bool {if _bbd .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_egg ,_cefb :=lhs .getRawSortValue ();_ecfb ,_bda :=rhs .getRawSortValue ();switch {case _cefb &&_bda :_agffd ,_ :=_be .ParseFloat (_egg ,64);_aad ,_ :=_be .ParseFloat (_ecfb ,64);return _agffd < _aad ;case _cefb :return true ;case _bda :return false ;};_egg =lhs .GetFormattedValue ();_ecfb =rhs .GetFormattedValue ();return _egg < _ecfb ;};

// Comment is a single comment within a sheet.
type Comment struct{_add *Workbook ;_ffde *_bdd .CT_Comment ;_afe *_bdd .Comments ;};func NewPatternFill (fills *_bdd .CT_Fills )PatternFill {_dbdfe :=_bdd .NewCT_Fill ();_dbdfe .PatternFill =_bdd .NewCT_PatternFill ();return PatternFill {_dbdfe .PatternFill ,_dbdfe };};

// SetStyle sets the style to be used for conditional rules
func (_fafg ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_fafg ._ggeg .DxfIdAttr =_f .Uint32 (d .Index ());};

// AddRun adds a new run of text to the cell.
func (_cgbb RichText )AddRun ()RichTextRun {_eecg :=_bdd .NewCT_RElt ();_cgbb ._gegc .R =append (_cgbb ._gegc .R ,_eecg );return RichTextRun {_eecg };};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_gccd Sheet )RangeReference (n string )string {_bedd :=_ce .Split (n ,"\u003a");_abfae ,_ :=_eg .ParseCellReference (_bedd [0]);_egad :=_fb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_abfae .Column ,_abfae .RowIdx );if len (_bedd )==1{return _fb .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_gccd .Name (),_egad );};_ffae ,_ :=_eg .ParseCellReference (_bedd [1]);_ffab :=_fb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_ffae .Column ,_ffae .RowIdx );return _fb .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_gccd .Name (),_egad ,_ffab );};var ErrorNotFound =_fa .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetColor sets teh color of the databar.
func (_cafd DataBarScale )SetColor (c _dc .Color ){_cafd ._dgcd .Color =_bdd .NewCT_Color ();_cafd ._dgcd .Color .RgbAttr =c .AsRGBAString ();};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_fdab DataValidationList )SetValues (values []string ){_fdab ._bebf .Formula1 =_f .String ("\u0022"+_ce .Join (values ,"\u002c")+"\u0022");_fdab ._bebf .Formula2 =_f .String ("\u0030");};func (_ab Border )SetLeft (style _bdd .ST_BorderStyle ,c _dc .Color ){if _ab ._adc .Left ==nil {_ab ._adc .Left =_bdd .NewCT_BorderPr ();};_ab ._adc .Left .Color =_bdd .NewCT_Color ();_ab ._adc .Left .Color .RgbAttr =c .AsRGBAString ();_ab ._adc .Left .StyleAttr =style ;};

// IsHidden returns whether the row is hidden or not.
func (_acab Row )IsHidden ()bool {return _acab ._ceea .HiddenAttr !=nil &&*_acab ._ceea .HiddenAttr };

// SetContent sets the defined name content.
func (_cbgg DefinedName )SetContent (s string ){_cbgg ._afg .Content =s };const _cggb ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";func (_efcb *evalContext )Sheet (name string )_agb .Context {for _ ,_fbg :=range _efcb ._agbd ._debfd .Sheets (){if _fbg .Name ()==name {return _fbg .FormulaContext ();};};return _agb .InvalidReferenceContext ;};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_ad .DocBase ;_cecaf *_bdd .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_eedb []*_bdd .Comments ;_acggg []*_bdd .Worksheet ;_bafe []_ad .Relationships ;_ggd _ad .Relationships ;_ffdc []*_adg .Theme ;_aeeg []*_bgd .WsDr ;_gefc []_ad .Relationships ;_bdaaa []*_db .Container ;_fbdg []*_df .ChartSpace ;_cafc []*_bdd .Table ;_eddc string ;_fbcg map[string ]string ;_fbga map[string ]*_df .ChartSpace ;_bfgc string ;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_bedb Sheet )Extents ()string {_befba ,_dee ,_daeb ,_efce :=_bedb .ExtentsIndex ();return _fb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_befba ,_dee ,_daeb ,_efce );};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gdac *Workbook )AddDefinedName (name ,ref string )DefinedName {if _gdac ._cecaf .DefinedNames ==nil {_gdac ._cecaf .DefinedNames =_bdd .NewCT_DefinedNames ();};_gggf :=_bdd .NewCT_DefinedName ();_gggf .Content =ref ;_gggf .NameAttr =name ;_gdac ._cecaf .DefinedNames .DefinedName =append (_gdac ._cecaf .DefinedNames .DefinedName ,_gggf );return DefinedName {_gggf };};func (_dfcc Fills )AddFill ()Fill {_ccfa :=_bdd .NewCT_Fill ();_dfcc ._bfeb .Fill =append (_dfcc ._bfeb .Fill ,_ccfa );_dfcc ._bfeb .CountAttr =_f .Uint32 (uint32 (len (_dfcc ._bfeb .Fill )));return Fill {_ccfa ,_dfcc ._bfeb };};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_ebcc *Sheet )RemoveMergedCell (mc MergedCell ){for _cfeb ,_fgd :=range _ebcc ._bcbe .MergeCells .MergeCell {if _fgd ==mc .X (){copy (_ebcc ._bcbe .MergeCells .MergeCell [_cfeb :],_ebcc ._bcbe .MergeCells .MergeCell [_cfeb +1:]);_ebcc ._bcbe .MergeCells .MergeCell [len (_ebcc ._bcbe .MergeCells .MergeCell )-1]=nil ;_ebcc ._bcbe .MergeCells .MergeCell =_ebcc ._bcbe .MergeCells .MergeCell [:len (_ebcc ._bcbe .MergeCells .MergeCell )-1];};};};func (_feca *Workbook )onNewRelationship (_ccdf *_e .DecodeMap ,_bbac ,_ddbe string ,_bdda []*_ag .File ,_bbad *_cef .Relationship ,_bdgf _e .Target )error {_cfce :=_f .DocTypeSpreadsheet ;switch _ddbe {case _f .OfficeDocumentType :_feca ._cecaf =_bdd .NewWorkbook ();_ccdf .AddTarget (_bbac ,_feca ._cecaf ,_ddbe ,0);_feca ._ggd =_ad .NewRelationships ();_ccdf .AddTarget (_e .RelationsPathFor (_bbac ),_feca ._ggd .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .CorePropertiesType :_ccdf .AddTarget (_bbac ,_feca .CoreProperties .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .CustomPropertiesType :_ccdf .AddTarget (_bbac ,_feca .CustomProperties .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .ExtendedPropertiesType :_ccdf .AddTarget (_bbac ,_feca .AppProperties .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .WorksheetType :_fgddd :=_bdd .NewWorksheet ();_gbgab :=uint32 (len (_feca ._acggg ));_feca ._acggg =append (_feca ._acggg ,_fgddd );_ccdf .AddTarget (_bbac ,_fgddd ,_ddbe ,_gbgab );_dgge :=_ad .NewRelationships ();_ccdf .AddTarget (_e .RelationsPathFor (_bbac ),_dgge .X (),_ddbe ,0);_feca ._bafe =append (_feca ._bafe ,_dgge );_feca ._eedb =append (_feca ._eedb ,nil );_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._acggg ));case _f .StylesType :_feca .StyleSheet =NewStyleSheet (_feca );_ccdf .AddTarget (_bbac ,_feca .StyleSheet .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .ThemeType :_cbeb :=_adg .NewTheme ();_feca ._ffdc =append (_feca ._ffdc ,_cbeb );_ccdf .AddTarget (_bbac ,_cbeb ,_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._ffdc ));case _f .SharedStringsType :_feca .SharedStrings =NewSharedStrings ();_ccdf .AddTarget (_bbac ,_feca .SharedStrings .X (),_ddbe ,0);_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,0);case _f .ThumbnailType :for _fcca ,_cfedg :=range _bdda {if _cfedg ==nil {continue ;};if _cfedg .Name ==_bbac {_acgc ,_gegb :=_cfedg .Open ();if _gegb !=nil {return _fb .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_gegb );};_feca .Thumbnail ,_ ,_gegb =_a .Decode (_acgc );_acgc .Close ();if _gegb !=nil {return _fb .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_gegb );};_bdda [_fcca ]=nil ;};};case _f .ImageType :for _acgcf ,_cdff :=range _feca ._fbcg {_ababb :=_cg .Clean (_bbac );if _ababb ==_acgcf {_bbad .TargetAttr =_cdff ;return nil ;};};_abag :=_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca .Images )+1);for _fgdb ,_edce :=range _bdda {if _edce ==nil {continue ;};if _edce .Name ==_cg .Clean (_bbac ){_cgdae ,_gbda :=_e .ExtractToDiskTmp (_edce ,_feca .TmpPath );if _gbda !=nil {return _gbda ;};_dgfg ,_gbda :=_ad .ImageFromStorage (_cgdae );if _gbda !=nil {return _gbda ;};_fffbd :=_ad .MakeImageRef (_dgfg ,&_feca .DocBase ,_feca ._ggd );_fffbd .SetTarget (_abag );_feca ._fbcg [_edce .Name ]=_abag ;_feca .Images =append (_feca .Images ,_fffbd );_bdda [_fgdb ]=nil ;};};_bbad .TargetAttr =_abag ;case _f .DrawingType :_bcab :=_bgd .NewWsDr ();_bfbcc :=uint32 (len (_feca ._aeeg ));_ccdf .AddTarget (_bbac ,_bcab ,_ddbe ,_bfbcc );_feca ._aeeg =append (_feca ._aeeg ,_bcab );_bded :=_ad .NewRelationships ();_ccdf .AddTarget (_e .RelationsPathFor (_bbac ),_bded .X (),_ddbe ,_bfbcc );_feca ._gefc =append (_feca ._gefc ,_bded );_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._aeeg ));case _f .VMLDrawingType :_baag :=_db .NewContainer ();_egeb :=uint32 (len (_feca ._bdaaa ));_ccdf .AddTarget (_bbac ,_baag ,_ddbe ,_egeb );_feca ._bdaaa =append (_feca ._bdaaa ,_baag );case _f .CommentsType :_feca ._eedb [_bdgf .Index ]=_bdd .NewComments ();_ccdf .AddTarget (_bbac ,_feca ._eedb [_bdgf .Index ],_ddbe ,_bdgf .Index );_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._eedb ));case _f .ChartType :_dcea :=_df .NewChartSpace ();_gdde :=uint32 (len (_feca ._fbdg ));_ccdf .AddTarget (_bbac ,_dcea ,_ddbe ,_gdde );_feca ._fbdg =append (_feca ._fbdg ,_dcea );_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._fbdg ));_feca ._fbga [_bbad .TargetAttr ]=_dcea ;case _f .TableType :_gcae :=_bdd .NewTable ();_edfe :=uint32 (len (_feca ._cafc ));_ccdf .AddTarget (_bbac ,_gcae ,_ddbe ,_edfe );_feca ._cafc =append (_feca ._cafc ,_gcae );_bbad .TargetAttr =_f .RelativeFilename (_cfce ,_bdgf .Typ ,_ddbe ,len (_feca ._cafc ));default:_aa .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_bbac ,_ddbe );};return nil ;};type Fills struct{_bfeb *_bdd .CT_Fills };