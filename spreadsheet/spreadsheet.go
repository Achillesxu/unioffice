//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_ge "archive/zip";_dc "bytes";_fgc "errors";_ba "fmt";_f "github.com/unidoc/unioffice";_cac "github.com/unidoc/unioffice/chart";_ebb "github.com/unidoc/unioffice/color";_fa "github.com/unidoc/unioffice/common";_bbc "github.com/unidoc/unioffice/common/logger";_eb "github.com/unidoc/unioffice/common/tempstorage";_ca "github.com/unidoc/unioffice/internal/license";_gb "github.com/unidoc/unioffice/measurement";_cb "github.com/unidoc/unioffice/schema/soo/dml";_da "github.com/unidoc/unioffice/schema/soo/dml/chart";_ab "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_cd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ad "github.com/unidoc/unioffice/schema/soo/sml";_gf "github.com/unidoc/unioffice/spreadsheet/format";_cea "github.com/unidoc/unioffice/spreadsheet/formula";_fec "github.com/unidoc/unioffice/spreadsheet/reference";_e "github.com/unidoc/unioffice/spreadsheet/update";_ce "github.com/unidoc/unioffice/vmldrawing";_fgb "github.com/unidoc/unioffice/zippkg";_g "image";_b "image/jpeg";_cf "io";_fed "math";_bbe "math/big";_fe "os";_a "path";_c "path/filepath";_bb "regexp";_fg "sort";_ga "strconv";_ff "strings";_feb "time";);type DifferentialStyle struct{_cebf *_ad .CT_Dxf ;_cga *Workbook ;_dbdb *_ad .CT_Dxfs ;};

// SetStyle sets the cell style for an entire column.
func (_cebg Column )SetStyle (cs CellStyle ){_cebg ._eede .StyleAttr =_f .Uint32 (cs .Index ())};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_dbde StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_ddcc :=range _dbde .CellStyles (){if _ddcc .HasNumberFormat ()&&_ddcc .NumberFormat ()==uint32 (f ){return _ddcc ;};};_adfe :=_dbde .AddCellStyle ();_adfe .SetNumberFormatStandard (f );return _adfe ;};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_ggd Cell )Reference ()string {if _ggd ._abg .RAttr !=nil {return *_ggd ._abg .RAttr ;};return "";};func _edbf ()*_ab .CT_AbsoluteAnchor {_edeg :=_ab .NewCT_AbsoluteAnchor ();return _edeg };

// SetColOffset sets a column offset in absolute distance.
func (_fga CellMarker )SetColOffset (m _gb .Distance ){_fga ._dcc .ColOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_gb .EMU ));};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_bbg Cell )AddHyperlink (url string ){for _dee ,_agf :=range _bbg ._bgf ._ebag {if _agf ==_bbg ._be ._dbfc {_bbg .SetHyperlink (_bbg ._bgf ._bced [_dee ].AddHyperlink (url ));return ;};};};

// SetFormat sets the number format code.
func (_faf NumberFormat )SetFormat (f string ){_faf ._ccdf .FormatCodeAttr =f };const (_dfcba ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_fedd ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_dfgd ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_abfff ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);func (_dff *evalContext )NamedRange (ref string )_cea .Reference {for _ ,_ffee :=range _dff ._gccf ._ffec .DefinedNames (){if _ffee .Name ()==ref {return _cea .MakeRangeReference (_ffee .Content ());};};for _ ,_edg :=range _dff ._gccf ._ffec .Tables (){if _edg .Name ()==ref {return _cea .MakeRangeReference (_ba .Sprintf ("\u0025\u0073\u0021%\u0073",_dff ._gccf .Name (),_edg .Reference ()));};};return _cea .ReferenceInvalid ;};func (_dabe *Sheet )setArray (_acae string ,_ggeg _cea .Result )error {_bcac ,_abde :=_fec .ParseCellReference (_acae );if _abde !=nil {return _abde ;};for _dafg ,_fgfa :=range _ggeg .ValueArray {_abfg :=_dabe .Row (_bcac .RowIdx +uint32 (_dafg ));for _abbgd ,_dfeb :=range _fgfa {_eefa :=_abfg .Cell (_fec .IndexToColumn (_bcac .ColumnIdx +uint32 (_abbgd )));if _dfeb .Type !=_cea .ResultTypeEmpty {if _dfeb .IsBoolean {_eefa .SetBool (_dfeb .ValueNumber !=0);}else {_eefa .SetCachedFormulaResult (_dfeb .String ());};};};};return nil ;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_cfdg Sheet )Extents ()string {_cad ,_edcb ,_dfbg ,_ddfc :=_cfdg .ExtentsIndex ();return _ba .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_cad ,_edcb ,_dfbg ,_ddfc );};func (_gbaa DataValidationCompare )SetValue2 (v string ){_gbaa ._daba .Formula2 =&v };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_dfbcg *Workbook )RecalculateFormulas (){for _ ,_cdabg :=range _dfbcg .Sheets (){_cdabg .RecalculateFormulas ();};};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_aagf StyleSheet )AddBorder ()Border {_dfae :=_ad .NewCT_Border ();_aagf ._gagf .Borders .Border =append (_aagf ._gagf .Borders .Border ,_dfae );_aagf ._gagf .Borders .CountAttr =_f .Uint32 (uint32 (len (_aagf ._gagf .Borders .Border )));return Border {_dfae ,_aagf ._gagf .Borders };};

// SetHeight sets the height of the anchored object.
func (_ec AbsoluteAnchor )SetHeight (h _gb .Distance ){_ec ._aa .Ext .CyAttr =int64 (h /_gb .EMU )};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_bcec *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_cebgc :=_ad .NewCT_ConditionalFormatting ();_bcec ._dbfc .ConditionalFormatting =append (_bcec ._dbfc .ConditionalFormatting ,_cebgc );_dbed :=make (_ad .ST_Sqref ,0,0);_cebgc .SqrefAttr =&_dbed ;for _ ,_bdef :=range cellRanges {*_cebgc .SqrefAttr =append (*_cebgc .SqrefAttr ,_bdef );};return ConditionalFormatting {_cebgc };};

// ClearAutoFilter removes the autofilters from the sheet.
func (_cgce *Sheet )ClearAutoFilter (){_cgce ._dbfc .AutoFilter =nil ;_dagfc :="\u0027"+_cgce .Name ()+"\u0027\u0021";for _ ,_dgafa :=range _cgce ._ffec .DefinedNames (){if _dgafa .Name ()==_fccb {if _ff .HasPrefix (_dgafa .Content (),_dagfc ){_cgce ._ffec .RemoveDefinedName (_dgafa );break ;};};};};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_age *evalContext )IsDBCS ()bool {_ddc :=_age ._gccf ._ffec .CoreProperties .X ().Language ;if _ddc ==nil {return false ;};_dgdb :=string (_ddc .Data );for _ ,_deff :=range _egg {if _dgdb ==_deff {return true ;};};return false ;};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_cedcd *Sheet )SetFrozen (firstRow ,firstCol bool ){_cedcd ._dbfc .SheetViews =nil ;_aggd :=_cedcd .AddView ();_aggd .SetState (_ad .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_aggd .SetYSplit (1);_aggd .SetXSplit (1);_aggd .SetTopLeft ("\u0042\u0032");case firstRow :_aggd .SetYSplit (1);_aggd .SetTopLeft ("\u0041\u0032");case firstCol :_aggd .SetXSplit (1);_aggd .SetTopLeft ("\u0042\u0031");};};func (_afa Cell )getLabelPrefix ()string {if _afa ._abg .SAttr ==nil {return "";};_cdg :=*_afa ._abg .SAttr ;_eeg :=_afa ._bgf .StyleSheet .GetCellStyle (_cdg );switch _eeg ._cff .Alignment .HorizontalAttr {case _ad .ST_HorizontalAlignmentLeft :return "\u0027";case _ad .ST_HorizontalAlignmentRight :return "\u0022";case _ad .ST_HorizontalAlignmentCenter :return "\u005e";case _ad .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_eabe *Sheet )InitialView ()SheetView {if _eabe ._dbfc .SheetViews ==nil ||len (_eabe ._dbfc .SheetViews .SheetView )==0{return _eabe .AddView ();};return SheetView {_eabe ._dbfc .SheetViews .SheetView [0]};};

// ExtractText returns text from the sheet as a SheetText object.
func (_fcgd *Sheet )ExtractText ()*SheetText {_fdf :=[]CellText {};for _ ,_ffgf :=range _fcgd .Rows (){for _ ,_dce :=range _ffgf .Cells (){if !_dce .IsEmpty (){if _feab :=_dce .GetFormattedValue ();_feab !=""{_fdf =append (_fdf ,CellText {Text :_feab ,Cell :_dce });};};};};return &SheetText {Cells :_fdf };};

// SetXSplit sets the column split point
func (_bbgd SheetView )SetXSplit (v float64 ){_bbgd .ensurePane ();_bbgd ._deeg .Pane .XSplitAttr =_f .Float64 (v );};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_geg Cell )SetTime (d _feb .Time ){_geg .clearValue ();d =_agb (d );_de :=_geg ._bgf .Epoch ();if d .Before (_de ){_bbc .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_gbd :=d .Sub (_de );_gdg :=new (_bbe .Float );_agba :=new (_bbe .Float );_agba .SetPrec (128);_agba .SetUint64 (uint64 (_gbd ));_gac :=new (_bbe .Float );_gac .SetUint64 (24*60*60*1e9);_gdg .Quo (_agba ,_gac );_geg ._abg .V =_f .String (_gdg .Text ('g',20));};

// MaxColumnIdx returns the max used column of the sheet.
func (_gdegf Sheet )MaxColumnIdx ()uint32 {_bfdb :=uint32 (0);for _ ,_geceb :=range _gdegf .Rows (){_ded :=_geceb ._eaecd .C ;if len (_ded )> 0{_fgaa :=_ded [len (_ded )-1];_fdbc ,_ :=_fec .ParseCellReference (*_fgaa .RAttr );if _bfdb < _fdbc .ColumnIdx {_bfdb =_fdbc .ColumnIdx ;};};};return _bfdb ;};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_cfdc Sheet )RangeReference (n string )string {_eca :=_ff .Split (n ,"\u003a");_egga ,_ :=_fec .ParseCellReference (_eca [0]);_gcd :=_ba .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_egga .Column ,_egga .RowIdx );if len (_eca )==1{return _ba .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_cfdc .Name (),_gcd );};_effbd ,_ :=_fec .ParseCellReference (_eca [1]);_gdga :=_ba .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_effbd .Column ,_effbd .RowIdx );return _ba .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_cfdc .Name (),_gcd ,_gdga );};

// X returns the inner wrapped XML type.
func (_gd Border )X ()*_ad .CT_Border {return _gd ._ecg };

// IsNumber returns true if the cell is a number type cell.
func (_ceaa Cell )IsNumber ()bool {switch _ceaa ._abg .TAttr {case _ad .ST_CellTypeN :return true ;case _ad .ST_CellTypeS ,_ad .ST_CellTypeB :return false ;};return _ceaa ._abg .V !=nil &&_gf .IsNumber (*_ceaa ._abg .V );};

// X returns the inner wrapped XML type.
func (_adb Font )X ()*_ad .CT_Font {return _adb ._fcgcc };

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_gfcd *_ab .CT_OneCellAnchor };

// Border is a cell border configuraton.
type Border struct{_ecg *_ad .CT_Border ;_bg *_ad .CT_Borders ;};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_ccgeg *Sheet )GetDrawing ()(*_ab .WsDr ,_fa .Relationships ){if _agcg :=_ccgeg ._dbfc .Drawing ;_agcg !=nil {_fcdd :=0;for _ ,_fegc :=range _ccgeg ._ffec ._ebag {if _bab :=_fegc .Drawing ;_bab !=nil {if _fegc ==_ccgeg ._dbfc {return _ccgeg ._ffec ._ggbb [_fcdd ],_ccgeg ._ffec ._fbae [_fcdd ];};_fcdd ++;};};};return nil ,_fa .Relationships {};};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_edbc *Sheet )RemoveMergedCell (mc MergedCell ){for _feae ,_cgef :=range _edbc ._dbfc .MergeCells .MergeCell {if _cgef ==mc .X (){copy (_edbc ._dbfc .MergeCells .MergeCell [_feae :],_edbc ._dbfc .MergeCells .MergeCell [_feae +1:]);_edbc ._dbfc .MergeCells .MergeCell [len (_edbc ._dbfc .MergeCells .MergeCell )-1]=nil ;_edbc ._dbfc .MergeCells .MergeCell =_edbc ._dbfc .MergeCells .MergeCell [:len (_edbc ._dbfc .MergeCells .MergeCell )-1];};};};

// HasFormula returns true if the cell contains formula.
func (_bag *evalContext )HasFormula (cellRef string )bool {return _bag ._gccf .Cell (cellRef ).HasFormula ();};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_cdd AbsoluteAnchor )SetRowOffset (m _gb .Distance ){_cdd ._aa .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_gb .EMU ));};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_acf Comment )CellReference ()string {return _acf ._gdd .RefAttr };

// SetConditionValue sets the condition value to be used for style applicaton.
func (_egb ConditionalFormattingRule )SetConditionValue (v string ){_egb ._fgd .Formula =[]string {v }};

// SetSize sets the text size for a rich text run.
func (_bge RichTextRun )SetSize (m _gb .Distance ){_bge .ensureRpr ();_bge ._dbec .RPr .Sz =_ad .NewCT_FontSize ();_bge ._dbec .RPr .Sz .ValAttr =float64 (m /_gb .Point );};

// SetRow set the row of the cell marker.
func (_fca CellMarker )SetRow (row int32 ){_fca ._dcc .Row =row };var _cbd =_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0);

// SetHidden marks the defined name as hidden.
func (_gdcb DefinedName )SetLocalSheetID (id uint32 ){_gdcb ._dagf .LocalSheetIdAttr =_f .Uint32 (id )};

// Workbook returns sheet's parent workbook.
func (_ggdg *Sheet )Workbook ()*Workbook {return _ggdg ._ffec };

// GetFormat sets the number format code.
func (_eefd NumberFormat )GetFormat ()string {return _eefd ._ccdf .FormatCodeAttr };const (DVCompareOpEqual =DVCompareOp (_ad .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_ad .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_ad .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ad .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ad .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_ad .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_ad .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ad .ST_DataValidationOperatorLessThanOrEqual ););

// SetAllowBlank controls if blank values are accepted.
func (_bafe DataValidation )SetAllowBlank (b bool ){if !b {_bafe ._ebef .AllowBlankAttr =nil ;}else {_bafe ._ebef .AllowBlankAttr =_f .Bool (true );};};

// SetTopLeft sets the top left visible cell after the split.
func (_bdad SheetView )SetTopLeft (cellRef string ){_bdad .ensurePane ();_bdad ._deeg .Pane .TopLeftCellAttr =&cellRef ;};func (_badb Sheet )IsValid ()bool {return _badb ._dbfc !=nil };

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_bbab *_ad .Sst ;_efda map[string ]int ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_cgfb IconScale )AddFormatValue (t _ad .ST_CfvoType ,val string ){_gfd :=_ad .NewCT_Cfvo ();_gfd .TypeAttr =t ;_gfd .ValAttr =_f .String (val );_cgfb ._gaac .Cfvo =append (_cgfb ._gaac .Cfvo ,_gfd );};

// SetColor sets teh color of the databar.
func (_acd DataBarScale )SetColor (c _ebb .Color ){_acd ._aeb .Color =_ad .NewCT_Color ();_acd ._aeb .Color .RgbAttr =c .AsRGBAString ();};func _bbcg ()*_ab .CT_OneCellAnchor {_bdfg :=_ab .NewCT_OneCellAnchor ();return _bdfg };

// ClearProtection clears all workbook protections.
func (_dcgbg *Workbook )ClearProtection (){_dcgbg ._aeaf .WorkbookProtection =nil };func (_fde CellStyle )Index ()uint32 {for _cgff ,_bcd :=range _fde ._ggff .Xf {if _fde ._cff ==_bcd {return uint32 (_cgff );};};return 0;};

// AddFormatValue adds a format value (databars require two).
func (_bffb DataBarScale )AddFormatValue (t _ad .ST_CfvoType ,val string ){_dffg :=_ad .NewCT_Cfvo ();_dffg .TypeAttr =t ;_dffg .ValAttr =_f .String (val );_bffb ._aeb .Cfvo =append (_bffb ._aeb .Cfvo ,_dffg );};

// ColOffset returns the offset from the row cell.
func (_daec CellMarker )ColOffset ()_gb .Distance {if _daec ._dcc .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _gb .Distance (float64 (*_daec ._dcc .ColOff .ST_CoordinateUnqualified )*_gb .EMU );};

// SetBorder applies a border to a cell style. The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_fcb CellStyle )SetBorder (b Border ){_fcb ._cff .BorderIdAttr =_f .Uint32 (b .Index ());_fcb ._cff .ApplyBorderAttr =_f .Bool (true );};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// X returns the inner wrapped XML type.
func (_dbbf MergedCell )X ()*_ad .CT_MergeCell {return _dbbf ._efag };

// ClearFont clears any font configuration from the cell style.
func (_fcf CellStyle )ClearFont (){_fcf ._cff .FontIdAttr =nil ;_fcf ._cff .ApplyFontAttr =nil };func (_fcae Fills )AddFill ()Fill {_ddeg :=_ad .NewCT_Fill ();_fcae ._gefe .Fill =append (_fcae ._gefe .Fill ,_ddeg );_fcae ._gefe .CountAttr =_f .Uint32 (uint32 (len (_fcae ._gefe .Fill )));return Fill {_ddeg ,_fcae ._gefe };};

// X returns the inner wrapped XML type.
func (_eda IconScale )X ()*_ad .CT_IconSet {return _eda ._gaac };

// Row returns the row of the cell marker.
func (_eebg CellMarker )Row ()int32 {return _eebg ._dcc .Row };

// SetPassword sets the password hash to a hash of the input password.
func (_eebe WorkbookProtection )SetPassword (pw string ){_eebe .SetPasswordHash (PasswordHash (pw ))};func (_gece Cell )GetRawValue ()(string ,error ){switch _gece ._abg .TAttr {case _ad .ST_CellTypeInlineStr :if _gece ._abg .Is ==nil ||_gece ._abg .Is .T ==nil {return "",nil ;};return *_gece ._abg .Is .T ,nil ;case _ad .ST_CellTypeS :if _gece ._abg .V ==nil {return "",nil ;};_efdb ,_fag :=_ga .Atoi (*_gece ._abg .V );if _fag !=nil {return "",_fag ;};return _gece ._bgf .SharedStrings .GetString (_efdb );case _ad .ST_CellTypeStr :if _gece ._abg .F !=nil {return _gece ._abg .F .Content ,nil ;};};if _gece ._abg .V ==nil {return "",nil ;};return *_gece ._abg .V ,nil ;};

// SetHidden marks the defined name as hidden.
func (_bbdc DefinedName )SetHidden (b bool ){_bbdc ._dagf .HiddenAttr =_f .Bool (b )};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_gc Cell )GetString ()string {switch _gc ._abg .TAttr {case _ad .ST_CellTypeInlineStr :if _gc ._abg .Is !=nil &&_gc ._abg .Is .T !=nil {return *_gc ._abg .Is .T ;};if _gc ._abg .V !=nil {return *_gc ._abg .V ;};case _ad .ST_CellTypeS :if _gc ._abg .V ==nil {return "";};_efd ,_cgbe :=_ga .Atoi (*_gc ._abg .V );if _cgbe !=nil {return "";};_dca ,_cgbe :=_gc ._bgf .SharedStrings .GetString (_efd );if _cgbe !=nil {return "";};return _dca ;};if _gc ._abg .V ==nil {return "";};return *_gc ._abg .V ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_bgd *Sheet )ClearCachedFormulaResults (){for _ ,_ebdg :=range _bgd .Rows (){for _ ,_caceb :=range _ebdg .Cells (){if _caceb .X ().F !=nil {_caceb .X ().V =nil ;};};};};

// AddGradientStop adds a color gradient stop.
func (_bbda ColorScale )AddGradientStop (color _ebb .Color ){_dda :=_ad .NewCT_Color ();_dda .RgbAttr =color .AsRGBAString ();_bbda ._fce .Color =append (_bbda ._fce .Color ,_dda );};

// IsStructureLocked returns whether the workbook structure is locked.
func (_eagg WorkbookProtection )IsStructureLocked ()bool {return _eagg ._gaga .LockStructureAttr !=nil &&*_eagg ._gaga .LockStructureAttr ;};

// SetWidthCells is a no-op.
func (_ef AbsoluteAnchor )SetWidthCells (int32 ){};

// GetEpoch returns a workbook's time epoch.
func (_gef *evalContext )GetEpoch ()_feb .Time {return _gef ._gccf ._ffec .Epoch ()};

// RowOffset returns the offset from the row cell.
func (_gag CellMarker )RowOffset ()_gb .Distance {if _gag ._dcc .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _gb .Distance (float64 (*_gag ._dcc .RowOff .ST_CoordinateUnqualified )*_gb .EMU );};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ebg ColorScale )AddFormatValue (t _ad .ST_CfvoType ,val string ){_baaa :=_ad .NewCT_Cfvo ();_baaa .TypeAttr =t ;_baaa .ValAttr =_f .String (val );_ebg ._fce .Cfvo =append (_ebg ._fce .Cfvo ,_baaa );};func (_ebgf Fill )SetPatternFill ()PatternFill {_ebgf ._dfef .GradientFill =nil ;_ebgf ._dfef .PatternFill =_ad .NewCT_PatternFill ();_ebgf ._dfef .PatternFill .PatternTypeAttr =_ad .ST_PatternTypeSolid ;return PatternFill {_ebgf ._dfef .PatternFill ,_ebgf ._dfef };};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_edfa *Sheet )Column (idx uint32 )Column {for _ ,_abfa :=range _edfa ._dbfc .Cols {for _ ,_adce :=range _abfa .Col {if idx >=_adce .MinAttr &&idx <=_adce .MaxAttr {return Column {_adce };};};};var _dbgb *_ad .CT_Cols ;if len (_edfa ._dbfc .Cols )==0{_dbgb =_ad .NewCT_Cols ();_edfa ._dbfc .Cols =append (_edfa ._dbfc .Cols ,_dbgb );}else {_dbgb =_edfa ._dbfc .Cols [0];};_babc :=_ad .NewCT_Col ();_babc .MinAttr =idx ;_babc .MaxAttr =idx ;_dbgb .Col =append (_dbgb .Col ,_babc );return Column {_babc };};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_ggfd *Workbook ;_cff *_ad .CT_Xf ;_ggff *_ad .CT_CellXfs ;};

// Priority returns the rule priority
func (_ebf ConditionalFormattingRule )Priority ()int32 {return _ebf ._fgd .PriorityAttr };

// ClearNumberFormat removes any number formatting from the style.
func (_egc CellStyle )ClearNumberFormat (){_egc ._cff .NumFmtIdAttr =nil ;_egc ._cff .ApplyNumberFormatAttr =nil ;};func (_ccc PatternFill )X ()*_ad .CT_PatternFill {return _ccc ._gdcg };

// SetError sets the cell type to error and the value to the given error message.
func (_fcc Cell )SetError (msg string ){_fcc .clearValue ();_fcc ._abg .V =_f .String (msg );_fcc ._abg .TAttr =_ad .ST_CellTypeE ;};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_fbb ConditionalFormattingRule )SetColorScale ()ColorScale {_fbb .clear ();_fbb .SetType (_ad .ST_CfTypeColorScale );_fbb ._fgd .ColorScale =_ad .NewCT_ColorScale ();return ColorScale {_fbb ._fgd .ColorScale };};

// Sheet is a single sheet within a workbook.
type Sheet struct{_ffec *Workbook ;_dgc *_ad .CT_Sheet ;_dbfc *_ad .Worksheet ;};

// ClearFill clears any fill configuration from the cell style.
func (_agbg CellStyle )ClearFill (){_agbg ._cff .FillIdAttr =nil ;_agbg ._cff .ApplyFillAttr =nil };type ConditionalFormattingRule struct{_fgd *_ad .CT_CfRule };

// IsWindowLocked returns whether the workbook windows are locked.
func (_gefg WorkbookProtection )IsWindowLocked ()bool {return _gefg ._gaga .LockWindowsAttr !=nil &&*_gefg ._gaga .LockWindowsAttr ;};

// Protection allows control over the workbook protections.
func (_gabd *Workbook )Protection ()WorkbookProtection {if _gabd ._aeaf .WorkbookProtection ==nil {_gabd ._aeaf .WorkbookProtection =_ad .NewCT_WorkbookProtection ();};return WorkbookProtection {_gabd ._aeaf .WorkbookProtection };};func NewPatternFill (fills *_ad .CT_Fills )PatternFill {_ceaf :=_ad .NewCT_Fill ();_ceaf .PatternFill =_ad .NewCT_PatternFill ();return PatternFill {_ceaf .PatternFill ,_ceaf };};func (_bdbc Row )renumberAs (_afce uint32 ){_bdbc ._eaecd .RAttr =_f .Uint32 (_afce );for _ ,_ffba :=range _bdbc .Cells (){_ceaaf ,_afec :=_fec .ParseCellReference (_ffba .Reference ());if _afec ==nil {_ffcg :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",_ceaaf .Column ,_afce );_ffba ._abg .RAttr =_f .String (_ffcg );};};};

// IsHidden returns whether the row is hidden or not.
func (_bba Row )IsHidden ()bool {return _bba ._eaecd .HiddenAttr !=nil &&*_bba ._eaecd .HiddenAttr };

// X returns the inner wrapped XML type.
func (_fadcf ConditionalFormattingRule )X ()*_ad .CT_CfRule {return _fadcf ._fgd };

// SetUnderline controls if the run is underlined.
func (_afc RichTextRun )SetUnderline (u _ad .ST_UnderlineValues ){_afc .ensureRpr ();_afc ._dbec .RPr .U =_ad .NewCT_UnderlineProperty ();_afc ._dbec .RPr .U .ValAttr =u ;};func (_afea *Workbook )ensureSharedStringsRelationships (){_cegbb :=false ;for _ ,_cacd :=range _afea .ContentTypes .X ().Override {if _cacd .ContentTypeAttr ==_f .SharedStringsContentType {_cegbb =true ;break ;};};if !_cegbb {_afea .ContentTypes .AddOverride (_cbd ,_f .SharedStringsContentType );};_abca :=false ;for _ ,_egbe :=range _afea ._bdgd .Relationships (){if _egbe .X ().TargetAttr ==_fdbg {_abca =true ;break ;};};if !_abca {_afea ._bdgd .AddRelationship (_fdbg ,_f .SharedStringsType );};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_egbef *Workbook )GetFilename ()string {return _egbef ._edbfe };

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_cgcf *Workbook )Epoch ()_feb .Time {if _cgcf .Uses1904Dates (){_feb .Date (1904,1,1,0,0,0,0,_feb .UTC );};return _feb .Date (1899,12,30,0,0,0,0,_feb .UTC );};func (_ddadd Font )SetItalic (b bool ){if b {_ddadd ._fcgcc .I =[]*_ad .CT_BooleanProperty {{}};}else {_ddadd ._fcgcc .I =nil ;};};

// HasFormula returns true if the cell has an asoociated formula.
func (_fbad Cell )HasFormula ()bool {return _fbad ._abg .F !=nil };

// X returns the inner wrapped XML type.
func (_ega RichTextRun )X ()*_ad .CT_RElt {return _ega ._dbec };

// AddString adds a string to the shared string cache.
func (_dgfc SharedStrings )AddString (v string )int {if _bbff ,_gfde :=_dgfc ._efda [v ];_gfde {return _bbff ;};_cfe :=_ad .NewCT_Rst ();_cfe .T =_f .String (v );_dgfc ._bbab .Si =append (_dgfc ._bbab .Si ,_cfe );_cbcbc :=len (_dgfc ._bbab .Si )-1;_dgfc ._efda [v ]=_cbcbc ;_dgfc ._bbab .CountAttr =_f .Uint32 (uint32 (len (_dgfc ._bbab .Si )));_dgfc ._bbab .UniqueCountAttr =_dgfc ._bbab .CountAttr ;return _cbcbc ;};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_abdee *Workbook )Uses1904Dates ()bool {if _abdee ._aeaf .WorkbookPr ==nil ||_abdee ._aeaf .WorkbookPr .Date1904Attr ==nil {return false ;};return *_abdee ._aeaf .WorkbookPr .Date1904Attr ;};var _cdga *_bb .Regexp =_bb .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// RemoveSheet removes the sheet with the given index from the workbook.
func (_ceeg *Workbook )RemoveSheet (ind int )error {if _ceeg .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_fgde :=range _ceeg ._bdgd .Relationships (){if _fgde .ID ()==_ceeg ._aeaf .Sheets .Sheet [ind ].IdAttr {_ceeg ._bdgd .Remove (_fgde );break ;};};_ceeg .ContentTypes .RemoveOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1));copy (_ceeg ._ebag [ind :],_ceeg ._ebag [ind +1:]);_ceeg ._ebag =_ceeg ._ebag [:len (_ceeg ._ebag )-1];_aacg :=_ceeg ._aeaf .Sheets .Sheet [ind ];copy (_ceeg ._aeaf .Sheets .Sheet [ind :],_ceeg ._aeaf .Sheets .Sheet [ind +1:]);_ceeg ._aeaf .Sheets .Sheet =_ceeg ._aeaf .Sheets .Sheet [:len (_ceeg ._aeaf .Sheets .Sheet )-1];for _dddd :=range _ceeg ._aeaf .Sheets .Sheet {if _ceeg ._aeaf .Sheets .Sheet [_dddd ].SheetIdAttr > _aacg .SheetIdAttr {_ceeg ._aeaf .Sheets .Sheet [_dddd ].SheetIdAttr --;};};copy (_ceeg ._bced [ind :],_ceeg ._bced [ind +1:]);_ceeg ._bced =_ceeg ._bced [:len (_ceeg ._bced )-1];copy (_ceeg ._febe [ind :],_ceeg ._febe [ind +1:]);_ceeg ._febe =_ceeg ._febe [:len (_ceeg ._febe )-1];return nil ;};

// Wrapped returns true if the cell will wrap text.
func (_dbd CellStyle )Wrapped ()bool {if _dbd ._cff .Alignment ==nil {return false ;};if _dbd ._cff .Alignment .WrapTextAttr ==nil {return false ;};return *_dbd ._cff .Alignment .WrapTextAttr ;};

// SetHeightCells is a no-op.
func (_egbf OneCellAnchor )SetHeightCells (int32 ){};func _eaec (_gad string )bool {_gad =_ff .Replace (_gad ,"\u0024","",-1);if _aea :=_cdga .FindStringSubmatch (_ff .ToLower (_gad ));len (_aea )> 2{_afee :=_aea [1];_bgaa ,_bgbg :=_ga .Atoi (_aea [2]);if _bgbg !=nil {return false ;};return _bgaa <=1048576&&_afee <="\u007a\u007a";};return false ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_eac Row )RowNumber ()uint32 {if _eac ._eaecd .RAttr !=nil {return *_eac ._eaecd .RAttr ;};return 0;};

// Name returns the sheet name
func (_egea Sheet )Name ()string {return _egea ._dgc .NameAttr };

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// LockStructure controls the locking of the workbook structure.
func (_eadgb WorkbookProtection )LockStructure (b bool ){if !b {_eadgb ._gaga .LockStructureAttr =nil ;}else {_eadgb ._gaga .LockStructureAttr =_f .Bool (true );};};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cbcbb *Workbook )ClearCachedFormulaResults (){for _ ,_ecdcb :=range _cbcbb .Sheets (){_ecdcb .ClearCachedFormulaResults ();};};

// BottomRight is a no-op.
func (_bf AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_fa .DocBase ;_aeaf *_ad .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_febe []*_ad .Comments ;_ebag []*_ad .Worksheet ;_bced []_fa .Relationships ;_bdgd _fa .Relationships ;_ecgeb []*_cb .Theme ;_ggbb []*_ab .WsDr ;_fbae []_fa .Relationships ;_addg []*_ce .Container ;_fefd []*_da .ChartSpace ;_dbge []*_ad .Table ;_edbfe string ;_efadg map[string ]string ;_agdb map[string ]*_da .ChartSpace ;_eedd string ;};

// SetName sets the sheet name.
func (_adf *Sheet )SetName (name string ){_adf ._dgc .NameAttr =name };

// X returns the inner wrapped XML type.
func (_cbed Table )X ()*_ad .Table {return _cbed ._edcd };

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_agcab *Workbook )RemoveSheetByName (name string )error {_feff :=-1;for _fdg ,_gcbf :=range _agcab .Sheets (){if name ==_gcbf .Name (){_feff =_fdg ;break ;};};if _feff ==-1{return ErrorNotFound ;};return _agcab .RemoveSheet (_feff );};func (_bcae Sheet )validateSheetNames ()error {if len (_bcae .Name ())> 31{return _ba .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_bcae .Name (),len (_bcae .Name ()));};return nil ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_gfca *evalContext )GetLabelPrefix (cellRef string )string {return _gfca ._gccf .Cell (cellRef ).getLabelPrefix ();};

// GetValueAsNumber retrieves the cell's value as a number
func (_cfa Cell )GetValueAsNumber ()(float64 ,error ){if _cfa ._abg .V ==nil &&_cfa ._abg .Is ==nil {return 0,nil ;};if _cfa ._abg .TAttr ==_ad .ST_CellTypeS ||!_gf .IsNumber (*_cfa ._abg .V ){return _fed .NaN (),_fgc .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _ga .ParseFloat (*_cfa ._abg .V ,64);};var _fdbg =_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0);

// X returns the inner XML entity for a stylesheet.
func (_egfb StyleSheet )X ()*_ad .StyleSheet {return _egfb ._gagf };

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_ebbf DataValidation )SetRange (cellRange string ){_ebbf ._ebef .SqrefAttr =_ad .ST_Sqref {cellRange };};

// SetWrapped configures the cell to wrap text.
func (_bga CellStyle )SetWrapped (b bool ){if _bga ._cff .Alignment ==nil {_bga ._cff .Alignment =_ad .NewCT_CellAlignment ();};if !b {_bga ._cff .Alignment .WrapTextAttr =nil ;}else {_bga ._cff .Alignment .WrapTextAttr =_f .Bool (true );_bga ._cff .ApplyAlignmentAttr =_f .Bool (true );};};

// SetFont sets the font name for a rich text run.
func (_eaece RichTextRun )SetFont (s string ){_eaece .ensureRpr ();_eaece ._dbec .RPr .RFont =_ad .NewCT_FontName ();_eaece ._dbec .RPr .RFont .ValAttr =s ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_eafb StyleSheet )AddNumberFormat ()NumberFormat {if _eafb ._gagf .NumFmts ==nil {_eafb ._gagf .NumFmts =_ad .NewCT_NumFmts ();};_bcbg :=_ad .NewCT_NumFmt ();_bcbg .NumFmtIdAttr =uint32 (200+len (_eafb ._gagf .NumFmts .NumFmt ));_eafb ._gagf .NumFmts .NumFmt =append (_eafb ._gagf .NumFmts .NumFmt ,_bcbg );_eafb ._gagf .NumFmts .CountAttr =_f .Uint32 (uint32 (len (_eafb ._gagf .NumFmts .NumFmt )));return NumberFormat {_eafb ._geecg ,_bcbg };};

// SetStyle sets the style to be used for conditional rules
func (_ecf ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_ecf ._fgd .DxfIdAttr =_f .Uint32 (d .Index ());};

// SetWidth sets the width of the anchored object.
func (_afaf OneCellAnchor )SetWidth (w _gb .Distance ){_afaf ._gfcd .Ext .CxAttr =int64 (w /_gb .EMU )};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_caa Border )InitializeDefaults (){_caa ._ecg .Left =_ad .NewCT_BorderPr ();_caa ._ecg .Bottom =_ad .NewCT_BorderPr ();_caa ._ecg .Right =_ad .NewCT_BorderPr ();_caa ._ecg .Top =_ad .NewCT_BorderPr ();_caa ._ecg .Diagonal =_ad .NewCT_BorderPr ();};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_gdf CellStyle )SetNumberFormatStandard (s StandardFormat ){_gdf ._cff .NumFmtIdAttr =_f .Uint32 (uint32 (s ));_gdf ._cff .ApplyNumberFormatAttr =_f .Bool (true );};func (_db Border )SetLeft (style _ad .ST_BorderStyle ,c _ebb .Color ){if _db ._ecg .Left ==nil {_db ._ecg .Left =_ad .NewCT_BorderPr ();};_db ._ecg .Left .Color =_ad .NewCT_Color ();_db ._ecg .Left .Color .RgbAttr =c .AsRGBAString ();_db ._ecg .Left .StyleAttr =style ;};func NewFills ()Fills {return Fills {_ad .NewCT_Fills ()}};

// GetValueAsBool retrieves the cell's value as a boolean
func (_dbf Cell )GetValueAsBool ()(bool ,error ){if _dbf ._abg .TAttr !=_ad .ST_CellTypeB {return false ,_fgc .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _dbf ._abg .V ==nil {return false ,_fgc .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _ga .ParseBool (*_dbf ._abg .V );};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_fcgcc *_ad .CT_Font ;_ccaa *_ad .StyleSheet ;};

// Type returns the type of anchor
func (_fb AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// X returns the inner wrapped XML type.
func (_febc NumberFormat )X ()*_ad .CT_NumFmt {return _febc ._ccdf };const (DVOpGreater =_ad .ST_DataValidationOperatorGreaterThanOrEqual ;);const _eafe ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// Row is a row within a spreadsheet.
type Row struct{_adbg *Workbook ;_gdae *Sheet ;_eaecd *_ad .CT_Row ;};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_gcff TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_gcff ._deac .To }};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// SetPattern sets the pattern of the fill.
func (_eecc PatternFill )SetPattern (p _ad .ST_PatternType ){_eecc ._gdcg .PatternTypeAttr =p };

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_cbbge *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _cbbge .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _dadd _fa .Relationship ;for _ ,_abaf :=range _cbbge ._bdgd .Relationships (){if _abaf .ID ()==_cbbge ._aeaf .Sheets .Sheet [ind ].IdAttr {var _efcf bool ;if _dadd ,_efcf =_cbbge ._bdgd .CopyRelationship (_abaf .ID ());!_efcf {return Sheet {},ErrorNotFound ;};break ;};};_cbbge .ContentTypes .CopyOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,ind +1),_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .WorksheetContentType ,len (_cbbge .ContentTypes .X ().Override )));_gdbefe :=*_cbbge ._ebag [ind ];_cbbge ._ebag =append (_cbbge ._ebag ,&_gdbefe );var _dbda uint32 =0;for _ ,_cgbac :=range _cbbge ._aeaf .Sheets .Sheet {if _cgbac .SheetIdAttr > _dbda {_dbda =_cgbac .SheetIdAttr ;};};_dbda ++;_agedd :=*_cbbge ._aeaf .Sheets .Sheet [ind ];_agedd .IdAttr =_dadd .ID ();_agedd .NameAttr =copiedSheetName ;_agedd .SheetIdAttr =_dbda ;_cbbge ._aeaf .Sheets .Sheet =append (_cbbge ._aeaf .Sheets .Sheet ,&_agedd );_cdfb :=_fa .NewRelationshipsCopy (_cbbge ._bced [ind ]);_cbbge ._bced =append (_cbbge ._bced ,_cdfb );_ecdc :=_cbbge ._febe [ind ];if _ecdc ==nil {_cbbge ._febe =append (_cbbge ._febe ,nil );}else {_dgdc :=*_ecdc ;_cbbge ._febe =append (_cbbge ._febe ,&_dgdc );};_abcg :=Sheet {_cbbge ,&_agedd ,&_gdbefe };return _abcg ,nil ;};type evalContext struct{_gccf *Sheet ;_gfad ,_efg uint32 ;_faa map[string ]struct{};};

// Sheets returns the sheets from the workbook.
func (_ecag *Workbook )Sheets ()[]Sheet {_fecdg :=[]Sheet {};for _ffca ,_gfbb :=range _ecag ._ebag {_ecce :=_ecag ._aeaf .Sheets .Sheet [_ffca ];_ceab :=Sheet {_ecag ,_ecce ,_gfbb };_fecdg =append (_fecdg ,_ceab );};return _fecdg ;};

// X returns the inner wrapped XML type.
func (_fcab DataValidation )X ()*_ad .CT_DataValidation {return _fcab ._ebef };

// Content returns the content of the defined range (the range in most cases)/
func (_fbaa DefinedName )Content ()string {return _fbaa ._dagf .Content };

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_gcg CellStyle )SetProtection (protected bool ,hidden bool ){_gcg ._cff .Protection =&_ad .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};type MergedCell struct{_caced *Workbook ;_bac *Sheet ;_efag *_ad .CT_MergeCell ;};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_aa *_ab .CT_AbsoluteAnchor };

// GetString retrieves a string from the shared strings table by index.
func (_acg SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ba .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_acg ._bbab .Si ){return "",_ba .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_acg ._bbab .Si ));};_fgcf :=_acg ._bbab .Si [id ];if _fgcf .T !=nil {return *_fgcf .T ,nil ;};return "",nil ;};

// LockObject controls the locking of the sheet objects.
func (_beba SheetProtection )LockObject (b bool ){if !b {_beba ._egeag .ObjectsAttr =nil ;}else {_beba ._egeag .ObjectsAttr =_f .Bool (true );};};

// SetHeightCells is a no-op.
func (_aag AbsoluteAnchor )SetHeightCells (int32 ){};

// Column returns the cell column
func (_eba Cell )Column ()(string ,error ){_aaf ,_bgb :=_fec .ParseCellReference (_eba .Reference ());if _bgb !=nil {return "",_bgb ;};return _aaf .Column ,nil ;};func (_cfc Cell )clearValue (){_cfc ._abg .F =nil ;_cfc ._abg .Is =nil ;_cfc ._abg .V =nil ;_cfc ._abg .TAttr =_ad .ST_CellTypeUnset ;};

// AddDataValidation adds a data validation rule to a sheet.
func (_ecc *Sheet )AddDataValidation ()DataValidation {if _ecc ._dbfc .DataValidations ==nil {_ecc ._dbfc .DataValidations =_ad .NewCT_DataValidations ();};_gefa :=_ad .NewCT_DataValidation ();_gefa .ShowErrorMessageAttr =_f .Bool (true );_ecc ._dbfc .DataValidations .DataValidation =append (_ecc ._dbfc .DataValidations .DataValidation ,_gefa );_ecc ._dbfc .DataValidations .CountAttr =_f .Uint32 (uint32 (len (_ecc ._dbfc .DataValidations .DataValidation )));return DataValidation {_gefa };};func (_fc Border )SetBottom (style _ad .ST_BorderStyle ,c _ebb .Color ){if _fc ._ecg .Bottom ==nil {_fc ._ecg .Bottom =_ad .NewCT_BorderPr ();};_fc ._ecg .Bottom .Color =_ad .NewCT_Color ();_fc ._ecg .Bottom .Color .RgbAttr =c .AsRGBAString ();_fc ._ecg .Bottom .StyleAttr =style ;};func (_cffa *evalContext )SetOffset (col ,row uint32 ){_cffa ._gfad =col ;_cffa ._efg =row };

// Reference returns the region of cells that are merged.
func (_efcd MergedCell )Reference ()string {return _efcd ._efag .RefAttr };

// GetWidth returns a worksheet's column width.
func (_ccg *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_ecgg :=range _ccg ._gccf .X ().Cols [0].Col {if int (_ecgg .MinAttr )<=colIdx &&colIdx <=int (_ecgg .MaxAttr ){return float64 (int (*_ecgg .WidthAttr ));};};return 0;};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_abe Cell )SetBool (v bool ){_abe .clearValue ();_abe ._abg .V =_f .String (_ga .Itoa (_dag (v )));_abe ._abg .TAttr =_ad .ST_CellTypeB ;};

// SetShowRuler controls the visibility of the ruler
func (_geef SheetView )SetShowRuler (b bool ){if !b {_geef ._deeg .ShowRulerAttr =_f .Bool (false );}else {_geef ._deeg .ShowRulerAttr =nil ;};};

// Author returns the author of the comment
func (_dggd Comment )Author ()string {if _dggd ._gdd .AuthorIdAttr < uint32 (len (_dggd ._gce .Authors .Author )){return _dggd ._gce .Authors .Author [_dggd ._gdd .AuthorIdAttr ];};return "";};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_bgce *Sheet )SetDrawing (d Drawing ){var _ceff _fa .Relationships ;for _bcfa ,_ccf :=range _bgce ._ffec ._ebag {if _ccf ==_bgce ._dbfc {_ceff =_bgce ._ffec ._bced [_bcfa ];break ;};};var _dacd string ;for _adfa ,_dge :=range d ._eaa ._ggbb {if _dge ==d ._geff {_cfb :=_ceff .AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_adfa +1,_f .DrawingType );_dacd =_cfb .ID ();break ;};};_bgce ._dbfc .Drawing =_ad .NewCT_Drawing ();_bgce ._dbfc .Drawing .IdAttr =_dacd ;};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_bdb DataValidationCompare )SetValue (v string ){_bdb ._daba .Formula1 =&v };

// SetNumber sets the cell type to number, and the value to the given number
func (_daa Cell )SetNumber (v float64 ){_daa .clearValue ();if _fed .IsNaN (v )||_fed .IsInf (v ,0){_daa ._abg .TAttr =_ad .ST_CellTypeE ;_daa ._abg .V =_f .String ("\u0023\u004e\u0055M\u0021");return ;};_daa ._abg .TAttr =_ad .ST_CellTypeN ;_daa ._abg .V =_f .String (_ga .FormatFloat (v ,'f',-1,64));};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_fgba :=_ad .NewStyleSheet ();_fgba .CellStyleXfs =_ad .NewCT_CellStyleXfs ();_fgba .CellXfs =_ad .NewCT_CellXfs ();_fgba .CellStyles =_ad .NewCT_CellStyles ();_accg :=_ad .NewCT_CellStyle ();_accg .NameAttr =_f .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_accg .XfIdAttr =0;_accg .BuiltinIdAttr =_f .Uint32 (0);_fgba .CellStyles .CellStyle =append (_fgba .CellStyles .CellStyle ,_accg );_fgba .CellStyles .CountAttr =_f .Uint32 (uint32 (len (_fgba .CellStyles .CellStyle )));_ffbf :=_ad .NewCT_Xf ();_ffbf .NumFmtIdAttr =_f .Uint32 (0);_ffbf .FontIdAttr =_f .Uint32 (0);_ffbf .FillIdAttr =_f .Uint32 (0);_ffbf .BorderIdAttr =_f .Uint32 (0);_fgba .CellStyleXfs .Xf =append (_fgba .CellStyleXfs .Xf ,_ffbf );_fgba .CellStyleXfs .CountAttr =_f .Uint32 (uint32 (len (_fgba .CellStyleXfs .Xf )));_cfdgb :=NewFills ();_fgba .Fills =_cfdgb .X ();_aefg :=_cfdgb .AddFill ().SetPatternFill ();_aefg .SetPattern (_ad .ST_PatternTypeNone );_aefg =_cfdgb .AddFill ().SetPatternFill ();_aefg .SetPattern (_ad .ST_PatternTypeGray125 );_fgba .Fonts =_ad .NewCT_Fonts ();_fgba .Borders =_ad .NewCT_Borders ();_ccgc :=StyleSheet {wb ,_fgba };_ccgc .AddBorder ().InitializeDefaults ();_fbda :=_ccgc .AddFont ();_fbda .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_fbda .SetSize (11);_bfda :=_ad .NewCT_Xf ();*_bfda =*_ffbf ;_bfda .XfIdAttr =_f .Uint32 (0);_fgba .CellXfs .Xf =append (_fgba .CellXfs .Xf ,_bfda );_fgba .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_fgba .CellXfs .Xf )));return _ccgc ;};

// SetWidth controls the width of a column.
func (_ebca Column )SetWidth (w _gb .Distance ){_ebca ._eede .WidthAttr =_f .Float64 (float64 (w /_gb .Character ));};

// SetIcons sets the icon set to use for display.
func (_gbc IconScale )SetIcons (t _ad .ST_IconSetType ){_gbc ._gaac .IconSetAttr =t };const (DVCompareTypeWholeNumber =DVCompareType (_ad .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_ad .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_ad .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ad .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ad .ST_DataValidationTypeTextLength ););const _aaef ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ddf CellStyle )SetHorizontalAlignment (a _ad .ST_HorizontalAlignment ){if _ddf ._cff .Alignment ==nil {_ddf ._cff .Alignment =_ad .NewCT_CellAlignment ();};_ddf ._cff .Alignment .HorizontalAttr =a ;_ddf ._cff .ApplyAlignmentAttr =_f .Bool (true );};

// IsError returns true if the cell is an error type cell.
func (_dfe Cell )IsError ()bool {return _dfe ._abg .TAttr ==_ad .ST_CellTypeE };func (_bgfe Cell )getRawSortValue ()(string ,bool ){if _bgfe .HasFormula (){_ggg :=_bgfe .GetCachedFormulaResult ();return _ggg ,_gf .IsNumber (_ggg );};_dfa ,_ :=_bgfe .GetRawValue ();return _dfa ,_gf .IsNumber (_dfa );};

// AddSheet adds a new sheet to a workbook.
func (_cfdca *Workbook )AddSheet ()Sheet {_eacb :=_ad .NewCT_Sheet ();_eacb .SheetIdAttr =1;for _ ,_gdab :=range _cfdca ._aeaf .Sheets .Sheet {if _eacb .SheetIdAttr <=_gdab .SheetIdAttr {_eacb .SheetIdAttr =_gdab .SheetIdAttr +1;};};_cfdca ._aeaf .Sheets .Sheet =append (_cfdca ._aeaf .Sheets .Sheet ,_eacb );_eacb .NameAttr =_ba .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_eacb .SheetIdAttr );_baab :=_ad .NewWorksheet ();_baab .Dimension =_ad .NewCT_SheetDimension ();_baab .Dimension .RefAttr ="\u0041\u0031";_cfdca ._ebag =append (_cfdca ._ebag ,_baab );_caeae :=_fa .NewRelationships ();_cfdca ._bced =append (_cfdca ._bced ,_caeae );_baab .SheetData =_ad .NewCT_SheetData ();_cfdca ._febe =append (_cfdca ._febe ,nil );_cgge :=_f .DocTypeSpreadsheet ;_fgcdg :=_cfdca ._bdgd .AddAutoRelationship (_cgge ,_f .OfficeDocumentType ,len (_cfdca ._aeaf .Sheets .Sheet ),_f .WorksheetType );_eacb .IdAttr =_fgcdg .ID ();_cfdca .ContentTypes .AddOverride (_f .AbsoluteFilename (_cgge ,_f .WorksheetContentType ,len (_cfdca ._aeaf .Sheets .Sheet )),_f .WorksheetContentType );return Sheet {_cfdca ,_eacb ,_baab };};func (_dffgg Sheet )validateMergedCells ()error {_dgag :=map[uint64 ]struct{}{};for _ ,_ggfe :=range _dffgg .MergedCells (){_bcfc ,_cecd ,_aefe :=_fec .ParseRangeReference (_ggfe .Reference ());if _aefe !=nil {return _ba .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_dffgg .Name (),_ggfe .Reference ());};for _cbcg :=_bcfc .RowIdx ;_cbcg <=_cecd .RowIdx ;_cbcg ++{for _bggf :=_bcfc .ColumnIdx ;_bggf <=_cecd .ColumnIdx ;_bggf ++{_bfe :=uint64 (_cbcg )<<32|uint64 (_bggf );if _ ,_gdgf :=_dgag [_bfe ];_gdgf {return _ba .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_dffgg .Name ());};_dgag [_bfe ]=struct{}{};};};};return nil ;};

// ClearBorder clears any border configuration from the cell style.
func (_add CellStyle )ClearBorder (){_add ._cff .BorderIdAttr =nil ;_add ._cff .ApplyBorderAttr =nil };type Fills struct{_gefe *_ad .CT_Fills };

// SetCol set the column of the cell marker.
func (_ffcf CellMarker )SetCol (col int32 ){_ffcf ._dcc .Col =col };

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_ffge *Workbook )SetActiveSheet (s Sheet ){for _cgde ,_bceca :=range _ffge ._ebag {if s ._dbfc ==_bceca {_ffge .SetActiveSheetIndex (uint32 (_cgde ));};};};func (_eeec RichTextRun )ensureRpr (){if _eeec ._dbec .RPr ==nil {_eeec ._dbec .RPr =_ad .NewCT_RPrElt ();};};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ecgec Row )AddNamedCell (col string )Cell {_cdee :=_ad .NewCT_Cell ();_cdee .RAttr =_f .Stringf ("\u0025\u0073\u0025\u0064",col ,_ecgec .RowNumber ());_bbdb :=-1;_bcee :=_fec .ColumnToIndex (col );for _fagc ,_cefe :=range _ecgec ._eaecd .C {_eeee ,_aeef :=_fec .ParseCellReference (*_cefe .RAttr );if _aeef !=nil {return Cell {};};if _bcee < _eeee .ColumnIdx {_bbdb =_fagc ;break ;};};if _bbdb ==-1{_ecgec ._eaecd .C =append (_ecgec ._eaecd .C ,_cdee );}else {_ecgec ._eaecd .C =append (_ecgec ._eaecd .C [:_bbdb ],append ([]*_ad .CT_Cell {_cdee },_ecgec ._eaecd .C [_bbdb :]...)...);};return Cell {_ecgec ._adbg ,_ecgec ._gdae ,_ecgec ._eaecd ,_cdee };};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_gdea *Workbook )Close ()error {if _gdea .TmpPath !=""{return _eb .RemoveAll (_gdea .TmpPath );};return nil ;};

// GetFormat returns a cell data format.
func (_eff *evalContext )GetFormat (cellRef string )string {return _eff ._gccf .Cell (cellRef ).getFormat ();};

// IsBool returns true if the cell boolean value.
func (_ddg *evalContext )IsBool (cellRef string )bool {return _ddg ._gccf .Cell (cellRef ).IsBool ()};

// X returns the inner wrapped XML type.
func (_aabc Drawing )X ()*_ab .WsDr {return _aabc ._geff };

// GetFormula returns the formula for a cell.
func (_cbc Cell )GetFormula ()string {if _cbc ._abg .F !=nil {return _cbc ._abg .F .Content ;};return "";};

// SetHeight is a nop-op.
func (_eadd TwoCellAnchor )SetHeight (h _gb .Distance ){};var ErrorNotFound =_fgc .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_gde Cell )SetFormulaRaw (s string ){_fbc :=_cea .ParseString (s );if _fbc ==nil {return ;};_gde .clearValue ();_gde ._abg .TAttr =_ad .ST_CellTypeStr ;_gde ._abg .F =_ad .NewCT_CellFormula ();_gde ._abg .F .Content =s ;};

// TopLeft is a no-op.
func (_bd AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// SetMinLength sets the minimum bar length in percent.
func (_ege DataBarScale )SetMinLength (l uint32 ){_ege ._aeb .MinLengthAttr =_f .Uint32 (l )};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_bec Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _dab ,_agg Cell ;for _ ,_eef :=range lhs .Cells (){_cafc ,_ :=_fec .ParseCellReference (_eef .Reference ());if _cafc .Column ==column {_dab =_eef ;break ;};};for _ ,_ebd :=range rhs .Cells (){_eae ,_ :=_fec .ParseCellReference (_ebd .Reference ());if _eae .Column ==column {_agg =_ebd ;break ;};};return _bec .LessCells (_dab ,_agg );};

// X returns the inner wrapped XML type.
func (_gdbef RichText )X ()*_ad .CT_Rst {return _gdbef ._abfe };

// X returns the inner wrapped XML type.
func (_ddb DataBarScale )X ()*_ad .CT_DataBar {return _ddb ._aeb };

// Name returns the name of the defined name.
func (_eeca DefinedName )Name ()string {return _eeca ._dagf .NameAttr };

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_dcfc *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_efce :=range _dcfc .Sheets (){if _efce .Name ()==name {return _efce ,nil ;};};return Sheet {},ErrorNotFound ;};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_eede *_ad .CT_Col };

// SetHeight sets the height of the anchored object.
func (_abee OneCellAnchor )SetHeight (h _gb .Distance ){_abee ._gfcd .Ext .CyAttr =int64 (h /_gb .EMU )};func (_dcg *Sheet )updateAfterRemove (_abda uint32 ,_edfg _e .UpdateAction )error {_ggee :=_dcg .Name ();_fdbb :=&_e .UpdateQuery {UpdateType :_edfg ,ColumnIdx :_abda ,SheetToUpdate :_ggee };for _ ,_gcb :=range _dcg ._ffec .Sheets (){_fdbb .UpdateCurrentSheet =_ggee ==_gcb .Name ();for _ ,_gddcg :=range _gcb .Rows (){for _ ,_dfbe :=range _gddcg .Cells (){if _dfbe .X ().F !=nil {_cgfa :=_dfbe .X ().F .Content ;_edeeb :=_cea .ParseString (_cgfa );if _edeeb ==nil {_dfbe .SetError ("\u0023\u0052\u0045F\u0021");}else {_acgg :=_edeeb .Update (_fdbb );_dfbe .X ().F .Content =_ba .Sprintf ("\u003d\u0025\u0073",_acgg .String ());};};};};};return nil ;};

// SetColOffset sets the column offset of the two cell anchor.
func (_cdae TwoCellAnchor )SetColOffset (m _gb .Distance ){_fgbd :=m -_cdae .TopLeft ().ColOffset ();_cdae .TopLeft ().SetColOffset (m );_cdae .BottomRight ().SetColOffset (_cdae .BottomRight ().ColOffset ()+_fgbd );};

// SetRowOffset sets the row offset of the top-left anchor.
func (_cbf OneCellAnchor )SetRowOffset (m _gb .Distance ){_cbf .TopLeft ().SetRowOffset (m )};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_dgdce *Workbook )AddImage (i _fa .Image )(_fa .ImageRef ,error ){_defc :=_fa .MakeImageRef (i ,&_dgdce .DocBase ,_dgdce ._bdgd );if i .Data ==nil &&i .Path ==""{return _defc ,_fgc .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _defc ,_fgc .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _defc ,_fgc .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_efdaa :=_eb .Add (i .Path );if _efdaa !=nil {return _defc ,_efdaa ;};};_dgdce .Images =append (_dgdce .Images ,_defc );return _defc ,nil ;};func (_cda Comments )getOrCreateAuthor (_fcd string )uint32 {for _bea ,_bee :=range _cda ._gdbe .Authors .Author {if _bee ==_fcd {return uint32 (_bea );};};_cbe :=uint32 (len (_cda ._gdbe .Authors .Author ));_cda ._gdbe .Authors .Author =append (_cda ._gdbe .Authors .Author ,_fcd );return _cbe ;};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_eaa *Workbook ;_geff *_ab .WsDr ;};var (_eggf =[...]uint8 {0,21,46,61,76,91};_aaae =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_efgc =[...]uint8 {0,16,32,48,64};_cabc =[...]uint8 {0,16,32,48,64,80};);

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_eeed *evalContext )LastRow (col string )int {_gaef :=_eeed ._gccf ;_cgba :=int (_fec .ColumnToIndex (col ));_fcdf :=1;for _ ,_fdeee :=range _gaef ._dbfc .SheetData .Row {if _fdeee .RAttr !=nil {_ccd :=Row {_gaef ._ffec ,_gaef ,_fdeee };_cdb :=len (_ccd .Cells ());if _cdb > _cgba {_fcdf =int (_ccd .RowNumber ());};};};return _fcdf ;};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_dfb Cell )GetValueAsTime ()(_feb .Time ,error ){if _dfb ._abg .TAttr !=_ad .ST_CellTypeUnset {return _feb .Time {},_fgc .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _dfb ._abg .V ==nil {return _feb .Time {},_fgc .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_dga ,_ ,_fcge :=_bbe .ParseFloat (*_dfb ._abg .V ,10,128,_bbe .ToNearestEven );if _fcge !=nil {return _feb .Time {},_fcge ;};_fad :=new (_bbe .Float );_fad .SetUint64 (uint64 (24*_feb .Hour ));_dga .Mul (_dga ,_fad );_gge ,_ :=_dga .Uint64 ();_caf :=_dfb ._bgf .Epoch ().Add (_feb .Duration (_gge ));return _cgb (_caf ),nil ;};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_dgaa StyleSheet )RemoveFont (f Font )error {for _feag ,_bffa :=range _dgaa ._gagf .Fonts .Font {if _bffa ==f .X (){_dgaa ._gagf .Fonts .Font =append (_dgaa ._gagf .Fonts .Font [:_feag ],_dgaa ._gagf .Fonts .Font [_feag +1:]...);return nil ;};};return _fgc .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// SetFont applies a font to a cell style. The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_eed CellStyle )SetFont (f Font ){_eed ._cff .FontIdAttr =_f .Uint32 (f .Index ());_eed ._cff .ApplyFontAttr =_f .Bool (true );};

// AddCell adds a cell to a spreadsheet.
func (_abdd Row )AddCell ()Cell {_dfab :=uint32 (len (_abdd ._eaecd .C ));var _cgbbg *string ;if _dfab > 0{_daeaa :=_f .Stringf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_dfab -1),_abdd .RowNumber ());if _abdd ._eaecd .C [_dfab -1].RAttr !=nil &&*_abdd ._eaecd .C [_dfab -1].RAttr ==*_daeaa {_cgbbg =_f .Stringf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_dfab ),_abdd .RowNumber ());};};_cagb :=_ad .NewCT_Cell ();_abdd ._eaecd .C =append (_abdd ._eaecd .C ,_cagb );if _cgbbg ==nil {_afca :=uint32 (0);for _ ,_fecc :=range _abdd ._eaecd .C {if _fecc .RAttr !=nil {_abdb ,_ :=_fec .ParseCellReference (*_fecc .RAttr );if _abdb .ColumnIdx >=_afca {_afca =_abdb .ColumnIdx +1;};};};_cgbbg =_f .Stringf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_afca ),_abdd .RowNumber ());};_cagb .RAttr =_cgbbg ;return Cell {_abdd ._adbg ,_abdd ._gdae ,_abdd ._eaecd ,_cagb };};

// X returns the inner wrapped XML type.
func (_gbfb WorkbookProtection )X ()*_ad .CT_WorkbookProtection {return _gbfb ._gaga };

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_fabcg *_ad .CT_ConditionalFormatting };

// SetText sets the text to be displayed.
func (_ecfa RichTextRun )SetText (s string ){_ecfa ._dbec .T =s };

// SetReference sets the regin of cells that the merged cell applies to.
func (_fbdg MergedCell )SetReference (ref string ){_fbdg ._efag .RefAttr =ref };

// AnchorType is the type of anchor.
type AnchorType byte ;

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_aaa ConditionalFormattingRule )SetIcons ()IconScale {_aaa .clear ();_aaa .SetType (_ad .ST_CfTypeIconSet );_aaa ._fgd .IconSet =_ad .NewCT_IconSet ();_fegf :=IconScale {_aaa ._fgd .IconSet };_fegf .SetIcons (_ad .ST_IconSetType3TrafficLights1 );return _fegf ;};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_dbec *_ad .CT_RElt };

// X returns the inner wrapped XML type.
func (_fffg ColorScale )X ()*_ad .CT_ColorScale {return _fffg ._fce };

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_bbbb *Sheet )InsertRow (rowNum int )Row {_cae :=uint32 (rowNum );for _ ,_eefe :=range _bbbb .Rows (){if _eefe ._eaecd .RAttr !=nil &&*_eefe ._eaecd .RAttr >=_cae {*_eefe ._eaecd .RAttr ++;for _ ,_fgce :=range _eefe .Cells (){_edce ,_dfad :=_fec .ParseCellReference (_fgce .Reference ());if _dfad !=nil {continue ;};_edce .RowIdx ++;_fgce ._abg .RAttr =_f .String (_edce .String ());};};};for _ ,_bdac :=range _bbbb .MergedCells (){_gagb ,_fdcf ,_eace :=_fec .ParseRangeReference (_bdac .Reference ());if _eace !=nil {continue ;};if int (_gagb .RowIdx )>=rowNum {_gagb .RowIdx ++;};if int (_fdcf .RowIdx )>=rowNum {_fdcf .RowIdx ++;};_ebfe :=_ba .Sprintf ("\u0025\u0073\u003a%\u0073",_gagb ,_fdcf );_bdac .SetReference (_ebfe );};return _bbbb .AddNumberedRow (_cae );};func (_cacg PatternFill )SetBgColor (c _ebb .Color ){_cacg ._gdcg .BgColor =_ad .NewCT_Color ();_cacg ._gdcg .BgColor .RgbAttr =c .AsRGBAString ();};

// New constructs a new workbook.
func New ()*Workbook {_dfbc :=&Workbook {};_dfbc ._aeaf =_ad .NewWorkbook ();_dfbc .AppProperties =_fa .NewAppProperties ();_dfbc .CoreProperties =_fa .NewCoreProperties ();_dfbc .StyleSheet =NewStyleSheet (_dfbc );_dfbc .Rels =_fa .NewRelationships ();_dfbc ._bdgd =_fa .NewRelationships ();_dfbc .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .ExtendedPropertiesType ,0),_f .ExtendedPropertiesType );_dfbc .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .CorePropertiesType ,0),_f .CorePropertiesType );_dfbc .Rels .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,"",_f .OfficeDocumentType ,0),_f .OfficeDocumentType );_dfbc ._bdgd .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .StylesType ,0),_f .StylesType );_dfbc .ContentTypes =_fa .NewContentTypes ();_dfbc .ContentTypes .AddDefault ("\u0076\u006d\u006c",_f .VMLDrawingContentType );_dfbc .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_dfbc .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .StylesType ,0),_f .SMLStyleSheetContentType );_dfbc .SharedStrings =NewSharedStrings ();_dfbc .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .SharedStringsType ,0),_f .SharedStringsContentType );_dfbc ._bdgd .AddRelationship (_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .OfficeDocumentType ,_f .SharedStringsType ,0),_f .SharedStringsType );_dfbc ._efadg =map[string ]string {};return _dfbc ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_fcff *Workbook )DefinedNames ()[]DefinedName {if _fcff ._aeaf .DefinedNames ==nil {return nil ;};_bgad :=[]DefinedName {};for _ ,_cgffg :=range _fcff ._aeaf .DefinedNames .DefinedName {_bgad =append (_bgad ,DefinedName {_cgffg });};return _bgad ;};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_aeg CellStyle )GetVerticalAlignment ()_ad .ST_VerticalAlignment {if _aeg ._cff .Alignment ==nil {return _ad .ST_VerticalAlignmentUnset ;};return _aeg ._cff .Alignment .VerticalAttr ;};

// LockSheet controls the locking of the sheet.
func (_agga SheetProtection )LockSheet (b bool ){if !b {_agga ._egeag .SheetAttr =nil ;}else {_agga ._egeag .SheetAttr =_f .Bool (true );};};

// SetHeightAuto sets the row height to be automatically determined.
func (_gbcb Row )SetHeightAuto (){_gbcb ._eaecd .HtAttr =nil ;_gbcb ._eaecd .CustomHeightAttr =nil };

// TopLeft returns the top-left corner of the anchored object.
func (_ffef OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_ffef ._gfcd .From }};

// LockWindow controls the locking of the workbook windows.
func (_fdea WorkbookProtection )LockWindow (b bool ){if !b {_fdea ._gaga .LockWindowsAttr =nil ;}else {_fdea ._gaga .LockWindowsAttr =_f .Bool (true );};};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_cfdf *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_dede :=_cfdf ._dbfc .SheetData .Row ;_fgcdd :=_cfdf .Rows ();for _abgg ,_bagf :=range _fgcdd {if _bagf .RowNumber ()==firstRow {_dede =_cfdf ._dbfc .SheetData .Row [_abgg :];break ;};};_dage :=Comparer {Order :order };_fg .Slice (_dede ,func (_adgg ,_gedc int )bool {return _dage .LessRows (column ,Row {_cfdf ._ffec ,_cfdf ,_dede [_adgg ]},Row {_cfdf ._ffec ,_cfdf ,_dede [_gedc ]});});for _becg ,_efgbg :=range _cfdf .Rows (){_geb :=uint32 (_becg +1);if _efgbg .RowNumber ()!=_geb {_efgbg .renumberAs (_geb );};};};func (_gfaf SortOrder )String ()string {if _gfaf >=SortOrder (len (_cgga )-1){return _ba .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_gfaf );};return _eafe [_cgga [_gfaf ]:_cgga [_gfaf +1]];};

// SetRotation configures the cell to be rotated.
func (_cefg CellStyle )SetRotation (deg uint8 ){if _cefg ._cff .Alignment ==nil {_cefg ._cff .Alignment =_ad .NewCT_CellAlignment ();};_cefg ._cff .ApplyAlignmentAttr =_f .Bool (true );_cefg ._cff .Alignment .TextRotationAttr =_f .Uint8 (deg );};

// SetPasswordHash sets the password hash to the input.
func (_gbff SheetProtection )SetPasswordHash (pwHash string ){_gbff ._egeag .PasswordAttr =_f .String (pwHash );};func (_fgfg Sheet )validateRowCellNumbers ()error {_dbbe :=map[uint32 ]struct{}{};for _ ,_gcgb :=range _fgfg ._dbfc .SheetData .Row {if _gcgb .RAttr !=nil {if _ ,_eabg :=_dbbe [*_gcgb .RAttr ];_eabg {return _ba .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_fgfg .Name (),*_gcgb .RAttr );};_dbbe [*_gcgb .RAttr ]=struct{}{};};_cdff :=map[string ]struct{}{};for _ ,_acab :=range _gcgb .C {if _acab .RAttr ==nil {continue ;};if _ ,_eeace :=_cdff [*_acab .RAttr ];_eeace {return _ba .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_fgfg .Name (),*_acab .RAttr );};_cdff [*_acab .RAttr ]=struct{}{};};};return nil ;};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_dgac DataValidationList )SetValues (values []string ){_dgac ._bgg .Formula1 =_f .String ("\u0022"+_ff .Join (values ,"\u002c")+"\u0022");_dgac ._bgg .Formula2 =_f .String ("\u0030");};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_afac *Sheet )SetBorder (cellRange string ,border Border )error {_bgga ,_fbcf ,_efab :=_fec .ParseRangeReference (cellRange );if _efab !=nil {return _efab ;};_gcea :=_afac ._ffec .StyleSheet .AddCellStyle ();_gddcf :=_afac ._ffec .StyleSheet .AddBorder ();_gcea .SetBorder (_gddcf );_gddcf ._ecg .Top =border ._ecg .Top ;_gddcf ._ecg .Left =border ._ecg .Left ;_gagg :=_afac ._ffec .StyleSheet .AddCellStyle ();_badg :=_afac ._ffec .StyleSheet .AddBorder ();_gagg .SetBorder (_badg );_badg ._ecg .Top =border ._ecg .Top ;_badg ._ecg .Right =border ._ecg .Right ;_adfc :=_afac ._ffec .StyleSheet .AddCellStyle ();_efad :=_afac ._ffec .StyleSheet .AddBorder ();_adfc .SetBorder (_efad );_efad ._ecg .Top =border ._ecg .Top ;_ceafd :=_afac ._ffec .StyleSheet .AddCellStyle ();_dcdb :=_afac ._ffec .StyleSheet .AddBorder ();_ceafd .SetBorder (_dcdb );_dcdb ._ecg .Left =border ._ecg .Left ;_edfb :=_afac ._ffec .StyleSheet .AddCellStyle ();_edgd :=_afac ._ffec .StyleSheet .AddBorder ();_edfb .SetBorder (_edgd );_edgd ._ecg .Right =border ._ecg .Right ;_acag :=_afac ._ffec .StyleSheet .AddCellStyle ();_cgbbc :=_afac ._ffec .StyleSheet .AddBorder ();_acag .SetBorder (_cgbbc );_cgbbc ._ecg .Bottom =border ._ecg .Bottom ;_abc :=_afac ._ffec .StyleSheet .AddCellStyle ();_ggda :=_afac ._ffec .StyleSheet .AddBorder ();_abc .SetBorder (_ggda );_ggda ._ecg .Bottom =border ._ecg .Bottom ;_ggda ._ecg .Left =border ._ecg .Left ;_faac :=_afac ._ffec .StyleSheet .AddCellStyle ();_afef :=_afac ._ffec .StyleSheet .AddBorder ();_faac .SetBorder (_afef );_afef ._ecg .Bottom =border ._ecg .Bottom ;_afef ._ecg .Right =border ._ecg .Right ;_gdbc :=_bgga .RowIdx ;_ccbe :=_bgga .ColumnIdx ;_ceaad :=_fbcf .RowIdx ;_ebad :=_fbcf .ColumnIdx ;for _cecg :=_gdbc ;_cecg <=_ceaad ;_cecg ++{for _fedf :=_ccbe ;_fedf <=_ebad ;_fedf ++{_adgb :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_fedf ),_cecg );switch {case _cecg ==_gdbc &&_fedf ==_ccbe :_afac .Cell (_adgb ).SetStyle (_gcea );case _cecg ==_gdbc &&_fedf ==_ebad :_afac .Cell (_adgb ).SetStyle (_gagg );case _cecg ==_ceaad &&_fedf ==_ccbe :_afac .Cell (_adgb ).SetStyle (_abc );case _cecg ==_ceaad &&_fedf ==_ebad :_afac .Cell (_adgb ).SetStyle (_faac );case _cecg ==_gdbc :_afac .Cell (_adgb ).SetStyle (_adfc );case _cecg ==_ceaad :_afac .Cell (_adgb ).SetStyle (_acag );case _fedf ==_ccbe :_afac .Cell (_adgb ).SetStyle (_ceafd );case _fedf ==_ebad :_afac .Cell (_adgb ).SetStyle (_edfb );};};};return nil ;};

// GetFont gets a Font from a cell style.
func (_cedc CellStyle )GetFont ()*_ad .CT_Font {if _agde :=_cedc ._cff .FontIdAttr ;_agde !=nil {_dec :=_cedc ._ggfd .StyleSheet .Fonts ();if int (*_agde )< len (_dec ){return _dec [int (*_agde )].X ();};};return nil ;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fge Comment )SetCellReference (cellRef string ){_fge ._gdd .RefAttr =cellRef };var _egg []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_fbf Cell )SetString (s string )int {_fbf ._bgf .ensureSharedStringsRelationships ();_fbf .clearValue ();_fbe :=_fbf ._bgf .SharedStrings .AddString (s );_fbf ._abg .V =_f .String (_ga .Itoa (_fbe ));_fbf ._abg .TAttr =_ad .ST_CellTypeS ;return _fbe ;};func (_gbae DifferentialStyle )Fill ()Fill {if _gbae ._cebf .Fill ==nil {_gbae ._cebf .Fill =_ad .NewCT_Fill ();};return Fill {_gbae ._cebf .Fill ,nil };};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_deea CellStyle )SetVerticalAlignment (a _ad .ST_VerticalAlignment ){if _deea ._cff .Alignment ==nil {_deea ._cff .Alignment =_ad .NewCT_CellAlignment ();};_deea ._cff .ApplyAlignmentAttr =_f .Bool (true );_deea ._cff .Alignment .VerticalAttr =a ;};func (_cec Cell )getLocked ()bool {if _cec ._abg .SAttr ==nil {return false ;};_fabc :=*_cec ._abg .SAttr ;_cba :=_cec ._bgf .StyleSheet .GetCellStyle (_fabc );return *_cba ._cff .Protection .LockedAttr ;};func (_fdb Fills )X ()*_ad .CT_Fills {return _fdb ._gefe };

// SetWidth is a no-op.
func (_gdfba TwoCellAnchor )SetWidth (w _gb .Distance ){};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_facd *Workbook )SetActiveSheetIndex (idx uint32 ){if _facd ._aeaf .BookViews ==nil {_facd ._aeaf .BookViews =_ad .NewCT_BookViews ();};if len (_facd ._aeaf .BookViews .WorkbookView )==0{_facd ._aeaf .BookViews .WorkbookView =append (_facd ._aeaf .BookViews .WorkbookView ,_ad .NewCT_BookView ());};_facd ._aeaf .BookViews .WorkbookView [0].ActiveTabAttr =_f .Uint32 (idx );};

// SetShowValue controls if the cell value is displayed.
func (_ccba DataBarScale )SetShowValue (b bool ){_ccba ._aeb .ShowValueAttr =_f .Bool (b )};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_ceegf *Workbook )Save (w _cf .Writer )error {const _dcda ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_ca .GetLicenseKey ().IsLicensed ()&&!_eacbd {_ba .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_ba .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _fgc .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_ceegf ._eedd )==0{_dbcc ,_fabg :=_ca .GenRefId ("\u0073\u0077");if _fabg !=nil {_bbc .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_fabg );return _fabg ;};_ceegf ._eedd =_dbcc ;};if _egegg :=_ca .Track (_ceegf ._eedd ,_dcda );_egegg !=nil {_bbc .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_egegg );return _egegg ;};_cacf :=_ge .NewWriter (w );defer _cacf .Close ();_fbcfe :=_f .DocTypeSpreadsheet ;if _dfeeb :=_fgb .MarshalXML (_cacf ,_f .BaseRelsFilename ,_ceegf .Rels .X ());_dfeeb !=nil {return _dfeeb ;};if _afgd :=_fgb .MarshalXMLByType (_cacf ,_fbcfe ,_f .ExtendedPropertiesType ,_ceegf .AppProperties .X ());_afgd !=nil {return _afgd ;};if _fgef :=_fgb .MarshalXMLByType (_cacf ,_fbcfe ,_f .CorePropertiesType ,_ceegf .CoreProperties .X ());_fgef !=nil {return _fgef ;};_cbee :=_f .AbsoluteFilename (_fbcfe ,_f .OfficeDocumentType ,0);if _gfbe :=_fgb .MarshalXML (_cacf ,_cbee ,_ceegf ._aeaf );_gfbe !=nil {return _gfbe ;};if _fbac :=_fgb .MarshalXML (_cacf ,_fgb .RelationsPathFor (_cbee ),_ceegf ._bdgd .X ());_fbac !=nil {return _fbac ;};if _bgedg :=_fgb .MarshalXMLByType (_cacf ,_fbcfe ,_f .StylesType ,_ceegf .StyleSheet .X ());_bgedg !=nil {return _bgedg ;};for _dbgd ,_dfbb :=range _ceegf ._ecgeb {if _efcdd :=_fgb .MarshalXMLByTypeIndex (_cacf ,_fbcfe ,_f .ThemeType ,_dbgd +1,_dfbb );_efcdd !=nil {return _efcdd ;};};for _ceee ,_ceca :=range _ceegf ._ebag {_ceca .Dimension .RefAttr =Sheet {_ceegf ,nil ,_ceca }.Extents ();_gdgd :=_f .AbsoluteFilename (_fbcfe ,_f .WorksheetType ,_ceee +1);_fgb .MarshalXML (_cacf ,_gdgd ,_ceca );_fgb .MarshalXML (_cacf ,_fgb .RelationsPathFor (_gdgd ),_ceegf ._bced [_ceee ].X ());};if _dacdc :=_fgb .MarshalXMLByType (_cacf ,_fbcfe ,_f .SharedStringsType ,_ceegf .SharedStrings .X ());_dacdc !=nil {return _dacdc ;};if _ceegf .CustomProperties .X ()!=nil {if _cdab :=_fgb .MarshalXMLByType (_cacf ,_fbcfe ,_f .CustomPropertiesType ,_ceegf .CustomProperties .X ());_cdab !=nil {return _cdab ;};};if _ceegf .Thumbnail !=nil {_geaa :=_f .AbsoluteFilename (_fbcfe ,_f .ThumbnailType ,0);_gebb ,_cbea :=_cacf .Create (_geaa );if _cbea !=nil {return _cbea ;};if _adbge :=_b .Encode (_gebb ,_ceegf .Thumbnail ,nil );_adbge !=nil {return _adbge ;};};for _abdf ,_dcba :=range _ceegf ._fefd {_cebe :=_f .AbsoluteFilename (_fbcfe ,_f .ChartType ,_abdf +1);_fgb .MarshalXML (_cacf ,_cebe ,_dcba );};for _aebg ,_dfcf :=range _ceegf ._dbge {_gbbf :=_f .AbsoluteFilename (_fbcfe ,_f .TableType ,_aebg +1);_fgb .MarshalXML (_cacf ,_gbbf ,_dfcf );};for _ecfd ,_eaag :=range _ceegf ._ggbb {_gggb :=_f .AbsoluteFilename (_fbcfe ,_f .DrawingType ,_ecfd +1);_fgb .MarshalXML (_cacf ,_gggb ,_eaag );if !_ceegf ._fbae [_ecfd ].IsEmpty (){_fgb .MarshalXML (_cacf ,_fgb .RelationsPathFor (_gggb ),_ceegf ._fbae [_ecfd ].X ());};};for _ebge ,_bceg :=range _ceegf ._addg {_fgb .MarshalXML (_cacf ,_f .AbsoluteFilename (_fbcfe ,_f .VMLDrawingType ,_ebge +1),_bceg );};for _gfaaf ,_bfbe :=range _ceegf .Images {if _gcbb :=_fa .AddImageToZip (_cacf ,_bfbe ,_gfaaf +1,_f .DocTypeSpreadsheet );_gcbb !=nil {return _gcbb ;};};if _gfada :=_fgb .MarshalXML (_cacf ,_f .ContentTypesFilename ,_ceegf .ContentTypes .X ());_gfada !=nil {return _gfada ;};for _eggbb ,_adab :=range _ceegf ._febe {if _adab ==nil {continue ;};_fgb .MarshalXML (_cacf ,_f .AbsoluteFilename (_fbcfe ,_f .CommentsType ,_eggbb +1),_adab );};if _fddc :=_ceegf .WriteExtraFiles (_cacf );_fddc !=nil {return _fddc ;};return _cacf .Close ();};func (_afdg *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _afdg .getAllCellsInFormulaArrays (false );};

// SetWidth sets the width of the anchored object.
func (_gec AbsoluteAnchor )SetWidth (w _gb .Distance ){_gec ._aa .Ext .CxAttr =int64 (w /_gb .EMU )};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_dcbea ,_aged :=_fe .Open (filename );if _aged !=nil {return nil ,_ba .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_aged );};defer _dcbea .Close ();_dgaf ,_aged :=_fe .Stat (filename );if _aged !=nil {return nil ,_ba .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_aged );};_geec ,_aged :=Read (_dcbea ,_dgaf .Size ());if _aged !=nil {return nil ,_aged ;};_bcfd ,_ :=_c .Abs (_c .Dir (filename ));_geec ._edbfe =_c .Join (_bcfd ,filename );return _geec ,nil ;};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_ae ,_ee int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_daf _gb .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_efc int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_ffe _gb .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_gab int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_cc _gb .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_cbb _gb .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// X returns the inner wrapped XML type.
func (_gfc Comment )X ()*_ad .CT_Comment {return _gfc ._gdd };

// Comment is a single comment within a sheet.
type Comment struct{_dgf *Workbook ;_gdd *_ad .CT_Comment ;_gce *_ad .Comments ;};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_fd Cell )SetRichTextString ()RichText {_fd .clearValue ();_fd ._abg .Is =_ad .NewCT_Rst ();_fd ._abg .TAttr =_ad .ST_CellTypeInlineStr ;return RichText {_fd ._abg .Is };};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_bbdac *Sheet )AddNumberedRow (rowNum uint32 )Row {_bgec :=_ad .NewCT_Row ();_bgec .RAttr =_f .Uint32 (rowNum );_bbdac ._dbfc .SheetData .Row =append (_bbdac ._dbfc .SheetData .Row ,_bgec );_fg .Slice (_bbdac ._dbfc .SheetData .Row ,func (_ccad ,_cffc int )bool {_cfg :=_bbdac ._dbfc .SheetData .Row [_ccad ].RAttr ;_ddgg :=_bbdac ._dbfc .SheetData .Row [_cffc ].RAttr ;if _cfg ==nil {return true ;};if _ddgg ==nil {return true ;};return *_cfg < *_ddgg ;});return Row {_bbdac ._ffec ,_bbdac ,_bgec };};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// IsSheetLocked returns whether the sheet objects are locked.
func (_bef SheetProtection )IsObjectLocked ()bool {return _bef ._egeag .ObjectsAttr !=nil &&*_bef ._egeag .ObjectsAttr ;};

// Text returns text from the sheet as one string separated with line breaks.
func (_fffgd *SheetText )Text ()string {_cffe :=_dc .NewBuffer ([]byte {});for _ ,_bcf :=range _fffgd .Cells {if _bcf .Text !=""{_cffe .WriteString (_bcf .Text );_cffe .WriteString ("\u000a");};};return _cffe .String ();};

// Tables returns a slice of all defined tables in the workbook.
func (_fcbg *Workbook )Tables ()[]Table {if _fcbg ._dbge ==nil {return nil ;};_abea :=[]Table {};for _ ,_cfde :=range _fcbg ._dbge {_abea =append (_abea ,Table {_cfde });};return _abea ;};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_bebe Sheet )Validate ()error {_gbf :=[]func ()error {_bebe .validateRowCellNumbers ,_bebe .validateMergedCells ,_bebe .validateSheetNames };for _ ,_aaac :=range _gbf {if _cffag :=_aaac ();_cffag !=nil {return _cffag ;};};if _cgg :=_bebe ._dbfc .Validate ();_cgg !=nil {return _cgg ;};return _bebe ._dbfc .Validate ();};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_aac StyleSheet )Fills ()Fills {return Fills {_aac ._gagf .Fills }};func (_gaa Cell )setLocked (_agfa bool ){_bcg :=_gaa ._abg .SAttr ;if _bcg !=nil {_eeaa :=_gaa ._bgf .StyleSheet .GetCellStyle (*_bcg );if _eeaa ._cff .Protection ==nil {_eeaa ._cff .Protection =_ad .NewCT_CellProtection ();};_eeaa ._cff .Protection .LockedAttr =&_agfa ;};};

// Comments returns the list of comments for this sheet
func (_bdfc Comments )Comments ()[]Comment {_ada :=[]Comment {};for _ ,_dbg :=range _bdfc ._gdbe .CommentList .Comment {_ada =append (_ada ,Comment {_bdfc ._dfcb ,_dbg ,_bdfc ._gdbe });};return _ada ;};

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_dea *Sheet )Row (rowNum uint32 )Row {for _ ,_fgac :=range _dea ._dbfc .SheetData .Row {if _fgac .RAttr !=nil &&*_fgac .RAttr ==rowNum {return Row {_dea ._ffec ,_dea ,_fgac };};};return _dea .AddNumberedRow (rowNum );};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_bdbcg *Workbook )AddDefinedName (name ,ref string )DefinedName {if _bdbcg ._aeaf .DefinedNames ==nil {_bdbcg ._aeaf .DefinedNames =_ad .NewCT_DefinedNames ();};_ababe :=_ad .NewCT_DefinedName ();_ababe .Content =ref ;_ababe .NameAttr =name ;_bdbcg ._aeaf .DefinedNames .DefinedName =append (_bdbcg ._aeaf .DefinedNames .DefinedName ,_ababe );return DefinedName {_ababe };};func (_eadg *Sheet )setList (_egee string ,_gfda _cea .Result )error {_dfed ,_gbef :=_fec .ParseCellReference (_egee );if _gbef !=nil {return _gbef ;};_cebd :=_eadg .Row (_dfed .RowIdx );for _abfd ,_abdeg :=range _gfda .ValueList {_ggga :=_cebd .Cell (_fec .IndexToColumn (_dfed .ColumnIdx +uint32 (_abfd )));if _abdeg .Type !=_cea .ResultTypeEmpty {if _abdeg .IsBoolean {_ggga .SetBool (_abdeg .ValueNumber !=0);}else {_ggga .SetCachedFormulaResult (_abdeg .String ());};};};return nil ;};

// SetRowOffset sets the row offset of the two cell anchor
func (_ecad TwoCellAnchor )SetRowOffset (m _gb .Distance ){_ddfcg :=m -_ecad .TopLeft ().RowOffset ();_ecad .TopLeft ().SetRowOffset (m );_ecad .BottomRight ().SetRowOffset (_ecad .BottomRight ().RowOffset ()+_ddfcg );};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_edb Cell )SetDate (d _feb .Time ){_edb .clearValue ();d =_agb (d );_eea :=_edb ._bgf .Epoch ();if d .Before (_eea ){_bbc .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_gba :=d .Sub (_eea );_ac :=new (_bbe .Float );_cef :=new (_bbe .Float );_cef .SetPrec (128);_cef .SetUint64 (uint64 (_gba ));_dbff :=new (_bbe .Float );_dbff .SetUint64 (24*60*60*1e9);_ac .Quo (_cef ,_dbff );_caad ,_ :=_ac .Uint64 ();_edb ._abg .V =_f .Stringf ("\u0025\u0064",_caad );};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_fdeg Row )Cell (col string )Cell {_fgf :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",col ,_fdeg .RowNumber ());for _ ,_daaf :=range _fdeg ._eaecd .C {if _daaf .RAttr !=nil &&*_daaf .RAttr ==_fgf {return Cell {_fdeg ._adbg ,_fdeg ._gdae ,_fdeg ._eaecd ,_daaf };};};return _fdeg .AddNamedCell (col );};

// Themes returns the array of workbook dml.Theme.
func (_gfcbg *Workbook )Themes ()[]*_cb .Theme {return _gfcbg ._ecgeb };func (_ggc PatternFill )ClearFgColor (){_ggc ._gdcg .FgColor =nil };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_ed Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_feg :=_cea .ParseString (formulaStr );if _feg ==nil {return _fgc .New (_ba .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));};_ed .clearValue ();_ed ._abg .TAttr =_ad .ST_CellTypeStr ;_ed ._abg .F =_ad .NewCT_CellFormula ();_ed ._abg .F .TAttr =_ad .ST_CellFormulaTypeShared ;_ed ._abg .F .Content =formulaStr ;_aff ,_dgd :=_fec .ParseCellReference (_ed .Reference ());if _dgd !=nil {return _dgd ;};_cde :=uint32 (0);for _ ,_ecb :=range _ed ._be .Rows (){for _ ,_dfc :=range _ecb ._eaecd .C {if _dfc .F !=nil &&_dfc .F .SiAttr !=nil &&*_dfc .F .SiAttr >=_cde {_cde =*_dfc .F .SiAttr ;};};};_cde ++;_ggf :=_ba .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_aff .Column ,_aff .RowIdx ,_fec .IndexToColumn (_aff .ColumnIdx +cols ),_aff .RowIdx +rows );_ed ._abg .F .RefAttr =_f .String (_ggf );_ed ._abg .F .SiAttr =_f .Uint32 (_cde );_dd :=Sheet {_ed ._bgf ,_ed ._be ._dgc ,_ed ._be ._dbfc };for _ced :=_aff .RowIdx ;_ced <=_aff .RowIdx +rows ;_ced ++{for _bfb :=_aff .ColumnIdx ;_bfb <=_aff .ColumnIdx +cols ;_bfb ++{if _ced ==_aff .RowIdx &&_bfb ==_aff .ColumnIdx {continue ;};_dae :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_bfb ),_ced );_dd .Cell (_dae ).Clear ();_dd .Cell (_dae ).X ().F =_ad .NewCT_CellFormula ();_dd .Cell (_dae ).X ().F .TAttr =_ad .ST_CellFormulaTypeShared ;_dd .Cell (_dae ).X ().F .SiAttr =_f .Uint32 (_cde );};};return nil ;};

// Text returns text from the workbook as one string separated with line breaks.
func (_bgfa *WorkbookText )Text ()string {_ffad :=_dc .NewBuffer ([]byte {});for _ ,_efgb :=range _bgfa .Sheets {_ffad .WriteString (_efgb .Text ());};return _ffad .String ();};

// GetFilename returns the filename of the context's workbook.
func (_eaga *evalContext )GetFilename ()string {return _eaga ._gccf ._ffec .GetFilename ()};

// SetMaxLength sets the maximum bar length in percent.
func (_abab DataBarScale )SetMaxLength (l uint32 ){_abab ._aeb .MaxLengthAttr =_f .Uint32 (l )};func (_fcgc DataValidation )clear (){_fcgc ._ebef .Formula1 =_f .String ("\u0030");_fcgc ._ebef .Formula2 =_f .String ("\u0030");};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_ffga ConditionalFormattingRule )SetDataBar ()DataBarScale {_ffga .clear ();_ffga .SetType (_ad .ST_CfTypeDataBar );_ffga ._fgd .DataBar =_ad .NewCT_DataBar ();_bega :=DataBarScale {_ffga ._fgd .DataBar };_bega .SetShowValue (true );_bega .SetMinLength (10);_bega .SetMaxLength (90);return _bega ;};

// MoveTo is a no-op.
func (_cg AbsoluteAnchor )MoveTo (x ,y int32 ){};func (_aeeg StandardFormat )String ()string {switch {case 0<=_aeeg &&_aeeg <=4:return _dfcba [_eggf [_aeeg ]:_eggf [_aeeg +1]];case 9<=_aeeg &&_aeeg <=22:_aeeg -=9;return _fedd [_aaae [_aeeg ]:_aaae [_aeeg +1]];case 37<=_aeeg &&_aeeg <=40:_aeeg -=37;return _dfgd [_efgc [_aeeg ]:_efgc [_aeeg +1]];case 45<=_aeeg &&_aeeg <=49:_aeeg -=45;return _abfff [_cabc [_aeeg ]:_cabc [_aeeg +1]];default:return _ba .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_aeeg );};};type Fill struct{_dfef *_ad .CT_Fill ;_effb *_ad .CT_Fills ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// Type returns the type of anchor
func (_ddada OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_afge Cell )GetCachedFormulaResult ()string {if _afge ._abg .V !=nil {return *_afge ._abg .V ;};return "";};

// Name returns the name of the table
func (_gfcdc Table )Name ()string {if _gfcdc ._edcd .NameAttr !=nil {return *_gfcdc ._edcd .NameAttr ;};return "";};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_fedae *Sheet )Cell (cellRef string )Cell {_ddfg ,_abbee :=_fec .ParseCellReference (cellRef );if _abbee !=nil {_bbc .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_abbee );return _fedae .AddRow ().AddCell ();};return _fedae .Row (_ddfg .RowIdx ).Cell (_ddfg .Column );};

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_fbcg NumberFormat )ID ()uint32 {return _fbcg ._ccdf .NumFmtIdAttr };

// Protection controls the protection on an individual sheet.
func (_ddbb *Sheet )Protection ()SheetProtection {if _ddbb ._dbfc .SheetProtection ==nil {_ddbb ._dbfc .SheetProtection =_ad .NewCT_SheetProtection ();};return SheetProtection {_ddbb ._dbfc .SheetProtection };};

// AddRule adds and returns a new rule that can be configured.
func (_gdfb ConditionalFormatting )AddRule ()ConditionalFormattingRule {_aee :=_ad .NewCT_CfRule ();_gdfb ._fabcg .CfRule =append (_gdfb ._fabcg .CfRule ,_aee );_efa :=ConditionalFormattingRule {_aee };_efa .InitializeDefaults ();_efa .SetPriority (int32 (len (_gdfb ._fabcg .CfRule )+1));return _efa ;};

// GetBorder gets a Border from a cell style.
func (_fdd CellStyle )GetBorder ()*_ad .CT_Border {if _ccb :=_fdd ._cff .BorderIdAttr ;_ccb !=nil {_fbd :=_fdd ._ggfd .StyleSheet .Borders ();if int (*_ccb )< len (_fbd ){return _fbd [int (*_ccb )].X ();};};return nil ;};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_efff DataValidationList )SetRange (cellRange string ){_efff ._bgg .Formula1 =_f .String (cellRange );_efff ._bgg .Formula2 =_f .String ("\u0030");};

// X returns the inner wrapped XML type.
func (_eegf SheetView )X ()*_ad .CT_SheetView {return _eegf ._deeg };

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_ffc Cell )SetStyle (cs CellStyle ){_ffc .SetStyleIndex (cs .Index ())};

// PasswordHash returns the hash of the workbook password.
func (_bacg SheetProtection )PasswordHash ()string {if _bacg ._egeag .PasswordAttr ==nil {return "";};return *_bacg ._egeag .PasswordAttr ;};

// SetHidden controls the visibility of a column.
func (_dgg Column )SetHidden (b bool ){if !b {_dgg ._eede .HiddenAttr =nil ;}else {_dgg ._eede .HiddenAttr =_f .Bool (true );};};

// X returns the inner wrapped XML type.
func (_cbcb DefinedName )X ()*_ad .CT_DefinedName {return _cbcb ._dagf };const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// SetOperator sets the operator for the rule.
func (_def ConditionalFormattingRule )SetOperator (t _ad .ST_ConditionalFormattingOperator ){_def ._fgd .OperatorAttr =t ;};func (_dege *Sheet )addNumberedRowFast (_cbeg uint32 )Row {_bafg :=_ad .NewCT_Row ();_bafg .RAttr =_f .Uint32 (_cbeg );_dege ._dbfc .SheetData .Row =append (_dege ._dbfc .SheetData .Row ,_bafg );return Row {_dege ._ffec ,_dege ,_bafg };};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_gcc Cell )SetCachedFormulaResult (s string ){_gcc ._abg .V =&s };

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_cfaa TwoCellAnchor )SetHeightCells (h int32 ){_cfaa .SetHeight (0);_fdda :=_cfaa .TopLeft ();_gedd :=_cfaa .BottomRight ();_gedd .SetRow (_fdda .Row ()+h );};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_bbab :_ad .NewSst (),_efda :make (map[string ]int )};};func (_efb Font )SetName (name string ){_efb ._fcgcc .Name =[]*_ad .CT_FontName {{ValAttr :name }}};

// Rows returns all of the rows in a sheet.
func (_ebfa *Sheet )Rows ()[]Row {_cfd :=[]Row {};for _ ,_gabe :=range _ebfa ._dbfc .SheetData .Row {_cfd =append (_cfd ,Row {_ebfa ._ffec ,_ebfa ,_gabe });};return _cfd ;};

// Operator returns the operator for the rule
func (_eec ConditionalFormattingRule )Operator ()_ad .ST_ConditionalFormattingOperator {return _eec ._fgd .OperatorAttr ;};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_edfc *Sheet )ClearSheetViews (){_edfc ._dbfc .SheetViews =nil };func (_gea Cell )getFormat ()string {if _gea ._abg .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_bbb :=*_gea ._abg .SAttr ;_ea :=_gea ._bgf .StyleSheet .GetCellStyle (_bbb );_fab :=_gea ._bgf .StyleSheet .GetNumberFormat (_ea .NumberFormat ());return _fab .GetFormat ();};func (_bacc StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_fffe :=range _bacc ._gagf .NumFmts .NumFmt {if _fffe .NumFmtIdAttr ==id {return NumberFormat {_bacc ._geecg ,_fffe };};};return NumberFormat {};};

// Fonts returns the list of fonts defined in the stylesheet.
func (_bedg StyleSheet )Fonts ()[]Font {_ebaeg :=[]Font {};for _ ,_acdf :=range _bedg ._gagf .Fonts .Font {_ebaeg =append (_ebaeg ,Font {_acdf ,_bedg ._gagf });};return _ebaeg ;};

// X returns the inner wrapped XML type.
func (_ffg Cell )X ()*_ad .CT_Cell {return _ffg ._abg };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_agfd *Workbook ;_ccdf *_ad .CT_NumFmt ;};

// SetFill applies a fill to a cell style. The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_fff CellStyle )SetFill (f Fill ){_fff ._cff .FillIdAttr =_f .Uint32 (f .Index ());_fff ._cff .ApplyFillAttr =_f .Bool (true );};var _eacbd =false ;

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_fdff PatternFill )SetFgColor (c _ebb .Color ){_fdff ._gdcg .FgColor =_ad .NewCT_Color ();_fdff ._gdcg .FgColor .RgbAttr =c .AsRGBAString ();};func (_adfad Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _ccce ,_fcdg ,_ggab ,_eefc uint32 =1,1,0,0;for _ ,_bbad :=range _adfad .Rows (){if _bbad .RowNumber ()< _ccce {_ccce =_bbad .RowNumber ();}else if _bbad .RowNumber ()> _fcdg {_fcdg =_bbad .RowNumber ();};for _ ,_fcebf :=range _bbad .Cells (){_geee ,_bffc :=_fec .ParseCellReference (_fcebf .Reference ());if _bffc ==nil {if _geee .ColumnIdx < _ggab {_ggab =_geee .ColumnIdx ;}else if _geee .ColumnIdx > _eefc {_eefc =_geee .ColumnIdx ;};};};};return _fec .IndexToColumn (_ggab ),_ccce ,_fec .IndexToColumn (_eefc ),_fcdg ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_dagf *_ad .CT_DefinedName };

// SetBold causes the text to be displayed in bold.
func (_gfcb RichTextRun )SetBold (b bool ){_gfcb .ensureRpr ();_gfcb ._dbec .RPr .B =_ad .NewCT_BooleanProperty ();_gfcb ._dbec .RPr .B .ValAttr =_f .Bool (b );};func (_eg Border )SetTop (style _ad .ST_BorderStyle ,c _ebb .Color ){if _eg ._ecg .Top ==nil {_eg ._ecg .Top =_ad .NewCT_BorderPr ();};_eg ._ecg .Top .Color =_ad .NewCT_Color ();_eg ._ecg .Top .Color .RgbAttr =c .AsRGBAString ();_eg ._ecg .Top .StyleAttr =style ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_bfd OneCellAnchor )SetColOffset (m _gb .Distance ){_bfd .TopLeft ().SetColOffset (m )};

// Clear clears the cell's value and type.
func (_gfa Cell )Clear (){_gfa .clearValue ();_gfa ._abg .TAttr =_ad .ST_CellTypeUnset };

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_bfff *Workbook )RemoveCalcChain (){var _abcb string ;for _ ,_gcba :=range _bfff ._bdgd .Relationships (){if _gcba .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_abcb ="\u0078\u006c\u002f"+_gcba .Target ();_bfff ._bdgd .Remove (_gcba );break ;};};if _abcb ==""{return ;};_bfff .ContentTypes .RemoveOverride (_abcb );for _dffc ,_dccd :=range _bfff .ExtraFiles {if _dccd .ZipPath ==_abcb {_bfff .ExtraFiles [_dffc ]=_bfff .ExtraFiles [len (_bfff .ExtraFiles )-1];_bfff .ExtraFiles =_bfff .ExtraFiles [:len (_bfff .ExtraFiles )-1];return ;};};};

// IsEmpty returns true if the cell is empty.
func (_afg Cell )IsEmpty ()bool {return _afg ._abg .TAttr ==_ad .ST_CellTypeUnset &&_afg ._abg .V ==nil &&_afg ._abg .F ==nil ;};func (_aae Border )SetRight (style _ad .ST_BorderStyle ,c _ebb .Color ){if _aae ._ecg .Right ==nil {_aae ._ecg .Right =_ad .NewCT_BorderPr ();};_aae ._ecg .Right .Color =_ad .NewCT_Color ();_aae ._ecg .Right .Color .RgbAttr =c .AsRGBAString ();_aae ._ecg .Right .StyleAttr =style ;};

// DataValidation controls cell validation
type DataValidation struct{_ebef *_ad .CT_DataValidation };

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_cefa StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _cefa ._gagf .Dxfs ==nil {_cefa ._gagf .Dxfs =_ad .NewCT_Dxfs ();};_gcce :=_ad .NewCT_Dxf ();_cefa ._gagf .Dxfs .Dxf =append (_cefa ._gagf .Dxfs .Dxf ,_gcce );_cefa ._gagf .Dxfs .CountAttr =_f .Uint32 (uint32 (len (_cefa ._gagf .Dxfs .Dxf )));return DifferentialStyle {_gcce ,_cefa ._geecg ,_cefa ._gagf .Dxfs };};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_agd CellStyle )GetHorizontalAlignment ()_ad .ST_HorizontalAlignment {if _agd ._cff .Alignment ==nil {return _ad .ST_HorizontalAlignmentUnset ;};return _agd ._cff .Alignment .HorizontalAttr ;};

// AddMergedCells merges cells within a sheet.
func (_ggcg *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _ggcg ._dbfc .MergeCells ==nil {_ggcg ._dbfc .MergeCells =_ad .NewCT_MergeCells ();};_aagg :=_ad .NewCT_MergeCell ();_aagg .RefAttr =_ba .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_ggcg ._dbfc .MergeCells .MergeCell =append (_ggcg ._dbfc .MergeCells .MergeCell ,_aagg );_ggcg ._dbfc .MergeCells .CountAttr =_f .Uint32 (uint32 (len (_ggcg ._dbfc .MergeCells .MergeCell )));return MergedCell {_ggcg ._ffec ,_ggcg ,_aagg };};

// Borders returns the list of borders defined in the stylesheet.
func (_gggc StyleSheet )Borders ()[]Border {_befd :=[]Border {};for _ ,_gdaf :=range _gggc ._gagf .Borders .Border {_befd =append (_befd ,Border {_ecg :_gdaf });};return _befd ;};func (_dbfa PatternFill )ClearBgColor (){_dbfa ._gdcg .BgColor =nil };

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_fgfe SheetView )SetZoom (pct uint32 ){_fgfe ._deeg .ZoomScaleAttr =&pct };func (_fecca *Sheet )setShared (_daag string ,_abec ,_agec _fec .CellReference ,_abbg string ){_cccg :=_fecca .FormulaContext ();_accbf :=_cea .NewEvaluator ();for _ecaa :=_abec .RowIdx ;_ecaa <=_agec .RowIdx ;_ecaa ++{for _edde :=_abec .ColumnIdx ;_edde <=_agec .ColumnIdx ;_edde ++{_egbfb :=_ecaa -_abec .RowIdx ;_gfe :=_edde -_abec .ColumnIdx ;_cccg .SetOffset (_gfe ,_egbfb );_dfadg :=_accbf .Eval (_cccg ,_abbg );_ggb :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",_fec .IndexToColumn (_edde ),_ecaa );_gffa :=_fecca .Cell (_ggb );if _dfadg .Type ==_cea .ResultTypeNumber {_gffa .X ().TAttr =_ad .ST_CellTypeN ;}else {_gffa .X ().TAttr =_ad .ST_CellTypeInlineStr ;};_gffa .X ().V =_f .String (_dfadg .Value ());};};_ =_accbf ;_ =_cccg ;};

// SetHidden hides or unhides the row
func (_cbcd Row )SetHidden (hidden bool ){if !hidden {_cbcd ._eaecd .HiddenAttr =nil ;}else {_cbcd ._eaecd .HiddenAttr =_f .Bool (true );};};

// Col returns the column of the cell marker.
func (_dde CellMarker )Col ()int32 {return _dde ._dcc .Col };

// Index returns the index of the differential style.
func (_ddge DifferentialStyle )Index ()uint32 {for _eeba ,_gddd :=range _ddge ._dbdb .Dxf {if _ddge ._cebf ==_gddd {return uint32 (_eeba );};};return 0;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_abfe *_ad .CT_Rst };type SheetProtection struct{_egeag *_ad .CT_SheetProtection };

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_bgg *_ad .CT_DataValidation };

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_cfgb *Sheet )AddHyperlink (url string )_fa .Hyperlink {for _bdaa ,_faae :=range _cfgb ._ffec ._ebag {if _faae ==_cfgb ._dbfc {return _cfgb ._ffec ._bced [_bdaa ].AddHyperlink (url );};};return _fa .Hyperlink {};};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_gae CellStyle )NumberFormat ()uint32 {if _gae ._cff .NumFmtIdAttr ==nil {return 0;};return *_gae ._cff .NumFmtIdAttr ;};

// StyleSheet is a document style sheet.
type StyleSheet struct{_geecg *Workbook ;_gagf *_ad .StyleSheet ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_agca :=uint16 (0);if len (s )> 0{for _decf :=len (s )-1;_decf >=0;_decf --{_acb :=s [_decf ];_agca =((_agca >>14)&0x01)|((_agca <<1)&0x7fff);_agca ^=uint16 (_acb );};_agca =((_agca >>14)&0x01)|((_agca <<1)&0x7fff);_agca ^=uint16 (len (s ));_agca ^=(0x8000|('N'<<8)|'K');};return _ba .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_agca ));};

// AddFont adds a new empty font to the stylesheet.
func (_dfacf StyleSheet )AddFont ()Font {_bfbb :=_ad .NewCT_Font ();_dfacf ._gagf .Fonts .Font =append (_dfacf ._gagf .Fonts .Font ,_bfbb );_dfacf ._gagf .Fonts .CountAttr =_f .Uint32 (uint32 (len (_dfacf ._gagf .Fonts .Font )));return Font {_bfbb ,_dfacf ._gagf };};func (_ade ConditionalFormattingRule )clear (){_ade ._fgd .OperatorAttr =_ad .ST_ConditionalFormattingOperatorUnset ;_ade ._fgd .ColorScale =nil ;_ade ._fgd .IconSet =nil ;_ade ._fgd .Formula =nil ;};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_gaf *Sheet )FormulaContext ()_cea .Context {return _defb (_gaf )};

// MoveTo repositions the anchor without changing the objects size.
func (_dfeef TwoCellAnchor )MoveTo (col ,row int32 ){_dfedf :=_dfeef .TopLeft ();_edad :=_dfeef .BottomRight ();_bbaa :=_edad .Col ()-_dfedf .Col ();_aeae :=_edad .Row ()-_dfedf .Row ();_dfedf .SetCol (col );_dfedf .SetRow (row );_edad .SetCol (col +_bbaa );_edad .SetRow (row +_aeae );};func (_gbaf *Sheet )removeColumnFromMergedCells (_daef uint32 )error {if _gbaf ._dbfc .MergeCells ==nil ||_gbaf ._dbfc .MergeCells .MergeCell ==nil {return nil ;};_ccfc :=[]*_ad .CT_MergeCell {};for _ ,_begg :=range _gbaf .MergedCells (){_abgb :=_cgcd (_begg .Reference (),_daef ,true );if _abgb !=""{_begg .SetReference (_abgb );_ccfc =append (_ccfc ,_begg .X ());};};_gbaf ._dbfc .MergeCells .MergeCell =_ccfc ;return nil ;};

// SetColor sets the text color.
func (_bbeb RichTextRun )SetColor (c _ebb .Color ){_bbeb .ensureRpr ();_bbeb ._dbec .RPr .Color =_ad .NewCT_Color ();_ebefg :="\u0066\u0066"+*c .AsRGBString ();_bbeb ._dbec .RPr .Color .RgbAttr =&_ebefg ;};

// SetPriority sets the rule priority
func (_egcg ConditionalFormattingRule )SetPriority (p int32 ){_egcg ._fgd .PriorityAttr =p };

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_af AbsoluteAnchor )SetColOffset (m _gb .Distance ){_af ._aa .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_gb .EMU ));};

// GetLocked returns true if the cell is locked.
func (_efaf *evalContext )GetLocked (cellRef string )bool {return _efaf ._gccf .Cell (cellRef ).getLocked ();};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_efac SheetView )SetState (st _ad .ST_PaneState ){_efac .ensurePane ();_efac ._deeg .Pane .StateAttr =st ;};

// IconScale maps values to icons.
type IconScale struct{_gaac *_ad .CT_IconSet };

// SetYSplit sets the row split point
func (_deae SheetView )SetYSplit (v float64 ){_deae .ensurePane ();_deae ._deeg .Pane .YSplitAttr =_f .Float64 (v );};

// Comments is the container for comments for a single sheet.
type Comments struct{_dfcb *Workbook ;_gdbe *_ad .Comments ;};

// SetRowOffset sets a column offset in absolute distance.
func (_egf CellMarker )SetRowOffset (m _gb .Distance ){_egf ._dcc .RowOff .ST_CoordinateUnqualified =_f .Int64 (int64 (m /_gb .EMU ));};

// SetContent sets the defined name content.
func (_dfg DefinedName )SetContent (s string ){_dfg ._dagf .Content =s };func (_bff ConditionalFormattingRule )InitializeDefaults (){_bff .SetType (_ad .ST_CfTypeCellIs );_bff .SetOperator (_ad .ST_ConditionalFormattingOperatorGreaterThan );_bff .SetPriority (1);};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_adg CellStyle )HasNumberFormat ()bool {return _adg ._cff .NumFmtIdAttr !=nil &&_adg ._cff .ApplyNumberFormatAttr !=nil &&*_adg ._cff .ApplyNumberFormatAttr ;};

// X returns the inner wrapped XML type.
func (_bbf ConditionalFormatting )X ()*_ad .CT_ConditionalFormatting {return _bbf ._fabcg };

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_ffb Row )Cells ()[]Cell {_affd :=[]Cell {};_bagbb :=-1;_fecd :=append ([]*_ad .CT_Cell {},_ffb ._eaecd .C ...);for _ ,_fead :=range _fecd {if _fead .RAttr ==nil {_bbc .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_dabb ,_bfc :=_fec .ParseCellReference (*_fead .RAttr );if _bfc !=nil {_bbc .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_fead .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_dcfe :=int (_dabb .ColumnIdx );if _dcfe -_bagbb > 1{for _ccgb :=_bagbb +1;_ccgb < _dcfe ;_ccgb ++{_affd =append (_affd ,_ffb .Cell (_fec .IndexToColumn (uint32 (_ccgb ))));};};_bagbb =_dcfe ;_affd =append (_affd ,Cell {_ffb ._adbg ,_ffb ._gdae ,_ffb ._eaecd ,_fead });};return _affd ;};

// SheetCount returns the number of sheets in the workbook.
func (_faacf Workbook )SheetCount ()int {return len (_faacf ._ebag )};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_gcge *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_ff .Replace (rangeRef ,"\u0024","",-1);_gcge ._dbfc .AutoFilter =_ad .NewCT_AutoFilter ();_gcge ._dbfc .AutoFilter .RefAttr =_f .String (rangeRef );_dcbc :="\u0027"+_gcge .Name ()+"\u0027\u0021";var _adbe DefinedName ;for _ ,_bdeg :=range _gcge ._ffec .DefinedNames (){if _bdeg .Name ()==_fccb {if _ff .HasPrefix (_bdeg .Content (),_dcbc ){_adbe =_bdeg ;_adbe .SetContent (_gcge .RangeReference (rangeRef ));break ;};};};if _adbe .X ()==nil {_adbe =_gcge ._ffec .AddDefinedName (_fccb ,_gcge .RangeReference (rangeRef ));};for _gbe ,_eabd :=range _gcge ._ffec ._ebag {if _eabd ==_gcge ._dbfc {_adbe .SetLocalSheetID (uint32 (_gbe ));};};};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_dfac :=NumberFormat {_ccdf :_ad .NewCT_NumFmt ()};_dfac ._ccdf .NumFmtIdAttr =uint32 (id );_dfac ._ccdf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_dfac ._ccdf .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_dfac ._ccdf .FormatCodeAttr ="\u0030";case StandardFormat2 :_dfac ._ccdf .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_dfac ._ccdf .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_dfac ._ccdf .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_dfac ._ccdf .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_dfac ._ccdf .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_dfac ._ccdf .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_dfac ._ccdf .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_dfac ._ccdf .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_dfac ._ccdf .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_dfac ._ccdf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_dfac ._ccdf .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_dfac ._ccdf .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_dfac ._ccdf .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_dfac ._ccdf .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_dfac ._ccdf .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_dfac ._ccdf .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_dfac ._ccdf .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_dfac ._ccdf .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_dfac ._ccdf .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_dfac ._ccdf .FormatCodeAttr ="\u0040";};return _dfac ;};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_bgeb *Workbook )AddDrawing ()Drawing {_cbfe :=_ab .NewWsDr ();_bgeb ._ggbb =append (_bgeb ._ggbb ,_cbfe );_dfdc :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,len (_bgeb ._ggbb ));_bgeb .ContentTypes .AddOverride (_dfdc ,_f .DrawingContentType );_bgeb ._fbae =append (_bgeb ._fbae ,_fa .NewRelationships ());return Drawing {_bgeb ,_cbfe };};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_deac *_ab .CT_TwoCellAnchor };

// SaveToFile writes the workbook out to a file.
func (_aadcg *Workbook )SaveToFile (path string )error {_cdgb ,_gbb :=_fe .Create (path );if _gbb !=nil {return _gbb ;};defer _cdgb .Close ();return _aadcg .Save (_cdgb );};

// IsSheetLocked returns whether the sheet is locked.
func (_dfd SheetProtection )IsSheetLocked ()bool {return _dfd ._egeag .SheetAttr !=nil &&*_dfd ._egeag .SheetAttr ;};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_bce Comparer )LessCells (lhs ,rhs Cell )bool {if _bce .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_cbbb ,_feda :=lhs .getRawSortValue ();_cca ,_gfag :=rhs .getRawSortValue ();switch {case _feda &&_gfag :_cfcf ,_ :=_ga .ParseFloat (_cbbb ,64);_eeac ,_ :=_ga .ParseFloat (_cca ,64);return _cfcf < _eeac ;case _feda :return true ;case _gfag :return false ;};_cbbb =lhs .GetFormattedValue ();_cca =rhs .GetFormattedValue ();return _cbbb < _cca ;};

// X returns the inner wrapped XML type.
func (_aega Column )X ()*_ad .CT_Col {return _aega ._eede };func (_bgac StyleSheet )GetCellStyle (id uint32 )CellStyle {for _bged ,_ebcfd :=range _bgac ._gagf .CellXfs .Xf {if uint32 (_bged )==id {return CellStyle {_bgac ._geecg ,_ebcfd ,_bgac ._gagf .CellXfs };};};return CellStyle {};};

// SetHeight sets the row height in points.
func (_fadf Row )SetHeight (d _gb .Distance ){_fadf ._eaecd .HtAttr =_f .Float64 (float64 (d ));_fadf ._eaecd .CustomHeightAttr =_f .Bool (true );};

// Type returns the type of the rule
func (_baad ConditionalFormattingRule )Type ()_ad .ST_CfType {return _baad ._fgd .TypeAttr };

// AddView adds a sheet view.
func (_eabge *Sheet )AddView ()SheetView {if _eabge ._dbfc .SheetViews ==nil {_eabge ._dbfc .SheetViews =_ad .NewCT_SheetViews ();};_ffecc :=_ad .NewCT_SheetView ();_eabge ._dbfc .SheetViews .SheetView =append (_eabge ._dbfc .SheetViews .SheetView ,_ffecc );return SheetView {_ffecc };};

// Cell is a single cell within a sheet.
type Cell struct{_bgf *Workbook ;_be *Sheet ;_cgda *_ad .CT_Row ;_abg *_ad .CT_Cell ;};func _defb (_abf *Sheet )*evalContext {return &evalContext {_gccf :_abf ,_faa :make (map[string ]struct{})};};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_gfb *Sheet )SheetViews ()[]SheetView {if _gfb ._dbfc .SheetViews ==nil {return nil ;};_daff :=[]SheetView {};for _ ,_deef :=range _gfb ._dbfc .SheetViews .SheetView {_daff =append (_daff ,SheetView {_deef });};return _daff ;};

// SetHyperlink sets a hyperlink on a cell.
func (_cee Cell )SetHyperlink (hl _fa .Hyperlink ){_deg :=_cee ._be ._dbfc ;if _deg .Hyperlinks ==nil {_deg .Hyperlinks =_ad .NewCT_Hyperlinks ();};_dcb :=_fa .Relationship (hl );_bc :=_ad .NewCT_Hyperlink ();_bc .RefAttr =_cee .Reference ();_bc .IdAttr =_f .String (_dcb .ID ());_deg .Hyperlinks .Hyperlink =append (_deg .Hyperlinks .Hyperlink ,_bc );};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_fce *_ad .CT_ColorScale };

// IsEmpty checks if the cell style contains nothing.
func (_gga CellStyle )IsEmpty ()bool {return _gga ._ggfd ==nil ||_gga ._cff ==nil ||_gga ._ggff ==nil ||_gga ._ggff .Xf ==nil ;};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_ceg Drawing )AddImage (img _fa .ImageRef ,at AnchorType )Anchor {_acc :=0;for _eabc ,_cgc :=range _ceg ._eaa .Images {if _cgc ==img {_acc =_eabc +1;break ;};};var _bde string ;for _bed ,_dbae :=range _ceg ._eaa ._ggbb {if _dbae ==_ceg ._geff {_gbde :=_ba .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_acc ,img .Format ());_abbe :=_ceg ._eaa ._fbae [_bed ].AddRelationship (_gbde ,_f .ImageType );_bde =_abbe .ID ();break ;};};var _dgga Anchor ;var _gadc *_ab .CT_Picture ;switch at {case AnchorTypeAbsolute :_bbgf :=_edbf ();_ceg ._geff .EG_Anchor =append (_ceg ._geff .EG_Anchor ,&_ab .EG_Anchor {AbsoluteAnchor :_bbgf });_bbgf .Choice =&_ab .EG_ObjectChoicesChoice {};_bbgf .Choice .Pic =_ab .NewCT_Picture ();_bbgf .Pos .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_bbgf .Pos .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_gadc =_bbgf .Choice .Pic ;_dgga =AbsoluteAnchor {_bbgf };case AnchorTypeOneCell :_gdce :=_bbcg ();_ceg ._geff .EG_Anchor =append (_ceg ._geff .EG_Anchor ,&_ab .EG_Anchor {OneCellAnchor :_gdce });_gdce .Choice =&_ab .EG_ObjectChoicesChoice {};_gdce .Choice .Pic =_ab .NewCT_Picture ();_gadc =_gdce .Choice .Pic ;_dgga =OneCellAnchor {_gdce };case AnchorTypeTwoCell :_aca :=_abd ();_ceg ._geff .EG_Anchor =append (_ceg ._geff .EG_Anchor ,&_ab .EG_Anchor {TwoCellAnchor :_aca });_aca .Choice =&_ab .EG_ObjectChoicesChoice {};_aca .Choice .Pic =_ab .NewCT_Picture ();_gadc =_aca .Choice .Pic ;_dgga =TwoCellAnchor {_aca };};_gadc .NvPicPr .CNvPr .IdAttr =uint32 (len (_ceg ._geff .EG_Anchor ));_gadc .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_gadc .BlipFill .Blip =_cb .NewCT_Blip ();_gadc .BlipFill .Blip .EmbedAttr =_f .String (_bde );_gadc .BlipFill .Stretch =_cb .NewCT_StretchInfoProperties ();_gadc .SpPr =_cb .NewCT_ShapeProperties ();_gadc .SpPr .Xfrm =_cb .NewCT_Transform2D ();_gadc .SpPr .Xfrm .Off =_cb .NewCT_Point2D ();_gadc .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_f .Int64 (0);_gadc .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_f .Int64 (0);_gadc .SpPr .Xfrm .Ext =_cb .NewCT_PositiveSize2D ();_gadc .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_gb .Pixel72 )/_gb .EMU );_gadc .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_gb .Pixel72 )/_gb .EMU );_gadc .SpPr .PrstGeom =_cb .NewCT_PresetGeometry2D ();_gadc .SpPr .PrstGeom .PrstAttr =_cb .ST_ShapeTypeRect ;_gadc .SpPr .Ln =_cb .NewCT_LineProperties ();_gadc .SpPr .Ln .NoFill =_cb .NewCT_NoFillProperties ();return _dgga ;};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_adc Comment )SetAuthor (author string ){_adc ._gdd .AuthorIdAttr =Comments {_adc ._dgf ,_adc ._gce }.getOrCreateAuthor (author );};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// RemoveDefinedName removes an existing defined name.
func (_aeaa *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _fgc .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _bae ,_accf :=range _aeaa ._aeaf .DefinedNames .DefinedName {if _accf ==dn .X (){copy (_aeaa ._aeaf .DefinedNames .DefinedName [_bae :],_aeaa ._aeaf .DefinedNames .DefinedName [_bae +1:]);_aeaa ._aeaf .DefinedNames .DefinedName [len (_aeaa ._aeaf .DefinedNames .DefinedName )-1]=nil ;_aeaa ._aeaf .DefinedNames .DefinedName =_aeaa ._aeaf .DefinedNames .DefinedName [:len (_aeaa ._aeaf .DefinedNames .DefinedName )-1];return nil ;};};return _fgc .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_eeb Cell )SetStyleIndex (idx uint32 ){_eeb ._abg .SAttr =_f .Uint32 (idx )};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_bgded StyleSheet )AddCellStyle ()CellStyle {_ddbf :=_ad .NewCT_Xf ();_bgded ._gagf .CellXfs .Xf =append (_bgded ._gagf .CellXfs .Xf ,_ddbf );_bgded ._gagf .CellXfs .CountAttr =_f .Uint32 (uint32 (len (_bgded ._gagf .CellXfs .Xf )));return CellStyle {_bgded ._geecg ,_ddbf ,_bgded ._gagf .CellXfs };};type WorkbookProtection struct{_gaga *_ad .CT_WorkbookProtection };

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_agc Cell )SetStringByID (id int ){_agc ._bgf .ensureSharedStringsRelationships ();_agc .clearValue ();_agc ._abg .V =_f .String (_ga .Itoa (id ));_agc ._abg .TAttr =_ad .ST_CellTypeS ;};func (_deeb *evalContext )Cell (ref string ,ev _cea .Evaluator )_cea .Result {if !_eaec (ref ){return _cea .MakeErrorResultType (_cea .ErrorTypeName ,"");};_ffa :=_deeb ._gccf .Name ()+"\u0021"+ref ;if _eebgf ,_eag :=ev .GetFromCache (_ffa );_eag {return _eebgf ;};_fgcd ,_gaed :=_fec .ParseCellReference (ref );if _gaed !=nil {return _cea .MakeErrorResult (_ba .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_gaed ));};if _deeb ._gfad !=0&&!_fgcd .AbsoluteColumn {_fgcd .ColumnIdx +=_deeb ._gfad ;_fgcd .Column =_fec .IndexToColumn (_fgcd .ColumnIdx );};if _deeb ._efg !=0&&!_fgcd .AbsoluteRow {_fgcd .RowIdx +=_deeb ._efg ;};_efcb :=_deeb ._gccf .Cell (_fgcd .String ());if _efcb .HasFormula (){if _ ,_cdaf :=_deeb ._faa [ref ];_cdaf {return _cea .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_deeb ._faa [ref ]=struct{}{};_fbfg :=ev .Eval (_deeb ,_efcb .GetFormula ());delete (_deeb ._faa ,ref );ev .SetCache (_ffa ,_fbfg );return _fbfg ;};if _efcb .IsEmpty (){_cfcd :=_cea .MakeEmptyResult ();ev .SetCache (_ffa ,_cfcd );return _cfcd ;}else if _efcb .IsNumber (){_adeb ,_ :=_efcb .GetValueAsNumber ();_bcdf :=_cea .MakeNumberResult (_adeb );ev .SetCache (_ffa ,_bcdf );return _bcdf ;}else if _efcb .IsBool (){_ebcf ,_ :=_efcb .GetValueAsBool ();_adcf :=_cea .MakeBoolResult (_ebcf );ev .SetCache (_ffa ,_adcf );return _adcf ;};_cce ,_ :=_efcb .GetRawValue ();if _efcb .IsError (){_ebae :=_cea .MakeErrorResult ("");_ebae .ValueString =_cce ;ev .SetCache (_ffa ,_ebae );return _ebae ;};_eab :=_cea .MakeStringResult (_cce );ev .SetCache (_ffa ,_eab );return _eab ;};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_ggag TwoCellAnchor )SetWidthCells (w int32 ){_dbcf :=_ggag .TopLeft ();_eefac :=_ggag .BottomRight ();_eefac .SetCol (_dbcf .Col ()+w );};

// ClearProtection removes any protections applied to teh sheet.
func (_dad *Sheet )ClearProtection (){_dad ._dbfc .SheetProtection =nil };func (_ddd SheetView )ensurePane (){if _ddd ._deeg .Pane ==nil {_ddd ._deeg .Pane =_ad .NewCT_Pane ();_ddd ._deeg .Pane .ActivePaneAttr =_ad .ST_PaneBottomLeft ;};};

// X returns the inner wrapped XML type.
func (_ecd Sheet )X ()*_ad .Worksheet {return _ecd ._dbfc };

// Type returns the type of anchor
func (_geca TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };func (_gg Border )SetDiagonal (style _ad .ST_BorderStyle ,c _ebb .Color ,up ,down bool ){if _gg ._ecg .Diagonal ==nil {_gg ._ecg .Diagonal =_ad .NewCT_BorderPr ();};_gg ._ecg .Diagonal .Color =_ad .NewCT_Color ();_gg ._ecg .Diagonal .Color .RgbAttr =c .AsRGBAString ();_gg ._ecg .Diagonal .StyleAttr =style ;if up {_gg ._ecg .DiagonalUpAttr =_f .Bool (true );};if down {_gg ._ecg .DiagonalDownAttr =_f .Bool (true );};};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_deeg *_ad .CT_SheetView };

// CellStyles returns the list of defined cell styles
func (_afae StyleSheet )CellStyles ()[]CellStyle {_fbgc :=[]CellStyle {};for _ ,_dfbf :=range _afae ._gagf .CellXfs .Xf {_fbgc =append (_fbgc ,CellStyle {_afae ._geecg ,_dfbf ,_afae ._gagf .CellXfs });};return _fbgc ;};

// BottomRight is a no-op.
func (_gaefc OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Validate attempts to validate the structure of a workbook.
func (_gdfa *Workbook )Validate ()error {if _gdfa ==nil ||_gdfa ._aeaf ==nil {return _fgc .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_gfdd :=uint32 (0);for _ ,_cgbc :=range _gdfa ._aeaf .Sheets .Sheet {if _cgbc .SheetIdAttr > _gfdd {_gfdd =_cgbc .SheetIdAttr ;};};if _gfdd !=uint32 (len (_gdfa ._ebag )){return _ba .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_gfdd ,len (_gdfa ._ebag ));};_gffd :=map[string ]struct{}{};for _cbbe ,_acggc :=range _gdfa ._aeaf .Sheets .Sheet {_ddbbg :=Sheet {_gdfa ,_acggc ,_gdfa ._ebag [_cbbe ]};if _ ,_fgcda :=_gffd [_ddbbg .Name ()];_fgcda {return _ba .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_cbbe ,_ddbbg .Name ());};_gffd [_ddbbg .Name ()]=struct{}{};if _acge :=_ddbbg .ValidateWithPath (_ba .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_cbbe ));_acge !=nil {return _acge ;};if _edfe :=_ddbbg .Validate ();_edfe !=nil {return _edfe ;};};return nil ;};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_ccdb *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_cbff :=-1;for _fdcg ,_bdba :=range _ccdb .Sheets (){if name ==_bdba .Name (){_cbff =_fdcg ;break ;};};if _cbff ==-1{return Sheet {},ErrorNotFound ;};return _ccdb .CopySheet (_cbff ,copiedSheetName );};

// AddRun adds a new run of text to the cell.
func (_cbca RichText )AddRun ()RichTextRun {_dbc :=_ad .NewCT_RElt ();_cbca ._abfe .R =append (_cbca ._abfe .R ,_dbc );return RichTextRun {_dbc };};func (_gca DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_gca .clear ();_gca ._ebef .TypeAttr =_ad .ST_DataValidationType (t );_gca ._ebef .OperatorAttr =_ad .ST_DataValidationOperator (op );return DataValidationCompare {_gca ._ebef };};func _agb (_aba _feb .Time )_feb .Time {_aba =_aba .Local ();return _feb .Date (_aba .Year (),_aba .Month (),_aba .Day (),_aba .Hour (),_aba .Minute (),_aba .Second (),_aba .Nanosecond (),_feb .UTC );};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_adfd Sheet )ValidateWithPath (path string )error {return _adfd ._dbfc .ValidateWithPath (path )};

// X returns the inner wrapped XML type.
func (_cgdag SharedStrings )X ()*_ad .Sst {return _cgdag ._bbab };

// SetInlineString adds a string inline instead of in the shared strings table.
func (_abbf Cell )SetInlineString (s string ){_abbf .clearValue ();_abbf ._abg .Is =_ad .NewCT_Rst ();_abbf ._abg .Is .T =_f .String (s );_abbf ._abg .TAttr =_ad .ST_CellTypeInlineStr ;};

// Reference returns the table reference (the cells within the table)
func (_dfgg Table )Reference ()string {return _dfgg ._edcd .RefAttr };

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ad .Comments )Comments {return Comments {w ,x }};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_afe Comments )AddComment (cellRef string ,author string )RichText {_beb :=_ad .NewCT_Comment ();_afe ._gdbe .CommentList .Comment =append (_afe ._gdbe .CommentList .Comment ,_beb );_beb .RefAttr =cellRef ;_beb .AuthorIdAttr =_afe .getOrCreateAuthor (author );_beb .Text =_ad .NewCT_Rst ();return RichText {_beb .Text };};func _cgcd (_gacc string ,_aaga uint32 ,_gaaf bool )string {_dffa ,_baba ,_ccac :=_fec .ParseRangeReference (_gacc );if _ccac ==nil {_dcbd ,_bgfc :=_dffa .ColumnIdx ,_baba .ColumnIdx ;if _aaga >=_dcbd &&_aaga <=_bgfc {if _dcbd ==_bgfc {if _gaaf {return "";}else {return _gacc ;};}else {_fda :=_baba .Update (_e .UpdateActionRemoveColumn );return _ba .Sprintf ("\u0025\u0073\u003a%\u0073",_dffa .String (),_fda .String ());};}else if _aaga < _dcbd {_bfg :=_dffa .Update (_e .UpdateActionRemoveColumn );_egeg :=_baba .Update (_e .UpdateActionRemoveColumn );return _ba .Sprintf ("\u0025\u0073\u003a%\u0073",_bfg .String (),_egeg .String ());};}else {_gfaa ,_gdgg ,_dcfb :=_fec .ParseColumnRangeReference (_gacc );if _dcfb !=nil {return "";};_cfbf ,_fgfb :=_gfaa .ColumnIdx ,_gdgg .ColumnIdx ;if _aaga >=_cfbf &&_aaga <=_fgfb {if _cfbf ==_fgfb {if _gaaf {return "";}else {return _gacc ;};}else {_ffaf :=_gdgg .Update (_e .UpdateActionRemoveColumn );return _ba .Sprintf ("\u0025\u0073\u003a%\u0073",_gfaa .String (),_ffaf .String ());};}else if _aaga < _cfbf {_bbcc :=_gfaa .Update (_e .UpdateActionRemoveColumn );_gfab :=_gdgg .Update (_e .UpdateActionRemoveColumn );return _ba .Sprintf ("\u0025\u0073\u003a%\u0073",_bbcc .String (),_gfab .String ());};};return "";};

// Cell returns the actual cell behind the merged region
func (_afd MergedCell )Cell ()Cell {_gbdeg :=_afd .Reference ();if _ccgf :=_ff .Index (_afd .Reference (),"\u003a");_ccgf !=-1{_gbdeg =_gbdeg [0:_ccgf ];return _afd ._bac .Cell (_gbdeg );};return Cell {};};func (_egbd *Sheet )getAllCellsInFormulaArrays (_fef bool )(map[string ]bool ,error ){_ecae :=_cea .NewEvaluator ();_dcdd :=_egbd .FormulaContext ();_bgde :=map[string ]bool {};for _ ,_gacf :=range _egbd .Rows (){for _ ,_cbbg :=range _gacf .Cells (){if _cbbg .X ().F !=nil {_bdace :=_cbbg .X ().F .Content ;if _cbbg .X ().F .TAttr ==_ad .ST_CellFormulaTypeArray {_cadc :=_ecae .Eval (_dcdd ,_bdace ).AsString ();if _cadc .Type ==_cea .ResultTypeError {_bbc .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bdace ,_cadc .ErrorMessage );_cbbg .X ().V =nil ;};if _cadc .Type ==_cea .ResultTypeArray {_cccc ,_afde :=_fec .ParseCellReference (_cbbg .Reference ());if _afde !=nil {return map[string ]bool {},_afde ;};if (_fef &&len (_cadc .ValueArray )==1)||(!_fef &&len (_cadc .ValueArray [0])==1){continue ;};for _eggb ,_bagdg :=range _cadc .ValueArray {_bdfgb :=_cccc .RowIdx +uint32 (_eggb );for _agce :=range _bagdg {_aebd :=_fec .IndexToColumn (_cccc .ColumnIdx +uint32 (_agce ));_bgde [_ba .Sprintf ("\u0025\u0073\u0025\u0064",_aebd ,_bdfgb )]=true ;};};}else if _cadc .Type ==_cea .ResultTypeList {_cab ,_fgaag :=_fec .ParseCellReference (_cbbg .Reference ());if _fgaag !=nil {return map[string ]bool {},_fgaag ;};if _fef ||len (_cadc .ValueList )==1{continue ;};_gcgg :=_cab .RowIdx ;for _aaee :=range _cadc .ValueList {_dbaf :=_fec .IndexToColumn (_cab .ColumnIdx +uint32 (_aaee ));_bgde [_ba .Sprintf ("\u0025\u0073\u0025\u0064",_dbaf ,_gcgg )]=true ;};};};};};};return _bgde ,nil ;};

// SetLocked sets cell locked or not.
func (_bbfd *evalContext )SetLocked (cellRef string ,locked bool ){_bbfd ._gccf .Cell (cellRef ).setLocked (locked );};

// Comments returns the comments for a sheet.
func (_dfbcc *Sheet )Comments ()Comments {for _ebdb ,_bdfce :=range _dfbcc ._ffec ._ebag {if _bdfce ==_dfbcc ._dbfc {if _dfbcc ._ffec ._febe [_ebdb ]==nil {_dfbcc ._ffec ._febe [_ebdb ]=_ad .NewComments ();_dfbcc ._ffec ._bced [_ebdb ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,_ebdb +1,_f .CommentsType );_dfbcc ._ffec .ContentTypes .AddOverride (_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .CommentsType ,_ebdb +1),_f .CommentsContentType );};if len (_dfbcc ._ffec ._addg )==0{_dfbcc ._ffec ._addg =append (_dfbcc ._ffec ._addg ,_ce .NewCommentDrawing ());_bgcg :=_dfbcc ._ffec ._bced [_ebdb ].AddAutoRelationship (_f .DocTypeSpreadsheet ,_f .WorksheetType ,1,_f .VMLDrawingType );if _dfbcc ._dbfc .LegacyDrawing ==nil {_dfbcc ._dbfc .LegacyDrawing =_ad .NewCT_LegacyDrawing ();};_dfbcc ._dbfc .LegacyDrawing .IdAttr =_bgcg .ID ();};return Comments {_dfbcc ._ffec ,_dfbcc ._ffec ._febe [_ebdb ]};};};_bbc .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};

// SetWidthCells is a no-op.
func (_abdc OneCellAnchor )SetWidthCells (int32 ){};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_dfca Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_dfca .SetNumber (v );_dfca .SetStyle (_dfca ._bgf .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;func (_gcgdf Font )SetColor (c _ebb .Color ){_gcaa :=_ad .NewCT_Color ();_dcd :="\u0066\u0066"+*c .AsRGBString ();_gcaa .RgbAttr =&_dcd ;_gcgdf ._fcgcc .Color =[]*_ad .CT_Color {_gcaa };};func _dag (_abag bool )int {if _abag {return 1;};return 0;};

// CellMarker represents a cell position
type CellMarker struct{_dcc *_ab .CT_Marker };

// GetFill gets a Fill from a cell style.
func (_ead CellStyle )GetFill ()*_ad .CT_Fill {if _bbd :=_ead ._cff .FillIdAttr ;_bbd !=nil {_ceb :=_ead ._ggfd .StyleSheet .Fills ().X ().Fill ;if int (*_bbd )< len (_ceb ){return _ceb [int (*_bbd )];};};return nil ;};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _cf .ReaderAt ,size int64 )(*Workbook ,error ){const _gaad ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_ca .GetLicenseKey ().IsLicensed ()&&!_eacbd {_ba .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_ba .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return nil ,_fgc .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_ccge :=New ();_aaab ,_gdda :=_ca .GenRefId ("\u0073\u0072");if _gdda !=nil {_bbc .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_gdda );return nil ,_gdda ;};_ccge ._eedd =_aaab ;if _daed :=_ca .Track (_ccge ._eedd ,_gaad );_daed !=nil {_bbc .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_daed );return nil ,_daed ;};_cega ,_gdda :=_eb .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _gdda !=nil {return nil ,_gdda ;};_ccge .TmpPath =_cega ;_gddab ,_gdda :=_ge .NewReader (r ,size );if _gdda !=nil {return nil ,_ba .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_gdda );};_cafd :=[]*_ge .File {};_cafd =append (_cafd ,_gddab .File ...);_gcf :=false ;for _ ,_gddc :=range _cafd {if _gddc .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_gcf =true ;break ;};};if _gcf {_ccge .CreateCustomProperties ();};_cgaa :=_fgb .DecodeMap {};_cgaa .SetOnNewRelationshipFunc (_ccge .onNewRelationship );_cgaa .AddTarget (_f .ContentTypesFilename ,_ccge .ContentTypes .X (),"",0);_cgaa .AddTarget (_f .BaseRelsFilename ,_ccge .Rels .X (),"",0);if _fbfd :=_cgaa .Decode (_cafd );_fbfd !=nil {return nil ,_fbfd ;};for _ ,_bcb :=range _cafd {if _bcb ==nil {continue ;};if _bbfb :=_ccge .AddExtraFileFromZip (_bcb );_bbfb !=nil {return nil ,_bbfb ;};};if _gcf {_eadc :=false ;for _ ,_agfc :=range _ccge .Rels .X ().Relationship {if _agfc .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_eadc =true ;break ;};};if !_eadc {_ccge .AddCustomRelationships ();};};return _ccge ,nil ;};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_dgb Cell )SetFormulaArray (s string ){_bda :=_cea .ParseString (s );if _bda ==nil {return ;};_dgb .clearValue ();_dgb ._abg .TAttr =_ad .ST_CellTypeStr ;_dgb ._abg .F =_ad .NewCT_CellFormula ();_dgb ._abg .F .TAttr =_ad .ST_CellFormulaTypeArray ;_dgb ._abg .F .Content =s ;};func (_ddaa DataValidation )SetList ()DataValidationList {_ddaa .clear ();_ddaa ._ebef .TypeAttr =_ad .ST_DataValidationTypeList ;_ddaa ._ebef .OperatorAttr =_ad .ST_DataValidationOperatorEqual ;return DataValidationList {_ddaa ._ebef };};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_cagd *Sheet )AddRow ()Row {_cfag :=uint32 (0);_begd :=uint32 (len (_cagd ._dbfc .SheetData .Row ));if _begd > 0&&_cagd ._dbfc .SheetData .Row [_begd -1].RAttr !=nil &&*_cagd ._dbfc .SheetData .Row [_begd -1].RAttr ==_begd {return _cagd .addNumberedRowFast (_begd +1);};for _ ,_cffcc :=range _cagd ._dbfc .SheetData .Row {if _cffcc .RAttr !=nil &&*_cffcc .RAttr > _cfag {_cfag =*_cffcc .RAttr ;};};return _cagd .AddNumberedRow (_cfag +1);};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_adee *evalContext )LastColumn (rowFrom ,rowTo int )string {_aaag :=_adee ._gccf ;_gfg :=1;for _cgbb :=rowFrom ;_cgbb <=rowTo ;_cgbb ++{_fedc :=len (_aaag .Row (uint32 (_cgbb )).Cells ());if _fedc > _gfg {_gfg =_fedc ;};};return _fec .IndexToColumn (uint32 (_gfg -1));};func (_fded Font )SetSize (size float64 ){_fded ._fcgcc .Sz =[]*_ad .CT_FontSize {{ValAttr :size }}};

// AddCommentWithStyle adds a new comment styled in a default way
func (_cace Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_fea :=_cace .AddComment (cellRef ,author );_gaag :=_fea .AddRun ();_gaag .SetBold (true );_gaag .SetSize (10);_gaag .SetColor (_ebb .Black );_gaag .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_gaag .SetText (author +"\u003a");_gaag =_fea .AddRun ();_gaag .SetSize (10);_gaag .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_gaag .SetColor (_ebb .Black );_gaag .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_gdc ,_daaa :=_fec .ParseCellReference (cellRef );if _daaa !=nil {return _daaa ;};_cace ._dfcb ._addg [0].Shape =append (_cace ._dfcb ._addg [0].Shape ,_ce .NewCommentShape (int64 (_gdc .ColumnIdx ),int64 (_gdc .RowIdx -1)));return nil ;};

// MoveTo moves the top-left of the anchored object.
func (_fdc OneCellAnchor )MoveTo (col ,row int32 ){_fdc .TopLeft ().SetCol (col );_fdc .TopLeft ().SetRow (row );};

// X returns the inner wrapped XML type.
func (_gcgd Comments )X ()*_ad .Comments {return _gcgd ._gdbe };type Table struct{_edcd *_ad .Table };

// SetPasswordHash sets the password hash to the input.
func (_bgaf WorkbookProtection )SetPasswordHash (pwHash string ){_bgaf ._gaga .WorkbookPasswordAttr =_f .String (pwHash );};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_abbd *Sheet )RecalculateFormulas (){_dfegg :=_cea .NewEvaluator ();_fcabe :=_abbd .FormulaContext ();for _ ,_bbaba :=range _abbd .Rows (){for _ ,_abba :=range _bbaba .Cells (){if _abba .X ().F !=nil {_bbbbe :=_abba .X ().F .Content ;if _abba .X ().F .TAttr ==_ad .ST_CellFormulaTypeShared &&len (_bbbbe )==0{continue ;};_ggce :=_dfegg .Eval (_fcabe ,_bbbbe ).AsString ();if _ggce .Type ==_cea .ResultTypeError {_bbc .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_bbbbe ,_ggce .ErrorMessage );_abba .X ().V =nil ;}else {if _ggce .Type ==_cea .ResultTypeNumber {_abba .X ().TAttr =_ad .ST_CellTypeN ;}else {_abba .X ().TAttr =_ad .ST_CellTypeInlineStr ;};_abba .X ().V =_f .String (_ggce .Value ());if _abba .X ().F .TAttr ==_ad .ST_CellFormulaTypeArray {if _ggce .Type ==_cea .ResultTypeArray {_abbd .setArray (_abba .Reference (),_ggce );}else if _ggce .Type ==_cea .ResultTypeList {_abbd .setList (_abba .Reference (),_ggce );};}else if _abba .X ().F .TAttr ==_ad .ST_CellFormulaTypeShared &&_abba .X ().F .RefAttr !=nil {_dcea ,_aggb ,_adeba :=_fec .ParseRangeReference (*_abba .X ().F .RefAttr );if _adeba !=nil {_bbc .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_adeba );continue ;};_abbd .setShared (_abba .Reference (),_dcea ,_aggb ,_bbbbe );};};};};};};

// SetType sets the type of the rule.
func (_aef ConditionalFormattingRule )SetType (t _ad .ST_CfType ){_aef ._fgd .TypeAttr =t };

// X returns the inner wrapped XML type.
func (_edc Row )X ()*_ad .CT_Row {return _edc ._eaecd };func (_cgcc *Sheet )slideCellsLeft (_beed []*_ad .CT_Cell )[]*_ad .CT_Cell {for _ ,_aead :=range _beed {_gfdac ,_bbgfc :=_fec .ParseCellReference (*_aead .RAttr );if _bbgfc !=nil {return _beed ;};_abdg :=_gfdac .ColumnIdx -1;_adbeg :=_fec .IndexToColumn (_abdg )+_ba .Sprintf ("\u0025\u0064",_gfdac .RowIdx );_aead .RAttr =&_adbeg ;};return _beed ;};func (_gda CellStyle )SetNumberFormat (s string ){_dfeg :=_gda ._ggfd .StyleSheet .AddNumberFormat ();_dfeg .SetFormat (s );_gda ._cff .ApplyNumberFormatAttr =_f .Bool (true );_gda ._cff .NumFmtIdAttr =_f .Uint32 (_dfeg .ID ());};func (_dbb Fill )Index ()uint32 {if _dbb ._effb ==nil {return 0;};for _cdaa ,_efdf :=range _dbb ._effb .Fill {if _dbb ._dfef ==_efdf {return uint32 (_cdaa );};};return 0;};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_fbff *Sheet )RemoveColumn (column string )error {_cgfcg ,_afeb :=_fbff .getAllCellsInFormulaArraysForColumn ();if _afeb !=nil {return _afeb ;};_eeag :=_fec .ColumnToIndex (column );for _ ,_edee :=range _fbff .Rows (){_gacb :=_ba .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_edee .X ().RAttr );if _ ,_eeff :=_cgfcg [_gacb ];_eeff {return nil ;};};for _ ,_ddcg :=range _fbff .Rows (){_ddecd :=_ddcg ._eaecd .C ;for _aggf ,_cfef :=range _ddecd {_bfdd ,_acdc :=_fec .ParseCellReference (*_cfef .RAttr );if _acdc !=nil {return _acdc ;};if _bfdd .ColumnIdx ==_eeag {_ddcg ._eaecd .C =append (_ddecd [:_aggf ],_fbff .slideCellsLeft (_ddecd [_aggf +1:])...);break ;}else if _bfdd .ColumnIdx > _eeag {_ddcg ._eaecd .C =append (_ddecd [:_aggf ],_fbff .slideCellsLeft (_ddecd [_aggf :])...);break ;};};};_afeb =_fbff .updateAfterRemove (_eeag ,_e .UpdateActionRemoveColumn );if _afeb !=nil {return _afeb ;};_afeb =_fbff .removeColumnFromNamedRanges (_eeag );if _afeb !=nil {return _afeb ;};_afeb =_fbff .removeColumnFromMergedCells (_eeag );if _afeb !=nil {return _afeb ;};for _ ,_acfg :=range _fbff ._ffec .Sheets (){_acfg .RecalculateFormulas ();};return nil ;};func (_baf CellStyle )SetShrinkToFit (b bool ){if _baf ._cff .Alignment ==nil {_baf ._cff .Alignment =_ad .NewCT_CellAlignment ();};_baf ._cff .ApplyAlignmentAttr =_f .Bool (true );if !b {_baf ._cff .Alignment .ShrinkToFitAttr =nil ;}else {_baf ._cff .Alignment .ShrinkToFitAttr =_f .Bool (b );};};

// SetItalic causes the text to be displayed in italic.
func (_cdbd RichTextRun )SetItalic (b bool ){_cdbd .ensureRpr ();_cdbd ._dbec .RPr .I =_ad .NewCT_BooleanProperty ();_cdbd ._dbec .RPr .I .ValAttr =_f .Bool (b );};

// X returns the inner wrapped XML type.
func (_gff DifferentialStyle )X ()*_ad .CT_Dxf {return _gff ._cebf };

// X returns the inner wrapped XML type.
func (_dfdf *Workbook )X ()*_ad .Workbook {return _dfdf ._aeaf };

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_efaa TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_efaa ._deac .From }};type PatternFill struct{_gdcg *_ad .CT_PatternFill ;_acfc *_ad .CT_Fill ;};

// X returns the inner wrapped XML type.
func (_cdf CellMarker )X ()*_ab .CT_Marker {return _cdf ._dcc };func (_dgcd *Workbook )onNewRelationship (_becc *_fgb .DecodeMap ,_fee ,_egff string ,_gaca []*_ge .File ,_bfae *_cd .Relationship ,_cadg _fgb .Target )error {_gfdace :=_f .DocTypeSpreadsheet ;switch _egff {case _f .OfficeDocumentType :_dgcd ._aeaf =_ad .NewWorkbook ();_becc .AddTarget (_fee ,_dgcd ._aeaf ,_egff ,0);_dgcd ._bdgd =_fa .NewRelationships ();_becc .AddTarget (_fgb .RelationsPathFor (_fee ),_dgcd ._bdgd .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .CorePropertiesType :_becc .AddTarget (_fee ,_dgcd .CoreProperties .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .CustomPropertiesType :_becc .AddTarget (_fee ,_dgcd .CustomProperties .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .ExtendedPropertiesType :_becc .AddTarget (_fee ,_dgcd .AppProperties .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .WorksheetType :_aadad :=_ad .NewWorksheet ();_ggcd :=uint32 (len (_dgcd ._ebag ));_dgcd ._ebag =append (_dgcd ._ebag ,_aadad );_becc .AddTarget (_fee ,_aadad ,_egff ,_ggcd );_ddbc :=_fa .NewRelationships ();_becc .AddTarget (_fgb .RelationsPathFor (_fee ),_ddbc .X (),_egff ,0);_dgcd ._bced =append (_dgcd ._bced ,_ddbc );_dgcd ._febe =append (_dgcd ._febe ,nil );_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._ebag ));case _f .StylesType :_dgcd .StyleSheet =NewStyleSheet (_dgcd );_becc .AddTarget (_fee ,_dgcd .StyleSheet .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .ThemeType :_ffacc :=_cb .NewTheme ();_dgcd ._ecgeb =append (_dgcd ._ecgeb ,_ffacc );_becc .AddTarget (_fee ,_ffacc ,_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._ecgeb ));case _f .SharedStringsType :_dgcd .SharedStrings =NewSharedStrings ();_becc .AddTarget (_fee ,_dgcd .SharedStrings .X (),_egff ,0);_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,0);case _f .ThumbnailType :for _fbadb ,_deda :=range _gaca {if _deda ==nil {continue ;};if _deda .Name ==_fee {_dgbd ,_bcad :=_deda .Open ();if _bcad !=nil {return _ba .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_bcad );};_dgcd .Thumbnail ,_ ,_bcad =_g .Decode (_dgbd );_dgbd .Close ();if _bcad !=nil {return _ba .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_bcad );};_gaca [_fbadb ]=nil ;};};case _f .ImageType :for _fcad ,_gcag :=range _dgcd ._efadg {_abaa :=_a .Clean (_fee );if _abaa ==_fcad {_bfae .TargetAttr =_gcag ;return nil ;};};_geae :=_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd .Images )+1);for _cgbd ,_gedf :=range _gaca {if _gedf ==nil {continue ;};if _gedf .Name ==_a .Clean (_fee ){_fafe ,_egd :=_fgb .ExtractToDiskTmp (_gedf ,_dgcd .TmpPath );if _egd !=nil {return _egd ;};_ceag ,_egd :=_fa .ImageFromStorage (_fafe );if _egd !=nil {return _egd ;};_dcgb :=_fa .MakeImageRef (_ceag ,&_dgcd .DocBase ,_dgcd ._bdgd );_dcgb .SetTarget (_geae );_dgcd ._efadg [_gedf .Name ]=_geae ;_dgcd .Images =append (_dgcd .Images ,_dcgb );_gaca [_cgbd ]=nil ;};};_bfae .TargetAttr =_geae ;case _f .DrawingType :_edcf :=_ab .NewWsDr ();_fcef :=uint32 (len (_dgcd ._ggbb ));_becc .AddTarget (_fee ,_edcf ,_egff ,_fcef );_dgcd ._ggbb =append (_dgcd ._ggbb ,_edcf );_cbag :=_fa .NewRelationships ();_becc .AddTarget (_fgb .RelationsPathFor (_fee ),_cbag .X (),_egff ,_fcef );_dgcd ._fbae =append (_dgcd ._fbae ,_cbag );_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._ggbb ));case _f .VMLDrawingType :_fbfb :=_ce .NewContainer ();_gfdae :=uint32 (len (_dgcd ._addg ));_becc .AddTarget (_fee ,_fbfb ,_egff ,_gfdae );_dgcd ._addg =append (_dgcd ._addg ,_fbfb );case _f .CommentsType :_dgcd ._febe [_cadg .Index ]=_ad .NewComments ();_becc .AddTarget (_fee ,_dgcd ._febe [_cadg .Index ],_egff ,_cadg .Index );_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._febe ));case _f .ChartType :_ebfea :=_da .NewChartSpace ();_ebcg :=uint32 (len (_dgcd ._fefd ));_becc .AddTarget (_fee ,_ebfea ,_egff ,_ebcg );_dgcd ._fefd =append (_dgcd ._fefd ,_ebfea );_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._fefd ));_dgcd ._agdb [_bfae .TargetAttr ]=_ebfea ;case _f .TableType :_degd :=_ad .NewTable ();_dagg :=uint32 (len (_dgcd ._dbge ));_becc .AddTarget (_fee ,_degd ,_egff ,_dagg );_dgcd ._dbge =append (_dgcd ._dbge ,_degd );_bfae .TargetAttr =_f .RelativeFilename (_gfdace ,_cadg .Typ ,_egff ,len (_dgcd ._dbge ));default:_bbc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_fee ,_egff );};return nil ;};

// ExtractText returns text from the workbook as a WorkbookText object.
func (_dac *Workbook )ExtractText ()*WorkbookText {_bdbf :=[]*SheetText {};for _ ,_gdeg :=range _dac .Sheets (){_bdbf =append (_bdbf ,&SheetText {Cells :_gdeg .ExtractText ().Cells });};return &WorkbookText {Sheets :_bdbf };};func _abd ()*_ab .CT_TwoCellAnchor {_gbag :=_ab .NewCT_TwoCellAnchor ();_gbag .EditAsAttr =_ab .ST_EditAsOneCell ;_gbag .From .Col =5;_gbag .From .Row =0;_gbag .From .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_gbag .From .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);_gbag .To .Col =10;_gbag .To .Row =20;_gbag .To .ColOff .ST_CoordinateUnqualified =_f .Int64 (0);_gbag .To .RowOff .ST_CoordinateUnqualified =_f .Int64 (0);return _gbag ;};func (_edd Font )SetBold (b bool ){if b {_edd ._fcgcc .B =[]*_ad .CT_BooleanProperty {{}};}else {_edd ._fcgcc .B =nil ;};};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// MergedCells returns the merged cell regions within the sheet.
func (_fgdg *Sheet )MergedCells ()[]MergedCell {if _fgdg ._dbfc .MergeCells ==nil {return nil ;};_dfee :=[]MergedCell {};for _ ,_ddec :=range _fgdg ._dbfc .MergeCells .MergeCell {_dfee =append (_dfee ,MergedCell {_fgdg ._ffec ,_fgdg ,_ddec });};return _dfee ;};func (_gee *evalContext )Sheet (name string )_cea .Context {for _ ,_dbe :=range _gee ._gccf ._ffec .Sheets (){if _dbe .Name ()==name {return _dbe .FormulaContext ();};};return _cea .InvalidReferenceContext ;};const _fccb ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_cafb *Workbook )GetChartByTargetId (targetAttr string )*_da .ChartSpace {return _cafb ._agdb [targetAttr ];};

// IsBool returns true if the cell is a boolean type cell.
func (_cddd Cell )IsBool ()bool {return _cddd ._abg .TAttr ==_ad .ST_CellTypeB };

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_bagd Drawing )AddChart (at AnchorType )(_cac .Chart ,Anchor ){_fbfc :=_da .NewChartSpace ();_bagd ._eaa ._fefd =append (_bagd ._eaa ._fefd ,_fbfc );_fcfg :=_f .AbsoluteFilename (_f .DocTypeSpreadsheet ,_f .ChartContentType ,len (_bagd ._eaa ._fefd ));_bagd ._eaa .ContentTypes .AddOverride (_fcfg ,_f .ChartContentType );var _fceb string ;for _baae ,_ebbfb :=range _bagd ._eaa ._ggbb {if _ebbfb ==_bagd ._geff {_ffeb :=_f .RelativeFilename (_f .DocTypeSpreadsheet ,_f .DrawingType ,_f .ChartType ,len (_bagd ._eaa ._fefd ));_dgbf :=_bagd ._eaa ._fbae [_baae ].AddRelationship (_ffeb ,_f .ChartType );_fceb =_dgbf .ID ();break ;};};var _dcac Anchor ;var _faed *_ab .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_cag :=_edbf ();_bagd ._geff .EG_Anchor =append (_bagd ._geff .EG_Anchor ,&_ab .EG_Anchor {AbsoluteAnchor :_cag });_cag .Choice =&_ab .EG_ObjectChoicesChoice {};_cag .Choice .GraphicFrame =_ab .NewCT_GraphicalObjectFrame ();_faed =_cag .Choice .GraphicFrame ;_dcac =AbsoluteAnchor {_cag };case AnchorTypeOneCell :_dcf :=_bbcg ();_bagd ._geff .EG_Anchor =append (_bagd ._geff .EG_Anchor ,&_ab .EG_Anchor {OneCellAnchor :_dcf });_dcf .Choice =&_ab .EG_ObjectChoicesChoice {};_dcf .Choice .GraphicFrame =_ab .NewCT_GraphicalObjectFrame ();_faed =_dcf .Choice .GraphicFrame ;_dcac =OneCellAnchor {_dcf };case AnchorTypeTwoCell :_cgee :=_abd ();_bagd ._geff .EG_Anchor =append (_bagd ._geff .EG_Anchor ,&_ab .EG_Anchor {TwoCellAnchor :_cgee });_cgee .Choice =&_ab .EG_ObjectChoicesChoice {};_cgee .Choice .GraphicFrame =_ab .NewCT_GraphicalObjectFrame ();_faed =_cgee .Choice .GraphicFrame ;_dcac =TwoCellAnchor {_cgee };};_faed .NvGraphicFramePr =_ab .NewCT_GraphicalObjectFrameNonVisual ();_faed .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_bagd ._geff .EG_Anchor ));_faed .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_faed .Graphic =_cb .NewGraphic ();_faed .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_bad :=_da .NewChart ();_bad .IdAttr =_fceb ;_faed .Graphic .GraphicData .Any =[]_f .Any {_bad };_bcda :=_cac .MakeChart (_fbfc );_bcda .Properties ().SetSolidFill (_ebb .White );_bcda .SetDisplayBlanksAs (_da .ST_DispBlanksAsGap );return _bcda ,_dcac ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_aeb *_ad .CT_DataBar };func _cgb (_aadc _feb .Time )_feb .Time {_aadc =_aadc .UTC ();return _feb .Date (_aadc .Year (),_aadc .Month (),_aadc .Day (),_aadc .Hour (),_aadc .Minute (),_aadc .Second (),_aadc .Nanosecond (),_feb .Local );};

// X returns the inner wrapped XML type.
func (_daga SheetProtection )X ()*_ad .CT_SheetProtection {return _daga ._egeag };var _cgga =[...]uint8 {0,18,37};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_feaf Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_afcf :=[]Cell {};for _ccgg :=uint32 (0);_ccgg <=lastColIdx ;_ccgg ++{_ccgga :=_feaf .Cell (_fec .IndexToColumn (_ccgg ));_afcf =append (_afcf ,_ccgga );};return _afcf ;};

// PasswordHash returns the hash of the workbook password.
func (_ccff WorkbookProtection )PasswordHash ()string {if _ccff ._gaga .WorkbookPasswordAttr ==nil {return "";};return *_ccff ._gaga .WorkbookPasswordAttr ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_aad Cell )GetFormattedValue ()string {_cbbc :=_aad .getFormat ();switch _aad ._abg .TAttr {case _ad .ST_CellTypeB :_baa ,_ :=_aad .GetValueAsBool ();if _baa {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ad .ST_CellTypeN :_cgdb ,_ :=_aad .GetValueAsNumber ();return _gf .Number (_cgdb ,_cbbc );case _ad .ST_CellTypeE :if _aad ._abg .V !=nil {return *_aad ._abg .V ;};return "";case _ad .ST_CellTypeS ,_ad .ST_CellTypeInlineStr :return _gf .String (_aad .GetString (),_cbbc );case _ad .ST_CellTypeStr :_cgf :=_aad .GetString ();if _gf .IsNumber (_cgf ){_ebc ,_ :=_ga .ParseFloat (_cgf ,64);return _gf .Number (_ebc ,_cbbc );};return _gf .String (_cgf ,_cbbc );case _ad .ST_CellTypeUnset :fallthrough;default:_gdb ,_ :=_aad .GetRawValue ();if len (_gdb )==0{return "";};_fcg ,_bdf :=_aad .GetValueAsNumber ();if _bdf ==nil {return _gf .Number (_fcg ,_cbbc );};return _gf .String (_gdb ,_cbbc );};};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_daba *_ad .CT_DataValidation };func (_dbbd *Sheet )removeColumnFromNamedRanges (_gaee uint32 )error {for _ ,_eebb :=range _dbbd ._ffec .DefinedNames (){_edba :=_eebb .Name ();_deffg :=_eebb .Content ();_fbec :=_ff .Split (_deffg ,"\u0021");if len (_fbec )!=2{return _fgc .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_deffg );};_daad :=_fbec [0];if _dbbd .Name ()==_daad {_adad :=_dbbd ._ffec .RemoveDefinedName (_eebb );if _adad !=nil {return _adad ;};_bdd :=_cgcd (_fbec [1],_gaee ,true );if _bdd !=""{_ggbe :=_daad +"\u0021"+_bdd ;_dbbd ._ffec .AddDefinedName (_edba ,_ggbe );};};};_cdgac :=0;if _dbbd ._dbfc .TableParts !=nil &&_dbbd ._dbfc .TableParts .TablePart !=nil {_cdgac =len (_dbbd ._dbfc .TableParts .TablePart );};if _cdgac !=0{_degg :=0;for _ ,_fbee :=range _dbbd ._ffec .Sheets (){if _fbee .Name ()==_dbbd .Name (){break ;}else {if _fbee ._dbfc .TableParts !=nil &&_fbee ._dbfc .TableParts .TablePart !=nil {_degg +=len (_fbee ._dbfc .TableParts .TablePart );};};};_dcfa :=_dbbd ._ffec ._dbge [_degg :_degg +_cdgac ];for _bbgg ,_egcc :=range _dcfa {_bfa :=_egcc ;_bfa .RefAttr =_cgcd (_bfa .RefAttr ,_gaee ,false );_dbbd ._ffec ._dbge [_degg +_bbgg ]=_bfa ;};};return nil ;};

// SetDateWithStyle sets a date with the default date style applied.
func (_dba Cell )SetDateWithStyle (d _feb .Time ){_dba .SetDate (d );for _ ,_fac :=range _dba ._bgf .StyleSheet .CellStyles (){if _fac .HasNumberFormat ()&&_fac .NumberFormat ()==uint32 (StandardFormatDate ){_dba .SetStyle (_fac );return ;};};_febg :=_dba ._bgf .StyleSheet .AddCellStyle ();_febg .SetNumberFormatStandard (StandardFormatDate );_dba .SetStyle (_febg );};func (_facc Font )Index ()uint32 {for _bagb ,_eeaf :=range _facc ._ccaa .Fonts .Font {if _facc ._fcgcc ==_eeaf {return uint32 (_bagb );};};return 0;};

// Index returns the index of the border for use with a cell style.
func (_abb Border )Index ()uint32 {for _dg ,_cgd :=range _abb ._bg .Border {if _cgd ==_abb ._ecg {return uint32 (_dg );};};return 0;};

// SetPassword sets the password hash to a hash of the input password.
func (_bbef SheetProtection )SetPassword (pw string ){_bbef .SetPasswordHash (PasswordHash (pw ))};