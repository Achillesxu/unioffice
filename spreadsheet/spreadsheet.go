//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_dgf "archive/zip";_gebb "errors";_fbge "fmt";_ebgf "github.com/unidoc/unioffice";_gebe "github.com/unidoc/unioffice/chart";_fdfa "github.com/unidoc/unioffice/color";_fdfe "github.com/unidoc/unioffice/common";_bgfec "github.com/unidoc/unioffice/common/license";_acgd "github.com/unidoc/unioffice/common/tempstorage";_ecf "github.com/unidoc/unioffice/measurement";_bebb "github.com/unidoc/unioffice/schema/soo/dml";_baba "github.com/unidoc/unioffice/schema/soo/dml/chart";_gga "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_ddac "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_cdcga "github.com/unidoc/unioffice/schema/soo/sml";_cg "github.com/unidoc/unioffice/spreadsheet/format";_aeaf "github.com/unidoc/unioffice/spreadsheet/formula";_eedc "github.com/unidoc/unioffice/spreadsheet/reference";_feea "github.com/unidoc/unioffice/spreadsheet/update";_fdebd "github.com/unidoc/unioffice/vmldrawing";_dga "github.com/unidoc/unioffice/zippkg";_bedg "image";_dff "image/jpeg";_becf "io";_ebgb "log";_cgcb "math";_eedd "math/big";_cddc "os";_adge "path/filepath";_fdcfb "regexp";_daeb "runtime/debug";_bafd "sort";_dag "strconv";_bda "strings";_afea "time";);

// TopLeft is a no-op.
func (_cbeg AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// Fonts returns the list of fonts defined in the stylesheet.
func (_fegc StyleSheet )Fonts ()[]Font {_dcb :=[]Font {};for _ ,_ggagc :=range _fegc ._gbf .Fonts .Font {_dcb =append (_dcb ,Font {_ggagc ,_fegc ._gbf });};return _dcb ;};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_beb *_gga .CT_AbsoluteAnchor };func (_acbf DataValidation )clear (){_acbf ._bdf .Formula1 =_ebgf .String ("\u0030");_acbf ._bdf .Formula2 =_ebgf .String ("\u0030");};func (_edcg Cell )setLocked (_aaee bool ){_edgc :=_edcg ._egbf .SAttr ;if _edgc !=nil {_fff :=_edcg ._dcdcd .StyleSheet .GetCellStyle (*_edgc );if _fff ._fceg .Protection ==nil {_fff ._fceg .Protection =_cdcga .NewCT_CellProtection ();};_fff ._fceg .Protection .LockedAttr =&_aaee ;};};

// SetHidden controls the visibility of a column.
func (_fbgec Column )SetHidden (b bool ){if !b {_fbgec ._fade .HiddenAttr =nil ;}else {_fbgec ._fade .HiddenAttr =_ebgf .Bool (true );};};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_gaf Cell )SetStringByID (id int ){_gaf ._dcdcd .ensureSharedStringsRelationships ();_gaf .clearValue ();_gaf ._egbf .V =_ebgf .String (_dag .Itoa (id ));_gaf ._egbf .TAttr =_cdcga .ST_CellTypeS ;};

// LockObject controls the locking of the sheet objects.
func (_afafgg SheetProtection )LockObject (b bool ){if !b {_afafgg ._caga .ObjectsAttr =nil ;}else {_afafgg ._caga .ObjectsAttr =_ebgf .Bool (true );};};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_cdfg Cell )SetBool (v bool ){_cdfg .clearValue ();_cdfg ._egbf .V =_ebgf .String (_dag .Itoa (_ffecc (v )));_cdfg ._egbf .TAttr =_cdcga .ST_CellTypeB ;};func (_cbd DataValidation )SetList ()DataValidationList {_cbd .clear ();_cbd ._bdf .TypeAttr =_cdcga .ST_DataValidationTypeList ;_cbd ._bdf .OperatorAttr =_cdcga .ST_DataValidationOperatorEqual ;return DataValidationList {_cbd ._bdf };};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_gedg CellStyle )HasNumberFormat ()bool {return _gedg ._fceg .NumFmtIdAttr !=nil &&_gedg ._fceg .ApplyNumberFormatAttr !=nil &&*_gedg ._fceg .ApplyNumberFormatAttr ;};func (_cbdaf *Sheet )getAllCellsInFormulaArrays (_gafcf bool )(map[string ]bool ,error ){_aedcf :=_aeaf .NewEvaluator ();_def :=_cbdaf .FormulaContext ();_cegf :=map[string ]bool {};for _ ,_ebca :=range _cbdaf .Rows (){for _ ,_faba :=range _ebca .Cells (){if _faba .X ().F !=nil {_ccf :=_faba .X ().F .Content ;if _faba .X ().F .TAttr ==_cdcga .ST_CellFormulaTypeArray {_afa :=_aedcf .Eval (_def ,_ccf ).AsString ();if _afa .Type ==_aeaf .ResultTypeError {_ebgf .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_ccf ,_afa .ErrorMessage );_faba .X ().V =nil ;};if _afa .Type ==_aeaf .ResultTypeArray {_eef ,_eaaa :=_eedc .ParseCellReference (_faba .Reference ());if _eaaa !=nil {return map[string ]bool {},_eaaa ;};if (_gafcf &&len (_afa .ValueArray )==1)||(!_gafcf &&len (_afa .ValueArray [0])==1){continue ;};for _bdgb ,_fbdg :=range _afa .ValueArray {_cgg :=_eef .RowIdx +uint32 (_bdgb );for _fdc :=range _fbdg {_dada :=_eedc .IndexToColumn (_eef .ColumnIdx +uint32 (_fdc ));_cegf [_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_dada ,_cgg )]=true ;};};}else if _afa .Type ==_aeaf .ResultTypeList {_ffe ,_fgcc :=_eedc .ParseCellReference (_faba .Reference ());if _fgcc !=nil {return map[string ]bool {},_fgcc ;};if _gafcf ||len (_afa .ValueList )==1{continue ;};_cbgfd :=_ffe .RowIdx ;for _gbbc :=range _afa .ValueList {_cec :=_eedc .IndexToColumn (_ffe .ColumnIdx +uint32 (_gbbc ));_cegf [_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_cec ,_cbgfd )]=true ;};};};};};};return _cegf ,nil ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_fcbc :=uint16 (0);if len (s )> 0{for _ccfe :=len (s )-1;_ccfe >=0;_ccfe --{_bdfg :=s [_ccfe ];_fcbc =((_fcbc >>14)&0x01)|((_fcbc <<1)&0x7fff);_fcbc ^=uint16 (_bdfg );};_fcbc =((_fcbc >>14)&0x01)|((_fcbc <<1)&0x7fff);_fcbc ^=uint16 (len (s ));_fcbc ^=(0x8000|('N'<<8)|'K');};return _fbge .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_fcbc ));};

// LockWindow controls the locking of the workbook windows.
func (_gcce WorkbookProtection )LockWindow (b bool ){if !b {_gcce ._caaf .LockWindowsAttr =nil ;}else {_gcce ._caaf .LockWindowsAttr =_ebgf .Bool (true );};};

// SetShowRuler controls the visibility of the ruler
func (_bce SheetView )SetShowRuler (b bool ){if !b {_bce ._gebf .ShowRulerAttr =_ebgf .Bool (false );}else {_bce ._gebf .ShowRulerAttr =nil ;};};

// X returns the inner wrapped XML type.
func (_ccdg Comments )X ()*_cdcga .Comments {return _ccdg ._dedd };

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_aadf AbsoluteAnchor )SetRowOffset (m _ecf .Distance ){_aadf ._beb .Pos .YAttr .ST_CoordinateUnqualified =_ebgf .Int64 (int64 (m /_ecf .EMU ));};

// SetRotation configures the cell to be rotated.
func (_de CellStyle )SetRotation (deg uint8 ){if _de ._fceg .Alignment ==nil {_de ._fceg .Alignment =_cdcga .NewCT_CellAlignment ();};_de ._fceg .ApplyAlignmentAttr =_ebgf .Bool (true );_de ._fceg .Alignment .TextRotationAttr =_ebgf .Uint8 (deg );};

// GetFormat returns a cell data format.
func (_geag *evalContext )GetFormat (cellRef string )string {return _geag ._abcf .Cell (cellRef ).getFormat ();};

// SetHeight sets the height of the anchored object.
func (_abdg AbsoluteAnchor )SetHeight (h _ecf .Distance ){_abdg ._beb .Ext .CyAttr =int64 (h /_ecf .EMU )};

// IsNumber returns true if the cell is a number type cell.
func (_dfaa Cell )IsNumber ()bool {switch _dfaa ._egbf .TAttr {case _cdcga .ST_CellTypeN :return true ;case _cdcga .ST_CellTypeS ,_cdcga .ST_CellTypeB :return false ;};return _dfaa ._egbf .V !=nil &&_cg .IsNumber (*_dfaa ._egbf .V );};

// GetLocked returns true if the cell is locked.
func (_ebcg *evalContext )GetLocked (cellRef string )bool {return _ebcg ._abcf .Cell (cellRef ).getLocked ();};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_afcg *_cdcga .CT_RElt };func (_bfedd Border )SetDiagonal (style _cdcga .ST_BorderStyle ,c _fdfa .Color ,up ,down bool ){if _bfedd ._gaad .Diagonal ==nil {_bfedd ._gaad .Diagonal =_cdcga .NewCT_BorderPr ();};_bfedd ._gaad .Diagonal .Color =_cdcga .NewCT_Color ();_bfedd ._gaad .Diagonal .Color .RgbAttr =c .AsRGBAString ();_bfedd ._gaad .Diagonal .StyleAttr =style ;if up {_bfedd ._gaad .DiagonalUpAttr =_ebgf .Bool (true );};if down {_bfedd ._gaad .DiagonalDownAttr =_ebgf .Bool (true );};};

// HasFormula returns true if the cell contains formula.
func (_beae *evalContext )HasFormula (cellRef string )bool {return _beae ._abcf .Cell (cellRef ).HasFormula ();};

// Comments is the container for comments for a single sheet.
type Comments struct{_ddad *Workbook ;_dedd *_cdcga .Comments ;};func (_acfg Fill )SetPatternFill ()PatternFill {_acfg ._cda .GradientFill =nil ;_acfg ._cda .PatternFill =_cdcga .NewCT_PatternFill ();_acfg ._cda .PatternFill .PatternTypeAttr =_cdcga .ST_PatternTypeSolid ;return PatternFill {_acfg ._cda .PatternFill ,_acfg ._cda };};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gdf Comments )AddComment (cellRef string ,author string )RichText {_edaf :=_cdcga .NewCT_Comment ();_gdf ._dedd .CommentList .Comment =append (_gdf ._dedd .CommentList .Comment ,_edaf );_edaf .RefAttr =cellRef ;_edaf .AuthorIdAttr =_gdf .getOrCreateAuthor (author );_edaf .Text =_cdcga .NewCT_Rst ();return RichText {_edaf .Text };};func (_edfc *Workbook )addCustomRelationships (){_edfc .ContentTypes .AddOverride ("/\u0064o\u0063\u0050\u0072\u006f\u0070\u0073\u002f\u0063u\u0073\u0074\u006f\u006d.x\u006d\u006c","\u0061\u0070\u0070\u006c\u0069\u0063a\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065n\u0078\u006d\u006c\u0066\u006fr\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064o\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0063\u0075\u0073\u0074\u006f\u006d\u002d\u0070r\u006f\u0070\u0065\u0072\u0074\u0069\u0065\u0073+\u0078\u006d\u006c");_edfc .Rels .AddRelationship ("\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c",_ebgf .CustomPropertiesType );};

// Clear clears the cell's value and type.
func (_abfcc Cell )Clear (){_abfcc .clearValue ();_abfcc ._egbf .TAttr =_cdcga .ST_CellTypeUnset };

// IsError returns true if the cell is an error type cell.
func (_gae Cell )IsError ()bool {return _gae ._egbf .TAttr ==_cdcga .ST_CellTypeE };func (_gf SortOrder )String ()string {if _gf >=SortOrder (len (_ggfa )-1){return _fbge .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_gf );};return _ebg [_ggfa [_gf ]:_ggfa [_gf +1]];};

// AddGradientStop adds a color gradient stop.
func (_gdfe ColorScale )AddGradientStop (color _fdfa .Color ){_gdbef :=_cdcga .NewCT_Color ();_gdbef .RgbAttr =color .AsRGBAString ();_gdfe ._cbeb .Color =append (_gdfe ._cbeb .Color ,_gdbef );};var _ccgb []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};

// ColOffset returns the offset from the row cell.
func (_gad CellMarker )ColOffset ()_ecf .Distance {if _gad ._cca .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ecf .Distance (float64 (*_gad ._cca .ColOff .ST_CoordinateUnqualified )*_ecf .EMU );};func (_fce *Sheet )slideCellsLeft (_eeda []*_cdcga .CT_Cell )[]*_cdcga .CT_Cell {for _ ,_fgfa :=range _eeda {_egcd ,_bfca :=_eedc .ParseCellReference (*_fgfa .RAttr );if _bfca !=nil {return _eeda ;};_gbfc :=_egcd .ColumnIdx -1;_aaab :=_eedc .IndexToColumn (_gbfc )+_fbge .Sprintf ("\u0025\u0064",_egcd .RowIdx );_fgfa .RAttr =&_aaab ;};return _eeda ;};

// MoveTo moves the top-left of the anchored object.
func (_egdg OneCellAnchor )MoveTo (col ,row int32 ){_egdg .TopLeft ().SetCol (col );_egdg .TopLeft ().SetRow (row );};

// BottomRight is a no-op.
func (_ffdbe AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};type DifferentialStyle struct{_bcaa *_cdcga .CT_Dxf ;_ccdd *Workbook ;_fgbf *_cdcga .CT_Dxfs ;};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// AddCell adds a cell to a spreadsheet.
func (_adf Row )AddCell ()Cell {_edddd :=uint32 (len (_adf ._aadg .C ));var _gdd *string ;if _edddd > 0{_agcg :=_ebgf .Stringf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_edddd -1),_adf .RowNumber ());if _adf ._aadg .C [_edddd -1].RAttr !=nil &&*_adf ._aadg .C [_edddd -1].RAttr ==*_agcg {_gdd =_ebgf .Stringf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_edddd ),_adf .RowNumber ());};};_bgb :=_cdcga .NewCT_Cell ();_adf ._aadg .C =append (_adf ._aadg .C ,_bgb );if _gdd ==nil {_bbebb :=uint32 (0);for _ ,_dcba :=range _adf ._aadg .C {if _dcba .RAttr !=nil {_ggfff ,_ :=_eedc .ParseCellReference (*_dcba .RAttr );if _ggfff .ColumnIdx >=_bbebb {_bbebb =_ggfff .ColumnIdx +1;};};};_gdd =_ebgf .Stringf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_bbebb ),_adf .RowNumber ());};_bgb .RAttr =_gdd ;return Cell {_adf ._abdb ,_adf ._ffdf ,_adf ._aadg ,_bgb };};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_dcef TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_dcef ._bedc .To }};func (_fbdef Font )SetSize (size float64 ){_fbdef ._cfed .Sz =[]*_cdcga .CT_FontSize {{ValAttr :size }}};

// HasFormula returns true if the cell has an asoociated formula.
func (_deab Cell )HasFormula ()bool {return _deab ._egbf .F !=nil };func _cfgf (_dbbag string ,_afag uint32 ,_fefcc bool )string {_abegd ,_fae ,_eddae :=_eedc .ParseRangeReference (_dbbag );if _eddae ==nil {_gage ,_ge :=_abegd .ColumnIdx ,_fae .ColumnIdx ;if _afag >=_gage &&_afag <=_ge {if _gage ==_ge {if _fefcc {return "";}else {return _dbbag ;};}else {_geee :=_fae .Update (_feea .UpdateActionRemoveColumn );return _fbge .Sprintf ("\u0025\u0073\u003a%\u0073",_abegd .String (),_geee .String ());};}else if _afag < _gage {_gc :=_abegd .Update (_feea .UpdateActionRemoveColumn );_ded :=_fae .Update (_feea .UpdateActionRemoveColumn );return _fbge .Sprintf ("\u0025\u0073\u003a%\u0073",_gc .String (),_ded .String ());};}else {_fddg ,_ecgc ,_gcgg :=_eedc .ParseColumnRangeReference (_dbbag );if _gcgg !=nil {return "";};_bacbde ,_dcdae :=_fddg .ColumnIdx ,_ecgc .ColumnIdx ;if _afag >=_bacbde &&_afag <=_dcdae {if _bacbde ==_dcdae {if _fefcc {return "";}else {return _dbbag ;};}else {_ecec :=_ecgc .Update (_feea .UpdateActionRemoveColumn );return _fbge .Sprintf ("\u0025\u0073\u003a%\u0073",_fddg .String (),_ecec .String ());};}else if _afag < _bacbde {_eceg :=_fddg .Update (_feea .UpdateActionRemoveColumn );_agea :=_ecgc .Update (_feea .UpdateActionRemoveColumn );return _fbge .Sprintf ("\u0025\u0073\u003a%\u0073",_eceg .String (),_agea .String ());};};return "";};

// LockStructure controls the locking of the workbook structure.
func (_baeb WorkbookProtection )LockStructure (b bool ){if !b {_baeb ._caaf .LockStructureAttr =nil ;}else {_baeb ._caaf .LockStructureAttr =_ebgf .Bool (true );};};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_aaag *_cdcga .CT_DataValidation };

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_gagb Cell )SetTime (d _afea .Time ){_gagb .clearValue ();d =_eeac (d );_ggae :=_gagb ._dcdcd .Epoch ();if d .Before (_ggae ){_ebgf .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_adec :=d .Sub (_ggae );_dfdd :=new (_eedd .Float );_agbd :=new (_eedd .Float );_agbd .SetPrec (128);_agbd .SetUint64 (uint64 (_adec ));_bcaab :=new (_eedd .Float );_bcaab .SetUint64 (24*60*60*1e9);_dfdd .Quo (_agbd ,_bcaab );_gagb ._egbf .V =_ebgf .String (_dfdd .Text ('g',20));};

// Reference returns the region of cells that are merged.
func (_cfcc MergedCell )Reference ()string {return _cfcc ._afadc .RefAttr };

// Cell returns the actual cell behind the merged region
func (_fced MergedCell )Cell ()Cell {_dbeg :=_fced .Reference ();if _edeee :=_bda .Index (_fced .Reference (),"\u003a");_edeee !=-1{_dbeg =_dbeg [0:_edeee ];return _fced ._add .Cell (_dbeg );};return Cell {};};type PatternFill struct{_ga *_cdcga .CT_PatternFill ;_dcf *_cdcga .CT_Fill ;};

// X returns the inner XML entity for a stylesheet.
func (_gdbd StyleSheet )X ()*_cdcga .StyleSheet {return _gdbd ._gbf };

// SetWidth controls the width of a column.
func (_dbb Column )SetWidth (w _ecf .Distance ){_dbb ._fade .WidthAttr =_ebgf .Float64 (float64 (w /_ecf .Character ));};

// SetFont sets the font name for a rich text run.
func (_ed RichTextRun )SetFont (s string ){_ed .ensureRpr ();_ed ._afcg .RPr .RFont =_cdcga .NewCT_FontName ();_ed ._afcg .RPr .RFont .ValAttr =s ;};

// SetContent sets the defined name content.
func (_gabg DefinedName )SetContent (s string ){_gabg ._bcee .Content =s };

// SetPassword sets the password hash to a hash of the input password.
func (_dcbbg WorkbookProtection )SetPassword (pw string ){_dcbbg .SetPasswordHash (PasswordHash (pw ))};func _egbc (_fabc *Sheet )*evalContext {return &evalContext {_abcf :_fabc ,_bgbd :make (map[string ]struct{})};};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_dac Sheet )Extents ()string {_fe ,_bdc ,_ccc ,_gcgb :=_dac .ExtentsIndex ();return _fbge .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_fe ,_bdc ,_ccc ,_gcgb );};

// SetColOffset sets the column offset of the two cell anchor.
func (_bdda TwoCellAnchor )SetColOffset (m _ecf .Distance ){_bgcg :=m -_bdda .TopLeft ().ColOffset ();_bdda .TopLeft ().SetColOffset (m );_bdda .BottomRight ().SetColOffset (_bdda .BottomRight ().ColOffset ()+_bgcg );};

// GetValueAsNumber retrieves the cell's value as a number
func (_gff Cell )GetValueAsNumber ()(float64 ,error ){if _gff ._egbf .V ==nil &&_gff ._egbf .Is ==nil {return 0,nil ;};if _gff ._egbf .TAttr ==_cdcga .ST_CellTypeS ||!_cg .IsNumber (*_gff ._egbf .V ){return _cgcb .NaN (),_gebb .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _dag .ParseFloat (*_gff ._egbf .V ,64);};

// SetAllowBlank controls if blank values are accepted.
func (_ebce DataValidation )SetAllowBlank (b bool ){if !b {_ebce ._bdf .AllowBlankAttr =nil ;}else {_ebce ._bdf .AllowBlankAttr =_ebgf .Bool (true );};};

// SetColOffset sets a column offset in absolute distance.
func (_abb CellMarker )SetColOffset (m _ecf .Distance ){_abb ._cca .ColOff .ST_CoordinateUnqualified =_ebgf .Int64 (int64 (m /_ecf .EMU ));};func (_dgefaa Cell )getFormat ()string {if _dgefaa ._egbf .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_gcfg :=*_dgefaa ._egbf .SAttr ;_fcea :=_dgefaa ._dcdcd .StyleSheet .GetCellStyle (_gcfg );_aaeg :=_dgefaa ._dcdcd .StyleSheet .GetNumberFormat (_fcea .NumberFormat ());return _aaeg .GetFormat ();};type evalContext struct{_abcf *Sheet ;_fcdd ,_faee uint32 ;_bgbd map[string ]struct{};};

// GetFormula returns the formula for a cell.
func (_efge Cell )GetFormula ()string {if _efge ._egbf .F !=nil {return _efge ._egbf .F .Content ;};return "";};func (_af Fills )X ()*_cdcga .CT_Fills {return _af ._cecab };func _egecb ()*_gga .CT_TwoCellAnchor {_gfdb :=_gga .NewCT_TwoCellAnchor ();_gfdb .EditAsAttr =_gga .ST_EditAsOneCell ;_gfdb .From .Col =5;_gfdb .From .Row =0;_gfdb .From .ColOff .ST_CoordinateUnqualified =_ebgf .Int64 (0);_gfdb .From .RowOff .ST_CoordinateUnqualified =_ebgf .Int64 (0);_gfdb .To .Col =10;_gfdb .To .Row =20;_gfdb .To .ColOff .ST_CoordinateUnqualified =_ebgf .Int64 (0);_gfdb .To .RowOff .ST_CoordinateUnqualified =_ebgf .Int64 (0);return _gfdb ;};

// TopLeft returns the top-left corner of the anchored object.
func (_eda OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_eda ._gaba .From }};type Table struct{_cgdf *_cdcga .Table };func (_edb ConditionalFormattingRule )clear (){_edb ._dbeb .OperatorAttr =_cdcga .ST_ConditionalFormattingOperatorUnset ;_edb ._dbeb .ColorScale =nil ;_edb ._dbeb .IconSet =nil ;_edb ._dbeb .Formula =nil ;};func _cfcd (_egfd string )bool {_egfd =_bda .Replace (_egfd ,"\u0024","",-1);if _edf :=_adbe .FindStringSubmatch (_bda .ToLower (_egfd ));len (_edf )> 2{_aag :=_edf [1];_fcae ,_beebc :=_dag .Atoi (_edf [2]);if _beebc !=nil {return false ;};return _fcae <=1048576&&_aag <="\u007a\u007a";};return false ;};

// SetRowOffset sets the row offset of the top-left anchor.
func (_fbfd OneCellAnchor )SetRowOffset (m _ecf .Distance ){_fbfd .TopLeft ().SetRowOffset (m )};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_bcfb Comparer )LessCells (lhs ,rhs Cell )bool {if _bcfb .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_adg ,_bfac :=lhs .getRawSortValue ();_agab ,_gdea :=rhs .getRawSortValue ();switch {case _bfac &&_gdea :_ade ,_ :=_dag .ParseFloat (_adg ,64);_gafa ,_ :=_dag .ParseFloat (_agab ,64);return _ade < _gafa ;case _bfac :return true ;case _gdea :return false ;};_adg =lhs .GetFormattedValue ();_agab =rhs .GetFormattedValue ();return _adg < _agab ;};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_gag Cell )SetFormulaRaw (s string ){_gag .clearValue ();_gag ._egbf .TAttr =_cdcga .ST_CellTypeStr ;_gag ._egbf .F =_cdcga .NewCT_CellFormula ();_gag ._egbf .F .Content =s ;};

// SetReference sets the regin of cells that the merged cell applies to.
func (_aabd MergedCell )SetReference (ref string ){_aabd ._afadc .RefAttr =ref };

// MergedCells returns the merged cell regions within the sheet.
func (_aaf *Sheet )MergedCells ()[]MergedCell {if _aaf ._bdec .MergeCells ==nil {return nil ;};_fgfb :=[]MergedCell {};for _ ,_dfa :=range _aaf ._bdec .MergeCells .MergeCell {_fgfb =append (_fgfb ,MergedCell {_aaf ._ddfe ,_aaf ,_dfa });};return _fgfb ;};type ConditionalFormattingRule struct{_dbeb *_cdcga .CT_CfRule };

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_cgdc Cell )Reference ()string {if _cgdc ._egbf .RAttr !=nil {return *_cgdc ._egbf .RAttr ;};return "";};

// X returns the inner wrapped XML type.
func (_bgbdg DataBarScale )X ()*_cdcga .CT_DataBar {return _bgbdg ._eefg };

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_efed Cell )SetDate (d _afea .Time ){_efed .clearValue ();d =_eeac (d );_bgdcc :=_efed ._dcdcd .Epoch ();if d .Before (_bgdcc ){_ebgf .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_egfg :=d .Sub (_bgdcc );_ega :=new (_eedd .Float );_ecfb :=new (_eedd .Float );_ecfb .SetPrec (128);_ecfb .SetUint64 (uint64 (_egfg ));_adbf :=new (_eedd .Float );_adbf .SetUint64 (24*60*60*1e9);_ega .Quo (_ecfb ,_adbf );_gbgd ,_ :=_ega .Uint64 ();_efed ._egbf .V =_ebgf .Stringf ("\u0025\u0064",_gbgd );};type MergedCell struct{_ffb *Workbook ;_add *Sheet ;_afadc *_cdcga .CT_MergeCell ;};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_edea Border )InitializeDefaults (){_edea ._gaad .Left =_cdcga .NewCT_BorderPr ();_edea ._gaad .Bottom =_cdcga .NewCT_BorderPr ();_edea ._gaad .Right =_cdcga .NewCT_BorderPr ();_edea ._gaad .Top =_cdcga .NewCT_BorderPr ();_edea ._gaad .Diagonal =_cdcga .NewCT_BorderPr ();};

// IsStructureLocked returns whether the workbook structure is locked.
func (_ecdb WorkbookProtection )IsStructureLocked ()bool {return _ecdb ._caaf .LockStructureAttr !=nil &&*_ecdb ._caaf .LockStructureAttr ;};

// SetSize sets the text size for a rich text run.
func (_eec RichTextRun )SetSize (m _ecf .Distance ){_eec .ensureRpr ();_eec ._afcg .RPr .Sz =_cdcga .NewCT_FontSize ();_eec ._afcg .RPr .Sz .ValAttr =float64 (m /_ecf .Point );};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ggab CellStyle )SetHorizontalAlignment (a _cdcga .ST_HorizontalAlignment ){if _ggab ._fceg .Alignment ==nil {_ggab ._fceg .Alignment =_cdcga .NewCT_CellAlignment ();};_ggab ._fceg .Alignment .HorizontalAttr =a ;_ggab ._fceg .ApplyAlignmentAttr =_ebgf .Bool (true );};func (_decg PatternFill )ClearBgColor (){_decg ._ga .BgColor =nil };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_agbb ColorScale )AddFormatValue (t _cdcga .ST_CfvoType ,val string ){_egc :=_cdcga .NewCT_Cfvo ();_egc .TypeAttr =t ;_egc .ValAttr =_ebgf .String (val );_agbb ._cbeb .Cfvo =append (_agbb ._cbeb .Cfvo ,_egc );};

// Protection controls the protection on an individual sheet.
func (_cffg *Sheet )Protection ()SheetProtection {if _cffg ._bdec .SheetProtection ==nil {_cffg ._bdec .SheetProtection =_cdcga .NewCT_SheetProtection ();};return SheetProtection {_cffg ._bdec .SheetProtection };};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_bcb *Sheet )SheetViews ()[]SheetView {if _bcb ._bdec .SheetViews ==nil {return nil ;};_faeb :=[]SheetView {};for _ ,_bga :=range _bcb ._bdec .SheetViews .SheetView {_faeb =append (_faeb ,SheetView {_bga });};return _faeb ;};

// PasswordHash returns the hash of the workbook password.
func (_bcg SheetProtection )PasswordHash ()string {if _bcg ._caga .PasswordAttr ==nil {return "";};return *_bcg ._caga .PasswordAttr ;};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_eefg *_cdcga .CT_DataBar };

// SetInlineString adds a string inline instead of in the shared strings table.
func (_gfca Cell )SetInlineString (s string ){_gfca .clearValue ();_gfca ._egbf .Is =_cdcga .NewCT_Rst ();_gfca ._egbf .Is .T =_ebgf .String (s );_gfca ._egbf .TAttr =_cdcga .ST_CellTypeInlineStr ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_fdb *Workbook )RecalculateFormulas (){for _ ,_baa :=range _fdb .Sheets (){_baa .RecalculateFormulas ();};};func NewPatternFill (fills *_cdcga .CT_Fills )PatternFill {_ffeb :=_cdcga .NewCT_Fill ();_ffeb .PatternFill =_cdcga .NewCT_PatternFill ();return PatternFill {_ffeb .PatternFill ,_ffeb };};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_efg Drawing )AddChart (at AnchorType )(_gebe .Chart ,Anchor ){_gcfa :=_baba .NewChartSpace ();_efg ._gba ._dafb =append (_efg ._gba ._dafb ,_gcfa );_eccd :=_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .ChartContentType ,len (_efg ._gba ._dafb ));_efg ._gba .ContentTypes .AddOverride (_eccd ,_ebgf .ChartContentType );var _agfd string ;for _cfca ,_cbcd :=range _efg ._gba ._fac {if _cbcd ==_efg ._fbfab {_egcg :=_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .DrawingType ,_ebgf .ChartType ,len (_efg ._gba ._dafb ));_degf :=_efg ._gba ._gabb [_cfca ].AddRelationship (_egcg ,_ebgf .ChartType );_agfd =_degf .ID ();break ;};};var _fbda Anchor ;var _cbce *_gga .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_cegb :=_ffbde ();_efg ._fbfab .EG_Anchor =append (_efg ._fbfab .EG_Anchor ,&_gga .EG_Anchor {AbsoluteAnchor :_cegb });_cegb .Choice =&_gga .EG_ObjectChoicesChoice {};_cegb .Choice .GraphicFrame =_gga .NewCT_GraphicalObjectFrame ();_cbce =_cegb .Choice .GraphicFrame ;_fbda =AbsoluteAnchor {_cegb };case AnchorTypeOneCell :_dba :=_fcagg ();_efg ._fbfab .EG_Anchor =append (_efg ._fbfab .EG_Anchor ,&_gga .EG_Anchor {OneCellAnchor :_dba });_dba .Choice =&_gga .EG_ObjectChoicesChoice {};_dba .Choice .GraphicFrame =_gga .NewCT_GraphicalObjectFrame ();_cbce =_dba .Choice .GraphicFrame ;_fbda =OneCellAnchor {_dba };case AnchorTypeTwoCell :_aeae :=_egecb ();_efg ._fbfab .EG_Anchor =append (_efg ._fbfab .EG_Anchor ,&_gga .EG_Anchor {TwoCellAnchor :_aeae });_aeae .Choice =&_gga .EG_ObjectChoicesChoice {};_aeae .Choice .GraphicFrame =_gga .NewCT_GraphicalObjectFrame ();_cbce =_aeae .Choice .GraphicFrame ;_fbda =TwoCellAnchor {_aeae };};_cbce .NvGraphicFramePr =_gga .NewCT_GraphicalObjectFrameNonVisual ();_cbce .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_efg ._fbfab .EG_Anchor ));_cbce .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_cbce .Graphic =_bebb .NewGraphic ();_cbce .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_dee :=_baba .NewChart ();_dee .IdAttr =_agfd ;_cbce .Graphic .GraphicData .Any =[]_ebgf .Any {_dee };_ecff :=_gebe .MakeChart (_gcfa );_ecff .Properties ().SetSolidFill (_fdfa .White );_ecff .SetDisplayBlanksAs (_baba .ST_DispBlanksAsGap );return _ecff ,_fbda ;};func (_gcggd DifferentialStyle )Fill ()Fill {if _gcggd ._bcaa .Fill ==nil {_gcggd ._bcaa .Fill =_cdcga .NewCT_Fill ();};return Fill {_gcggd ._bcaa .Fill ,nil };};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_edgb *_cdcga .Sst ;_abfd map[string ]int ;};

// AddDataValidation adds a data validation rule to a sheet.
func (_bbce *Sheet )AddDataValidation ()DataValidation {if _bbce ._bdec .DataValidations ==nil {_bbce ._bdec .DataValidations =_cdcga .NewCT_DataValidations ();};_ddag :=_cdcga .NewCT_DataValidation ();_ddag .ShowErrorMessageAttr =_ebgf .Bool (true );_bbce ._bdec .DataValidations .DataValidation =append (_bbce ._bdec .DataValidations .DataValidation ,_ddag );_bbce ._bdec .DataValidations .CountAttr =_ebgf .Uint32 (uint32 (len (_bbce ._bdec .DataValidations .DataValidation )));return DataValidation {_ddag };};

// SetColOffset sets the column offset of the top-left anchor.
func (_affb OneCellAnchor )SetColOffset (m _ecf .Distance ){_affb .TopLeft ().SetColOffset (m )};

// SetHeightCells is a no-op.
func (_gfc OneCellAnchor )SetHeightCells (int32 ){};func (_bbfa Font )Index ()uint32 {for _ggad ,_dbf :=range _bbfa ._aab .Fonts .Font {if _bbfa ._cfed ==_dbf {return uint32 (_ggad );};};return 0;};func (_dffe *evalContext )SetOffset (col ,row uint32 ){_dffe ._fcdd =col ;_dffe ._faee =row };

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_bced NumberFormat )ID ()uint32 {return _bced ._beeg .NumFmtIdAttr };func (_adb Font )SetColor (c _fdfa .Color ){_bacbd :=_cdcga .NewCT_Color ();_bfaa :="\u0066\u0066"+*c .AsRGBString ();_bacbd .RgbAttr =&_bfaa ;_adb ._cfed .Color =[]*_cdcga .CT_Color {_bacbd };};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_bdfe *Workbook )AddDrawing ()Drawing {_acdg :=_gga .NewWsDr ();_bdfe ._fac =append (_bdfe ._fac ,_acdg );_agef :=_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .DrawingType ,len (_bdfe ._fac ));_bdfe .ContentTypes .AddOverride (_agef ,_ebgf .DrawingContentType );_bdfe ._gabb =append (_bdfe ._gabb ,_fdfe .NewRelationships ());return Drawing {_bdfe ,_acdg };};

// Sheet is a single sheet within a workbook.
type Sheet struct{_ddfe *Workbook ;_gaag *_cdcga .CT_Sheet ;_bdec *_cdcga .Worksheet ;};

// X returns the inner wrapped XML type.
func (_gbfb Drawing )X ()*_gga .WsDr {return _gbfb ._fbfab };

// SetYSplit sets the row split point
func (_daad SheetView )SetYSplit (v float64 ){_daad .ensurePane ();_daad ._gebf .Pane .YSplitAttr =_ebgf .Float64 (v );};

// X returns the inner wrapped XML type.
func (_faeg Sheet )X ()*_cdcga .Worksheet {return _faeg ._bdec };

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_ebfe Cell )SetStyleIndex (idx uint32 ){_ebfe ._egbf .SAttr =_ebgf .Uint32 (idx )};

// Column returns the cell column
func (_edcgf Cell )Column ()(string ,error ){_dg ,_ecbf :=_eedc .ParseCellReference (_edcgf .Reference ());if _ecbf !=nil {return "",_ecbf ;};return _dg .Column ,nil ;};

// SetLocked sets cell locked or not.
func (_cbde *evalContext )SetLocked (cellRef string ,locked bool ){_cbde ._abcf .Cell (cellRef ).setLocked (locked );};

// DefinedNames returns a slice of all defined names in the workbook.
func (_gfb *Workbook )DefinedNames ()[]DefinedName {if _gfb ._cbc .DefinedNames ==nil {return nil ;};_fb :=[]DefinedName {};for _ ,_cfe :=range _gfb ._cbc .DefinedNames .DefinedName {_fb =append (_fb ,DefinedName {_cfe });};return _fb ;};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_fgb CellStyle )SetVerticalAlignment (a _cdcga .ST_VerticalAlignment ){if _fgb ._fceg .Alignment ==nil {_fgb ._fceg .Alignment =_cdcga .NewCT_CellAlignment ();};_fgb ._fceg .ApplyAlignmentAttr =_ebgf .Bool (true );_fgb ._fceg .Alignment .VerticalAttr =a ;};func (_fbd *Sheet )updateAfterRemove (_bgfe uint32 ,_cffb _feea .UpdateAction )error {_fcf :=_fbd .Name ();_f :=&_feea .UpdateQuery {UpdateType :_cffb ,ColumnIdx :_bgfe ,SheetToUpdate :_fcf };for _ ,_fbae :=range _fbd ._ddfe .Sheets (){_f .UpdateCurrentSheet =_fcf ==_fbae .Name ();for _ ,_bbdc :=range _fbae .Rows (){for _ ,_gcge :=range _bbdc .Cells (){if _gcge .X ().F !=nil {_ccfa :=_gcge .X ().F .Content ;_bdebb :=_aeaf .ParseString (_ccfa );if _bdebb ==nil {_gcge .SetError ("\u0023\u0052\u0045F\u0021");}else {_ddgc :=_bdebb .Update (_f );_gcge .X ().F .Content =_fbge .Sprintf ("\u003d\u0025\u0073",_ddgc .String ());};};};};};return nil ;};

// X returns the inner wrapped XML type.
func (_dfae DataValidation )X ()*_cdcga .CT_DataValidation {return _dfae ._bdf };

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_dgaf *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_dbfe :=_dgaf ._bdec .SheetData .Row ;_bfd :=_dgaf .Rows ();for _cabb ,_afaba :=range _bfd {if _afaba .RowNumber ()==firstRow {_dbfe =_dgaf ._bdec .SheetData .Row [_cabb :];break ;};};_bec :=Comparer {Order :order };_bafd .Slice (_dbfe ,func (_facf ,_aba int )bool {return _bec .LessRows (column ,Row {_dgaf ._ddfe ,_dgaf ,_dbfe [_facf ]},Row {_dgaf ._ddfe ,_dgaf ,_dbfe [_aba ]});});for _be ,_cfdaa :=range _dgaf .Rows (){_caba :=uint32 (_be +1);if _cfdaa .RowNumber ()!=_caba {_cfdaa .renumberAs (_caba );};};};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gcggb *Sheet )RecalculateFormulas (){_fbbg :=_aeaf .NewEvaluator ();_bfdf :=_gcggb .FormulaContext ();for _ ,_cgfe :=range _gcggb .Rows (){for _ ,_fcc :=range _cgfe .Cells (){if _fcc .X ().F !=nil {_gdca :=_fcc .X ().F .Content ;if _fcc .X ().F .TAttr ==_cdcga .ST_CellFormulaTypeShared &&len (_gdca )==0{continue ;};_cea :=_fbbg .Eval (_bfdf ,_gdca ).AsString ();if _cea .Type ==_aeaf .ResultTypeError {_ebgf .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_gdca ,_cea .ErrorMessage );_fcc .X ().V =nil ;}else {if _cea .Type ==_aeaf .ResultTypeNumber {_fcc .X ().TAttr =_cdcga .ST_CellTypeN ;}else {_fcc .X ().TAttr =_cdcga .ST_CellTypeInlineStr ;};_fcc .X ().V =_ebgf .String (_cea .Value ());if _fcc .X ().F .TAttr ==_cdcga .ST_CellFormulaTypeArray {if _cea .Type ==_aeaf .ResultTypeArray {_gcggb .setArray (_fcc .Reference (),_cea );}else if _cea .Type ==_aeaf .ResultTypeList {_gcggb .setList (_fcc .Reference (),_cea );};}else if _fcc .X ().F .TAttr ==_cdcga .ST_CellFormulaTypeShared &&_fcc .X ().F .RefAttr !=nil {_gdcg ,_abfc ,_eggf :=_eedc .ParseRangeReference (*_fcc .X ().F .RefAttr );if _eggf !=nil {_ebgb .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_eggf );continue ;};_gcggb .setShared (_fcc .Reference (),_gdcg ,_abfc ,_gdca );};};};};};};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_ag *Sheet )SetFrozen (firstRow ,firstCol bool ){_ag ._bdec .SheetViews =nil ;_dad :=_ag .AddView ();_dad .SetState (_cdcga .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_dad .SetYSplit (1);_dad .SetXSplit (1);_dad .SetTopLeft ("\u0042\u0032");case firstRow :_dad .SetYSplit (1);_dad .SetTopLeft ("\u0041\u0032");case firstCol :_dad .SetXSplit (1);_dad .SetTopLeft ("\u0042\u0031");};};

// SetRow set the row of the cell marker.
func (_ffgf CellMarker )SetRow (row int32 ){_ffgf ._cca .Row =row };func (_faag Border )SetTop (style _cdcga .ST_BorderStyle ,c _fdfa .Color ){if _faag ._gaad .Top ==nil {_faag ._gaad .Top =_cdcga .NewCT_BorderPr ();};_faag ._gaad .Top .Color =_cdcga .NewCT_Color ();_faag ._gaad .Top .Color .RgbAttr =c .AsRGBAString ();_faag ._gaad .Top .StyleAttr =style ;};func (_cdgg SheetView )ensurePane (){if _cdgg ._gebf .Pane ==nil {_cdgg ._gebf .Pane =_cdcga .NewCT_Pane ();_cdgg ._gebf .Pane .ActivePaneAttr =_cdcga .ST_PaneBottomLeft ;};};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_edgb :_cdcga .NewSst (),_abfd :make (map[string ]int )};};

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_abcg *Sheet )AddNumberedRow (rowNum uint32 )Row {_bcgg :=_cdcga .NewCT_Row ();_bcgg .RAttr =_ebgf .Uint32 (rowNum );_abcg ._bdec .SheetData .Row =append (_abcg ._bdec .SheetData .Row ,_bcgg );_bafd .Slice (_abcg ._bdec .SheetData .Row ,func (_b ,_cdcg int )bool {_gdfb :=_abcg ._bdec .SheetData .Row [_b ].RAttr ;_dde :=_abcg ._bdec .SheetData .Row [_cdcg ].RAttr ;if _gdfb ==nil {return true ;};if _dde ==nil {return true ;};return *_gdfb < *_dde ;});return Row {_abcg ._ddfe ,_abcg ,_bcgg };};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_ecbe CellStyle )NumberFormat ()uint32 {if _ecbe ._fceg .NumFmtIdAttr ==nil {return 0;};return *_ecbe ._fceg .NumFmtIdAttr ;};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_cbeb *_cdcga .CT_ColorScale };

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_gfe *Sheet )Row (rowNum uint32 )Row {for _ ,_agca :=range _gfe ._bdec .SheetData .Row {if _agca .RAttr !=nil &&*_agca .RAttr ==rowNum {return Row {_gfe ._ddfe ,_gfe ,_agca };};};return _gfe .AddNumberedRow (rowNum );};

// ClearFont clears any font configuration from the cell style.
func (_gcd CellStyle )ClearFont (){_gcd ._fceg .FontIdAttr =nil ;_gcd ._fceg .ApplyFontAttr =nil };

// SetStyle sets the style to be used for conditional rules
func (_eacc ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_eacc ._dbeb .DxfIdAttr =_ebgf .Uint32 (d .Index ());};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_dgg IconScale )AddFormatValue (t _cdcga .ST_CfvoType ,val string ){_fcaef :=_cdcga .NewCT_Cfvo ();_fcaef .TypeAttr =t ;_fcaef .ValAttr =_ebgf .String (val );_dgg ._gafc .Cfvo =append (_dgg ._gafc .Cfvo ,_fcaef );};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_eeag :=NumberFormat {_beeg :_cdcga .NewCT_NumFmt ()};_eeag ._beeg .NumFmtIdAttr =uint32 (id );_eeag ._beeg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_eeag ._beeg .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_eeag ._beeg .FormatCodeAttr ="\u0030";case StandardFormat2 :_eeag ._beeg .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_eeag ._beeg .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_eeag ._beeg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_eeag ._beeg .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_eeag ._beeg .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_eeag ._beeg .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_eeag ._beeg .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_eeag ._beeg .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_eeag ._beeg .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_eeag ._beeg .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_eeag ._beeg .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_eeag ._beeg .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_eeag ._beeg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_eeag ._beeg .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_eeag ._beeg .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_eeag ._beeg .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_eeag ._beeg .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_eeag ._beeg .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_eeag ._beeg .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_eeag ._beeg .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_eeag ._beeg .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_eeag ._beeg .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_eeag ._beeg .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_eeag ._beeg .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_eeag ._beeg .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_eeag ._beeg .FormatCodeAttr ="\u0040";};return _eeag ;};func (_cdga CellStyle )Index ()uint32 {for _dfbc ,_dcbf :=range _cdga ._fgdc .Xf {if _cdga ._fceg ==_dcbf {return uint32 (_dfbc );};};return 0;};

// X returns the inner wrapped XML type.
func (_aggg IconScale )X ()*_cdcga .CT_IconSet {return _aggg ._gafc };func (_fgfae *Workbook )onNewRelationship (_bbcd *_dga .DecodeMap ,_cade ,_eedcb string ,_aef []*_dgf .File ,_efbc *_ddac .Relationship ,_egfde _dga .Target )error {_ccbc :=_ebgf .DocTypeSpreadsheet ;switch _eedcb {case _ebgf .OfficeDocumentType :_fgfae ._cbc =_cdcga .NewWorkbook ();_bbcd .AddTarget (_cade ,_fgfae ._cbc ,_eedcb ,0);_fgfae ._fdeb =_fdfe .NewRelationships ();_bbcd .AddTarget (_dga .RelationsPathFor (_cade ),_fgfae ._fdeb .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .CorePropertiesType :_bbcd .AddTarget (_cade ,_fgfae .CoreProperties .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .CustomPropertiesType :_bbcd .AddTarget (_cade ,_fgfae .CustomProperties .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .ExtendedPropertiesType :_bbcd .AddTarget (_cade ,_fgfae .AppProperties .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .WorksheetType :_cddb :=_cdcga .NewWorksheet ();_ccbf :=uint32 (len (_fgfae ._cadcc ));_fgfae ._cadcc =append (_fgfae ._cadcc ,_cddb );_bbcd .AddTarget (_cade ,_cddb ,_eedcb ,_ccbf );_edeb :=_fdfe .NewRelationships ();_bbcd .AddTarget (_dga .RelationsPathFor (_cade ),_edeb .X (),_eedcb ,0);_fgfae ._efdf =append (_fgfae ._efdf ,_edeb );_fgfae ._aec =append (_fgfae ._aec ,nil );_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._cadcc ));case _ebgf .StylesType :_fgfae .StyleSheet =NewStyleSheet (_fgfae );_bbcd .AddTarget (_cade ,_fgfae .StyleSheet .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .ThemeType :_bdeac :=_bebb .NewTheme ();_fgfae ._gab =append (_fgfae ._gab ,_bdeac );_bbcd .AddTarget (_cade ,_bdeac ,_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._gab ));case _ebgf .SharedStringsType :_fgfae .SharedStrings =NewSharedStrings ();_bbcd .AddTarget (_cade ,_fgfae .SharedStrings .X (),_eedcb ,0);_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,0);case _ebgf .ThumbnailType :for _cba ,_cebad :=range _aef {if _cebad ==nil {continue ;};if _cebad .Name ==_cade {_gdcd ,_cbda :=_cebad .Open ();if _cbda !=nil {return _fbge .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_cbda );};_fgfae .Thumbnail ,_ ,_cbda =_bedg .Decode (_gdcd );_gdcd .Close ();if _cbda !=nil {return _fbge .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_cbda );};_aef [_cba ]=nil ;};};case _ebgf .ImageType :for _ege ,_eb :=range _aef {if _eb ==nil {continue ;};if _eb .Name ==_cade {_gcc ,_aee :=_dga .ExtractToDiskTmp (_eb ,_fgfae .TmpPath );if _aee !=nil {return _aee ;};_efc ,_aee :=_fdfe .ImageFromStorage (_gcc );if _aee !=nil {return _aee ;};_gcdb :=_fdfe .MakeImageRef (_efc ,&_fgfae .DocBase ,_fgfae ._fdeb );_fgfae .Images =append (_fgfae .Images ,_gcdb );_aef [_ege ]=nil ;};};_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae .Images ));case _ebgf .DrawingType :_bebe :=_gga .NewWsDr ();_ggac :=uint32 (len (_fgfae ._fac ));_bbcd .AddTarget (_cade ,_bebe ,_eedcb ,_ggac );_fgfae ._fac =append (_fgfae ._fac ,_bebe );_affe :=_fdfe .NewRelationships ();_bbcd .AddTarget (_dga .RelationsPathFor (_cade ),_affe .X (),_eedcb ,_ggac );_fgfae ._gabb =append (_fgfae ._gabb ,_affe );_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._fac ));case _ebgf .VMLDrawingType :_febc :=_fdebd .NewContainer ();_bee :=uint32 (len (_fgfae ._afee ));_bbcd .AddTarget (_cade ,_febc ,_eedcb ,_bee );_fgfae ._afee =append (_fgfae ._afee ,_febc );case _ebgf .CommentsType :_fgfae ._aec [_egfde .Index ]=_cdcga .NewComments ();_bbcd .AddTarget (_cade ,_fgfae ._aec [_egfde .Index ],_eedcb ,_egfde .Index );_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._aec ));case _ebgf .ChartType :_bg :=_baba .NewChartSpace ();_fggb :=uint32 (len (_fgfae ._dafb ));_bbcd .AddTarget (_cade ,_bg ,_eedcb ,_fggb );_fgfae ._dafb =append (_fgfae ._dafb ,_bg );_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._dafb ));case _ebgf .TableType :_bbac :=_cdcga .NewTable ();_gcag :=uint32 (len (_fgfae ._gca ));_bbcd .AddTarget (_cade ,_bbac ,_eedcb ,_gcag );_fgfae ._gca =append (_fgfae ._gca ,_bbac );_efbc .TargetAttr =_ebgf .RelativeFilename (_ccbc ,_egfde .Typ ,_eedcb ,len (_fgfae ._gca ));default:_ebgf .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_cade ,_eedcb );};return nil ;};

// SetDateWithStyle sets a date with the default date style applied.
func (_ddbc Cell )SetDateWithStyle (d _afea .Time ){_ddbc .SetDate (d );for _ ,_cegg :=range _ddbc ._dcdcd .StyleSheet .CellStyles (){if _cegg .HasNumberFormat ()&&_cegg .NumberFormat ()==uint32 (StandardFormatDate ){_ddbc .SetStyle (_cegg );return ;};};_fcfga :=_ddbc ._dcdcd .StyleSheet .AddCellStyle ();_fcfga .SetNumberFormatStandard (StandardFormatDate );_ddbc .SetStyle (_fcfga );};func (_bab Sheet )validateRowCellNumbers ()error {_cfee :=map[uint32 ]struct{}{};for _ ,_gecf :=range _bab ._bdec .SheetData .Row {if _gecf .RAttr !=nil {if _ ,_gfbf :=_cfee [*_gecf .RAttr ];_gfbf {return _fbge .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_bab .Name (),*_gecf .RAttr );};_cfee [*_gecf .RAttr ]=struct{}{};};_dfb :=map[string ]struct{}{};for _ ,_agegg :=range _gecf .C {if _agegg .RAttr ==nil {continue ;};if _ ,_gea :=_dfb [*_agegg .RAttr ];_gea {return _fbge .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_bab .Name (),*_agegg .RAttr );};_dfb [*_agegg .RAttr ]=struct{}{};};};return nil ;};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_aaac DataValidation )SetRange (cellRange string ){_aaac ._bdf .SqrefAttr =_cdcga .ST_Sqref {cellRange };};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_efaf *Sheet )InsertRow (rowNum int )Row {_acgc :=uint32 (rowNum );for _ ,_dfddf :=range _efaf .Rows (){if _dfddf ._aadg .RAttr !=nil &&*_dfddf ._aadg .RAttr >=_acgc {*_dfddf ._aadg .RAttr ++;for _ ,_acda :=range _dfddf .Cells (){_ccg ,_gbb :=_eedc .ParseCellReference (_acda .Reference ());if _gbb !=nil {continue ;};_ccg .RowIdx ++;_acda ._egbf .RAttr =_ebgf .String (_ccg .String ());};};};for _ ,_dbde :=range _efaf .MergedCells (){_fbeb ,_aggb ,_gcf :=_eedc .ParseRangeReference (_dbde .Reference ());if _gcf !=nil {continue ;};if int (_fbeb .RowIdx )>=rowNum {_fbeb .RowIdx ++;};if int (_aggb .RowIdx )>=rowNum {_aggb .RowIdx ++;};_gfff :=_fbge .Sprintf ("\u0025\u0073\u003a%\u0073",_fbeb ,_aggb );_dbde .SetReference (_gfff );};return _efaf .AddNumberedRow (_acgc );};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_gaba *_gga .CT_OneCellAnchor };

// SetPasswordHash sets the password hash to the input.
func (_fc SheetProtection )SetPasswordHash (pwHash string ){_fc ._caga .PasswordAttr =_ebgf .String (pwHash );};func (_gbdf Cell )GetRawValue ()(string ,error ){switch _gbdf ._egbf .TAttr {case _cdcga .ST_CellTypeInlineStr :if _gbdf ._egbf .Is ==nil ||_gbdf ._egbf .Is .T ==nil {return "",nil ;};return *_gbdf ._egbf .Is .T ,nil ;case _cdcga .ST_CellTypeS :if _gbdf ._egbf .V ==nil {return "",nil ;};_egac ,_bbacbd :=_dag .Atoi (*_gbdf ._egbf .V );if _bbacbd !=nil {return "",_bbacbd ;};return _gbdf ._dcdcd .SharedStrings .GetString (_egac );case _cdcga .ST_CellTypeStr :if _gbdf ._egbf .F !=nil {return _gbdf ._egbf .F .Content ,nil ;};};if _gbdf ._egbf .V ==nil {return "",nil ;};return *_gbdf ._egbf .V ,nil ;};

// IsHidden returns whether the row is hidden or not.
func (_bgdc Row )IsHidden ()bool {return _bgdc ._aadg .HiddenAttr !=nil &&*_bgdc ._aadg .HiddenAttr };

// X returns the inner wrapped XML type.
func (_efgd DifferentialStyle )X ()*_cdcga .CT_Dxf {return _efgd ._bcaa };func (_bbea Sheet )IsValid ()bool {return _bbea ._bdec !=nil };

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_geg *Workbook ;_beeg *_cdcga .CT_NumFmt ;};

// ClearNumberFormat removes any number formatting from the style.
func (_gfdcf CellStyle )ClearNumberFormat (){_gfdcf ._fceg .NumFmtIdAttr =nil ;_gfdcf ._fceg .ApplyNumberFormatAttr =nil ;};type Fill struct{_cda *_cdcga .CT_Fill ;_ggc *_cdcga .CT_Fills ;};

// Index returns the index of the border for use with a cell style.
func (_fca Border )Index ()uint32 {for _acg ,_fccaf :=range _fca ._bddg .Border {if _fccaf ==_fca ._gaad {return uint32 (_acg );};};return 0;};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_cffge *Workbook )AddImage (i _fdfe .Image )(_fdfe .ImageRef ,error ){_bae :=_fdfe .MakeImageRef (i ,&_cffge .DocBase ,_cffge ._fdeb );if i .Data ==nil &&i .Path ==""{return _bae ,_gebb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _bae ,_gebb .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _bae ,_gebb .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_dega :=_acgd .Add (i .Path );if _dega !=nil {return _bae ,_dega ;};};_cffge .Images =append (_cffge .Images ,_bae );return _bae ,nil ;};

// IsEmpty returns true if the cell is empty.
func (_abff Cell )IsEmpty ()bool {return _abff ._egbf .TAttr ==_cdcga .ST_CellTypeUnset &&_abff ._egbf .V ==nil &&_abff ._egbf .F ==nil ;};func (_caa Border )SetLeft (style _cdcga .ST_BorderStyle ,c _fdfa .Color ){if _caa ._gaad .Left ==nil {_caa ._gaad .Left =_cdcga .NewCT_BorderPr ();};_caa ._gaad .Left .Color =_cdcga .NewCT_Color ();_caa ._gaad .Left .Color .RgbAttr =c .AsRGBAString ();_caa ._gaad .Left .StyleAttr =style ;};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_bba Row )Cell (col string )Cell {_dbe :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",col ,_bba .RowNumber ());for _ ,_agde :=range _bba ._aadg .C {if _agde .RAttr !=nil &&*_agde .RAttr ==_dbe {return Cell {_bba ._abdb ,_bba ._ffdf ,_bba ._aadg ,_agde };};};return _bba .AddNamedCell (col );};

// SetConditionValue sets the condition value to be used for style applicaton.
func (_dacge ConditionalFormattingRule )SetConditionValue (v string ){_dacge ._dbeb .Formula =[]string {v };};

// IsBool returns true if the cell is a boolean type cell.
func (_dabb Cell )IsBool ()bool {return _dabb ._egbf .TAttr ==_cdcga .ST_CellTypeB };

// X returns the inner wrapped XML type.
func (_ggag RichTextRun )X ()*_cdcga .CT_RElt {return _ggag ._afcg };

// PasswordHash returns the hash of the workbook password.
func (_baga WorkbookProtection )PasswordHash ()string {if _baga ._caaf .WorkbookPasswordAttr ==nil {return "";};return *_baga ._caaf .WorkbookPasswordAttr ;};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_gfae TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_gfae ._bedc .From }};

// Type returns the type of the rule
func (_ecad ConditionalFormattingRule )Type ()_cdcga .ST_CfType {return _ecad ._dbeb .TypeAttr };func (_dgeg PatternFill )ClearFgColor (){_dgeg ._ga .FgColor =nil };func (_afafg DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_afafg .clear ();_afafg ._bdf .TypeAttr =_cdcga .ST_DataValidationType (t );_afafg ._bdf .OperatorAttr =_cdcga .ST_DataValidationOperator (op );return DataValidationCompare {_afafg ._bdf };};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_daccg Cell )AddHyperlink (url string ){for _bagc ,_becc :=range _daccg ._dcdcd ._cadcc {if _becc ==_daccg ._adgg ._bdec {_daccg .SetHyperlink (_daccg ._dcdcd ._efdf [_bagc ].AddHyperlink (url ));return ;};};};

// X returns the inner wrapped XML type.
func (_gffb Font )X ()*_cdcga .CT_Font {return _gffb ._cfed };func (_ecd CellStyle )SetNumberFormat (s string ){_bfcf :=_ecd ._beeag .StyleSheet .AddNumberFormat ();_bfcf .SetFormat (s );_ecd ._fceg .ApplyNumberFormatAttr =_ebgf .Bool (true );_ecd ._fceg .NumFmtIdAttr =_ebgf .Uint32 (_bfcf .ID ());};

// SetName sets the sheet name.
func (_ddbb *Sheet )SetName (name string ){_ddbb ._gaag .NameAttr =name };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_abab Cell )GetCachedFormulaResult ()string {if _abab ._egbf .V !=nil {return *_abab ._egbf .V ;};return "";};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_gfad Cell )SetRichTextString ()RichText {_gfad .clearValue ();_gfad ._egbf .Is =_cdcga .NewCT_Rst ();_gfad ._egbf .TAttr =_cdcga .ST_CellTypeInlineStr ;return RichText {_gfad ._egbf .Is };};func (_gdfd Font )SetName (name string ){_gdfd ._cfed .Name =[]*_cdcga .CT_FontName {{ValAttr :name }}};

// SetHeight is a nop-op.
func (_febe TwoCellAnchor )SetHeight (h _ecf .Distance ){};

// IsSheetLocked returns whether the sheet objects are locked.
func (_agfc SheetProtection )IsObjectLocked ()bool {return _agfc ._caga .ObjectsAttr !=nil &&*_agfc ._caga .ObjectsAttr ;};

// SetHeightAuto sets the row height to be automatically determined.
func (_ebcd Row )SetHeightAuto (){_ebcd ._aadg .HtAttr =nil ;_ebcd ._aadg .CustomHeightAttr =nil };

// LockSheet controls the locking of the sheet.
func (_bfee SheetProtection )LockSheet (b bool ){if !b {_bfee ._caga .SheetAttr =nil ;}else {_bfee ._caga .SheetAttr =_ebgf .Bool (true );};};func _ffecc (_cgd bool )int {if _cgd {return 1;};return 0;};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_cfed *_cdcga .CT_Font ;_aab *_cdcga .StyleSheet ;};

// Name returns the name of the defined name.
func (_cbae DefinedName )Name ()string {return _cbae ._bcee .NameAttr };

// Priority returns the rule priority
func (_fcb ConditionalFormattingRule )Priority ()int32 {return _fcb ._dbeb .PriorityAttr };

// Cell is a single cell within a sheet.
type Cell struct{_dcdcd *Workbook ;_adgg *Sheet ;_ccdf *_cdcga .CT_Row ;_egbf *_cdcga .CT_Cell ;};

// AddView adds a sheet view.
func (_abeg *Sheet )AddView ()SheetView {if _abeg ._bdec .SheetViews ==nil {_abeg ._bdec .SheetViews =_cdcga .NewCT_SheetViews ();};_cfb :=_cdcga .NewCT_SheetView ();_abeg ._bdec .SheetViews .SheetView =append (_abeg ._bdec .SheetViews .SheetView ,_cfb );return SheetView {_cfb };};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _becf .ReaderAt ,size int64 )(*Workbook ,error ){_baeg :=New ();_facc ,_egecg :=_acgd .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _egecg !=nil {return nil ,_egecg ;};_baeg .TmpPath =_facc ;_bgad ,_egecg :=_dgf .NewReader (r ,size );if _egecg !=nil {return nil ,_fbge .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_egecg );};_dfdg :=[]*_dgf .File {};_dfdg =append (_dfdg ,_bgad .File ...);_aegfd :=false ;for _ ,_bbc :=range _dfdg {if _bbc .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_aegfd =true ;break ;};};if _aegfd {_baeg .createCustomProperties ();};_acaf :=_dga .DecodeMap {};_acaf .SetOnNewRelationshipFunc (_baeg .onNewRelationship );_acaf .AddTarget (_ebgf .ContentTypesFilename ,_baeg .ContentTypes .X (),"",0);_acaf .AddTarget (_ebgf .BaseRelsFilename ,_baeg .Rels .X (),"",0);if _fcbd :=_acaf .Decode (_dfdg );_fcbd !=nil {return nil ,_fcbd ;};for _ ,_bgbb :=range _dfdg {if _bgbb ==nil {continue ;};if _affg :=_baeg .AddExtraFileFromZip (_bgbb );_affg !=nil {return nil ,_affg ;};};if _aegfd {_ea :=false ;for _ ,_eca :=range _baeg .Rels .X ().Relationship {if _eca .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_ea =true ;break ;};};if !_ea {_baeg .addCustomRelationships ();};};return _baeg ,nil ;};

// AddFormatValue adds a format value (databars require two).
func (_eccb DataBarScale )AddFormatValue (t _cdcga .ST_CfvoType ,val string ){_agdc :=_cdcga .NewCT_Cfvo ();_agdc .TypeAttr =t ;_agdc .ValAttr =_ebgf .String (val );_eccb ._eefg .Cfvo =append (_eccb ._eefg .Cfvo ,_agdc );};func _ggg (_beg _afea .Time )_afea .Time {_beg =_beg .UTC ();return _afea .Date (_beg .Year (),_beg .Month (),_beg .Day (),_beg .Hour (),_beg .Minute (),_beg .Second (),_beg .Nanosecond (),_afea .Local );};func (_ddgb ConditionalFormattingRule )InitializeDefaults (){_ddgb .SetType (_cdcga .ST_CfTypeCellIs );_ddgb .SetOperator (_cdcga .ST_ConditionalFormattingOperatorGreaterThan );_ddgb .SetPriority (1);};

// CellStyle is a formatting style for a cell.  CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_beeag *Workbook ;_fceg *_cdcga .CT_Xf ;_fgdc *_cdcga .CT_CellXfs ;};func (_cdf *Workbook )ensureSharedStringsRelationships (){_feeag :=false ;for _ ,_gdbed :=range _cdf .ContentTypes .X ().Override {if _gdbed .ContentTypeAttr ==_ebgf .SharedStringsContentType {_feeag =true ;break ;};};if !_feeag {_cdf .ContentTypes .AddOverride (_aae ,_ebgf .SharedStringsContentType );};_bafb :=false ;for _ ,_ddbbe :=range _cdf ._fdeb .Relationships (){if _ddbbe .X ().TargetAttr ==_cff {_bafb =true ;break ;};};if !_bafb {_cdf ._fdeb .AddRelationship (_cff ,_ebgf .SharedStringsType );};};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// SetWidth is a no-op.
func (_caeba TwoCellAnchor )SetWidth (w _ecf .Distance ){};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_cdcga .Comments )Comments {return Comments {w ,x }};

// Row is a row within a spreadsheet.
type Row struct{_abdb *Workbook ;_ffdf *Sheet ;_aadg *_cdcga .CT_Row ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_bbebf *evalContext )GetLabelPrefix (cellRef string )string {return _bbebf ._abcf .Cell (cellRef ).getLabelPrefix ();};var ErrorNotFound =_gebb .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// Comments returns the list of comments for this sheet
func (_adgda Comments )Comments ()[]Comment {_aaef :=[]Comment {};for _ ,_dbdb :=range _adgda ._dedd .CommentList .Comment {_aaef =append (_aaef ,Comment {_adgda ._ddad ,_dbdb ,_adgda ._dedd });};return _aaef ;};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_gbgg Cell )SetString (s string )int {_gbgg ._dcdcd .ensureSharedStringsRelationships ();_gbgg .clearValue ();_aage :=_gbgg ._dcdcd .SharedStrings .AddString (s );_gbgg ._egbf .V =_ebgf .String (_dag .Itoa (_aage ));_gbgg ._egbf .TAttr =_cdcga .ST_CellTypeS ;return _aage ;};

// SetHeight sets the height of the anchored object.
func (_daeff OneCellAnchor )SetHeight (h _ecf .Distance ){_daeff ._gaba .Ext .CyAttr =int64 (h /_ecf .EMU )};

// Content returns the content of the defined range (the range in most cases)/
func (_cfa DefinedName )Content ()string {return _cfa ._bcee .Content };

// SetHidden marks the defined name as hidden.
func (_dbce DefinedName )SetHidden (b bool ){_dbce ._bcee .HiddenAttr =_ebgf .Bool (b )};

// SetBold causes the text to be displayed in bold.
func (_cbb RichTextRun )SetBold (b bool ){_cbb .ensureRpr ();_cbb ._afcg .RPr .B =_cdcga .NewCT_BooleanProperty ();_cbb ._afcg .RPr .B .ValAttr =_ebgf .Bool (b );};

// Type returns the type of anchor
func (_dab TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };func (_eag PatternFill )X ()*_cdcga .CT_PatternFill {return _eag ._ga };

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_bad *Workbook )Close ()error {if _bad .TmpPath !=""{return _acgd .RemoveAll (_bad .TmpPath );};return nil ;};func (_dafd Cell )getLabelPrefix ()string {if _dafd ._egbf .SAttr ==nil {return "";};_ceba :=*_dafd ._egbf .SAttr ;_ffag :=_dafd ._dcdcd .StyleSheet .GetCellStyle (_ceba );switch _ffag ._fceg .Alignment .HorizontalAttr {case _cdcga .ST_HorizontalAlignmentLeft :return "\u0027";case _cdcga .ST_HorizontalAlignmentRight :return "\u0022";case _cdcga .ST_HorizontalAlignmentCenter :return "\u005e";case _cdcga .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_becg *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _becg .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _gaa _fdfe .Relationship ;for _ ,_eebe :=range _becg ._fdeb .Relationships (){if _eebe .ID ()==_becg ._cbc .Sheets .Sheet [ind ].IdAttr {var _aeg bool ;if _gaa ,_aeg =_becg ._fdeb .CopyRelationship (_eebe .ID ());!_aeg {return Sheet {},ErrorNotFound ;};break ;};};_becg .ContentTypes .CopyOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetContentType ,ind +1),_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetContentType ,len (_becg .ContentTypes .X ().Override )));_gbbe :=*_becg ._cadcc [ind ];_becg ._cadcc =append (_becg ._cadcc ,&_gbbe );var _dgfg uint32 =0;for _ ,_ccb :=range _becg ._cbc .Sheets .Sheet {if _ccb .SheetIdAttr > _dgfg {_dgfg =_ccb .SheetIdAttr ;};};_dgfg ++;_ecbg :=*_becg ._cbc .Sheets .Sheet [ind ];_ecbg .IdAttr =_gaa .ID ();_ecbg .NameAttr =copiedSheetName ;_ecbg .SheetIdAttr =_dgfg ;_becg ._cbc .Sheets .Sheet =append (_becg ._cbc .Sheets .Sheet ,&_ecbg );_aedc :=_fdfe .NewRelationshipsCopy (_becg ._efdf [ind ]);_becg ._efdf =append (_becg ._efdf ,_aedc );_cefg :=_becg ._aec [ind ];if _cefg ==nil {_becg ._aec =append (_becg ._aec ,nil );}else {_gfa :=*_cefg ;_becg ._aec =append (_becg ._aec ,&_gfa );};_aege :=Sheet {_becg ,&_ecbg ,&_gbbe };return _aege ,nil ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_fdbad StyleSheet )AddNumberFormat ()NumberFormat {if _fdbad ._gbf .NumFmts ==nil {_fdbad ._gbf .NumFmts =_cdcga .NewCT_NumFmts ();};_dcca :=_cdcga .NewCT_NumFmt ();_dcca .NumFmtIdAttr =uint32 (200+len (_fdbad ._gbf .NumFmts .NumFmt ));_fdbad ._gbf .NumFmts .NumFmt =append (_fdbad ._gbf .NumFmts .NumFmt ,_dcca );_fdbad ._gbf .NumFmts .CountAttr =_ebgf .Uint32 (uint32 (len (_fdbad ._gbf .NumFmts .NumFmt )));return NumberFormat {_fdbad ._ggf ,_dcca };};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_bcad DataValidationList )SetRange (cellRange string ){_bcad ._gde .Formula1 =_ebgf .String (cellRange );_bcad ._gde .Formula2 =_ebgf .String ("\u0030");};func (_ffec Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _cad ,_bea ,_efaa ,_ffg uint32 =1,1,0,0;for _ ,_bfeb :=range _ffec .Rows (){if _bfeb .RowNumber ()< _cad {_cad =_bfeb .RowNumber ();}else if _bfeb .RowNumber ()> _bea {_bea =_bfeb .RowNumber ();};for _ ,_cegd :=range _bfeb .Cells (){_cegc ,_eae :=_eedc .ParseCellReference (_cegd .Reference ());if _eae ==nil {if _cegc .ColumnIdx < _efaa {_efaa =_cegc .ColumnIdx ;}else if _cegc .ColumnIdx > _ffg {_ffg =_cegc .ColumnIdx ;};};};};return _eedc .IndexToColumn (_efaa ),_cad ,_eedc .IndexToColumn (_ffg ),_bea ;};

// SetFormat sets the number format code.
func (_afcc NumberFormat )SetFormat (f string ){_afcc ._beeg .FormatCodeAttr =f };

// DataValidation controls cell validation
type DataValidation struct{_bdf *_cdcga .CT_DataValidation };

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;func (_cecf Comments )getOrCreateAuthor (_ebeb string )uint32 {for _fgcf ,_dafe :=range _cecf ._dedd .Authors .Author {if _dafe ==_ebeb {return uint32 (_fgcf );};};_ece :=uint32 (len (_cecf ._dedd .Authors .Author ));_cecf ._dedd .Authors .Author =append (_cecf ._dedd .Authors .Author ,_ebeb );return _ece ;};func (_fdfab *evalContext )NamedRange (ref string )_aeaf .Reference {for _ ,_dgc :=range _fdfab ._abcf ._ddfe .DefinedNames (){if _dgc .Name ()==ref {return _aeaf .MakeRangeReference (_dgc .Content ());};};for _ ,_aada :=range _fdfab ._abcf ._ddfe .Tables (){if _aada .Name ()==ref {return _aeaf .MakeRangeReference (_fbge .Sprintf ("\u0025\u0073\u0021%\u0073",_fdfab ._abcf .Name (),_aada .Reference ()));};};return _aeaf .ReferenceInvalid ;};func (_ebgd Border )SetRight (style _cdcga .ST_BorderStyle ,c _fdfa .Color ){if _ebgd ._gaad .Right ==nil {_ebgd ._gaad .Right =_cdcga .NewCT_BorderPr ();};_ebgd ._gaad .Right .Color =_cdcga .NewCT_Color ();_ebgd ._gaad .Right .Color .RgbAttr =c .AsRGBAString ();_ebgd ._gaad .Right .StyleAttr =style ;};

// AddRun adds a new run of text to the cell.
func (_cdbgd RichText )AddRun ()RichTextRun {_dfcg :=_cdcga .NewCT_RElt ();_cdbgd ._cafe .R =append (_cdbgd ._cafe .R ,_dfcg );return RichTextRun {_dfcg };};

// X returns the inner wrapped XML type.
func (_fgc RichText )X ()*_cdcga .CT_Rst {return _fgc ._cafe };

// SetError sets the cell type to error and the value to the given error message.
func (_dacc Cell )SetError (msg string ){_dacc .clearValue ();_dacc ._egbf .V =_ebgf .String (msg );_dacc ._egbf .TAttr =_cdcga .ST_CellTypeE ;};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_bedc *_gga .CT_TwoCellAnchor };

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_edg ConditionalFormattingRule )SetDataBar ()DataBarScale {_edg .clear ();_edg .SetType (_cdcga .ST_CfTypeDataBar );_edg ._dbeb .DataBar =_cdcga .NewCT_DataBar ();_gcga :=DataBarScale {_edg ._dbeb .DataBar };_gcga .SetShowValue (true );_gcga .SetMinLength (10);_gcga .SetMaxLength (90);return _gcga ;};

// ClearBorder clears any border configuration from the cell style.
func (_bbacb CellStyle )ClearBorder (){_bbacb ._fceg .BorderIdAttr =nil ;_bbacb ._fceg .ApplyBorderAttr =nil ;};

// AddString adds a string to the shared string cache.
func (_ggfc SharedStrings )AddString (v string )int {if _aaff ,_ebfd :=_ggfc ._abfd [v ];_ebfd {return _aaff ;};_dabd :=_cdcga .NewCT_Rst ();_dabd .T =_ebgf .String (v );_ggfc ._edgb .Si =append (_ggfc ._edgb .Si ,_dabd );_bbe :=len (_ggfc ._edgb .Si )-1;_ggfc ._abfd [v ]=_bbe ;_ggfc ._edgb .CountAttr =_ebgf .Uint32 (uint32 (len (_ggfc ._edgb .Si )));_ggfc ._edgb .UniqueCountAttr =_ggfc ._edgb .CountAttr ;return _bbe ;};func (_bcc Cell )getLocked ()bool {if _bcc ._egbf .SAttr ==nil {return false ;};_ecegg :=*_bcc ._egbf .SAttr ;_c :=_bcc ._dcdcd .StyleSheet .GetCellStyle (_ecegg );return *_c ._fceg .Protection .LockedAttr ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_bacb Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_gdda :=_bacb .AddComment (cellRef ,author );_bde :=_gdda .AddRun ();_bde .SetBold (true );_bde .SetSize (10);_bde .SetColor (_fdfa .Black );_bde .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_bde .SetText (author +"\u003a");_bde =_gdda .AddRun ();_bde .SetSize (10);_bde .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_bde .SetColor (_fdfa .Black );_bde .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_daae ,_ccfd :=_eedc .ParseCellReference (cellRef );if _ccfd !=nil {return _ccfd ;};_bacb ._ddad ._afee [0].Shape =append (_bacb ._ddad ._afee [0].Shape ,_fdebd .NewCommentShape (int64 (_daae .ColumnIdx ),int64 (_daae .RowIdx -1)));return nil ;};

// SetShowValue controls if the cell value is displayed.
func (_efbcf DataBarScale )SetShowValue (b bool ){_efbcf ._eefg .ShowValueAttr =_ebgf .Bool (b )};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_fdfe .DocBase ;_cbc *_cdcga .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_aec []*_cdcga .Comments ;_cadcc []*_cdcga .Worksheet ;_efdf []_fdfe .Relationships ;_fdeb _fdfe .Relationships ;_gab []*_bebb .Theme ;_fac []*_gga .WsDr ;_gabb []_fdfe .Relationships ;_afee []*_fdebd .Container ;_dafb []*_baba .ChartSpace ;_gca []*_cdcga .Table ;_cefcc string ;};

// SetText sets the text to be displayed.
func (_dgb RichTextRun )SetText (s string ){_dgb ._afcg .T =s };const (DVOpGreater =_cdcga .ST_DataValidationOperatorGreaterThanOrEqual ;);

// SetIcons sets the icon set to use for display.
func (_aca IconScale )SetIcons (t _cdcga .ST_IconSetType ){_aca ._gafc .IconSetAttr =t };

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_ddd StyleSheet )RemoveFont (f Font )error {for _eaga ,_cb :=range _ddd ._gbf .Fonts .Font {if _cb ==f .X (){_ddd ._gbf .Fonts .Font =append (_ddd ._gbf .Fonts .Font [:_eaga ],_ddd ._gbf .Fonts .Font [_eaga +1:]...);return nil ;};};return _gebb .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// GetValueAsBool retrieves the cell's value as a boolean
func (_faea Cell )GetValueAsBool ()(bool ,error ){if _faea ._egbf .TAttr !=_cdcga .ST_CellTypeB {return false ,_gebb .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _faea ._egbf .V ==nil {return false ,_gebb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _dag .ParseBool (*_faea ._egbf .V );};var _cgce =false ;

// SetWidthCells is a no-op.
func (_cgdb AbsoluteAnchor )SetWidthCells (int32 ){};

// IsSheetLocked returns whether the sheet is locked.
func (_afff SheetProtection )IsSheetLocked ()bool {return _afff ._caga .SheetAttr !=nil &&*_afff ._caga .SheetAttr ;};

// X returns the inner wrapped XML type.
func (_beea *Workbook )X ()*_cdcga .Workbook {return _beea ._cbc };

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gdbe StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_fda :=range _gdbe .CellStyles (){if _fda .HasNumberFormat ()&&_fda .NumberFormat ()==uint32 (f ){return _fda ;};};_dace :=_gdbe .AddCellStyle ();_dace .SetNumberFormatStandard (f );return _dace ;};

// SetMinLength sets the minimum bar length in percent.
func (_gafe DataBarScale )SetMinLength (l uint32 ){_gafe ._eefg .MinLengthAttr =_ebgf .Uint32 (l )};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_eaf *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_dfca :=-1;for _bgfd ,_efa :=range _eaf .Sheets (){if name ==_efa .Name (){_dfca =_bgfd ;break ;};};if _dfca ==-1{return Sheet {},ErrorNotFound ;};return _eaf .CopySheet (_dfca ,copiedSheetName );};func (_eff Cell )getRawSortValue ()(string ,bool ){if _eff .HasFormula (){_caeb :=_eff .GetCachedFormulaResult ();return _caeb ,_cg .IsNumber (_caeb );};_bbfb ,_ :=_eff .GetRawValue ();return _bbfb ,_cg .IsNumber (_bbfb );};

// X returns the inner wrapped XML type.
func (_fbfa ColorScale )X ()*_cdcga .CT_ColorScale {return _fbfa ._cbeb };

// SetPassword sets the password hash to a hash of the input password.
func (_bbg SheetProtection )SetPassword (pw string ){_bbg .SetPasswordHash (PasswordHash (pw ))};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_bgc *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_ddbf :=_cdcga .NewCT_ConditionalFormatting ();_bgc ._bdec .ConditionalFormatting =append (_bgc ._bdec .ConditionalFormatting ,_ddbf );_gdad :=make (_cdcga .ST_Sqref ,0,0);_ddbf .SqrefAttr =&_gdad ;for _ ,_bge :=range cellRanges {*_ddbf .SqrefAttr =append (*_ddbf .SqrefAttr ,_bge );};return ConditionalFormatting {_ddbf };};

// X returns the inner wrapped XML type.
func (_egec CellMarker )X ()*_gga .CT_Marker {return _egec ._cca };

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_dacad *Sheet )SetDrawing (d Drawing ){var _adab _fdfe .Relationships ;for _bdaf ,_fee :=range _dacad ._ddfe ._cadcc {if _fee ==_dacad ._bdec {_adab =_dacad ._ddfe ._efdf [_bdaf ];break ;};};var _gbba string ;for _gacg ,_efae :=range d ._gba ._fac {if _efae ==d ._fbfab {_egd :=_adab .AddAutoRelationship (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetType ,_gacg +1,_ebgf .DrawingType );_gbba =_egd .ID ();break ;};};_dacad ._bdec .Drawing =_cdcga .NewCT_Drawing ();_dacad ._bdec .Drawing .IdAttr =_gbba ;};

// X returns the inner wrapped XML type.
func (_eegb NumberFormat )X ()*_cdcga .CT_NumFmt {return _eegb ._beeg };

// Validate attempts to validate the structure of a workbook.
func (_caf *Workbook )Validate ()error {if _caf ==nil ||_caf ._cbc ==nil {return _gebb .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_fcg :=uint32 (0);for _ ,_cdbc :=range _caf ._cbc .Sheets .Sheet {if _cdbc .SheetIdAttr > _fcg {_fcg =_cdbc .SheetIdAttr ;};};if _fcg !=uint32 (len (_caf ._cadcc )){return _fbge .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_fcg ,len (_caf ._cadcc ));};_aadc :=map[string ]struct{}{};for _agfda ,_ccgc :=range _caf ._cbc .Sheets .Sheet {_dege :=Sheet {_caf ,_ccgc ,_caf ._cadcc [_agfda ]};if _ ,_bcac :=_aadc [_dege .Name ()];_bcac {return _fbge .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_agfda ,_dege .Name ());};_aadc [_dege .Name ()]=struct{}{};if _dffee :=_dege .ValidateWithPath (_fbge .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_agfda ));_dffee !=nil {return _dffee ;};if _gede :=_dege .Validate ();_gede !=nil {return _gede ;};};return nil ;};func (_ggfd Cell )clearValue (){_ggfd ._egbf .F =nil ;_ggfd ._egbf .Is =nil ;_ggfd ._egbf .V =nil ;_ggfd ._egbf .TAttr =_cdcga .ST_CellTypeUnset ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_addg ,_ebcc :=_cddc .Open (filename );if _ebcc !=nil {return nil ,_fbge .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ebcc );};defer _addg .Close ();_afca ,_ebcc :=_cddc .Stat (filename );if _ebcc !=nil {return nil ,_fbge .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_ebcc );};_ccag ,_ebcc :=Read (_addg ,_afca .Size ());if _ebcc !=nil {return nil ,_ebcc ;};_aga ,_ :=_adge .Abs (_adge .Dir (filename ));_ccag ._cefcc =_adge .Join (_aga ,filename );return _ccag ,nil ;};

// ClearFill clears any fill configuration from the cell style.
func (_fad CellStyle )ClearFill (){_fad ._fceg .FillIdAttr =nil ;_fad ._fceg .ApplyFillAttr =nil };

// X returns the inner wrapped XML type.
func (_efd DefinedName )X ()*_cdcga .CT_DefinedName {return _efd ._bcee };

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_bbbbg Comment )SetCellReference (cellRef string ){_bbbbg ._gfdd .RefAttr =cellRef };

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_eabd TwoCellAnchor )SetHeightCells (h int32 ){_eabd .SetHeight (0);_ggba :=_eabd .TopLeft ();_bdbg :=_eabd .BottomRight ();_bdbg .SetRow (_ggba .Row ()+h );};

// X returns the inner wrapped XML type.
func (_eafc Table )X ()*_cdcga .Table {return _eafc ._cgdf };

// SetValues sets the possible values. This is incompatible with SetRange.
func (_deeb DataValidationList )SetValues (values []string ){_deeb ._gde .Formula1 =_ebgf .String ("\u0022"+_bda .Join (values ,"\u002c")+"\u0022");_deeb ._gde .Formula2 =_ebgf .String ("\u0030");};

// Operator returns the operator for the rule
func (_gegc ConditionalFormattingRule )Operator ()_cdcga .ST_ConditionalFormattingOperator {return _gegc ._dbeb .OperatorAttr ;};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_agdf ,_bbbc int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_cag _ecf .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_cecb int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_aa _ecf .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_geggg int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_ddcb _ecf .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_bfb _ecf .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// AddFont adds a new empty font to the stylesheet.
func (_ddg StyleSheet )AddFont ()Font {_fdf :=_cdcga .NewCT_Font ();_ddg ._gbf .Fonts .Font =append (_ddg ._gbf .Fonts .Font ,_fdf );_ddg ._gbf .Fonts .CountAttr =_ebgf .Uint32 (uint32 (len (_ddg ._gbf .Fonts .Font )));return Font {_fdf ,_ddg ._gbf };};

// StyleSheet is a document style sheet.
type StyleSheet struct{_ggf *Workbook ;_gbf *_cdcga .StyleSheet ;};func init (){_eed ()};func _eed (){_g ,_bfed :=_daeb .ReadBuildInfo ();if !_bfed {if !_cgce {_fbge .Printf ("\u0042\u0075il\u0064\u0020\u0069n\u0066\u006f\u0072\u006dati\u006fn \u006d\u0069\u0073\u0073\u0069\u006e\u0067 -\u0020\u0045\u0078\u0069\u0074\u0069\u006eg\u000a");_cddc .Exit (1);}else {return ;};};_cgb :=0;for _ ,_gfab :=range _g .Deps {if _gfab .Path =="g\u0069\u0074\u0068\u0075\u0062\u002ec\u006f\u006d\u002f\u0075\u006e\u0069\u0064\u006f\u0063/\u0075\u006e\u0069o\u0066f\u0069\u0063\u0065"&&_gfab .Replace ==nil {_cgb =1;};};_efddd :=_cgce ;if _bda .HasPrefix (_g .Path ,"\u0067i\u0074h\u0075\u0062\u002e\u0063\u006fm\u002f\u0075n\u0069\u0064\u006f\u0063\u002f"){_efddd =true ;};if _cgb !=1&&!_efddd {_fbge .Printf ("\u0050\u0061\u0063\u006b\u0061\u0067\u0065\u0020\u0069\u006e\u0066\u006f\u0072\u006d\u0061\u0074\u0069\u006f\u006e\u0020\u0069\u006e\u0076\u0061l\u0069\u0064\u0020\u002d\u0020E\u0078\u0069t\u0069\u006e\u0067\u000a");_cddc .Exit (1);};};

// MoveTo is a no-op.
func (_aegef AbsoluteAnchor )MoveTo (x ,y int32 ){};const _ebg ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";func (_ecc *Sheet )setArray (_fcaec string ,_adaa _aeaf .Result )error {_gbbd ,_gbc :=_eedc .ParseCellReference (_fcaec );if _gbc !=nil {return _gbc ;};for _geb ,_cgdg :=range _adaa .ValueArray {_cbe :=_ecc .Row (_gbbd .RowIdx +uint32 (_geb ));for _ceac ,_eac :=range _cgdg {_begg :=_cbe .Cell (_eedc .IndexToColumn (_gbbd .ColumnIdx +uint32 (_ceac )));if _eac .Type !=_aeaf .ResultTypeEmpty {if _eac .IsBoolean {_begg .SetBool (_eac .ValueNumber !=0);}else {_begg .SetCachedFormulaResult (_eac .String ());};};};};return nil ;};

// Name returns the name of the table
func (_dffdf Table )Name ()string {if _dffdf ._cgdf .NameAttr !=nil {return *_dffdf ._cgdf .NameAttr ;};return "";};

// MaxColumnIdx returns the max used column of the sheet.
func (_ddda Sheet )MaxColumnIdx ()uint32 {_fggc :=uint32 (0);for _ ,_bgd :=range _ddda .Rows (){_ead :=_bgd ._aadg .C ;if len (_ead )> 0{_gfg :=_ead [len (_ead )-1];_bcddb ,_ :=_eedc .ParseCellReference (*_gfg .RAttr );if _fggc < _bcddb .ColumnIdx {_fggc =_bcddb .ColumnIdx ;};};};return _fggc ;};

// SetColor sets the text color.
func (_cabg RichTextRun )SetColor (c _fdfa .Color ){_cabg .ensureRpr ();_cabg ._afcg .RPr .Color =_cdcga .NewCT_Color ();_bdcb :="\u0066\u0066"+*c .AsRGBString ();_cabg ._afcg .RPr .Color .RgbAttr =&_bdcb ;};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_beeb *Sheet )SetBorder (cellRange string ,border Border )error {_afaf ,_ggee ,_faca :=_eedc .ParseRangeReference (cellRange );if _faca !=nil {return _faca ;};_ffgd :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_ebe :=_beeb ._ddfe .StyleSheet .AddBorder ();_ffgd .SetBorder (_ebe );_ebe ._gaad .Top =border ._gaad .Top ;_ebe ._gaad .Left =border ._gaad .Left ;_caabb :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_gfd :=_beeb ._ddfe .StyleSheet .AddBorder ();_caabb .SetBorder (_gfd );_gfd ._gaad .Top =border ._gaad .Top ;_gfd ._gaad .Right =border ._gaad .Right ;_degb :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_edd :=_beeb ._ddfe .StyleSheet .AddBorder ();_degb .SetBorder (_edd );_edd ._gaad .Top =border ._gaad .Top ;_ccd :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_cfde :=_beeb ._ddfe .StyleSheet .AddBorder ();_ccd .SetBorder (_cfde );_cfde ._gaad .Left =border ._gaad .Left ;_cbfc :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_bcbe :=_beeb ._ddfe .StyleSheet .AddBorder ();_cbfc .SetBorder (_bcbe );_bcbe ._gaad .Right =border ._gaad .Right ;_fdcd :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_aggd :=_beeb ._ddfe .StyleSheet .AddBorder ();_fdcd .SetBorder (_aggd );_aggd ._gaad .Bottom =border ._gaad .Bottom ;_eeg :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_gce :=_beeb ._ddfe .StyleSheet .AddBorder ();_eeg .SetBorder (_gce );_gce ._gaad .Bottom =border ._gaad .Bottom ;_gce ._gaad .Left =border ._gaad .Left ;_dfd :=_beeb ._ddfe .StyleSheet .AddCellStyle ();_gdcc :=_beeb ._ddfe .StyleSheet .AddBorder ();_dfd .SetBorder (_gdcc );_gdcc ._gaad .Bottom =border ._gaad .Bottom ;_gdcc ._gaad .Right =border ._gaad .Right ;_db :=_afaf .RowIdx ;_dae :=_afaf .ColumnIdx ;_fge :=_ggee .RowIdx ;_deef :=_ggee .ColumnIdx ;for _eaa :=_db ;_eaa <=_fge ;_eaa ++{for _fdcf :=_dae ;_fdcf <=_deef ;_fdcf ++{_dbga :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_fdcf ),_eaa );switch {case _eaa ==_db &&_fdcf ==_dae :_beeb .Cell (_dbga ).SetStyle (_ffgd );case _eaa ==_db &&_fdcf ==_deef :_beeb .Cell (_dbga ).SetStyle (_caabb );case _eaa ==_fge &&_fdcf ==_dae :_beeb .Cell (_dbga ).SetStyle (_eeg );case _eaa ==_fge &&_fdcf ==_deef :_beeb .Cell (_dbga ).SetStyle (_dfd );case _eaa ==_db :_beeb .Cell (_dbga ).SetStyle (_degb );case _eaa ==_fge :_beeb .Cell (_dbga ).SetStyle (_fdcd );case _fdcf ==_dae :_beeb .Cell (_dbga ).SetStyle (_ccd );case _fdcf ==_deef :_beeb .Cell (_dbga ).SetStyle (_cbfc );};};};return nil ;};

// GetEpoch returns a workbook's time epoch.
func (_efbb *evalContext )GetEpoch ()_afea .Time {return _efbb ._abcf ._ddfe .Epoch ()};func NewFills ()Fills {return Fills {_cdcga .NewCT_Fills ()}};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_ebga *Workbook )ClearCachedFormulaResults (){for _ ,_efce :=range _ebga .Sheets (){_efce .ClearCachedFormulaResults ();};};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_cbfg *Sheet )ClearCachedFormulaResults (){for _ ,_bdff :=range _cbfg .Rows (){for _ ,_cdbgf :=range _bdff .Cells (){if _cdbgf .X ().F !=nil {_cdbgf .X ().V =nil ;};};};};

// SetHeightCells is a no-op.
func (_aggf AbsoluteAnchor )SetHeightCells (int32 ){};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_dagc *Sheet )AddHyperlink (url string )_fdfe .Hyperlink {for _ffee ,_aff :=range _dagc ._ddfe ._cadcc {if _aff ==_dagc ._bdec {return _dagc ._ddfe ._efdf [_ffee ].AddHyperlink (url );};};return _fdfe .Hyperlink {};};var _adbe *_fdcfb .Regexp =_fdcfb .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_acac Cell )SetFormulaShared (formula string ,rows ,cols uint32 )error {_acac .clearValue ();_acac ._egbf .TAttr =_cdcga .ST_CellTypeStr ;_acac ._egbf .F =_cdcga .NewCT_CellFormula ();_acac ._egbf .F .TAttr =_cdcga .ST_CellFormulaTypeShared ;_acac ._egbf .F .Content =formula ;_cbf ,_gcggg :=_eedc .ParseCellReference (_acac .Reference ());if _gcggg !=nil {return _gcggg ;};_ccgd :=uint32 (0);for _ ,_dede :=range _acac ._adgg .Rows (){for _ ,_gceg :=range _dede ._aadg .C {if _gceg .F !=nil &&_gceg .F .SiAttr !=nil &&*_gceg .F .SiAttr >=_ccgd {_ccgd =*_gceg .F .SiAttr ;};};};_ccgd ++;_dfdf :=_fbge .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_cbf .Column ,_cbf .RowIdx ,_eedc .IndexToColumn (_cbf .ColumnIdx +cols ),_cbf .RowIdx +rows );_acac ._egbf .F .RefAttr =_ebgf .String (_dfdf );_acac ._egbf .F .SiAttr =_ebgf .Uint32 (_ccgd );_fbe :=Sheet {_acac ._dcdcd ,_acac ._adgg ._gaag ,_acac ._adgg ._bdec };for _aaagf :=_cbf .RowIdx ;_aaagf <=_cbf .RowIdx +rows ;_aaagf ++{for _ffdb :=_cbf .ColumnIdx ;_ffdb <=_cbf .ColumnIdx +cols ;_ffdb ++{if _aaagf ==_cbf .RowIdx &&_ffdb ==_cbf .ColumnIdx {continue ;};_dcdf :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_ffdb ),_aaagf );_fbe .Cell (_dcdf ).Clear ();_fbe .Cell (_dcdf ).X ().F =_cdcga .NewCT_CellFormula ();_fbe .Cell (_dcdf ).X ().F .TAttr =_cdcga .ST_CellFormulaTypeShared ;_fbe .Cell (_dcdf ).X ().F .SiAttr =_ebgf .Uint32 (_ccgd );};};return nil ;};

// X returns the inner wrapped XML type.
func (_bcd Column )X ()*_cdcga .CT_Col {return _bcd ._fade };

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_ccfb Cell )SetFormulaArray (s string ){_ccfb .clearValue ();_ccfb ._egbf .TAttr =_cdcga .ST_CellTypeStr ;_ccfb ._egbf .F =_cdcga .NewCT_CellFormula ();_ccfb ._egbf .F .TAttr =_cdcga .ST_CellFormulaTypeArray ;_ccfb ._egbf .F .Content =s ;};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gef *Workbook )AddDefinedName (name ,ref string )DefinedName {if _gef ._cbc .DefinedNames ==nil {_gef ._cbc .DefinedNames =_cdcga .NewCT_DefinedNames ();};_gee :=_cdcga .NewCT_DefinedName ();_gee .Content =ref ;_gee .NameAttr =name ;_gef ._cbc .DefinedNames .DefinedName =append (_gef ._cbc .DefinedNames .DefinedName ,_gee );return DefinedName {_gee };};

// SetPasswordHash sets the password hash to the input.
func (_caab WorkbookProtection )SetPasswordHash (pwHash string ){_caab ._caaf .WorkbookPasswordAttr =_ebgf .String (pwHash );};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_dcc *Workbook )RemoveSheetByName (name string )error {_fde :=-1;for _abdf ,_dge :=range _dcc .Sheets (){if name ==_dge .Name (){_fde =_abdf ;break ;};};if _fde ==-1{return ErrorNotFound ;};return _dcc .RemoveSheet (_fde );};

// SetItalic causes the text to be displayed in italic.
func (_fcfa RichTextRun )SetItalic (b bool ){_fcfa .ensureRpr ();_fcfa ._afcg .RPr .I =_cdcga .NewCT_BooleanProperty ();_fcfa ._afcg .RPr .I .ValAttr =_ebgf .Bool (b );};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_faed Sheet )Validate ()error {_bggc :=[]func ()error {_faed .validateRowCellNumbers ,_faed .validateMergedCells ,_faed .validateSheetNames };for _ ,_baf :=range _bggc {if _fefc :=_baf ();_fefc !=nil {return _fefc ;};};if _gbge :=_faed ._bdec .Validate ();_gbge !=nil {return _gbge ;};return _faed ._bdec .Validate ();};

// SetWidth sets the width of the anchored object.
func (_cbgf OneCellAnchor )SetWidth (w _ecf .Distance ){_cbgf ._gaba .Ext .CxAttr =int64 (w /_ecf .EMU )};

// SetNumber sets the cell type to number, and the value to the given number
func (_fefa Cell )SetNumber (v float64 ){_fefa .clearValue ();if _cgcb .IsNaN (v )||_cgcb .IsInf (v ,0){_fefa ._egbf .TAttr =_cdcga .ST_CellTypeE ;_fefa ._egbf .V =_ebgf .String ("\u0023\u004e\u0055M\u0021");return ;};_fefa ._egbf .TAttr =_cdcga .ST_CellTypeN ;_fefa ._egbf .V =_ebgf .String (_dag .FormatFloat (v ,'f',-1,64));};

// Border is a cell border configuraton.
type Border struct{_gaad *_cdcga .CT_Border ;_bddg *_cdcga .CT_Borders ;};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// AddSheet adds a new sheet to a workbook.
func (_cfg *Workbook )AddSheet ()Sheet {_edda :=_cdcga .NewCT_Sheet ();_edda .SheetIdAttr =1;for _ ,_cdfd :=range _cfg ._cbc .Sheets .Sheet {if _edda .SheetIdAttr <=_cdfd .SheetIdAttr {_edda .SheetIdAttr =_cdfd .SheetIdAttr +1;};};_cfg ._cbc .Sheets .Sheet =append (_cfg ._cbc .Sheets .Sheet ,_edda );_edda .NameAttr =_fbge .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_edda .SheetIdAttr );_acaa :=_cdcga .NewWorksheet ();_acaa .Dimension =_cdcga .NewCT_SheetDimension ();_acaa .Dimension .RefAttr ="\u0041\u0031";_cfg ._cadcc =append (_cfg ._cadcc ,_acaa );_cef :=_fdfe .NewRelationships ();_cfg ._efdf =append (_cfg ._efdf ,_cef );_acaa .SheetData =_cdcga .NewCT_SheetData ();_cfg ._aec =append (_cfg ._aec ,nil );_ggffa :=_ebgf .DocTypeSpreadsheet ;_bcdd :=_cfg ._fdeb .AddAutoRelationship (_ggffa ,_ebgf .OfficeDocumentType ,len (_cfg ._cbc .Sheets .Sheet ),_ebgf .WorksheetType );_edda .IdAttr =_bcdd .ID ();_cfg .ContentTypes .AddOverride (_ebgf .AbsoluteFilename (_ggffa ,_ebgf .WorksheetContentType ,len (_cfg ._cbc .Sheets .Sheet )),_ebgf .WorksheetContentType );return Sheet {_cfg ,_edda ,_acaa };};

// X returns the inner wrapped XML type.
func (_eebef Border )X ()*_cdcga .CT_Border {return _eebef ._gaad };

// CellStyles returns the list of defined cell styles
func (_cfda StyleSheet )CellStyles ()[]CellStyle {_gafca :=[]CellStyle {};for _ ,_ffd :=range _cfda ._gbf .CellXfs .Xf {_gafca =append (_gafca ,CellStyle {_cfda ._ggf ,_ffd ,_cfda ._gbf .CellXfs });};return _gafca ;};var _cff =_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .OfficeDocumentType ,_ebgf .SharedStringsType ,0);

// X returns the inner wrapped XML type.
func (_egaf Cell )X ()*_cdcga .CT_Cell {return _egaf ._egbf };

// SetRowOffset sets a column offset in absolute distance.
func (_ageb CellMarker )SetRowOffset (m _ecf .Distance ){_ageb ._cca .RowOff .ST_CoordinateUnqualified =_ebgf .Int64 (int64 (m /_ecf .EMU ));};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_dbgg Cell )GetValueAsTime ()(_afea .Time ,error ){if _dbgg ._egbf .TAttr !=_cdcga .ST_CellTypeUnset {return _afea .Time {},_gebb .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _dbgg ._egbf .V ==nil {return _afea .Time {},_gebb .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_bcfgb ,_ ,_cagc :=_eedd .ParseFloat (*_dbgg ._egbf .V ,10,128,_eedd .ToNearestEven );if _cagc !=nil {return _afea .Time {},_cagc ;};_fbgeg :=new (_eedd .Float );_fbgeg .SetUint64 (uint64 (24*_afea .Hour ));_bcfgb .Mul (_bcfgb ,_fbgeg );_gbfe ,_ :=_bcfgb .Uint64 ();_bcfd :=_dbgg ._dcdcd .Epoch ().Add (_afea .Duration (_gbfe ));return _ggg (_bcfd ),nil ;};var (_dcfb =[...]uint8 {0,21,46,61,76,91};_ffbf =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_gec =[...]uint8 {0,16,32,48,64};_dcg =[...]uint8 {0,16,32,48,64,80};);

// SetColor sets teh color of the databar.
func (_efbe DataBarScale )SetColor (c _fdfa .Color ){_efbe ._eefg .Color =_cdcga .NewCT_Color ();_efbe ._eefg .Color .RgbAttr =c .AsRGBAString ();};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_dfbcd Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_bagd :=[]Cell {};for _agba :=uint32 (0);_agba <=lastColIdx ;_agba ++{_ffea :=_dfbcd .Cell (_eedc .IndexToColumn (_agba ));_bagd =append (_bagd ,_ffea );};return _bagd ;};

// Rows returns all of the rows in a sheet.
func (_bdea *Sheet )Rows ()[]Row {_fbb :=[]Row {};for _ ,_faccg :=range _bdea ._bdec .SheetData .Row {_fbb =append (_fbb ,Row {_bdea ._ddfe ,_bdea ,_faccg });};return _fbb ;};

// X returns the inner wrapped XML type.
func (_daf SharedStrings )X ()*_cdcga .Sst {return _daf ._edgb };

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_fadf Row )Cells ()[]Cell {_gagf :=[]Cell {};_age :=-1;for _ ,_gegb :=range _fadf ._aadg .C {if _gegb .RAttr ==nil {_ebgf .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_gdb ,_degff :=_eedc .ParseCellReference (*_gegb .RAttr );if _degff !=nil {_ebgf .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_gegb .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_ecegb :=int (_gdb .ColumnIdx );if _ecegb -_age > 1{for _dcec :=_age +1;_dcec < _ecegb ;_dcec ++{_gagf =append (_gagf ,_fadf .Cell (_eedc .IndexToColumn (uint32 (_dcec ))));};};_age =_ecegb ;_gagf =append (_gagf ,Cell {_fadf ._abdb ,_fadf ._ffdf ,_fadf ._aadg ,_gegb });};return _gagf ;};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_fade *_cdcga .CT_Col };

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_dfab Cell )SetCachedFormulaResult (s string ){_dfab ._egbf .V =&s };

// Type returns the type of anchor
func (_ac AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_egff ConditionalFormattingRule )SetIcons ()IconScale {_egff .clear ();_egff .SetType (_cdcga .ST_CfTypeIconSet );_egff ._dbeb .IconSet =_cdcga .NewCT_IconSet ();_fgae :=IconScale {_egff ._dbeb .IconSet };_fgae .SetIcons (_cdcga .ST_IconSetType3TrafficLights1 );return _fgae ;};

// X returns the inner wrapped XML type.
func (_dedcc ConditionalFormatting )X ()*_cdcga .CT_ConditionalFormatting {return _dedcc ._ccgdf };

// Comments returns the comments for a sheet.
func (_bbcda *Sheet )Comments ()Comments {for _aed ,_dfe :=range _bbcda ._ddfe ._cadcc {if _dfe ==_bbcda ._bdec {if _bbcda ._ddfe ._aec [_aed ]==nil {_bbcda ._ddfe ._aec [_aed ]=_cdcga .NewComments ();_bbcda ._ddfe ._efdf [_aed ].AddAutoRelationship (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetType ,_aed +1,_ebgf .CommentsType );_bbcda ._ddfe .ContentTypes .AddOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .CommentsType ,_aed +1),_ebgf .CommentsContentType );};if len (_bbcda ._ddfe ._afee )==0{_bbcda ._ddfe ._afee =append (_bbcda ._ddfe ._afee ,_fdebd .NewCommentDrawing ());_ggdg :=_bbcda ._ddfe ._efdf [_aed ].AddAutoRelationship (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetType ,1,_ebgf .VMLDrawingType );if _bbcda ._bdec .LegacyDrawing ==nil {_bbcda ._bdec .LegacyDrawing =_cdcga .NewCT_LegacyDrawing ();};_bbcda ._bdec .LegacyDrawing .IdAttr =_ggdg .ID ();};return Comments {_bbcda ._ddfe ,_bbcda ._ddfe ._aec [_aed ]};};};_ebgf .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};const _fcgc ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_cacg *Workbook )Save (w _becf .Writer )error {if !_bgfec .GetLicenseKey ().IsLicensed ()&&!_cgce {_fbge .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_fbge .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _gebb .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_cab :=_dgf .NewWriter (w );defer _cab .Close ();_gedgg :=_ebgf .DocTypeSpreadsheet ;if _cbfgb :=_dga .MarshalXML (_cab ,_ebgf .BaseRelsFilename ,_cacg .Rels .X ());_cbfgb !=nil {return _cbfgb ;};if _gbdc :=_dga .MarshalXMLByType (_cab ,_gedgg ,_ebgf .ExtendedPropertiesType ,_cacg .AppProperties .X ());_gbdc !=nil {return _gbdc ;};if _aea :=_dga .MarshalXMLByType (_cab ,_gedgg ,_ebgf .CorePropertiesType ,_cacg .CoreProperties .X ());_aea !=nil {return _aea ;};_dcee :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .OfficeDocumentType ,0);if _cfd :=_dga .MarshalXML (_cab ,_dcee ,_cacg ._cbc );_cfd !=nil {return _cfd ;};if _bgaf :=_dga .MarshalXML (_cab ,_dga .RelationsPathFor (_dcee ),_cacg ._fdeb .X ());_bgaf !=nil {return _bgaf ;};if _edee :=_dga .MarshalXMLByType (_cab ,_gedgg ,_ebgf .StylesType ,_cacg .StyleSheet .X ());_edee !=nil {return _edee ;};for _gdab ,_fgd :=range _cacg ._gab {if _ggaa :=_dga .MarshalXMLByTypeIndex (_cab ,_gedgg ,_ebgf .ThemeType ,_gdab +1,_fgd );_ggaa !=nil {return _ggaa ;};};for _ebfg ,_fcd :=range _cacg ._cadcc {_fcd .Dimension .RefAttr =Sheet {_cacg ,nil ,_fcd }.Extents ();_bfe :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .WorksheetType ,_ebfg +1);_dga .MarshalXML (_cab ,_bfe ,_fcd );_dga .MarshalXML (_cab ,_dga .RelationsPathFor (_bfe ),_cacg ._efdf [_ebfg ].X ());};if _acff :=_dga .MarshalXMLByType (_cab ,_gedgg ,_ebgf .SharedStringsType ,_cacg .SharedStrings .X ());_acff !=nil {return _acff ;};if _cacg .CustomProperties .X ()!=nil {if _bfcaf :=_dga .MarshalXMLByType (_cab ,_gedgg ,_ebgf .CustomPropertiesType ,_cacg .CustomProperties .X ());_bfcaf !=nil {return _bfcaf ;};};if _cacg .Thumbnail !=nil {_fbgf :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .ThumbnailType ,0);_gfbg ,_cd :=_cab .Create (_fbgf );if _cd !=nil {return _cd ;};if _fa :=_dff .Encode (_gfbg ,_cacg .Thumbnail ,nil );_fa !=nil {return _fa ;};};for _eaff ,_fgbb :=range _cacg ._dafb {_gadd :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .ChartType ,_eaff +1);_dga .MarshalXML (_cab ,_gadd ,_fgbb );};for _acfc ,_eadd :=range _cacg ._gca {_deb :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .TableType ,_acfc +1);_dga .MarshalXML (_cab ,_deb ,_eadd );};for _efea ,_egbgf :=range _cacg ._fac {_bag :=_ebgf .AbsoluteFilename (_gedgg ,_ebgf .DrawingType ,_efea +1);_dga .MarshalXML (_cab ,_bag ,_egbgf );if !_cacg ._gabb [_efea ].IsEmpty (){_dga .MarshalXML (_cab ,_dga .RelationsPathFor (_bag ),_cacg ._gabb [_efea ].X ());};};for _afac ,_adggg :=range _cacg ._afee {_dga .MarshalXML (_cab ,_ebgf .AbsoluteFilename (_gedgg ,_ebgf .VMLDrawingType ,_afac +1),_adggg );};for _aedcd ,_a :=range _cacg .Images {if _aaeb :=_fdfe .AddImageToZip (_cab ,_a ,_aedcd +1,_ebgf .DocTypeSpreadsheet );_aaeb !=nil {return _aaeb ;};};if _fbdc :=_dga .MarshalXML (_cab ,_ebgf .ContentTypesFilename ,_cacg .ContentTypes .X ());_fbdc !=nil {return _fbdc ;};for _eagc ,_fef :=range _cacg ._aec {if _fef ==nil {continue ;};_dga .MarshalXML (_cab ,_ebgf .AbsoluteFilename (_gedgg ,_ebgf .CommentsType ,_eagc +1),_fef );};if _daebc :=_cacg .WriteExtraFiles (_cab );_daebc !=nil {return _daebc ;};return _cab .Close ();};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_geff :=_cdcga .NewStyleSheet ();_geff .CellStyleXfs =_cdcga .NewCT_CellStyleXfs ();_geff .CellXfs =_cdcga .NewCT_CellXfs ();_geff .CellStyles =_cdcga .NewCT_CellStyles ();_efdd :=_cdcga .NewCT_CellStyle ();_efdd .NameAttr =_ebgf .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_efdd .XfIdAttr =0;_efdd .BuiltinIdAttr =_ebgf .Uint32 (0);_geff .CellStyles .CellStyle =append (_geff .CellStyles .CellStyle ,_efdd );_geff .CellStyles .CountAttr =_ebgf .Uint32 (uint32 (len (_geff .CellStyles .CellStyle )));_ff :=_cdcga .NewCT_Xf ();_ff .NumFmtIdAttr =_ebgf .Uint32 (0);_ff .FontIdAttr =_ebgf .Uint32 (0);_ff .FillIdAttr =_ebgf .Uint32 (0);_ff .BorderIdAttr =_ebgf .Uint32 (0);_geff .CellStyleXfs .Xf =append (_geff .CellStyleXfs .Xf ,_ff );_geff .CellStyleXfs .CountAttr =_ebgf .Uint32 (uint32 (len (_geff .CellStyleXfs .Xf )));_egf :=NewFills ();_geff .Fills =_egf .X ();_dgeb :=_egf .AddFill ().SetPatternFill ();_dgeb .SetPattern (_cdcga .ST_PatternTypeNone );_dgeb =_egf .AddFill ().SetPatternFill ();_dgeb .SetPattern (_cdcga .ST_PatternTypeGray125 );_geff .Fonts =_cdcga .NewCT_Fonts ();_geff .Borders =_cdcga .NewCT_Borders ();_cee :=StyleSheet {wb ,_geff };_cee .AddBorder ().InitializeDefaults ();_eba :=_cee .AddFont ();_eba .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_eba .SetSize (11);_fbdcf :=_cdcga .NewCT_Xf ();*_fbdcf =*_ff ;_fbdcf .XfIdAttr =_ebgf .Uint32 (0);_geff .CellXfs .Xf =append (_geff .CellXfs .Xf ,_fbdcf );_geff .CellXfs .CountAttr =_ebgf .Uint32 (uint32 (len (_geff .CellXfs .Xf )));return _cee ;};type WorkbookProtection struct{_caaf *_cdcga .CT_WorkbookProtection };func (_bfg Row )renumberAs (_ecge uint32 ){_bfg ._aadg .RAttr =_ebgf .Uint32 (_ecge );for _ ,_gagff :=range _bfg .Cells (){_acb ,_abffe :=_eedc .ParseCellReference (_gagff .Reference ());if _abffe ==nil {_cfff :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_acb .Column ,_ecge );_gagff ._egbf .RAttr =_ebgf .String (_cfff );};};};func (_gfde *Sheet )setShared (_ddgad string ,_daed ,_dbfc _eedc .CellReference ,_gdabd string ){_fgg :=_gfde .FormulaContext ();_aabf :=_aeaf .NewEvaluator ();for _cbac :=_daed .RowIdx ;_cbac <=_dbfc .RowIdx ;_cbac ++{for _caaa :=_daed .ColumnIdx ;_caaa <=_dbfc .ColumnIdx ;_caaa ++{_faa :=_cbac -_daed .RowIdx ;_cdbg :=_caaa -_daed .ColumnIdx ;_fgg .SetOffset (_cdbg ,_faa );_dfc :=_aabf .Eval (_fgg ,_gdabd );_fbde :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",_eedc .IndexToColumn (_caaa ),_cbac );_adfa :=_gfde .Cell (_fbde );if _dfc .Type ==_aeaf .ResultTypeNumber {_adfa .X ().TAttr =_cdcga .ST_CellTypeN ;}else {_adfa .X ().TAttr =_cdcga .ST_CellTypeInlineStr ;};_adfa .X ().V =_ebgf .String (_dfc .Value ());};};_ =_aabf ;_ =_fgg ;};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_daa *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_bda .Replace (rangeRef ,"\u0024","",-1);_daa ._bdec .AutoFilter =_cdcga .NewCT_AutoFilter ();_daa ._bdec .AutoFilter .RefAttr =_ebgf .String (rangeRef );_cgf :="\u0027"+_daa .Name ()+"\u0027\u0021";var _dcdd DefinedName ;for _ ,_eegf :=range _daa ._ddfe .DefinedNames (){if _eegf .Name ()==_fcgc {if _bda .HasPrefix (_eegf .Content (),_cgf ){_dcdd =_eegf ;_dcdd .SetContent (_daa .RangeReference (rangeRef ));break ;};};};if _dcdd .X ()==nil {_dcdd =_daa ._ddfe .AddDefinedName (_fcgc ,_daa .RangeReference (rangeRef ));};for _bac ,_abgd :=range _daa ._ddfe ._cadcc {if _abgd ==_daa ._bdec {_dcdd .SetLocalSheetID (uint32 (_bac ));};};};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_gebf *_cdcga .CT_SheetView };

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_ba StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _ba ._gbf .Dxfs ==nil {_ba ._gbf .Dxfs =_cdcga .NewCT_Dxfs ();};_efb :=_cdcga .NewCT_Dxf ();_ba ._gbf .Dxfs .Dxf =append (_ba ._gbf .Dxfs .Dxf ,_efb );_ba ._gbf .Dxfs .CountAttr =_ebgf .Uint32 (uint32 (len (_ba ._gbf .Dxfs .Dxf )));return DifferentialStyle {_efb ,_ba ._ggf ,_ba ._gbf .Dxfs };};

// Author returns the author of the comment
func (_efcd Comment )Author ()string {if _efcd ._gfdd .AuthorIdAttr < uint32 (len (_efcd ._ecgea .Authors .Author )){return _efcd ._ecgea .Authors .Author [_efcd ._gfdd .AuthorIdAttr ];};return "";};

// SetOperator sets the operator for the rule.
func (_eddc ConditionalFormattingRule )SetOperator (t _cdcga .ST_ConditionalFormattingOperator ){_eddc ._dbeb .OperatorAttr =t ;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_dbdcb AbsoluteAnchor )SetColOffset (m _ecf .Distance ){_dbdcb ._beb .Pos .XAttr .ST_CoordinateUnqualified =_ebgf .Int64 (int64 (m /_ecf .EMU ));};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bgfeg Row )RowNumber ()uint32 {if _bgfeg ._aadg .RAttr !=nil {return *_bgfeg ._aadg .RAttr ;};return 0;};

// SetFont applies a font to a cell style.  The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_babd CellStyle )SetFont (f Font ){_babd ._fceg .FontIdAttr =_ebgf .Uint32 (f .Index ());_babd ._fceg .ApplyFontAttr =_ebgf .Bool (true );};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_ebff *Sheet )RemoveColumn (column string )error {_gdce ,_ce :=_ebff .getAllCellsInFormulaArraysForColumn ();if _ce !=nil {return _ce ;};_bbeb :=_eedc .ColumnToIndex (column );for _ ,_fdg :=range _ebff .Rows (){_gaagb :=_fbge .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_fdg .X ().RAttr );if _ ,_cae :=_gdce [_gaagb ];_cae {return nil ;};};for _ ,_cc :=range _ebff .Rows (){_afab :=_cc ._aadg .C ;for _bcge ,_deg :=range _afab {_ef ,_fab :=_eedc .ParseCellReference (*_deg .RAttr );if _fab !=nil {return _fab ;};if _ef .ColumnIdx ==_bbeb {_cc ._aadg .C =append (_afab [:_bcge ],_ebff .slideCellsLeft (_afab [_bcge +1:])...);break ;}else if _ef .ColumnIdx > _bbeb {_cc ._aadg .C =append (_afab [:_bcge ],_ebff .slideCellsLeft (_afab [_bcge :])...);break ;};};};_ce =_ebff .updateAfterRemove (_bbeb ,_feea .UpdateActionRemoveColumn );if _ce !=nil {return _ce ;};_ce =_ebff .removeColumnFromNamedRanges (_bbeb );if _ce !=nil {return _ce ;};_ce =_ebff .removeColumnFromMergedCells (_bbeb );if _ce !=nil {return _ce ;};for _ ,_eccc :=range _ebff ._ddfe .Sheets (){_eccc .RecalculateFormulas ();};return nil ;};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_fcfg DataValidationCompare )SetValue (v string ){_fcfg ._aaag .Formula1 =&v };func (_afdd Fills )AddFill ()Fill {_fcca :=_cdcga .NewCT_Fill ();_afdd ._cecab .Fill =append (_afdd ._cecab .Fill ,_fcca );_afdd ._cecab .CountAttr =_ebgf .Uint32 (uint32 (len (_afdd ._cecab .Fill )));return Fill {_fcca ,_afdd ._cecab };};

// SetType sets the type of the rule.
func (_dabbc ConditionalFormattingRule )SetType (t _cdcga .ST_CfType ){_dabbc ._dbeb .TypeAttr =t };

// SetUnderline controls if the run is underlined.
func (_babac RichTextRun )SetUnderline (u _cdcga .ST_UnderlineValues ){_babac .ensureRpr ();_babac ._afcg .RPr .U =_cdcga .NewCT_UnderlineProperty ();_babac ._afcg .RPr .U .ValAttr =u ;};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_cce SheetView )SetZoom (pct uint32 ){_cce ._gebf .ZoomScaleAttr =&pct };

// SetTopLeft sets the top left visible cell after the split.
func (_gfcg SheetView )SetTopLeft (cellRef string ){_gfcg .ensurePane ();_gfcg ._gebf .Pane .TopLeftCellAttr =&cellRef ;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_bgf *Workbook )SetActiveSheet (s Sheet ){for _daag ,_caac :=range _bgf ._cadcc {if s ._bdec ==_caac {_bgf .SetActiveSheetIndex (uint32 (_daag ));};};};

// GetFilename returns the filename of the context's workbook.
func (_bdbb *evalContext )GetFilename ()string {return _bdbb ._abcf ._ddfe .GetFilename ()};

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_fag *Sheet )Column (idx uint32 )Column {for _ ,_bgcb :=range _fag ._bdec .Cols {for _ ,_bcdb :=range _bgcb .Col {if idx >=_bcdb .MinAttr &&idx <=_bcdb .MaxAttr {return Column {_bcdb };};};};var _cfc *_cdcga .CT_Cols ;if len (_fag ._bdec .Cols )==0{_cfc =_cdcga .NewCT_Cols ();_fag ._bdec .Cols =append (_fag ._bdec .Cols ,_cfc );}else {_cfc =_fag ._bdec .Cols [0];};_dcd :=_cdcga .NewCT_Col ();_dcd .MinAttr =idx ;_dcd .MaxAttr =idx ;_cfc .Col =append (_cfc .Col ,_dcd );return Column {_dcd };};

// Reference returns the table reference (the cells within the table)
func (_daebb Table )Reference ()string {return _daebb ._cgdf .RefAttr };

// Wrapped returns true if the cell will wrap text.
func (_degfd CellStyle )Wrapped ()bool {if _degfd ._fceg .Alignment ==nil {return false ;};if _degfd ._fceg .Alignment .WrapTextAttr ==nil {return false ;};return *_degfd ._fceg .Alignment .WrapTextAttr ;};func (_afce Sheet )validateSheetNames ()error {if len (_afce .Name ())> 31{return _fbge .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_afce .Name (),len (_afce .Name ()));};return nil ;};

// New constructs a new workbook.
func New ()*Workbook {_abde :=&Workbook {};_abde ._cbc =_cdcga .NewWorkbook ();_abde .AppProperties =_fdfe .NewAppProperties ();_abde .CoreProperties =_fdfe .NewCoreProperties ();_abde .StyleSheet =NewStyleSheet (_abde );_abde .Rels =_fdfe .NewRelationships ();_abde ._fdeb =_fdfe .NewRelationships ();_abde .Rels .AddRelationship (_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,"",_ebgf .ExtendedPropertiesType ,0),_ebgf .ExtendedPropertiesType );_abde .Rels .AddRelationship (_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,"",_ebgf .CorePropertiesType ,0),_ebgf .CorePropertiesType );_abde .Rels .AddRelationship (_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,"",_ebgf .OfficeDocumentType ,0),_ebgf .OfficeDocumentType );_abde ._fdeb .AddRelationship (_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .OfficeDocumentType ,_ebgf .StylesType ,0),_ebgf .StylesType );_abde .ContentTypes =_fdfe .NewContentTypes ();_abde .ContentTypes .AddDefault ("\u0076\u006d\u006c",_ebgf .VMLDrawingContentType );_abde .ContentTypes .AddOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_abde .ContentTypes .AddOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .StylesType ,0),_ebgf .SMLStyleSheetContentType );_abde .SharedStrings =NewSharedStrings ();_abde .ContentTypes .AddOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .SharedStringsType ,0),_ebgf .SharedStringsContentType );_abde ._fdeb .AddRelationship (_ebgf .RelativeFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .OfficeDocumentType ,_ebgf .SharedStringsType ,0),_ebgf .SharedStringsType );return _abde ;};

// SetWidthCells is a no-op.
func (_ddc OneCellAnchor )SetWidthCells (int32 ){};

// SheetCount returns the number of sheets in the workbook.
func (_fdd Workbook )SheetCount ()int {return len (_fdd ._cadcc )};func (_cddd StandardFormat )String ()string {switch {case 0<=_cddd &&_cddd <=4:return _fgefe [_dcfb [_cddd ]:_dcfb [_cddd +1]];case 9<=_cddd &&_cddd <=22:_cddd -=9;return _adde [_ffbf [_cddd ]:_ffbf [_cddd +1]];case 37<=_cddd &&_cddd <=40:_cddd -=37;return _gbgf [_gec [_cddd ]:_gec [_cddd +1]];case 45<=_cddd &&_cddd <=49:_cddd -=45;return _cffc [_dcg [_cddd ]:_dcg [_cddd +1]];default:return _fbge .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_cddd );};};

// SetMaxLength sets the maximum bar length in percent.
func (_fagf DataBarScale )SetMaxLength (l uint32 ){_fagf ._eefg .MaxLengthAttr =_ebgf .Uint32 (l )};func (_fffd Border )SetBottom (style _cdcga .ST_BorderStyle ,c _fdfa .Color ){if _fffd ._gaad .Bottom ==nil {_fffd ._gaad .Bottom =_cdcga .NewCT_BorderPr ();};_fffd ._gaad .Bottom .Color =_cdcga .NewCT_Color ();_fffd ._gaad .Bottom .Color .RgbAttr =c .AsRGBAString ();_fffd ._gaad .Bottom .StyleAttr =style ;};func (_bfc Fill )Index ()uint32 {if _bfc ._ggc ==nil {return 0;};for _bdfa ,_ggadf :=range _bfc ._ggc .Fill {if _bfc ._cda ==_ggadf {return uint32 (_bdfa );};};return 0;};

// SetCol set the column of the cell marker.
func (_adee CellMarker )SetCol (col int32 ){_adee ._cca .Col =col };

// AnchorType is the type of anchor.
type AnchorType byte ;

// X returns the inner wrapped XML type.
func (_fg MergedCell )X ()*_cdcga .CT_MergeCell {return _fg ._afadc };

// Sheets returns the sheets from the workbook.
func (_abed *Workbook )Sheets ()[]Sheet {_ecg :=[]Sheet {};for _cafc ,_ebc :=range _abed ._cadcc {_dfbca :=_abed ._cbc .Sheets .Sheet [_cafc ];_bbae :=Sheet {_abed ,_dfbca ,_ebc };_ecg =append (_ecg ,_bbae );};return _ecg ;};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_fgce *evalContext )IsDBCS ()bool {_faad :=_fgce ._abcf ._ddfe .CoreProperties .X ().Language ;if _faad ==nil {return false ;};_gdac :=string (_faad .Data );for _ ,_abf :=range _ccgb {if _gdac ==_abf {return true ;};};return false ;};

// SetPattern sets the pattern of the fill.
func (_ad PatternFill )SetPattern (p _cdcga .ST_PatternType ){_ad ._ga .PatternTypeAttr =p };

// SaveToFile writes the workbook out to a file.
func (_aad *Workbook )SaveToFile (path string )error {_fcff ,_caae :=_cddc .Create (path );if _caae !=nil {return _caae ;};defer _fcff .Close ();return _aad .Save (_fcff );};const _dccf ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";func (_abea StyleSheet )GetCellStyle (id uint32 )CellStyle {for _gcg ,_efda :=range _abea ._gbf .CellXfs .Xf {if uint32 (_gcg )==id {return CellStyle {_abea ._ggf ,_efda ,_abea ._gbf .CellXfs };};};return CellStyle {};};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_daca Drawing )AddImage (img _fdfe .ImageRef ,at AnchorType )Anchor {_agcgf :=0;for _cbfd ,_fgef :=range _daca ._gba .Images {if _fgef ==img {_agcgf =_cbfd +1;break ;};};var _dafa string ;for _adce ,_ggbc :=range _daca ._gba ._fac {if _ggbc ==_daca ._fbfab {_daagb :=_fbge .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_agcgf ,img .Format ());_ddfeg :=_daca ._gba ._gabb [_adce ].AddRelationship (_daagb ,_ebgf .ImageType );_dafa =_ddfeg .ID ();break ;};};var _efdg Anchor ;var _bbd *_gga .CT_Picture ;switch at {case AnchorTypeAbsolute :_ebf :=_ffbde ();_daca ._fbfab .EG_Anchor =append (_daca ._fbfab .EG_Anchor ,&_gga .EG_Anchor {AbsoluteAnchor :_ebf });_ebf .Choice =&_gga .EG_ObjectChoicesChoice {};_ebf .Choice .Pic =_gga .NewCT_Picture ();_bbd =_ebf .Choice .Pic ;_efdg =AbsoluteAnchor {_ebf };case AnchorTypeOneCell :_gfef :=_fcagg ();_daca ._fbfab .EG_Anchor =append (_daca ._fbfab .EG_Anchor ,&_gga .EG_Anchor {OneCellAnchor :_gfef });_gfef .Choice =&_gga .EG_ObjectChoicesChoice {};_gfef .Choice .Pic =_gga .NewCT_Picture ();_bbd =_gfef .Choice .Pic ;_efdg =OneCellAnchor {_gfef };case AnchorTypeTwoCell :_dcfc :=_egecb ();_daca ._fbfab .EG_Anchor =append (_daca ._fbfab .EG_Anchor ,&_gga .EG_Anchor {TwoCellAnchor :_dcfc });_dcfc .Choice =&_gga .EG_ObjectChoicesChoice {};_dcfc .Choice .Pic =_gga .NewCT_Picture ();_bbd =_dcfc .Choice .Pic ;_efdg =TwoCellAnchor {_dcfc };};_bbd .NvPicPr .CNvPr .IdAttr =uint32 (len (_daca ._fbfab .EG_Anchor ));_bbd .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_bbd .BlipFill .Blip =_bebb .NewCT_Blip ();_bbd .BlipFill .Blip .EmbedAttr =_ebgf .String (_dafa );_bbd .BlipFill .Stretch =_bebb .NewCT_StretchInfoProperties ();_bbd .SpPr =_bebb .NewCT_ShapeProperties ();_bbd .SpPr .Xfrm =_bebb .NewCT_Transform2D ();_bbd .SpPr .Xfrm .Off =_bebb .NewCT_Point2D ();_bbd .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_ebgf .Int64 (0);_bbd .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_ebgf .Int64 (0);_bbd .SpPr .Xfrm .Ext =_bebb .NewCT_PositiveSize2D ();_bbd .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ecf .Pixel72 )/_ecf .EMU );_bbd .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ecf .Pixel72 )/_ecf .EMU );_bbd .SpPr .PrstGeom =_bebb .NewCT_PresetGeometry2D ();_bbd .SpPr .PrstGeom .PrstAttr =_bebb .ST_ShapeTypeRect ;_bbd .SpPr .Ln =_bebb .NewCT_LineProperties ();_bbd .SpPr .Ln .NoFill =_bebb .NewCT_NoFillProperties ();return _efdg ;};

// SetHidden hides or unhides the row
func (_bbed Row )SetHidden (hidden bool ){if !hidden {_bbed ._aadg .HiddenAttr =nil ;}else {_bbed ._aadg .HiddenAttr =_ebgf .Bool (true );};};

// Index returns the index of the differential style.
func (_cdd DifferentialStyle )Index ()uint32 {for _cefe ,_gd :=range _cdd ._fgbf .Dxf {if _cdd ._bcaa ==_gd {return uint32 (_cefe );};};return 0;};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_gcfb *Workbook )Uses1904Dates ()bool {if _gcfb ._cbc .WorkbookPr ==nil ||_gcfb ._cbc .WorkbookPr .Date1904Attr ==nil {return false ;};return *_gcfb ._cbc .WorkbookPr .Date1904Attr ;};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_bfcg Sheet )ValidateWithPath (path string )error {return _bfcg ._bdec .ValidateWithPath (path )};func (_eege Font )SetItalic (b bool ){if b {_eege ._cfed .I =[]*_cdcga .CT_BooleanProperty {{}};}else {_eege ._cfed .I =nil ;};};

// Protection allows control over the workbook protections.
func (_gfag *Workbook )Protection ()WorkbookProtection {if _gfag ._cbc .WorkbookProtection ==nil {_gfag ._cbc .WorkbookProtection =_cdcga .NewCT_WorkbookProtection ();};return WorkbookProtection {_gfag ._cbc .WorkbookProtection };};func _fcagg ()*_gga .CT_OneCellAnchor {_bff :=_gga .NewCT_OneCellAnchor ();return _bff };func (_ebffa Font )SetBold (b bool ){if b {_ebffa ._cfed .B =[]*_cdcga .CT_BooleanProperty {{}};}else {_ebffa ._cfed .B =nil ;};};func _ffbde ()*_gga .CT_AbsoluteAnchor {_ffdbf :=_gga .NewCT_AbsoluteAnchor ();return _ffdbf };

// IsWindowLocked returns whether the workbook windows are locked.
func (_gcb WorkbookProtection )IsWindowLocked ()bool {return _gcb ._caaf .LockWindowsAttr !=nil &&*_gcb ._caaf .LockWindowsAttr ;};func (_daab PatternFill )SetBgColor (c _fdfa .Color ){_daab ._ga .BgColor =_cdcga .NewCT_Color ();_daab ._ga .BgColor .RgbAttr =c .AsRGBAString ();};

// SetHyperlink sets a hyperlink on a cell.
func (_cedb Cell )SetHyperlink (hl _fdfe .Hyperlink ){_bgfb :=_cedb ._adgg ._bdec ;if _bgfb .Hyperlinks ==nil {_bgfb .Hyperlinks =_cdcga .NewCT_Hyperlinks ();};_cfgd :=_fdfe .Relationship (hl );_fbf :=_cdcga .NewCT_Hyperlink ();_fbf .RefAttr =_cedb .Reference ();_fbf .IdAttr =_ebgf .String (_cfgd .ID ());_bgfb .Hyperlinks .Hyperlink =append (_bgfb .Hyperlinks .Hyperlink ,_fbf );};type Fills struct{_cecab *_cdcga .CT_Fills };

// GetWidth returns a worksheet's column width.
func (_ecdd *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_dgcf :=range _ecdd ._abcf .X ().Cols [0].Col {if int (_dgcf .MinAttr )<=colIdx &&colIdx <=int (_dgcf .MaxAttr ){return float64 (int (*_dgcf .WidthAttr ));};};return 0;};

// SetStyle sets the cell style for an entire column.
func (_egb Column )SetStyle (cs CellStyle ){_egb ._fade .StyleAttr =_ebgf .Uint32 (cs .Index ())};

// RemoveDefinedName removes an existing defined name.
func (_e *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _gebb .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _dgd ,_cac :=range _e ._cbc .DefinedNames .DefinedName {if _cac ==dn .X (){copy (_e ._cbc .DefinedNames .DefinedName [_dgd :],_e ._cbc .DefinedNames .DefinedName [_dgd +1:]);_e ._cbc .DefinedNames .DefinedName [len (_e ._cbc .DefinedNames .DefinedName )-1]=nil ;_e ._cbc .DefinedNames .DefinedName =_e ._cbc .DefinedNames .DefinedName [:len (_e ._cbc .DefinedNames .DefinedName )-1];return nil ;};};return _gebb .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// CellMarker represents a cell position
type CellMarker struct{_cca *_gga .CT_Marker };

// Tables returns a slice of all defined tables in the workbook.
func (_cgc *Workbook )Tables ()[]Table {if _cgc ._gca ==nil {return nil ;};_fbbb :=[]Table {};for _ ,_bed :=range _cgc ._gca {_fbbb =append (_fbbb ,Table {_bed });};return _fbbb ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_dc *Workbook )SetActiveSheetIndex (idx uint32 ){if _dc ._cbc .BookViews ==nil {_dc ._cbc .BookViews =_cdcga .NewCT_BookViews ();};if len (_dc ._cbc .BookViews .WorkbookView )==0{_dc ._cbc .BookViews .WorkbookView =append (_dc ._cbc .BookViews .WorkbookView ,_cdcga .NewCT_BookView ());};_dc ._cbc .BookViews .WorkbookView [0].ActiveTabAttr =_ebgf .Uint32 (idx );};

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// X returns the inner wrapped XML type.
func (_cffe ConditionalFormattingRule )X ()*_cdcga .CT_CfRule {return _cffe ._dbeb };

// SetHeight sets the row height in points.
func (_ca Row )SetHeight (d _ecf .Distance ){_ca ._aadg .HtAttr =_ebgf .Float64 (float64 (d ));_ca ._aadg .CustomHeightAttr =_ebgf .Bool (true );};

// SetWrapped configures the cell to wrap text.
func (_agff CellStyle )SetWrapped (b bool ){if _agff ._fceg .Alignment ==nil {_agff ._fceg .Alignment =_cdcga .NewCT_CellAlignment ();};if !b {_agff ._fceg .Alignment .WrapTextAttr =nil ;}else {_agff ._fceg .Alignment .WrapTextAttr =_ebgf .Bool (true );_agff ._fceg .ApplyAlignmentAttr =_ebgf .Bool (true );};};

// GetOrCreateCustomProperties returns the custom properties of the document (and if they not exist yet, creating them first)
func (_fd *Workbook )GetOrCreateCustomProperties ()_fdfe .CustomProperties {if _fd .CustomProperties .X ()==nil {_fd .createCustomProperties ();};return _fd .CustomProperties ;};const (DVCompareTypeWholeNumber =DVCompareType (_cdcga .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_cdcga .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_cdcga .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_cdcga .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_cdcga .ST_DataValidationTypeTextLength ););

// SetWidth sets the width of the anchored object.
func (_dda AbsoluteAnchor )SetWidth (w _ecf .Distance ){_dda ._beb .Ext .CxAttr =int64 (w /_ecf .EMU )};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_bb *Sheet )Cell (cellRef string )Cell {_daef ,_bcf :=_eedc .ParseCellReference (cellRef );if _bcf !=nil {_ebgf .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_bcf );return _bb .AddRow ().AddCell ();};return _bb .Row (_daef .RowIdx ).Cell (_daef .Column );};

// IsBool returns true if the cell boolean value.
func (_agcf *evalContext )IsBool (cellRef string )bool {return _agcf ._abcf .Cell (cellRef ).IsBool ()};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_gbee *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_ecbc :=range _gbee .Sheets (){if _ecbc .Name ()==name {return _ecbc ,nil ;};};return Sheet {},ErrorNotFound ;};func (_bgg CellStyle )SetShrinkToFit (b bool ){if _bgg ._fceg .Alignment ==nil {_bgg ._fceg .Alignment =_cdcga .NewCT_CellAlignment ();};_bgg ._fceg .ApplyAlignmentAttr =_ebgf .Bool (true );if !b {_bgg ._fceg .Alignment .ShrinkToFitAttr =nil ;}else {_bgg ._fceg .Alignment .ShrinkToFitAttr =_ebgf .Bool (b );};};

// AddMergedCells merges cells within a sheet.
func (_fegb *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _fegb ._bdec .MergeCells ==nil {_fegb ._bdec .MergeCells =_cdcga .NewCT_MergeCells ();};_ebb :=_cdcga .NewCT_MergeCell ();_ebb .RefAttr =_fbge .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_fegb ._bdec .MergeCells .MergeCell =append (_fegb ._bdec .MergeCells .MergeCell ,_ebb );_fegb ._bdec .MergeCells .CountAttr =_ebgf .Uint32 (uint32 (len (_fegb ._bdec .MergeCells .MergeCell )));return MergedCell {_fegb ._ddfe ,_fegb ,_ebb };};func (_ecbb *Sheet )removeColumnFromMergedCells (_decc uint32 )error {if _ecbb ._bdec .MergeCells ==nil ||_ecbb ._bdec .MergeCells .MergeCell ==nil {return nil ;};_bfea :=[]*_cdcga .CT_MergeCell {};for _ ,_acc :=range _ecbb .MergedCells (){_egga :=_cfgf (_acc .Reference (),_decc ,true );if _egga !=""{_acc .SetReference (_egga );_bfea =append (_bfea ,_acc .X ());};};_ecbb ._bdec .MergeCells .MergeCell =_bfea ;return nil ;};func (_gcagg StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_gbe :=range _gcagg ._gbf .NumFmts .NumFmt {if _gbe .NumFmtIdAttr ==id {return NumberFormat {_gcagg ._ggf ,_gbe };};};return NumberFormat {};};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_cafe *_cdcga .CT_Rst };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_dacg *evalContext )LastRow (col string )int {_dbba :=_dacg ._abcf ;_bdeb :=int (_eedc .ColumnToIndex (col ));_abd :=1;for _ ,_ccgf :=range _dbba ._bdec .SheetData .Row {if _ccgf .RAttr !=nil {_feeb :=Row {_dbba ._ddfe ,_dbba ,_ccgf };_acf :=len (_feeb .Cells ());if _acf > _bdeb {_abd =int (_feeb .RowNumber ());};};};return _abd ;};const (DVCompareOpEqual =DVCompareOp (_cdcga .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_cdcga .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_cdcga .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_cdcga .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_cdcga .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_cdcga .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_cdcga .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_cdcga .ST_DataValidationOperatorLessThanOrEqual ););

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_afad Cell )GetFormattedValue ()string {_df :=_afad .getFormat ();switch _afad ._egbf .TAttr {case _cdcga .ST_CellTypeB :_dgfd ,_ :=_afad .GetValueAsBool ();if _dgfd {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _cdcga .ST_CellTypeN :_bdd ,_ :=_afad .GetValueAsNumber ();return _cg .Number (_bdd ,_df );case _cdcga .ST_CellTypeE :if _afad ._egbf .V !=nil {return *_afad ._egbf .V ;};return "";case _cdcga .ST_CellTypeS ,_cdcga .ST_CellTypeInlineStr :return _cg .String (_afad .GetString (),_df );case _cdcga .ST_CellTypeStr :_ab :=_afad .GetString ();if _cg .IsNumber (_ab ){_gbd ,_ :=_dag .ParseFloat (_ab ,64);return _cg .Number (_gbd ,_df );};return _cg .String (_ab ,_df );case _cdcga .ST_CellTypeUnset :fallthrough;default:_cde ,_ :=_afad .GetRawValue ();if len (_cde )==0{return "";};_gdg ,_debf :=_afad .GetValueAsNumber ();if _debf ==nil {return _cg .Number (_gdg ,_df );};return _cg .String (_cde ,_df );};};

// X returns the inner wrapped XML type.
func (_cefb Row )X ()*_cdcga .CT_Row {return _cefb ._aadg };var _ggfa =[...]uint8 {0,18,37};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_fcec TwoCellAnchor )SetWidthCells (w int32 ){_agg :=_fcec .TopLeft ();_bbcf :=_fcec .BottomRight ();_bbcf .SetCol (_agg .Col ()+w );};type SheetProtection struct{_caga *_cdcga .CT_SheetProtection };

// ClearAutoFilter removes the autofilters from the sheet.
func (_ddb *Sheet )ClearAutoFilter (){_ddb ._bdec .AutoFilter =nil ;_aagf :="\u0027"+_ddb .Name ()+"\u0027\u0021";for _ ,_bbaeg :=range _ddb ._ddfe .DefinedNames (){if _bbaeg .Name ()==_fcgc {if _bda .HasPrefix (_bbaeg .Content (),_aagf ){_ddb ._ddfe .RemoveDefinedName (_bbaeg );break ;};};};};func (_afafc *Sheet )addNumberedRowFast (_ddca uint32 )Row {_egbg :=_cdcga .NewCT_Row ();_egbg .RAttr =_ebgf .Uint32 (_ddca );_afafc ._bdec .SheetData .Row =append (_afafc ._bdec .SheetData .Row ,_egbg );return Row {_afafc ._ddfe ,_afafc ,_egbg };};

// SetPriority sets the rule priority
func (_ebd ConditionalFormattingRule )SetPriority (p int32 ){_ebd ._dbeb .PriorityAttr =p };

// Type returns the type of anchor
func (_gac OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// RemoveSheet removes the sheet with the given index from the workbook.
func (_ebfc *Workbook )RemoveSheet (ind int )error {if _ebfc .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_gbbf :=range _ebfc ._fdeb .Relationships (){if _gbbf .ID ()==_ebfc ._cbc .Sheets .Sheet [ind ].IdAttr {_ebfc ._fdeb .Remove (_gbbf );break ;};};_ebfc .ContentTypes .RemoveOverride (_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .WorksheetContentType ,ind +1));copy (_ebfc ._cadcc [ind :],_ebfc ._cadcc [ind +1:]);_ebfc ._cadcc =_ebfc ._cadcc [:len (_ebfc ._cadcc )-1];_geeb :=_ebfc ._cbc .Sheets .Sheet [ind ];copy (_ebfc ._cbc .Sheets .Sheet [ind :],_ebfc ._cbc .Sheets .Sheet [ind +1:]);_ebfc ._cbc .Sheets .Sheet =_ebfc ._cbc .Sheets .Sheet [:len (_ebfc ._cbc .Sheets .Sheet )-1];for _cfcb :=range _ebfc ._cbc .Sheets .Sheet {if _ebfc ._cbc .Sheets .Sheet [_cfcb ].SheetIdAttr > _geeb .SheetIdAttr {_ebfc ._cbc .Sheets .Sheet [_cfcb ].SheetIdAttr --;};};copy (_ebfc ._efdf [ind :],_ebfc ._efdf [ind +1:]);_ebfc ._efdf =_ebfc ._efdf [:len (_ebfc ._efdf )-1];copy (_ebfc ._aec [ind :],_ebfc ._aec [ind +1:]);_ebfc ._aec =_ebfc ._aec [:len (_ebfc ._aec )-1];return nil ;};

// X returns the inner wrapped XML type.
func (_fcde SheetView )X ()*_cdcga .CT_SheetView {return _fcde ._gebf };

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_bfebg *Workbook )RemoveCalcChain (){var _cdc string ;for _ ,_eaag :=range _bfebg ._fdeb .Relationships (){if _eaag .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_cdc ="\u0078\u006c\u002f"+_eaag .Target ();_bfebg ._fdeb .Remove (_eaag );break ;};};if _cdc ==""{return ;};_bfebg .ContentTypes .RemoveOverride (_cdc );for _daba ,_bbdb :=range _bfebg .ExtraFiles {if _bbdb .ZipPath ==_cdc {_bfebg .ExtraFiles [_daba ]=_bfebg .ExtraFiles [len (_bfebg .ExtraFiles )-1];_bfebg .ExtraFiles =_bfebg .ExtraFiles [:len (_bfebg .ExtraFiles )-1];return ;};};};

// BottomRight is a no-op.
func (_dea OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// IsEmpty checks if the cell style contains nothing.
func (_cbfb CellStyle )IsEmpty ()bool {return _cbfb ._beeag ==nil ||_cbfb ._fceg ==nil ||_cbfb ._fgdc ==nil ||_cbfb ._fgdc .Xf ==nil ;};

// SetBorder applies a border to a cell style.  The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_fba CellStyle )SetBorder (b Border ){_fba ._fceg .BorderIdAttr =_ebgf .Uint32 (b .Index ());_fba ._fceg .ApplyBorderAttr =_ebgf .Bool (true );};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_agc Sheet )RangeReference (n string )string {_gddc :=_bda .Split (n ,"\u003a");_aegf ,_ :=_eedc .ParseCellReference (_gddc [0]);_bc :=_fbge .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_aegf .Column ,_aegf .RowIdx );if len (_gddc )==1{return _fbge .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_agc .Name (),_bc );};_aead ,_ :=_eedc .ParseCellReference (_gddc [1]);_cadeb :=_fbge .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_aead .Column ,_aead .RowIdx );return _fbge .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_agc .Name (),_bc ,_cadeb );};

// Col returns the column of the cell marker.
func (_cddg CellMarker )Col ()int32 {return _cddg ._cca .Col };

// SetFill applies a fill to a cell style.  The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_ebdg CellStyle )SetFill (f Fill ){_ebdg ._fceg .FillIdAttr =_ebgf .Uint32 (f .Index ());_ebdg ._fceg .ApplyFillAttr =_ebgf .Bool (true );};

// X returns the inner wrapped XML type.
func (_cadc Comment )X ()*_cdcga .CT_Comment {return _cadc ._gfdd };func (_dd *Sheet )removeColumnFromNamedRanges (_caaag uint32 )error {for _ ,_geec :=range _dd ._ddfe .DefinedNames (){_dcdfa :=_geec .Name ();_ee :=_geec .Content ();_ddga :=_bda .Split (_ee ,"\u0021");if len (_ddga )!=2{return _gebb .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_ee );};_fbdb :=_ddga [0];if _dd .Name ()==_fbdb {_ggff :=_dd ._ddfe .RemoveDefinedName (_geec );if _ggff !=nil {return _ggff ;};_gb :=_cfgf (_ddga [1],_caaag ,true );if _gb !=""{_agce :=_fbdb +"\u0021"+_gb ;_dd ._ddfe .AddDefinedName (_dcdfa ,_agce );};};};_egfe :=0;if _dd ._bdec .TableParts !=nil &&_dd ._bdec .TableParts .TablePart !=nil {_egfe =len (_dd ._bdec .TableParts .TablePart );};if _egfe !=0{_aaaa :=0;for _ ,_bbbb :=range _dd ._ddfe .Sheets (){if _bbbb .Name ()==_dd .Name (){break ;}else {if _bbbb ._bdec .TableParts !=nil &&_bbbb ._bdec .TableParts .TablePart !=nil {_aaaa +=len (_bbbb ._bdec .TableParts .TablePart );};};};_ggbcb :=_dd ._ddfe ._gca [_aaaa :_aaaa +_egfe ];for _bbf ,_abda :=range _ggbcb {_ggd :=_abda ;_ggd .RefAttr =_cfgf (_ggd .RefAttr ,_caaag ,false );_dd ._ddfe ._gca [_aaaa +_bbf ]=_ggd ;};};return nil ;};

// AddRule adds and returns a new rule that can be configured.
func (_ceb ConditionalFormatting )AddRule ()ConditionalFormattingRule {_bdg :=_cdcga .NewCT_CfRule ();_ceb ._ccgdf .CfRule =append (_ceb ._ccgdf .CfRule ,_bdg );_ccfc :=ConditionalFormattingRule {_bdg };_ccfc .InitializeDefaults ();_ccfc .SetPriority (int32 (len (_ceb ._ccgdf .CfRule )+1));return _ccfc ;};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_fgf *Workbook )Epoch ()_afea .Time {if _fgf .Uses1904Dates (){_afea .Date (1904,1,1,0,0,0,0,_afea .UTC );};return _afea .Date (1899,12,30,0,0,0,0,_afea .UTC );};

// GetString retrieves a string from the shared strings table by index.
func (_dffed SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_fbge .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_dffed ._edgb .Si ){return "",_fbge .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_dffed ._edgb .Si ));};_ddf :=_dffed ._edgb .Si [id ];if _ddf .T !=nil {return *_ddf .T ,nil ;};return "",nil ;};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_acd Comment )CellReference ()string {return _acd ._gfdd .RefAttr };

// SetRowOffset sets the row offset of the two cell anchor
func (_dffd TwoCellAnchor )SetRowOffset (m _ecf .Distance ){_ec :=m -_dffd .TopLeft ().RowOffset ();_dffd .TopLeft ().SetRowOffset (m );_dffd .BottomRight ().SetRowOffset (_dffd .BottomRight ().RowOffset ()+_ec );};

// Name returns the sheet name
func (_bcfg Sheet )Name ()string {return _bcfg ._gaag .NameAttr };

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_eeba ConditionalFormattingRule )SetColorScale ()ColorScale {_eeba .clear ();_eeba .SetType (_cdcga .ST_CfTypeColorScale );_eeba ._dbeb .ColorScale =_cdcga .NewCT_ColorScale ();return ColorScale {_eeba ._dbeb .ColorScale };};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_abfe *Sheet )InitialView ()SheetView {if _abfe ._bdec .SheetViews ==nil ||len (_abfe ._bdec .SheetViews .SheetView )==0{return _abfe .AddView ();};return SheetView {_abfe ._bdec .SheetViews .SheetView [0]};};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_caec PatternFill )SetFgColor (c _fdfa .Color ){_caec ._ga .FgColor =_cdcga .NewCT_Color ();_caec ._ga .FgColor .RgbAttr =c .AsRGBAString ();};func (_bggf *evalContext )Sheet (name string )_aeaf .Context {for _ ,_dabe :=range _bggf ._abcf ._ddfe .Sheets (){if _dabe .Name ()==name {return _dabe .FormulaContext ();};};return _aeaf .InvalidReferenceContext ;};

// Comment is a single comment within a sheet.
type Comment struct{_gdgb *Workbook ;_gfdd *_cdcga .CT_Comment ;_ecgea *_cdcga .Comments ;};func (_feg *Workbook )createCustomProperties (){_feg .CustomProperties =_fdfe .NewCustomProperties ();_feg .addCustomRelationships ();};

// ClearProtection clears all workbook protections.
func (_dbfcg *Workbook )ClearProtection (){_dbfcg ._cbc .WorkbookProtection =nil };

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_baec *Sheet )FormulaContext ()_aeaf .Context {return _egbc (_baec )};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_gagg SheetView )SetState (st _cdcga .ST_PaneState ){_gagg .ensurePane ();_gagg ._gebf .Pane .StateAttr =st ;};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_cf *evalContext )LastColumn (rowFrom ,rowTo int )string {_gdaa :=_cf ._abcf ;_gfdc :=1;for _ffbg :=rowFrom ;_ffbg <=rowTo ;_ffbg ++{_cabdc :=len (_gdaa .Row (uint32 (_ffbg )).Cells ());if _cabdc > _gfdc {_gfdc =_cabdc ;};};return _eedc .IndexToColumn (uint32 (_gfdc -1));};func (_dfaeb *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _dfaeb .getAllCellsInFormulaArrays (false );};func _eeac (_ecb _afea .Time )_afea .Time {_ecb =_ecb .Local ();return _afea .Date (_ecb .Year (),_ecb .Month (),_ecb .Day (),_ecb .Hour (),_ecb .Minute (),_ecb .Second (),_ecb .Nanosecond (),_afea .UTC );};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_gebg Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _gda ,_dceb Cell ;for _ ,_fgaa :=range lhs .Cells (){_ecfbe ,_ :=_eedc .ParseCellReference (_fgaa .Reference ());if _ecfbe .Column ==column {_gda =_fgaa ;break ;};};for _ ,_aaa :=range rhs .Cells (){_cbg ,_ :=_eedc .ParseCellReference (_aaa .Reference ());if _cbg .Column ==column {_dceb =_aaa ;break ;};};return _gebg .LessCells (_gda ,_dceb );};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_cga Cell )GetString ()string {switch _cga ._egbf .TAttr {case _cdcga .ST_CellTypeInlineStr :if _cga ._egbf .Is !=nil &&_cga ._egbf .Is .T !=nil {return *_cga ._egbf .Is .T ;};if _cga ._egbf .V !=nil {return *_cga ._egbf .V ;};case _cdcga .ST_CellTypeS :if _cga ._egbf .V ==nil {return "";};_cgbe ,_fdfg :=_dag .Atoi (*_cga ._egbf .V );if _fdfg !=nil {return "";};_adgd ,_fdfg :=_cga ._dcdcd .SharedStrings .GetString (_cgbe );if _fdfg !=nil {return "";};return _adgd ;};if _cga ._egbf .V ==nil {return "";};return *_cga ._egbf .V ;};func (_cdb Sheet )validateMergedCells ()error {_dddg :=map[uint64 ]struct{}{};for _ ,_egeg :=range _cdb .MergedCells (){_ebcf ,_eage ,_agd :=_eedc .ParseRangeReference (_egeg .Reference ());if _agd !=nil {return _fbge .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_cdb .Name (),_egeg .Reference ());};for _gfge :=_ebcf .RowIdx ;_gfge <=_eage .RowIdx ;_gfge ++{for _gefc :=_ebcf .ColumnIdx ;_gefc <=_eage .ColumnIdx ;_gefc ++{_gbg :=uint64 (_gfge )<<32|uint64 (_gefc );if _ ,_dbdc :=_dddg [_gbg ];_dbdc {return _fbge .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_cdb .Name ());};_dddg [_gbg ]=struct{}{};};};};return nil ;};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_ccgdf *_cdcga .CT_ConditionalFormatting ;};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_gde *_cdcga .CT_DataValidation };const (_fgefe ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_adde ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_gbgf ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_cffc ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);func (_bbde *Sheet )setList (_ageg string ,_dcbc _aeaf .Result )error {_fcdeg ,_dbad :=_eedc .ParseCellReference (_ageg );if _dbad !=nil {return _dbad ;};_fbafa :=_bbde .Row (_fcdeg .RowIdx );for _adgdc ,_aafd :=range _dcbc .ValueList {_cebf :=_fbafa .Cell (_eedc .IndexToColumn (_fcdeg .ColumnIdx +uint32 (_adgdc )));if _aafd .Type !=_aeaf .ResultTypeEmpty {if _aafd .IsBoolean {_cebf .SetBool (_aafd .ValueNumber !=0);}else {_cebf .SetCachedFormulaResult (_aafd .String ());};};};return nil ;};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_ddae *Sheet )RemoveMergedCell (mc MergedCell ){for _fgec ,_gfdf :=range _ddae ._bdec .MergeCells .MergeCell {if _gfdf ==mc .X (){copy (_ddae ._bdec .MergeCells .MergeCell [_fgec :],_ddae ._bdec .MergeCells .MergeCell [_fgec +1:]);_ddae ._bdec .MergeCells .MergeCell [len (_ddae ._bdec .MergeCells .MergeCell )-1]=nil ;_ddae ._bdec .MergeCells .MergeCell =_ddae ._bdec .MergeCells .MergeCell [:len (_ddae ._bdec .MergeCells .MergeCell )-1];};};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_gcfc *Workbook )GetFilename ()string {return _gcfc ._cefcc };

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_eafd CellStyle )SetNumberFormatStandard (s StandardFormat ){_eafd ._fceg .NumFmtIdAttr =_ebgf .Uint32 (uint32 (s ));_eafd ._fceg .ApplyNumberFormatAttr =_ebgf .Bool (true );};

// RowOffset returns the offset from the row cell.
func (_efcc CellMarker )RowOffset ()_ecf .Distance {if _efcc ._cca .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ecf .Distance (float64 (*_efcc ._cca .RowOff .ST_CoordinateUnqualified )*_ecf .EMU );};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_fcfd StyleSheet )Fills ()Fills {return Fills {_fcfd ._gbf .Fills }};func (_edff DataValidationCompare )SetValue2 (v string ){_edff ._aaag .Formula2 =&v };

// GetFormat sets the number format code.
func (_ada NumberFormat )GetFormat ()string {return _ada ._beeg .FormatCodeAttr };

// X returns the inner wrapped XML type.
func (_eab SheetProtection )X ()*_cdcga .CT_SheetProtection {return _eab ._caga };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_gba *Workbook ;_fbfab *_gga .WsDr ;};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_cdag Comment )SetAuthor (author string ){_cdag ._gfdd .AuthorIdAttr =Comments {_cdag ._gdgb ,_cdag ._ecgea }.getOrCreateAuthor (author );};func (_efdgd RichTextRun )ensureRpr (){if _efdgd ._afcg .RPr ==nil {_efdgd ._afcg .RPr =_cdcga .NewCT_RPrElt ();};};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_geffg *Sheet )ClearSheetViews (){_geffg ._bdec .SheetViews =nil };

// Row returns the row of the cell marker.
func (_gfgd CellMarker )Row ()int32 {return _gfgd ._cca .Row };

// SetXSplit sets the column split point
func (_ced SheetView )SetXSplit (v float64 ){_ced .ensurePane ();_ced ._gebf .Pane .XSplitAttr =_ebgf .Float64 (v );};

// SetHidden marks the defined name as hidden.
func (_agf DefinedName )SetLocalSheetID (id uint32 ){_agf ._bcee .LocalSheetIdAttr =_ebgf .Uint32 (id )};

// ClearProtection removes any protections applied to teh sheet.
func (_fffa *Sheet )ClearProtection (){_fffa ._bdec .SheetProtection =nil };

// AddBorder creates a new empty border that can be applied to a cell style.
func (_edc StyleSheet )AddBorder ()Border {_bfa :=_cdcga .NewCT_Border ();_edc ._gbf .Borders .Border =append (_edc ._gbf .Borders .Border ,_bfa );_edc ._gbf .Borders .CountAttr =_ebgf .Uint32 (uint32 (len (_edc ._gbf .Borders .Border )));return Border {_bfa ,_edc ._gbf .Borders };};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_dbgga Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_dbgga .SetNumber (v );_dbgga .SetStyle (_dbgga ._dcdcd .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_bcee *_cdcga .CT_DefinedName };var _aae =_ebgf .AbsoluteFilename (_ebgf .DocTypeSpreadsheet ,_ebgf .SharedStringsType ,0);

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_eega *Sheet )AddRow ()Row {_ggb :=uint32 (0);_bcag :=uint32 (len (_eega ._bdec .SheetData .Row ));if _bcag > 0&&_eega ._bdec .SheetData .Row [_bcag -1].RAttr !=nil &&*_eega ._bdec .SheetData .Row [_bcag -1].RAttr ==_bcag {return _eega .addNumberedRowFast (_bcag +1);};for _ ,_bca :=range _eega ._bdec .SheetData .Row {if _bca .RAttr !=nil &&*_bca .RAttr > _ggb {_ggb =*_bca .RAttr ;};};return _eega .AddNumberedRow (_ggb +1);};

// IconScale maps values to icons.
type IconScale struct{_gafc *_cdcga .CT_IconSet };

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_aeec Cell )SetStyle (cs CellStyle ){_aeec .SetStyleIndex (cs .Index ())};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ddbd Row )AddNamedCell (col string )Cell {_dbfce :=_cdcga .NewCT_Cell ();_dbfce .RAttr =_ebgf .Stringf ("\u0025\u0073\u0025\u0064",col ,_ddbd .RowNumber ());_cgde :=-1;_cadec :=_eedc .ColumnToIndex (col );for _cabd ,_ccda :=range _ddbd ._aadg .C {_ecab ,_fcag :=_eedc .ParseCellReference (*_ccda .RAttr );if _fcag !=nil {return Cell {};};if _cadec < _ecab .ColumnIdx {_cgde =_cabd ;break ;};};if _cgde ==-1{_ddbd ._aadg .C =append (_ddbd ._aadg .C ,_dbfce );}else {_ddbd ._aadg .C =append (_ddbd ._aadg .C [:_cgde ],append ([]*_cdcga .CT_Cell {_dbfce },_ddbd ._aadg .C [_cgde :]...)...);};return Cell {_ddbd ._abdb ,_ddbd ._ffdf ,_ddbd ._aadg ,_dbfce };};

// MoveTo repositions the anchor without changing the objects size.
func (_ddaa TwoCellAnchor )MoveTo (col ,row int32 ){_d :=_ddaa .TopLeft ();_ddaag :=_ddaa .BottomRight ();_ede :=_ddaag .Col ()-_d .Col ();_ceca :=_ddaag .Row ()-_d .Row ();_d .SetCol (col );_d .SetRow (row );_ddaag .SetCol (col +_ede );_ddaag .SetRow (row +_ceca );};func (_gbff *evalContext )Cell (ref string ,ev _aeaf .Evaluator )_aeaf .Result {if !_cfcd (ref ){return _aeaf .MakeErrorResultType (_aeaf .ErrorTypeName ,"");};_fdba :=_gbff ._abcf .Name ()+"\u0021"+ref ;if _abc ,_aadd :=ev .GetFromCache (_fdba );_aadd {return _abc ;};_eddd ,_fgac :=_eedc .ParseCellReference (ref );if _fgac !=nil {return _aeaf .MakeErrorResult (_fbge .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_fgac ));};if _gbff ._fcdd !=0&&!_eddd .AbsoluteColumn {_eddd .ColumnIdx +=_gbff ._fcdd ;_eddd .Column =_eedc .IndexToColumn (_eddd .ColumnIdx );};if _gbff ._faee !=0&&!_eddd .AbsoluteRow {_eddd .RowIdx +=_gbff ._faee ;};_efe :=_gbff ._abcf .Cell (_eddd .String ());if _efe .HasFormula (){if _ ,_ecbd :=_gbff ._bgbd [ref ];_ecbd {return _aeaf .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_gbff ._bgbd [ref ]=struct{}{};_ceee :=ev .Eval (_gbff ,_efe .GetFormula ());delete (_gbff ._bgbd ,ref );ev .SetCache (_fdba ,_ceee );return _ceee ;};if _efe .IsEmpty (){_ddff :=_aeaf .MakeEmptyResult ();ev .SetCache (_fdba ,_ddff );return _ddff ;}else if _efe .IsNumber (){_gabf ,_ :=_efe .GetValueAsNumber ();_bggb :=_aeaf .MakeNumberResult (_gabf );ev .SetCache (_fdba ,_bggb );return _bggb ;}else if _efe .IsBool (){_efec ,_ :=_efe .GetValueAsBool ();_bcgc :=_aeaf .MakeBoolResult (_efec );ev .SetCache (_fdba ,_bcgc );return _bcgc ;};_ddgd ,_ :=_efe .GetRawValue ();if _efe .IsError (){_faaf :=_aeaf .MakeErrorResult ("");_faaf .ValueString =_ddgd ;ev .SetCache (_fdba ,_faaf );return _faaf ;};_fdff :=_aeaf .MakeStringResult (_ddgd );ev .SetCache (_fdba ,_fdff );return _fdff ;};

// X returns the inner wrapped XML type.
func (_fegbf WorkbookProtection )X ()*_cdcga .CT_WorkbookProtection {return _fegbf ._caaf };

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_dadg StyleSheet )AddCellStyle ()CellStyle {_ebfge :=_cdcga .NewCT_Xf ();_dadg ._gbf .CellXfs .Xf =append (_dadg ._gbf .CellXfs .Xf ,_ebfge );_dadg ._gbf .CellXfs .CountAttr =_ebgf .Uint32 (uint32 (len (_dadg ._gbf .CellXfs .Xf )));return CellStyle {_dadg ._ggf ,_ebfge ,_dadg ._gbf .CellXfs };};