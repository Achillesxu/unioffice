//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_gc "archive/zip";_ac "bytes";_cf "errors";_ebb "fmt";_c "github.com/unidoc/unioffice";_gcc "github.com/unidoc/unioffice/chart";_ffb "github.com/unidoc/unioffice/color";_ad "github.com/unidoc/unioffice/common";_cfa "github.com/unidoc/unioffice/common/logger";
_fgb "github.com/unidoc/unioffice/common/tempstorage";_ca "github.com/unidoc/unioffice/internal/license";_ge "github.com/unidoc/unioffice/measurement";_dg "github.com/unidoc/unioffice/schema/soo/dml";_cd "github.com/unidoc/unioffice/schema/soo/dml/chart";
_bgg "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_da "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_bcd "github.com/unidoc/unioffice/schema/soo/sml";_gd "github.com/unidoc/unioffice/spreadsheet/format";_acb "github.com/unidoc/unioffice/spreadsheet/formula";
_gdc "github.com/unidoc/unioffice/spreadsheet/reference";_df "github.com/unidoc/unioffice/spreadsheet/update";_ed "github.com/unidoc/unioffice/vmldrawing";_bc "github.com/unidoc/unioffice/zippkg";_f "image";_g "image/jpeg";_ef "io";_ff "math";_bgb "math/big";
_e "os";_ce "path";_a "path/filepath";_eb "reflect";_bg "regexp";_b "sort";_cc "strconv";_fg "strings";_acc "time";);

// SetAllowBlank controls if blank values are accepted.
func (_egfe DataValidation )SetAllowBlank (b bool ){if !b {_egfe ._aegb .AllowBlankAttr =nil ;}else {_egfe ._aegb .AllowBlankAttr =_c .Bool (true );};};func (_ddg DataValidationCompare )SetValue2 (v string ){_ddg ._ccga .Formula2 =&v };

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_edbc *Workbook ;_cbc *_bcd .CT_Xf ;_fcg *_bcd .CT_CellXfs ;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gdcd Comment )SetCellReference (cellRef string ){_gdcd ._aaef .RefAttr =cellRef };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_ec Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_eg :=_acb .ParseString (formulaStr );if _eg ==nil {return _cf .New (_ebb .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));
};_ec .clearValue ();_ec ._de .TAttr =_bcd .ST_CellTypeStr ;_ec ._de .F =_bcd .NewCT_CellFormula ();_ec ._de .F .TAttr =_bcd .ST_CellFormulaTypeShared ;_ec ._de .F .Content =formulaStr ;_bfc ,_cge :=_gdc .ParseCellReference (_ec .Reference ());if _cge !=nil {return _cge ;
};_ga :=uint32 (0);for _ ,_gbb :=range _ec ._ebg .Rows (){for _ ,_dgg :=range _gbb ._dddc .C {if _dgg .F !=nil &&_dgg .F .SiAttr !=nil &&*_dgg .F .SiAttr >=_ga {_ga =*_dgg .F .SiAttr ;};};};_ga ++;_ee :=_ebb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_bfc .Column ,_bfc .RowIdx ,_gdc .IndexToColumn (_bfc .ColumnIdx +cols ),_bfc .RowIdx +rows );
_ec ._de .F .RefAttr =_c .String (_ee );_ec ._de .F .SiAttr =_c .Uint32 (_ga );_ccf :=Sheet {_ec ._fbc ,_ec ._ebg ._ceda ,_ec ._ebg ._gbef };for _bde :=_bfc .RowIdx ;_bde <=_bfc .RowIdx +rows ;_bde ++{for _dbc :=_bfc .ColumnIdx ;_dbc <=_bfc .ColumnIdx +cols ;
_dbc ++{if _bde ==_bfc .RowIdx &&_dbc ==_bfc .ColumnIdx {continue ;};_cfd :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_dbc ),_bde );_ccf .Cell (_cfd ).Clear ();_ccf .Cell (_cfd ).X ().F =_bcd .NewCT_CellFormula ();_ccf .Cell (_cfd ).X ().F .TAttr =_bcd .ST_CellFormulaTypeShared ;
_ccf .Cell (_cfd ).X ().F .SiAttr =_c .Uint32 (_ga );};};return nil ;};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_dbf Drawing )AddImage (img _ad .ImageRef ,at AnchorType )Anchor {_cdb :=0;for _febg ,_dffd :=range _dbf ._cbfg .Images {if _dffd ==img {_cdb =_febg +1;break ;};};var _dgaf string ;for _ecf ,_cbd :=range _dbf ._cbfg ._edbf {if _cbd ==_dbf ._bbaa {_gge :=_ebb .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_cdb ,img .Format ());
_eed :=_dbf ._cbfg ._fbfbf [_ecf ].AddRelationship (_gge ,_c .ImageType );_dgaf =_eed .ID ();break ;};};var _gcd Anchor ;var _adga *_bgg .CT_Picture ;switch at {case AnchorTypeAbsolute :_fabca :=_efcb ();_dbf ._bbaa .EG_Anchor =append (_dbf ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {AbsoluteAnchor :_fabca });
_fabca .Choice =&_bgg .EG_ObjectChoicesChoice {};_fabca .Choice .Pic =_bgg .NewCT_Picture ();_fabca .Pos .XAttr .ST_CoordinateUnqualified =_c .Int64 (0);_fabca .Pos .YAttr .ST_CoordinateUnqualified =_c .Int64 (0);_adga =_fabca .Choice .Pic ;_gcd =AbsoluteAnchor {_fabca };
case AnchorTypeOneCell :_gfg :=_bfdf ();_dbf ._bbaa .EG_Anchor =append (_dbf ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {OneCellAnchor :_gfg });_gfg .Choice =&_bgg .EG_ObjectChoicesChoice {};_gfg .Choice .Pic =_bgg .NewCT_Picture ();_adga =_gfg .Choice .Pic ;
_gcd =OneCellAnchor {_gfg };case AnchorTypeTwoCell :_eef :=_fbfc ();_dbf ._bbaa .EG_Anchor =append (_dbf ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {TwoCellAnchor :_eef });_eef .Choice =&_bgg .EG_ObjectChoicesChoice {};_eef .Choice .Pic =_bgg .NewCT_Picture ();
_adga =_eef .Choice .Pic ;_gcd =TwoCellAnchor {_eef };};_adga .NvPicPr .CNvPr .IdAttr =uint32 (len (_dbf ._bbaa .EG_Anchor ));_adga .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_adga .BlipFill .Blip =_dg .NewCT_Blip ();_adga .BlipFill .Blip .EmbedAttr =_c .String (_dgaf );
_adga .BlipFill .Stretch =_dg .NewCT_StretchInfoProperties ();_adga .SpPr =_dg .NewCT_ShapeProperties ();_adga .SpPr .Xfrm =_dg .NewCT_Transform2D ();_adga .SpPr .Xfrm .Off =_dg .NewCT_Point2D ();_adga .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_c .Int64 (0);
_adga .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_c .Int64 (0);_adga .SpPr .Xfrm .Ext =_dg .NewCT_PositiveSize2D ();_adga .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_ge .Pixel72 )/_ge .EMU );_adga .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_ge .Pixel72 )/_ge .EMU );
_adga .SpPr .PrstGeom =_dg .NewCT_PresetGeometry2D ();_adga .SpPr .PrstGeom .PrstAttr =_dg .ST_ShapeTypeRect ;_adga .SpPr .Ln =_dg .NewCT_LineProperties ();_adga .SpPr .Ln .NoFill =_dg .NewCT_NoFillProperties ();return _gcd ;};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_dedb *Sheet )SetFrozen (firstRow ,firstCol bool ){_dedb ._gbef .SheetViews =nil ;_dfca :=_dedb .AddView ();_dfca .SetState (_bcd .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_dfca .SetYSplit (1);_dfca .SetXSplit (1);_dfca .SetTopLeft ("\u0042\u0032");
case firstRow :_dfca .SetYSplit (1);_dfca .SetTopLeft ("\u0041\u0032");case firstCol :_dfca .SetXSplit (1);_dfca .SetTopLeft ("\u0042\u0031");};};func _geeg (_dgfg string )bool {_dgfg =_fg .Replace (_dgfg ,"\u0024","",-1);if _bggce :=_aacd .FindStringSubmatch (_fg .ToLower (_dgfg ));
len (_bggce )> 2{_fdee :=_bggce [1];_dbefg ,_bcfb :=_cc .Atoi (_bggce [2]);if _bcfb !=nil {return false ;};return _dbefg <=1048576&&_fdee <="\u007a\u007a";};return false ;};

// Index returns the index of the border for use with a cell style.
func (_dac Border )Index ()uint32 {for _bcf ,_dc :=range _dac ._fb .Border {if _dc ==_dac ._fa {return uint32 (_bcf );};};return 0;};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_cdege *Workbook )Epoch ()_acc .Time {if _cdege .Uses1904Dates (){_acc .Date (1904,1,1,0,0,0,0,_acc .UTC );};return _acc .Date (1899,12,30,0,0,0,0,_acc .UTC );};

// Column returns the cell column
func (_eba Cell )Column ()(string ,error ){_dbgb ,_bggc :=_gdc .ParseCellReference (_eba .Reference ());if _bggc !=nil {return "",_bggc ;};return _dbgb .Column ,nil ;};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_gdg *_bcd .CT_Col };

// AddFormatValue adds a format value to be used to determine the cell background.
func (_gde ColorScale )AddFormatValue (t _bcd .ST_CfvoType ,val string ){_bgf :=_bcd .NewCT_Cfvo ();_bgf .TypeAttr =t ;_bgf .ValAttr =_c .String (val );_gde ._dcfbd .Cfvo =append (_gde ._dcfbd .Cfvo ,_bgf );};

// IsBool returns true if the cell is a boolean type cell.
func (_bgba Cell )IsBool ()bool {return _bgba ._de .TAttr ==_bcd .ST_CellTypeB };

// AddCommentWithStyle adds a new comment styled in a default way
func (_fbf Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_fcfb :=_fbf .AddComment (cellRef ,author );_efdb :=_fcfb .AddRun ();_efdb .SetBold (true );_efdb .SetSize (10);_efdb .SetColor (_ffb .Black );_efdb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");
_efdb .SetText (author +"\u003a");_efdb =_fcfb .AddRun ();_efdb .SetSize (10);_efdb .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_efdb .SetColor (_ffb .Black );_efdb .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_cbf ,_egdf :=_gdc .ParseCellReference (cellRef );
if _egdf !=nil {return _egdf ;};_fbf ._faba ._fgga [0].Shape =append (_fbf ._faba ._fgga [0].Shape ,_ed .NewCommentShape (int64 (_cbf .ColumnIdx ),int64 (_cbf .RowIdx -1)));return nil ;};

// Cell is a single cell within a sheet.
type Cell struct{_fbc *Workbook ;_ebg *Sheet ;_bf *_bcd .CT_Row ;_de *_bcd .CT_Cell ;};

// Row is a row within a spreadsheet.
type Row struct{_ecag *Workbook ;_dad *Sheet ;_dddc *_bcd .CT_Row ;};var _aabd =false ;

// Reference returns the region of cells that are merged.
func (_fbfa MergedCell )Reference ()string {return _fbfa ._fegcc .RefAttr };

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_bfd Cell )GetCachedFormulaResult ()string {if _bfd ._de .V !=nil {return *_bfd ._de .V ;};return "";};

// SetValues sets the possible values. This is incompatible with SetRange.
func (_afbg DataValidationList )SetValues (values []string ){_afbg ._gfdc .Formula1 =_c .String ("\u0022"+_fg .Join (values ,"\u002c")+"\u0022");_afbg ._gfdc .Formula2 =_c .String ("\u0030");};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_agf Cell )GetFormattedValue ()string {_cff :=_agf .getFormat ();switch _agf ._de .TAttr {case _bcd .ST_CellTypeB :_cab ,_ :=_agf .GetValueAsBool ();if _cab {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _bcd .ST_CellTypeN :_dcfb ,_ :=_agf .GetValueAsNumber ();
return _gd .Number (_dcfb ,_cff );case _bcd .ST_CellTypeE :if _agf ._de .V !=nil {return *_agf ._de .V ;};return "";case _bcd .ST_CellTypeS ,_bcd .ST_CellTypeInlineStr :return _gd .String (_agf .GetString (),_cff );case _bcd .ST_CellTypeStr :_ab :=_agf .GetString ();
if _gd .IsNumber (_ab ){_cea ,_ :=_cc .ParseFloat (_ab ,64);return _gd .Number (_cea ,_cff );};return _gd .String (_ab ,_cff );case _bcd .ST_CellTypeUnset :fallthrough;default:_ece ,_ :=_agf .GetRawValue ();if len (_ece )==0{return "";};_fba ,_egg :=_agf .GetValueAsNumber ();
if _egg ==nil {return _gd .Number (_fba ,_cff );};return _gd .String (_ece ,_cff );};};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_dce CellStyle )SetProtection (protected bool ,hidden bool ){_dce ._cbc .Protection =&_bcd .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};func (_abbc *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _abbc .getAllCellsInFormulaArrays (false );
};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_ada Cell )SetStyleIndex (idx uint32 ){_ada ._de .SAttr =_c .Uint32 (idx )};func (_gdee Sheet )validateRowCellNumbers ()error {_cfde :=map[uint32 ]struct{}{};for _ ,_bdgc :=range _gdee ._gbef .SheetData .Row {if _bdgc .RAttr !=nil {if _ ,_eeag :=_cfde [*_bdgc .RAttr ];
_eeag {return _ebb .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_gdee .Name (),*_bdgc .RAttr );};_cfde [*_bdgc .RAttr ]=struct{}{};};_bdcc :=map[string ]struct{}{};for _ ,_bafb :=range _bdgc .C {if _bafb .RAttr ==nil {continue ;
};if _ ,_ebda :=_bdcc [*_bafb .RAttr ];_ebda {return _ebb .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_gdee .Name (),*_bafb .RAttr );};_bdcc [*_bafb .RAttr ]=struct{}{};};};return nil ;
};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_dbga Cell )SetFormulaArray (s string ){_bd :=_acb .ParseString (s );if _bd ==nil {return ;};_dbga .clearValue ();_dbga ._de .TAttr =_bcd .ST_CellTypeStr ;_dbga ._de .F =_bcd .NewCT_CellFormula ();_dbga ._de .F .TAttr =_bcd .ST_CellFormulaTypeArray ;
_dbga ._de .F .Content =s ;};

// SetRotation configures the cell to be rotated.
func (_dgfe CellStyle )SetRotation (deg uint8 ){if _dgfe ._cbc .Alignment ==nil {_dgfe ._cbc .Alignment =_bcd .NewCT_CellAlignment ();};_dgfe ._cbc .ApplyAlignmentAttr =_c .Bool (true );_dgfe ._cbc .Alignment .TextRotationAttr =_c .Uint8 (deg );};

// X returns the inner wrapped XML type.
func (_bef DataBarScale )X ()*_bcd .CT_DataBar {return _bef ._gfe };

// SetReference sets the regin of cells that the merged cell applies to.
func (_fdeb MergedCell )SetReference (ref string ){_fdeb ._fegcc .RefAttr =ref };

// GetLocked returns true if the cell is locked.
func (_ddc *evalContext )GetLocked (cellRef string )bool {return _ddc ._bge .Cell (cellRef ).getLocked ()};

// DataValidation controls cell validation
type DataValidation struct{_aegb *_bcd .CT_DataValidation };

// AddSheet adds a new sheet to a workbook.
func (_cce *Workbook )AddSheet ()Sheet {_ffge :=_bcd .NewCT_Sheet ();_ffge .SheetIdAttr =1;for _ ,_dabd :=range _cce ._dfdc .Sheets .Sheet {if _ffge .SheetIdAttr <=_dabd .SheetIdAttr {_ffge .SheetIdAttr =_dabd .SheetIdAttr +1;};};_cce ._dfdc .Sheets .Sheet =append (_cce ._dfdc .Sheets .Sheet ,_ffge );
_ffge .NameAttr =_ebb .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_ffge .SheetIdAttr );_agfgc :=_bcd .NewWorksheet ();_agfgc .Dimension =_bcd .NewCT_SheetDimension ();_agfgc .Dimension .RefAttr ="\u0041\u0031";_cce ._agbbg =append (_cce ._agbbg ,_agfgc );
_gagc :=_ad .NewRelationships ();_cce ._dagcbb =append (_cce ._dagcbb ,_gagc );_agfgc .SheetData =_bcd .NewCT_SheetData ();_cce ._bfdfd =append (_cce ._bfdfd ,nil );_adeea :=_c .DocTypeSpreadsheet ;_dggec :=_cce ._dcef .AddAutoRelationship (_adeea ,_c .OfficeDocumentType ,len (_cce ._dfdc .Sheets .Sheet ),_c .WorksheetType );
_ffge .IdAttr =_dggec .ID ();_cce .ContentTypes .AddOverride (_c .AbsoluteFilename (_adeea ,_c .WorksheetContentType ,len (_cce ._dfdc .Sheets .Sheet )),_c .WorksheetContentType );return Sheet {_cce ,_ffge ,_agfgc };};

// SetHeightCells is a no-op.
func (_ffaf OneCellAnchor )SetHeightCells (int32 ){};type Fill struct{_cggag *_bcd .CT_Fill ;_bbfa *_bcd .CT_Fills ;};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_efc Cell )SetStringByID (id int ){_efc ._fbc .ensureSharedStringsRelationships ();_efc .clearValue ();_efc ._de .V =_c .String (_cc .Itoa (id ));_efc ._de .TAttr =_bcd .ST_CellTypeS ;};

// AddCell adds a cell to a spreadsheet.
func (_gecfe Row )AddCell ()Cell {_cdeg :=uint32 (len (_gecfe ._dddc .C ));var _dagc *string ;if _cdeg > 0{_cbfb :=_c .Stringf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_cdeg -1),_gecfe .RowNumber ());if _gecfe ._dddc .C [_cdeg -1].RAttr !=nil &&*_gecfe ._dddc .C [_cdeg -1].RAttr ==*_cbfb {_dagc =_c .Stringf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_cdeg ),_gecfe .RowNumber ());
};};_dbdf :=_bcd .NewCT_Cell ();_gecfe ._dddc .C =append (_gecfe ._dddc .C ,_dbdf );if _dagc ==nil {_adfgg :=uint32 (0);for _ ,_cgce :=range _gecfe ._dddc .C {if _cgce .RAttr !=nil {_bdga ,_ :=_gdc .ParseCellReference (*_cgce .RAttr );if _bdga .ColumnIdx >=_adfgg {_adfgg =_bdga .ColumnIdx +1;
};};};_dagc =_c .Stringf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_adfgg ),_gecfe .RowNumber ());};_dbdf .RAttr =_dagc ;return Cell {_gecfe ._ecag ,_gecfe ._dad ,_gecfe ._dddc ,_dbdf };};

// X returns the inner wrapped XML type.
func (_degd RichText )X ()*_bcd .CT_Rst {return _degd ._gecf };

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_bgef StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_dfe :=range _bgef .CellStyles (){if _dfe .HasNumberFormat ()&&_dfe .NumberFormat ()==uint32 (f ){return _dfe ;};};_dggae :=_bgef .AddCellStyle ();_dggae .SetNumberFormatStandard (f );
return _dggae ;};

// AddFont creates a new empty Font style.
func (_afggcd StyleSheet )AddFont ()Font {_dbcd :=_bcd .NewCT_Font ();return Font {_dbcd ,_afggcd ._gaff };};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_dcbg *Workbook ;_ccge *_bcd .CT_NumFmt ;};

// SetWidth is a no-op.
func (_bgge TwoCellAnchor )SetWidth (w _ge .Distance ){};

// PasswordHash returns the hash of the workbook password.
func (_dceg WorkbookProtection )PasswordHash ()string {if _dceg ._deed .WorkbookPasswordAttr ==nil {return "";};return *_dceg ._deed .WorkbookPasswordAttr ;};

// LockWindow controls the locking of the workbook windows.
func (_cfff WorkbookProtection )LockWindow (b bool ){if !b {_cfff ._deed .LockWindowsAttr =nil ;}else {_cfff ._deed .LockWindowsAttr =_c .Bool (true );};};const (DVCompareTypeWholeNumber =DVCompareType (_bcd .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_bcd .ST_DataValidationTypeDecimal );
DVCompareTypeDate =DVCompareType (_bcd .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_bcd .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_bcd .ST_DataValidationTypeTextLength ););

// ExtractText returns text from the sheet as a SheetText object.
func (_cdba *Sheet )ExtractText ()*SheetText {_efgb :=[]CellText {};for _ ,_cee :=range _cdba .Rows (){for _ ,_ebff :=range _cee .Cells (){if !_ebff .IsEmpty (){if _ffa :=_ebff .GetFormattedValue ();_ffa !=""{_efgb =append (_efgb ,CellText {Text :_ffa ,Cell :_ebff });
};};};};return &SheetText {Cells :_efgb };};

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_ddee StyleSheet )RemoveFont (f Font )error {for _dacde ,_dgae :=range _ddee ._gaff .Fonts .Font {if _dgae ==f .X (){_ddee ._gaff .Fonts .Font =append (_ddee ._gaff .Fonts .Font [:_dacde ],_ddee ._gaff .Fonts .Font [_dacde +1:]...);return nil ;};
};return _cf .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_dgcdg *Workbook )SetActiveSheet (s Sheet ){for _ecegg ,_bfccg :=range _dgcdg ._agbbg {if s ._gbef ==_bfccg {_dgcdg .SetActiveSheetIndex (uint32 (_ecegg ));};};};func (_bgea *Workbook )onNewRelationship (_dfad *_bc .DecodeMap ,_eafdf ,_gaee string ,_bffb []*_gc .File ,_abbg *_da .Relationship ,_agfbd _bc .Target )error {_fgeb :=_c .DocTypeSpreadsheet ;
switch _gaee {case _c .OfficeDocumentType :_bgea ._dfdc =_bcd .NewWorkbook ();_dfad .AddTarget (_eafdf ,_bgea ._dfdc ,_gaee ,0);_bgea ._dcef =_ad .NewRelationships ();_dfad .AddTarget (_bc .RelationsPathFor (_eafdf ),_bgea ._dcef .X (),_gaee ,0);_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);
case _c .CorePropertiesType :_dfad .AddTarget (_eafdf ,_bgea .CoreProperties .X (),_gaee ,0);_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);case _c .CustomPropertiesType :_dfad .AddTarget (_eafdf ,_bgea .CustomProperties .X (),_gaee ,0);
_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);case _c .ExtendedPropertiesType :_dfad .AddTarget (_eafdf ,_bgea .AppProperties .X (),_gaee ,0);_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);case _c .WorksheetType :_dcfba :=_bcd .NewWorksheet ();
_gbaaf :=uint32 (len (_bgea ._agbbg ));_bgea ._agbbg =append (_bgea ._agbbg ,_dcfba );_dfad .AddTarget (_eafdf ,_dcfba ,_gaee ,_gbaaf );_defg :=_ad .NewRelationships ();_dfad .AddTarget (_bc .RelationsPathFor (_eafdf ),_defg .X (),_gaee ,0);_bgea ._dagcbb =append (_bgea ._dagcbb ,_defg );
_bgea ._bfdfd =append (_bgea ._bfdfd ,nil );_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._agbbg ));case _c .StylesType :_bgea .StyleSheet =NewStyleSheet (_bgea );_dfad .AddTarget (_eafdf ,_bgea .StyleSheet .X (),_gaee ,0);
_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);case _c .ThemeType :_cfgcf :=_dg .NewTheme ();_bgea ._gdba =append (_bgea ._gdba ,_cfgcf );_dfad .AddTarget (_eafdf ,_cfgcf ,_gaee ,0);_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._gdba ));
case _c .SharedStringsType :_bgea .SharedStrings =NewSharedStrings ();_dfad .AddTarget (_eafdf ,_bgea .SharedStrings .X (),_gaee ,0);_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,0);case _c .ThumbnailType :for _gfcc ,_ceed :=range _bffb {if _ceed ==nil {continue ;
};if _ceed .Name ==_eafdf {_gbafd ,_ceggcg :=_ceed .Open ();if _ceggcg !=nil {return _ebb .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_ceggcg );};_bgea .Thumbnail ,_ ,_ceggcg =_f .Decode (_gbafd );
_gbafd .Close ();if _ceggcg !=nil {return _ebb .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_ceggcg );};_bffb [_gfcc ]=nil ;};};case _c .ImageType :for _efdg ,_aceb :=range _bgea ._bcdb {_gafb :=_ce .Clean (_eafdf );
if _gafb ==_efdg {_abbg .TargetAttr =_aceb ;return nil ;};};_deeb :=_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea .Images )+1);for _fabf ,_bbccg :=range _bffb {if _bbccg ==nil {continue ;};if _bbccg .Name ==_ce .Clean (_eafdf ){_eadad ,_dfcd :=_bc .ExtractToDiskTmp (_bbccg ,_bgea .TmpPath );
if _dfcd !=nil {return _dfcd ;};_eggcg ,_dfcd :=_ad .ImageFromStorage (_eadad );if _dfcd !=nil {return _dfcd ;};_daba :=_ad .MakeImageRef (_eggcg ,&_bgea .DocBase ,_bgea ._dcef );_daba .SetTarget (_deeb );_bgea ._bcdb [_bbccg .Name ]=_deeb ;_bgea .Images =append (_bgea .Images ,_daba );
_bffb [_fabf ]=nil ;};};_abbg .TargetAttr =_deeb ;case _c .DrawingType :_dcggd :=_bgg .NewWsDr ();_begf :=uint32 (len (_bgea ._edbf ));_dfad .AddTarget (_eafdf ,_dcggd ,_gaee ,_begf );_bgea ._edbf =append (_bgea ._edbf ,_dcggd );_cdg :=_ad .NewRelationships ();
_dfad .AddTarget (_bc .RelationsPathFor (_eafdf ),_cdg .X (),_gaee ,_begf );_bgea ._fbfbf =append (_bgea ._fbfbf ,_cdg );_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._edbf ));case _c .VMLDrawingType :_adbdg :=_ed .NewContainer ();
_bdeca :=uint32 (len (_bgea ._fgga ));_dfad .AddTarget (_eafdf ,_adbdg ,_gaee ,_bdeca );_bgea ._fgga =append (_bgea ._fgga ,_adbdg );case _c .CommentsType :_bgea ._bfdfd [_agfbd .Index ]=_bcd .NewComments ();_dfad .AddTarget (_eafdf ,_bgea ._bfdfd [_agfbd .Index ],_gaee ,_agfbd .Index );
_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._bfdfd ));case _c .ChartType :_cfaf :=_cd .NewChartSpace ();_eeeg :=uint32 (len (_bgea ._bfda ));_dfad .AddTarget (_eafdf ,_cfaf ,_gaee ,_eeeg );_bgea ._bfda =append (_bgea ._bfda ,_cfaf );
_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._bfda ));_bgea ._bccce [_abbg .TargetAttr ]=_cfaf ;case _c .TableType :_afda :=_bcd .NewTable ();_acab :=uint32 (len (_bgea ._cfgf ));_dfad .AddTarget (_eafdf ,_afda ,_gaee ,_acab );
_bgea ._cfgf =append (_bgea ._cfgf ,_afda );_abbg .TargetAttr =_c .RelativeFilename (_fgeb ,_agfbd .Typ ,_gaee ,len (_bgea ._cfgf ));default:_cfa .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_eafdf ,_gaee );
};return nil ;};

// SetFormat sets the number format code.
func (_gcab NumberFormat )SetFormat (f string ){_gcab ._ccge .FormatCodeAttr =f };const _dbe ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// SetColOffset sets the column offset of the two cell anchor.
func (_baag TwoCellAnchor )SetColOffset (m _ge .Distance ){_cfgb :=m -_baag .TopLeft ().ColOffset ();_baag .TopLeft ().SetColOffset (m );_baag .BottomRight ().SetColOffset (_baag .BottomRight ().ColOffset ()+_cfgb );};

// AddBorder creates a new empty Border style.
func (_dgdab StyleSheet )AddBorder ()Border {_gaga :=_bcd .NewCT_Border ();return Border {_gaga ,_dgdab ._gaff .Borders };};func (_bbf Border )SetDiagonal (style _bcd .ST_BorderStyle ,c _ffb .Color ,up ,down bool ){if _bbf ._fa .Diagonal ==nil {_bbf ._fa .Diagonal =_bcd .NewCT_BorderPr ();
};_bbf ._fa .Diagonal .Color =_bcd .NewCT_Color ();_bbf ._fa .Diagonal .Color .RgbAttr =c .AsRGBAString ();_bbf ._fa .Diagonal .StyleAttr =style ;if up {_bbf ._fa .DiagonalUpAttr =_c .Bool (true );};if down {_bbf ._fa .DiagonalDownAttr =_c .Bool (true );
};};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_adcgcf *_bcd .CT_SheetView };

// X returns the inner wrapped XML type.
func (_fadbf *Workbook )X ()*_bcd .Workbook {return _fadbf ._dfdc };

// HasFormula returns true if the cell contains formula.
func (_edd *evalContext )HasFormula (cellRef string )bool {return _edd ._bge .Cell (cellRef ).HasFormula ()};

// SetWidthCells is a no-op.
func (_cdf AbsoluteAnchor )SetWidthCells (int32 ){};

// Comments returns the list of comments for this sheet
func (_gfa Comments )Comments ()[]Comment {_bdg :=[]Comment {};for _ ,_aad :=range _gfa ._bfcf .CommentList .Comment {_bdg =append (_bdg ,Comment {_gfa ._faba ,_aad ,_gfa ._bfcf });};return _bdg ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_adfae *Workbook )RecalculateFormulas (){for _ ,_dcfge :=range _adfae .Sheets (){_dcfge .RecalculateFormulas ();};};

// New constructs a new workbook.
func New ()*Workbook {_fdf :=&Workbook {};_fdf ._dfdc =_bcd .NewWorkbook ();_fdf .AppProperties =_ad .NewAppProperties ();_fdf .CoreProperties =_ad .NewCoreProperties ();_fdf .StyleSheet =NewStyleSheet (_fdf );_fdf .Rels =_ad .NewRelationships ();_fdf ._dcef =_ad .NewRelationships ();
_fdf .Rels .AddRelationship (_c .RelativeFilename (_c .DocTypeSpreadsheet ,"",_c .ExtendedPropertiesType ,0),_c .ExtendedPropertiesType );_fdf .Rels .AddRelationship (_c .RelativeFilename (_c .DocTypeSpreadsheet ,"",_c .CorePropertiesType ,0),_c .CorePropertiesType );
_fdf .Rels .AddRelationship (_c .RelativeFilename (_c .DocTypeSpreadsheet ,"",_c .OfficeDocumentType ,0),_c .OfficeDocumentType );_fdf ._dcef .AddRelationship (_c .RelativeFilename (_c .DocTypeSpreadsheet ,_c .OfficeDocumentType ,_c .StylesType ,0),_c .StylesType );
_fdf .ContentTypes =_ad .NewContentTypes ();_fdf .ContentTypes .AddDefault ("\u0076\u006d\u006c",_c .VMLDrawingContentType );_fdf .ContentTypes .AddOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");
_fdf .ContentTypes .AddOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .StylesType ,0),_c .SMLStyleSheetContentType );_fdf .SharedStrings =NewSharedStrings ();_fdf .ContentTypes .AddOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .SharedStringsType ,0),_c .SharedStringsContentType );
_fdf ._dcef .AddRelationship (_c .RelativeFilename (_c .DocTypeSpreadsheet ,_c .OfficeDocumentType ,_c .SharedStringsType ,0),_c .SharedStringsType );_fdf ._bcdb =map[string ]string {};return _fdf ;};

// SetCol set the column of the cell marker.
func (_dgf CellMarker )SetCol (col int32 ){_dgf ._dfd .Col =col };func _efcb ()*_bgg .CT_AbsoluteAnchor {_ceggc :=_bgg .NewCT_AbsoluteAnchor ();return _ceggc };

// AddGradientStop adds a color gradient stop.
func (_gcb ColorScale )AddGradientStop (color _ffb .Color ){_gce :=_bcd .NewCT_Color ();_gce .RgbAttr =color .AsRGBAString ();_gcb ._dcfbd .Color =append (_gcb ._dcfbd .Color ,_gce );};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_fddf *evalContext )IsDBCS ()bool {_bba :=_fddf ._bge ._feaa .CoreProperties .X ().Language ;if _bba ==nil {return false ;};_eddc :=string (_bba .Data );for _ ,_eea :=range _gbafb {if _eddc ==_eea {return true ;};};return false ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_bec :=uint16 (0);if len (s )> 0{for _ebgf :=len (s )-1;_ebgf >=0;_ebgf --{_dbgbe :=s [_ebgf ];_bec =((_bec >>14)&0x01)|((_bec <<1)&0x7fff);_bec ^=uint16 (_dbgbe );};_bec =((_bec >>14)&0x01)|((_bec <<1)&0x7fff);_bec ^=uint16 (len (s ));
_bec ^=(0x8000|('N'<<8)|'K');};return _ebb .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_bec ));};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_ccb *_bcd .CT_ConditionalFormatting ;};

// Row returns the row of the cell marker.
func (_aec CellMarker )Row ()int32 {return _aec ._dfd .Row };

// IsSheetLocked returns whether the sheet is locked.
func (_dbgbed SheetProtection )IsSheetLocked ()bool {return _dbgbed ._fggg .SheetAttr !=nil &&*_dbgbed ._fggg .SheetAttr ;};func (_fae Font )Index ()uint32 {for _dfcf ,_gdec :=range _fae ._dbbf .Fonts .Font {if _fae ._fgd ==_gdec {return uint32 (_dfcf );
};};return 0;};func (_fbgf Row )renumberAs (_ddba uint32 ){_fbgf ._dddc .RAttr =_c .Uint32 (_ddba );for _ ,_gcaaa :=range _fbgf .Cells (){_dea ,_abg :=_gdc .ParseCellReference (_gcaaa .Reference ());if _abg ==nil {_bfbd :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_dea .Column ,_ddba );
_gcaaa ._de .RAttr =_c .String (_bfbd );};};};

// GetWidth returns a worksheet's column width.
func (_geg *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_ced :=range _geg ._bge .X ().Cols [0].Col {if int (_ced .MinAttr )<=colIdx &&colIdx <=int (_ced .MaxAttr ){return float64 (int (*_ced .WidthAttr ));};};return 0;};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_ad .DocBase ;_dfdc *_bcd .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_bfdfd []*_bcd .Comments ;_agbbg []*_bcd .Worksheet ;_dagcbb []_ad .Relationships ;_dcef _ad .Relationships ;_gdba []*_dg .Theme ;_edbf []*_bgg .WsDr ;
_fbfbf []_ad .Relationships ;_fgga []*_ed .Container ;_bfda []*_cd .ChartSpace ;_cfgf []*_bcd .Table ;_dcde string ;_bcdb map[string ]string ;_bccce map[string ]*_cd .ChartSpace ;_dabb string ;};type MergedCell struct{_bfg *Workbook ;_cag *Sheet ;_fegcc *_bcd .CT_MergeCell ;
};

// SetHeight is a nop-op.
func (_fbgg TwoCellAnchor )SetHeight (h _ge .Distance ){};

// SetItalic causes the text to be displayed in italic.
func (_afae RichTextRun )SetItalic (b bool ){_afae .ensureRpr ();_afae ._cegd .RPr .I =_bcd .NewCT_BooleanProperty ();_afae ._cegd .RPr .I .ValAttr =_c .Bool (b );};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_egd Cell )SetString (s string )int {_egd ._fbc .ensureSharedStringsRelationships ();_egd .clearValue ();_fef :=_egd ._fbc .SharedStrings .AddString (s );_egd ._de .V =_c .String (_cc .Itoa (_fef ));_egd ._de .TAttr =_bcd .ST_CellTypeS ;return _fef ;
};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_afd CellStyle )SetNumberFormatStandard (s StandardFormat ){_afd ._cbc .NumFmtIdAttr =_c .Uint32 (uint32 (s ));_afd ._cbc .ApplyNumberFormatAttr =_c .Bool (true );};func (_cgcc ConditionalFormattingRule )clear (){_cgcc ._faa .OperatorAttr =_bcd .ST_ConditionalFormattingOperatorUnset ;
_cgcc ._faa .ColorScale =nil ;_cgcc ._faa .IconSet =nil ;_cgcc ._faa .Formula =nil ;};func (_begb StyleSheet )appendBorder ()Border {_egfef :=_bcd .NewCT_Border ();_begb ._gaff .Borders .Border =append (_begb ._gaff .Borders .Border ,_egfef );_begb ._gaff .Borders .CountAttr =_c .Uint32 (uint32 (len (_begb ._gaff .Borders .Border )));
return Border {_egfef ,_begb ._gaff .Borders };};

// SetWidth sets the width of the anchored object.
func (_bb AbsoluteAnchor )SetWidth (w _ge .Distance ){_bb ._gb .Ext .CxAttr =int64 (w /_ge .EMU )};func (_edbb *Sheet )removeColumnFromMergedCells (_gdab uint32 )error {if _edbb ._gbef .MergeCells ==nil ||_edbb ._gbef .MergeCells .MergeCell ==nil {return nil ;
};_abbf :=[]*_bcd .CT_MergeCell {};for _ ,_cfacg :=range _edbb .MergedCells (){_gdf :=_befcg (_cfacg .Reference (),_gdab ,true );if _gdf !=""{_cfacg .SetReference (_gdf );_abbf =append (_abbf ,_cfacg .X ());};};_edbb ._gbef .MergeCells .MergeCell =_abbf ;
return nil ;};

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_fde Cell )SetStyle (cs CellStyle ){_aeac :=cs ._fcg .Xf ;for _ ,_bdc :=range _aeac {if _eb .DeepEqual (_bdc ,cs ._cbc ){cs ._cbc =_bdc ;_fde .SetStyleIndex (cs .Index ());return ;};};cs ._fcg .Xf =append (cs ._fcg .Xf ,cs ._cbc );cs ._fcg .CountAttr =_c .Uint32 (uint32 (len (cs ._fcg .Xf )));
_fde .SetStyleIndex (cs .Index ());};

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_cbag CellStyle )SetBorder (b Border ){_eecc :=b ._fb .Border ;for _ ,_dcfa :=range _eecc {if _eb .DeepEqual (_dcfa ,b ._fa ){b ._fa =_dcfa ;_cbag ._cbc .BorderIdAttr =_c .Uint32 (b .Index ());_cbag ._cbc .ApplyBorderAttr =_c .Bool (true );return ;
};};b ._fb .Border =append (b ._fb .Border ,b ._fa );b ._fb .CountAttr =_c .Uint32 (uint32 (len (b ._fb .Border )));_cbag ._cbc .BorderIdAttr =_c .Uint32 (b .Index ());_cbag ._cbc .ApplyBorderAttr =_c .Bool (true );};func (_ceaeg StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));
};for _ ,_cbdb :=range _ceaeg ._gaff .NumFmts .NumFmt {if _cbdb .NumFmtIdAttr ==id {return NumberFormat {_ceaeg ._edgf ,_cbdb };};};return NumberFormat {};};func (_aee DataValidation )clear (){_aee ._aegb .Formula1 =_c .String ("\u0030");_aee ._aegb .Formula2 =_c .String ("\u0030");
};func (_dacg Font )SetColor (c _ffb .Color ){_fceb :=_bcd .NewCT_Color ();_cae :="\u0066\u0066"+*c .AsRGBString ();_fceb .RgbAttr =&_cae ;_dacg ._fgd .Color =[]*_bcd .CT_Color {_fceb };};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_acg *_bgg .CT_OneCellAnchor };

// AnchorType is the type of anchor.
type AnchorType byte ;

// IsEmpty checks if the cell style contains nothing.
func (_abf CellStyle )IsEmpty ()bool {return _abf ._edbc ==nil ||_abf ._cbc ==nil ||_abf ._fcg ==nil ||_abf ._fcg .Xf ==nil ;};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_ebfc Comparer )LessCells (lhs ,rhs Cell )bool {if _ebfc .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_fbae ,_dgfc :=lhs .getRawSortValue ();
_fdcf ,_fegc :=rhs .getRawSortValue ();switch {case _dgfc &&_fegc :_dgebg ,_ :=_cc .ParseFloat (_fbae ,64);_cbfe ,_ :=_cc .ParseFloat (_fdcf ,64);return _dgebg < _cbfe ;case _dgfc :return true ;case _fegc :return false ;};_fbae =lhs .GetFormattedValue ();
_fdcf =rhs .GetFormattedValue ();return _fbae < _fdcf ;};

// MoveTo repositions the anchor without changing the objects size.
func (_gga TwoCellAnchor )MoveTo (col ,row int32 ){_daag :=_gga .TopLeft ();_cgffd :=_gga .BottomRight ();_fefb :=_cgffd .Col ()-_daag .Col ();_gfdcd :=_cgffd .Row ()-_daag .Row ();_daag .SetCol (col );_daag .SetRow (row );_cgffd .SetCol (col +_fefb );
_cgffd .SetRow (row +_gfdcd );};

// SetStyle sets the cell style for an entire column.
func (_badg Column )SetStyle (cs CellStyle ){_badg ._gdg .StyleAttr =_c .Uint32 (cs .Index ())};

// GetFilename returns the filename of the context's workbook.
func (_cfbcg *evalContext )GetFilename ()string {return _cfbcg ._bge ._feaa .GetFilename ()};func (_dgafg Sheet )IsValid ()bool {return _dgafg ._gbef !=nil };

// Fonts returns the list of fonts defined in the stylesheet.
func (_cdcad StyleSheet )Fonts ()[]Font {_dgea :=[]Font {};for _ ,_ddeb :=range _cdcad ._gaff .Fonts .Font {_dgea =append (_dgea ,Font {_ddeb ,_cdcad ._gaff });};return _dgea ;};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;
);

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_edac ConditionalFormattingRule )SetColorScale ()ColorScale {_edac .clear ();_edac .SetType (_bcd .ST_CfTypeColorScale );_edac ._faa .ColorScale =_bcd .NewCT_ColorScale ();return ColorScale {_edac ._faa .ColorScale };};func _befcg (_adfa string ,_baec uint32 ,_egec bool )string {_cbcff ,_ccc ,_abgb :=_gdc .ParseRangeReference (_adfa );
if _abgb ==nil {_cedc ,_eddcg :=_cbcff .ColumnIdx ,_ccc .ColumnIdx ;if _baec >=_cedc &&_baec <=_eddcg {if _cedc ==_eddcg {if _egec {return "";}else {return _adfa ;};}else {_fbcc :=_ccc .Update (_df .UpdateActionRemoveColumn );return _ebb .Sprintf ("\u0025\u0073\u003a%\u0073",_cbcff .String (),_fbcc .String ());
};}else if _baec < _cedc {_defbg :=_cbcff .Update (_df .UpdateActionRemoveColumn );_bcbd :=_ccc .Update (_df .UpdateActionRemoveColumn );return _ebb .Sprintf ("\u0025\u0073\u003a%\u0073",_defbg .String (),_bcbd .String ());};}else {_dgcg ,_gcg ,_geba :=_gdc .ParseColumnRangeReference (_adfa );
if _geba !=nil {return "";};_adcgc ,_ggbg :=_dgcg .ColumnIdx ,_gcg .ColumnIdx ;if _baec >=_adcgc &&_baec <=_ggbg {if _adcgc ==_ggbg {if _egec {return "";}else {return _adfa ;};}else {_ggfe :=_gcg .Update (_df .UpdateActionRemoveColumn );return _ebb .Sprintf ("\u0025\u0073\u003a%\u0073",_dgcg .String (),_ggfe .String ());
};}else if _baec < _adcgc {_cacd :=_dgcg .Update (_df .UpdateActionRemoveColumn );_acaf :=_gcg .Update (_df .UpdateActionRemoveColumn );return _ebb .Sprintf ("\u0025\u0073\u003a%\u0073",_cacd .String (),_acaf .String ());};};return "";};

// X returns the inner wrapped XML type.
func (_eagge Table )X ()*_bcd .Table {return _eagge ._eacdd };

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_fdece *Workbook )Close ()error {if _fdece .TmpPath !=""{return _fgb .RemoveAll (_fdece .TmpPath );};return nil ;};func (_bbdc DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_bbdc .clear ();_bbdc ._aegb .TypeAttr =_bcd .ST_DataValidationType (t );
_bbdc ._aegb .OperatorAttr =_bcd .ST_DataValidationOperator (op );return DataValidationCompare {_bbdc ._aegb };};func (_eae *evalContext )Sheet (name string )_acb .Context {for _ ,_agfc :=range _eae ._bge ._feaa .Sheets (){if _agfc .Name ()==name {return _agfc .FormulaContext ();
};};return _acb .InvalidReferenceContext ;};

// X returns the inner wrapped XML type.
func (_gfd ConditionalFormattingRule )X ()*_bcd .CT_CfRule {return _gfd ._faa };

// SetHidden marks the defined name as hidden.
func (_eebb DefinedName )SetHidden (b bool ){_eebb ._bcbee .HiddenAttr =_c .Bool (b )};

// MergedCells returns the merged cell regions within the sheet.
func (_bdda *Sheet )MergedCells ()[]MergedCell {if _bdda ._gbef .MergeCells ==nil {return nil ;};_ffcc :=[]MergedCell {};for _ ,_gcfa :=range _bdda ._gbef .MergeCells .MergeCell {_ffcc =append (_ffcc ,MergedCell {_bdda ._feaa ,_bdda ,_gcfa });};return _ffcc ;
};

// SetShowValue controls if the cell value is displayed.
func (_bcbe DataBarScale )SetShowValue (b bool ){_bcbe ._gfe .ShowValueAttr =_c .Bool (b )};func _ffc (_fce _acc .Time )_acc .Time {_fce =_fce .Local ();return _acc .Date (_fce .Year (),_fce .Month (),_fce .Day (),_fce .Hour (),_fce .Minute (),_fce .Second (),_fce .Nanosecond (),_acc .UTC );
};

// Cell returns the actual cell behind the merged region
func (_ebdb MergedCell )Cell ()Cell {_bdfg :=_ebdb .Reference ();if _dcc :=_fg .Index (_ebdb .Reference (),"\u003a");_dcc !=-1{_bdfg =_bdfg [0:_dcc ];return _ebdb ._cag .Cell (_bdfg );};return Cell {};};

// X returns the inner wrapped XML type.
func (_fgbc Column )X ()*_bcd .CT_Col {return _fgbc ._gdg };

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_bfb CellStyle )SetFill (f Fill ){_ccg :=f ._bbfa .Fill ;for _ ,_fcf :=range _ccg {if _eb .DeepEqual (_fcf ,f ._cggag ){f ._cggag =_fcf ;_bfb ._cbc .FillIdAttr =_c .Uint32 (f .Index ());_bfb ._cbc .ApplyFillAttr =_c .Bool (true );return ;};};f ._bbfa .Fill =append (f ._bbfa .Fill ,f ._cggag );
f ._bbfa .CountAttr =_c .Uint32 (uint32 (len (f ._bbfa .Fill )));_bfb ._cbc .FillIdAttr =_c .Uint32 (f .Index ());_bfb ._cbc .ApplyFillAttr =_c .Bool (true );};

// IsEmpty returns true if the cell is empty.
func (_fab Cell )IsEmpty ()bool {return _fab ._de .TAttr ==_bcd .ST_CellTypeUnset &&_fab ._de .V ==nil &&_fab ._de .F ==nil ;};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_deb Cell )SetInlineString (s string ){_deb .clearValue ();_deb ._de .Is =_bcd .NewCT_Rst ();_deb ._de .Is .T =_c .String (s );_deb ._de .TAttr =_bcd .ST_CellTypeInlineStr ;};

// Text returns text from the sheet as one string separated with line breaks.
func (_bbad *SheetText )Text ()string {_ecfc :=_ac .NewBuffer ([]byte {});for _ ,_gafc :=range _bbad .Cells {if _gafc .Text !=""{_ecfc .WriteString (_gafc .Text );_ecfc .WriteString ("\u000a");};};return _ecfc .String ();};func (_afg ConditionalFormattingRule )InitializeDefaults (){_afg .SetType (_bcd .ST_CfTypeCellIs );
_afg .SetOperator (_bcd .ST_ConditionalFormattingOperatorGreaterThan );_afg .SetPriority (1);};

// Type returns the type of anchor
func (_baef TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };func (_cegg *evalContext )Cell (ref string ,ev _acb .Evaluator )_acb .Result {if !_geeg (ref ){return _acb .MakeErrorResultType (_acb .ErrorTypeName ,"");};_agc :=_cegg ._bge .Name ()+"\u0021"+ref ;
if _cfeg ,_geb :=ev .GetFromCache (_agc );_geb {return _cfeg ;};_dfdg ,_aca :=_gdc .ParseCellReference (ref );if _aca !=nil {return _acb .MakeErrorResult (_ebb .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_aca ));
};if _cegg ._dcdg !=0&&!_dfdg .AbsoluteColumn {_dfdg .ColumnIdx +=_cegg ._dcdg ;_dfdg .Column =_gdc .IndexToColumn (_dfdg .ColumnIdx );};if _cegg ._gbaf !=0&&!_dfdg .AbsoluteRow {_dfdg .RowIdx +=_cegg ._gbaf ;};_ebbf :=_cegg ._bge .Cell (_dfdg .String ());
if _ebbf .HasFormula (){if _ ,_cfca :=_cegg ._fbdf [ref ];_cfca {return _acb .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );
};_cegg ._fbdf [ref ]=struct{}{};_egdd :=ev .Eval (_cegg ,_ebbf .GetFormula ());delete (_cegg ._fbdf ,ref );ev .SetCache (_agc ,_egdd );return _egdd ;};if _ebbf .IsEmpty (){_bccd :=_acb .MakeEmptyResult ();ev .SetCache (_agc ,_bccd );return _bccd ;}else if _ebbf .IsNumber (){_eeg ,_ :=_ebbf .GetValueAsNumber ();
_bbff :=_acb .MakeNumberResult (_eeg );ev .SetCache (_agc ,_bbff );return _bbff ;}else if _ebbf .IsBool (){_afac ,_ :=_ebbf .GetValueAsBool ();_aeg :=_acb .MakeBoolResult (_afac );ev .SetCache (_agc ,_aeg );return _aeg ;};_bddb ,_ :=_ebbf .GetRawValue ();
if _ebbf .IsError (){_efg :=_acb .MakeErrorResult ("");_efg .ValueString =_bddb ;ev .SetCache (_agc ,_efg );return _efg ;};_dga :=_acb .MakeStringResult (_bddb );ev .SetCache (_agc ,_dga );return _dga ;};func (_fbfcc RichTextRun )ensureRpr (){if _fbfcc ._cegd .RPr ==nil {_fbfcc ._cegd .RPr =_bcd .NewCT_RPrElt ();
};};

// GetFormat returns a cell data format.
func (_cgge *evalContext )GetFormat (cellRef string )string {return _cgge ._bge .Cell (cellRef ).getFormat ();};func _bac (_edg bool )int {if _edg {return 1;};return 0;};

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_dcg CellStyle )SetHorizontalAlignment (a _bcd .ST_HorizontalAlignment ){if _dcg ._cbc .Alignment ==nil {_dcg ._cbc .Alignment =_bcd .NewCT_CellAlignment ();};_dcg ._cbc .Alignment .HorizontalAttr =a ;_dcg ._cbc .ApplyAlignmentAttr =_c .Bool (true );
};

// SetMaxLength sets the maximum bar length in percent.
func (_acdf DataBarScale )SetMaxLength (l uint32 ){_acdf ._gfe .MaxLengthAttr =_c .Uint32 (l )};type evalContext struct{_bge *Sheet ;_dcdg ,_gbaf uint32 ;_fbdf map[string ]struct{};};

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_cace *Sheet )SetDrawing (d Drawing ){var _fcca _ad .Relationships ;for _eff ,_bgfe :=range _cace ._feaa ._agbbg {if _bgfe ==_cace ._gbef {_fcca =_cace ._feaa ._dagcbb [_eff ];break ;};};var _dgef string ;for _dead ,_dcga :=range d ._cbfg ._edbf {if _dcga ==d ._bbaa {_bab :=_fcca .AddAutoRelationship (_c .DocTypeSpreadsheet ,_c .WorksheetType ,_dead +1,_c .DrawingType );
_dgef =_bab .ID ();break ;};};_cace ._gbef .Drawing =_bcd .NewCT_Drawing ();_cace ._gbef .Drawing .IdAttr =_dgef ;};

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_cad *evalContext )LastRow (col string )int {_fddfg :=_cad ._bge ;_deg :=int (_gdc .ColumnToIndex (col ));_ddf :=1;for _ ,_cbac :=range _fddfg ._gbef .SheetData .Row {if _cbac .RAttr !=nil {_fga :=Row {_fddfg ._feaa ,_fddfg ,_cbac };_cdfa :=len (_fga .Cells ());
if _cdfa > _deg {_ddf =int (_fga .RowNumber ());};};};return _ddf ;};func (_bgcb Sheet )validateSheetNames ()error {_fdgd :=len ([]rune (_bgcb .Name ()));if _fdgd > 31{return _ebb .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_bgcb .Name (),_fdgd );
};return nil ;};const _edde ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_aa ,_dbd int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_fe _ge .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_dgc int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_af _ge .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_ea int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_efa _ge .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_ae _ge .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};func (_eda Cell )GetRawValue ()(string ,error ){switch _eda ._de .TAttr {case _bcd .ST_CellTypeInlineStr :if _eda ._de .Is ==nil ||_eda ._de .Is .T ==nil {return "",nil ;};return *_eda ._de .Is .T ,nil ;case _bcd .ST_CellTypeS :if _eda ._de .V ==nil {return "",nil ;
};_dfc ,_abeg :=_cc .Atoi (*_eda ._de .V );if _abeg !=nil {return "",_abeg ;};return _eda ._fbc .SharedStrings .GetString (_dfc );case _bcd .ST_CellTypeStr :if _eda ._de .F !=nil {return _eda ._de .F .Content ,nil ;};};if _eda ._de .V ==nil {return "",nil ;
};return *_eda ._de .V ,nil ;};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_fgde Sheet )Validate ()error {_ggg :=[]func ()error {_fgde .validateRowCellNumbers ,_fgde .validateMergedCells ,_fgde .validateSheetNames };for _ ,_bacg :=range _ggg {if _cgeg :=_bacg ();_cgeg !=nil {return _cgeg ;};};if _bdgb :=_fgde ._gbef .Validate ();
_bdgb !=nil {return _bdgb ;};return _fgde ._gbef .Validate ();};

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_fada *Sheet )RemoveColumn (column string )error {_fbce ,_aege :=_fada .getAllCellsInFormulaArraysForColumn ();if _aege !=nil {return _aege ;};_egdb :=_gdc .ColumnToIndex (column );for _ ,_edeg :=range _fada .Rows (){_eggc :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_edeg .X ().RAttr );
if _ ,_bdec :=_fbce [_eggc ];_bdec {return nil ;};};for _ ,_gggd :=range _fada .Rows (){_egdfe :=_gggd ._dddc .C ;for _dagcb ,_fdba :=range _egdfe {_fagb ,_fbe :=_gdc .ParseCellReference (*_fdba .RAttr );if _fbe !=nil {return _fbe ;};if _fagb .ColumnIdx ==_egdb {_gggd ._dddc .C =append (_egdfe [:_dagcb ],_fada .slideCellsLeft (_egdfe [_dagcb +1:])...);
break ;}else if _fagb .ColumnIdx > _egdb {_gggd ._dddc .C =append (_egdfe [:_dagcb ],_fada .slideCellsLeft (_egdfe [_dagcb :])...);break ;};};};_aege =_fada .updateAfterRemove (_egdb ,_df .UpdateActionRemoveColumn );if _aege !=nil {return _aege ;};_aege =_fada .removeColumnFromNamedRanges (_egdb );
if _aege !=nil {return _aege ;};_aege =_fada .removeColumnFromMergedCells (_egdb );if _aege !=nil {return _aege ;};for _ ,_ccggg :=range _fada ._feaa .Sheets (){_ccggg .RecalculateFormulas ();};return nil ;};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_eaa TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_eaa ._adee .From }};

// Index returns the index of the differential style.
func (_gda DifferentialStyle )Index ()uint32 {for _dgga ,_def :=range _gda ._ffga .Dxf {if _gda ._bbb ==_def {return uint32 (_dgga );};};return 0;};

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_ccga *_bcd .CT_DataValidation };

// Validate attempts to validate the structure of a workbook.
func (_fcda *Workbook )Validate ()error {if _fcda ==nil ||_fcda ._dfdc ==nil {return _cf .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");
};_fcbc :=uint32 (0);for _ ,_adcgf :=range _fcda ._dfdc .Sheets .Sheet {if _adcgf .SheetIdAttr > _fcbc {_fcbc =_adcgf .SheetIdAttr ;};};if _fcbc !=uint32 (len (_fcda ._agbbg )){return _ebb .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_fcbc ,len (_fcda ._agbbg ));
};_dfcba :=map[string ]struct{}{};for _dbca ,_eefd :=range _fcda ._dfdc .Sheets .Sheet {_dbfc :=Sheet {_fcda ,_eefd ,_fcda ._agbbg [_dbca ]};if _ ,_babf :=_dfcba [_dbfc .Name ()];_babf {return _ebb .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_dbca ,_dbfc .Name ());
};_dfcba [_dbfc .Name ()]=struct{}{};if _fbec :=_dbfc .ValidateWithPath (_ebb .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_dbca ));_fbec !=nil {return _fbec ;};if _faacf :=_dbfc .Validate ();_faacf !=nil {return _faacf ;
};};return nil ;};

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_cgdg Row )Cell (col string )Cell {_afad :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",col ,_cgdg .RowNumber ());for _ ,_eaca :=range _cgdg ._dddc .C {if _eaca .RAttr !=nil &&*_eaca .RAttr ==_afad {return Cell {_cgdg ._ecag ,_cgdg ._dad ,_cgdg ._dddc ,_eaca };
};};return _cgdg .AddNamedCell (col );};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_fcb CellStyle )SetVerticalAlignment (a _bcd .ST_VerticalAlignment ){if _fcb ._cbc .Alignment ==nil {_fcb ._cbc .Alignment =_bcd .NewCT_CellAlignment ();};_fcb ._cbc .ApplyAlignmentAttr =_c .Bool (true );_fcb ._cbc .Alignment .VerticalAttr =a ;};


// Name returns the sheet name
func (_eddd Sheet )Name ()string {return _eddd ._ceda .NameAttr };

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_ccfb Cell )GetValueAsTime ()(_acc .Time ,error ){if _ccfb ._de .TAttr !=_bcd .ST_CellTypeUnset {return _acc .Time {},_cf .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");
};if _ccfb ._de .V ==nil {return _acc .Time {},_cf .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_gbfd ,_ ,_dgb :=_bgb .ParseFloat (*_ccfb ._de .V ,10,128,_bgb .ToNearestEven );if _dgb !=nil {return _acc .Time {},_dgb ;
};_gba :=new (_bgb .Float );_gba .SetUint64 (uint64 (24*_acc .Hour ));_gbfd .Mul (_gbfd ,_gba );_cb ,_ :=_gbfd .Uint64 ();_cdfb :=_ccfb ._fbc .Epoch ().Add (_acc .Duration (_cb ));return _debb (_cdfb ),nil ;};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_cgdge :=_bcd .NewStyleSheet ();_cgdge .CellStyleXfs =_bcd .NewCT_CellStyleXfs ();_cgdge .CellXfs =_bcd .NewCT_CellXfs ();_cgdge .CellStyles =_bcd .NewCT_CellStyles ();_dcad :=_bcd .NewCT_CellStyle ();_dcad .NameAttr =_c .String ("\u004e\u006f\u0072\u006d\u0061\u006c");
_dcad .XfIdAttr =0;_dcad .BuiltinIdAttr =_c .Uint32 (0);_cgdge .CellStyles .CellStyle =append (_cgdge .CellStyles .CellStyle ,_dcad );_cgdge .CellStyles .CountAttr =_c .Uint32 (uint32 (len (_cgdge .CellStyles .CellStyle )));_badd :=_bcd .NewCT_Xf ();_badd .NumFmtIdAttr =_c .Uint32 (0);
_badd .FontIdAttr =_c .Uint32 (0);_badd .FillIdAttr =_c .Uint32 (0);_badd .BorderIdAttr =_c .Uint32 (0);_cgdge .CellStyleXfs .Xf =append (_cgdge .CellStyleXfs .Xf ,_badd );_cgdge .CellStyleXfs .CountAttr =_c .Uint32 (uint32 (len (_cgdge .CellStyleXfs .Xf )));
_eadab :=NewFills ();_cgdge .Fills =_eadab .X ();_dbad :=_eadab .appendFill ().SetPatternFill ();_dbad .SetPattern (_bcd .ST_PatternTypeNone );_dbad =_eadab .appendFill ().SetPatternFill ();_dbad .SetPattern (_bcd .ST_PatternTypeGray125 );_cgdge .Fonts =_bcd .NewCT_Fonts ();
_cgdge .Borders =_bcd .NewCT_Borders ();_dace :=StyleSheet {wb ,_cgdge };_dace .appendBorder ().InitializeDefaults ();_dacdb :=_dace .appendFont ();_dacdb .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_dacdb .SetSize (11);_fgaf :=_bcd .NewCT_Xf ();
*_fgaf =*_badd ;_fgaf .XfIdAttr =_c .Uint32 (0);_cgdge .CellXfs .Xf =append (_cgdge .CellXfs .Xf ,_fgaf );_cgdge .CellXfs .CountAttr =_c .Uint32 (uint32 (len (_cgdge .CellXfs .Xf )));return _dace ;};

// X returns the inner wrapped XML type.
func (_agbb MergedCell )X ()*_bcd .CT_MergeCell {return _agbb ._fegcc };

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_gcag *evalContext )GetLabelPrefix (cellRef string )string {return _gcag ._bge .Cell (cellRef ).getLabelPrefix ();};func (_gbaff PatternFill )ClearFgColor (){_gbaff ._bea .FgColor =nil };

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_acbf *Workbook )GetChartByTargetId (targetAttr string )*_cd .ChartSpace {return _acbf ._bccce [targetAttr ];};

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_dbcf *Sheet )Cell (cellRef string )Cell {_dgbd ,_bbdb :=_gdc .ParseCellReference (cellRef );if _bbdb !=nil {_cfa .Log .Debug ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_bbdb );
return _dbcf .AddRow ().AddCell ();};return _dbcf .Row (_dgbd .RowIdx ).Cell (_dgbd .Column );};

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_cegd *_bcd .CT_RElt };

// ExtractText returns text from the workbook as a WorkbookText object.
func (_adcf *Workbook )ExtractText ()*WorkbookText {_edgb :=[]*SheetText {};for _ ,_afgd :=range _adcf .Sheets (){_edgb =append (_edgb ,&SheetText {Cells :_afgd .ExtractText ().Cells });};return &WorkbookText {Sheets :_edgb };};

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_aegbd :_bcd .NewSst (),_dcgd :make (map[string ]int )};};func (_aef Font )SetSize (size float64 ){_aef ._fgd .Sz =[]*_bcd .CT_FontSize {{ValAttr :size }}};

// HasFormula returns true if the cell has an asoociated formula.
func (_cba Cell )HasFormula ()bool {return _cba ._de .F !=nil };func (_adbd Font )SetName (name string ){_adbd ._fgd .Name =[]*_bcd .CT_FontName {{ValAttr :name }}};

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_ecegd *Workbook )Uses1904Dates ()bool {if _ecegd ._dfdc .WorkbookPr ==nil ||_ecegd ._dfdc .WorkbookPr .Date1904Attr ==nil {return false ;};return *_ecegd ._dfdc .WorkbookPr .Date1904Attr ;};

// MaxColumnIdx returns the max used column of the sheet.
func (_gced Sheet )MaxColumnIdx ()uint32 {_bag :=uint32 (0);for _ ,_bbbe :=range _gced .Rows (){_eddg :=_bbbe ._dddc .C ;if len (_eddg )> 0{_dfa :=_eddg [len (_eddg )-1];_fbfad ,_ :=_gdc .ParseCellReference (*_dfa .RAttr );if _bag < _fbfad .ColumnIdx {_bag =_fbfad .ColumnIdx ;
};};};return _bag ;};type Fills struct{_cda *_bcd .CT_Fills };

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_gecf *_bcd .CT_Rst };

// SetHyperlink sets a hyperlink on a cell.
func (_eac Cell )SetHyperlink (hl _ad .Hyperlink ){_gfc :=_eac ._ebg ._gbef ;if _gfc .Hyperlinks ==nil {_gfc .Hyperlinks =_bcd .NewCT_Hyperlinks ();};_ebd :=_ad .Relationship (hl );_gbaa :=_bcd .NewCT_Hyperlink ();_gbaa .RefAttr =_eac .Reference ();_gbaa .IdAttr =_c .String (_ebd .ID ());
_gfc .Hyperlinks .Hyperlink =append (_gfc .Hyperlinks .Hyperlink ,_gbaa );};

// Content returns the content of the defined range (the range in most cases)/
func (_gbag DefinedName )Content ()string {return _gbag ._bcbee .Content };var _gbafb []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};


// Author returns the author of the comment
func (_dacd Comment )Author ()string {if _dacd ._aaef .AuthorIdAttr < uint32 (len (_dacd ._add .Authors .Author )){return _dacd ._add .Authors .Author [_dacd ._aaef .AuthorIdAttr ];};return "";};

// ClearProtection removes any protections applied to teh sheet.
func (_gdde *Sheet )ClearProtection (){_gdde ._gbef .SheetProtection =nil };

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _ef .ReaderAt ,size int64 )(*Workbook ,error ){const _cgcb ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_ca .GetLicenseKey ().IsLicensed ()&&!_aabd {_ebb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ebb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return nil ,_cf .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_bgga :=New ();_fcce ,_bgd :=_ca .GenRefId ("\u0073\u0072");if _bgd !=nil {_cfa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bgd );
return nil ,_bgd ;};_bgga ._dabb =_fcce ;if _ecef :=_ca .Track (_bgga ._dabb ,_cgcb );_ecef !=nil {_cfa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_ecef );return nil ,_ecef ;};_cbb ,_bgd :=_fgb .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");
if _bgd !=nil {return nil ,_bgd ;};_bgga .TmpPath =_cbb ;_dafa ,_bgd :=_gc .NewReader (r ,size );if _bgd !=nil {return nil ,_ebb .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_bgd );};_dab :=[]*_gc .File {};
_dab =append (_dab ,_dafa .File ...);_ffbb :=false ;for _ ,_fcgd :=range _dab {if _fcgd .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_ffbb =true ;break ;};};if _ffbb {_bgga .CreateCustomProperties ();
};_deca :=_bc .DecodeMap {};_deca .SetOnNewRelationshipFunc (_bgga .onNewRelationship );_deca .AddTarget (_c .ContentTypesFilename ,_bgga .ContentTypes .X (),"",0);_deca .AddTarget (_c .BaseRelsFilename ,_bgga .Rels .X (),"",0);if _fadb :=_deca .Decode (_dab );
_fadb !=nil {return nil ,_fadb ;};for _ ,_fggf :=range _dab {if _fggf ==nil {continue ;};if _fegd :=_bgga .AddExtraFileFromZip (_fggf );_fegd !=nil {return nil ,_fegd ;};};if _ffbb {_fbdc :=false ;for _ ,_ggb :=range _bgga .Rels .X ().Relationship {if _ggb .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_fbdc =true ;
break ;};};if !_fbdc {_bgga .AddCustomRelationships ();};};return _bgga ,nil ;};

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_ffag *Sheet )RecalculateFormulas (){_acge :=_acb .NewEvaluator ();_bgcf :=_ffag .FormulaContext ();for _ ,_bgaa :=range _ffag .Rows (){for _ ,_daff :=range _bgaa .Cells (){if _daff .X ().F !=nil {_beabg :=_daff .X ().F .Content ;if _daff .X ().F .TAttr ==_bcd .ST_CellFormulaTypeShared &&len (_beabg )==0{continue ;
};_baed :=_acge .Eval (_bgcf ,_beabg ).AsString ();if _baed .Type ==_acb .ResultTypeError {_cfa .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_beabg ,_baed .ErrorMessage );
_daff .X ().V =nil ;}else {if _baed .Type ==_acb .ResultTypeNumber {_daff .X ().TAttr =_bcd .ST_CellTypeN ;}else {_daff .X ().TAttr =_bcd .ST_CellTypeInlineStr ;};_daff .X ().V =_c .String (_baed .Value ());if _daff .X ().F .TAttr ==_bcd .ST_CellFormulaTypeArray {if _baed .Type ==_acb .ResultTypeArray {_ffag .setArray (_daff .Reference (),_baed );
}else if _baed .Type ==_acb .ResultTypeList {_ffag .setList (_daff .Reference (),_baed );};}else if _daff .X ().F .TAttr ==_bcd .ST_CellFormulaTypeShared &&_daff .X ().F .RefAttr !=nil {_feef ,_aagf ,_daee :=_gdc .ParseRangeReference (*_daff .X ().F .RefAttr );
if _daee !=nil {_cfa .Log .Debug ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_daee );continue ;
};_ffag .setShared (_daff .Reference (),_feef ,_aagf ,_beabg );};};};};};};

// ClearNumberFormat removes any number formatting from the style.
func (_abd CellStyle )ClearNumberFormat (){_abd ._cbc .NumFmtIdAttr =nil ;_abd ._cbc .ApplyNumberFormatAttr =nil ;};

// PasswordHash returns the hash of the workbook password.
func (_ebgg SheetProtection )PasswordHash ()string {if _ebgg ._fggg .PasswordAttr ==nil {return "";};return *_ebgg ._fggg .PasswordAttr ;};

// AddFormatValue adds a format value (databars require two).
func (_fcbg DataBarScale )AddFormatValue (t _bcd .ST_CfvoType ,val string ){_egf :=_bcd .NewCT_Cfvo ();_egf .TypeAttr =t ;_egf .ValAttr =_c .String (val );_fcbg ._gfe .Cfvo =append (_fcbg ._gfe .Cfvo ,_egf );};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_gfdc *_bcd .CT_DataValidation };func (_fbb Cell )setLocked (_gbdf bool ){_gbe :=_fbb ._de .SAttr ;if _gbe !=nil {_ba :=_fbb ._fbc .StyleSheet .GetCellStyle (*_gbe );if _ba ._cbc .Protection ==nil {_ba ._cbc .Protection =_bcd .NewCT_CellProtection ();
};_ba ._cbc .Protection .LockedAttr =&_gbdf ;};};

// SetPassword sets the password hash to a hash of the input password.
func (_gdfa SheetProtection )SetPassword (pw string ){_gdfa .SetPasswordHash (PasswordHash (pw ))};

// GetFont gets a Font from a cell style.
func (_cegb CellStyle )GetFont ()*_bcd .CT_Font {if _bbe :=_cegb ._cbc .FontIdAttr ;_bbe !=nil {_bcc :=_cegb ._edbc .StyleSheet .Fonts ();if int (*_bbe )< len (_bcc ){return _bcc [int (*_bbe )].X ();};};return nil ;};

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_gddeb SheetView )SetState (st _bcd .ST_PaneState ){_gddeb .ensurePane ();_gddeb ._adcgcf .Pane .StateAttr =st ;};func (_dffa StandardFormat )String ()string {switch {case 0<=_dffa &&_dffa <=4:return _efcg [_gfab [_dffa ]:_gfab [_dffa +1]];case 9<=_dffa &&_dffa <=22:_dffa -=9;
return _eaeg [_cacf [_dffa ]:_cacf [_dffa +1]];case 37<=_dffa &&_dffa <=40:_dffa -=37;return _cggaee [_addd [_dffa ]:_addd [_dffa +1]];case 45<=_dffa &&_dffa <=49:_dffa -=45;return _ccdd [_cacdc [_dffa ]:_cacdc [_dffa +1]];default:return _ebb .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_dffa );
};};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_gfad *Workbook )AddImage (i _ad .Image )(_ad .ImageRef ,error ){_aecb :=_ad .MakeImageRef (i ,&_gfad .DocBase ,_gfad ._dcef );if i .Data ==nil &&i .Path ==""{return _aecb ,_cf .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");
};if i .Format ==""{return _aecb ,_cf .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _aecb ,_cf .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");
};if i .Path !=""{_bfef :=_fgb .Add (i .Path );if _bfef !=nil {return _aecb ,_bfef ;};};_gfad .Images =append (_gfad .Images ,_aecb );return _aecb ,nil ;};

// GetFormat sets the number format code.
func (_fgg NumberFormat )GetFormat ()string {return _fgg ._ccge .FormatCodeAttr };func (_bcdf *Sheet )setList (_eace string ,_ceb _acb .Result )error {_afggc ,_bfagf :=_gdc .ParseCellReference (_eace );if _bfagf !=nil {return _bfagf ;};_dcgg :=_bcdf .Row (_afggc .RowIdx );
for _cgagb ,_ecdc :=range _ceb .ValueList {_ceae :=_dcgg .Cell (_gdc .IndexToColumn (_afggc .ColumnIdx +uint32 (_cgagb )));if _ecdc .Type !=_acb .ResultTypeEmpty {if _ecdc .IsBoolean {_ceae .SetBool (_ecdc .ValueNumber !=0);}else {_ceae .SetCachedFormulaResult (_ecdc .String ());
};};};return nil ;};

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_fdfed *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_deef :=_fdfed ._gbef .SheetData .Row ;_edf :=_fdfed .Rows ();for _ecg ,_baca :=range _edf {if _baca .RowNumber ()==firstRow {_deef =_fdfed ._gbef .SheetData .Row [_ecg :];break ;
};};_cddb :=Comparer {Order :order };_b .Slice (_deef ,func (_abc ,_cfdee int )bool {return _cddb .LessRows (column ,Row {_fdfed ._feaa ,_fdfed ,_deef [_abc ]},Row {_fdfed ._feaa ,_fdfed ,_deef [_cfdee ]});});for _fddb ,_cggg :=range _fdfed .Rows (){_ffgf :=uint32 (_fddb +1);
if _cggg .RowNumber ()!=_ffgf {_cggg .renumberAs (_ffgf );};};};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_cgae *evalContext )LastColumn (rowFrom ,rowTo int )string {_abb :=_cgae ._bge ;_fged :=1;for _eegg :=rowFrom ;_eegg <=rowTo ;_eegg ++{_cdfc :=len (_abb .Row (uint32 (_eegg )).Cells ());if _cdfc > _fged {_fged =_cdfc ;};};return _gdc .IndexToColumn (uint32 (_fged -1));
};

// AddRun adds a new run of text to the cell.
func (_dgeg RichText )AddRun ()RichTextRun {_febfd :=_bcd .NewCT_RElt ();_dgeg ._gecf .R =append (_dgeg ._gecf .R ,_febfd );return RichTextRun {_febfd };};

// GetEpoch returns a workbook's time epoch.
func (_cfcac *evalContext )GetEpoch ()_acc .Time {return _cfcac ._bge ._feaa .Epoch ()};var _aacd *_bg .Regexp =_bg .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// SetYSplit sets the row split point
func (_dbff SheetView )SetYSplit (v float64 ){_dbff .ensurePane ();_dbff ._adcgcf .Pane .YSplitAttr =_c .Float64 (v );};

// Name returns the name of the defined name.
func (_gafa DefinedName )Name ()string {return _gafa ._bcbee .NameAttr };

// X returns the inner wrapped XML type.
func (_eeaf Drawing )X ()*_bgg .WsDr {return _eeaf ._bbaa };

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_eeb CellStyle )SetFont (f Font ){_adaf :=f ._dbbf .Fonts .Font ;for _ ,_ebde :=range _adaf {if _eb .DeepEqual (_ebde ,f ._fgd ){f ._fgd =_ebde ;_eeb ._cbc .FontIdAttr =_c .Uint32 (f .Index ());_eeb ._cbc .ApplyFontAttr =_c .Bool (true );return ;
};};f ._dbbf .Fonts .Font =append (f ._dbbf .Fonts .Font ,f ._fgd );f ._dbbf .Fonts .CountAttr =_c .Uint32 (uint32 (len (f ._dbbf .Fonts .Font )));_eeb ._cbc .FontIdAttr =_c .Uint32 (f .Index ());_eeb ._cbc .ApplyFontAttr =_c .Bool (true );};

// SetRowOffset sets the row offset of the top-left anchor.
func (_affg OneCellAnchor )SetRowOffset (m _ge .Distance ){_affg .TopLeft ().SetRowOffset (m )};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// BottomRight is a no-op.
func (_bcfd OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// SetHidden hides or unhides the row
func (_gdd Row )SetHidden (hidden bool ){if !hidden {_gdd ._dddc .HiddenAttr =nil ;}else {_gdd ._dddc .HiddenAttr =_c .Bool (true );};};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_ccbf IconScale )AddFormatValue (t _bcd .ST_CfvoType ,val string ){_gbbaf :=_bcd .NewCT_Cfvo ();_gbbaf .TypeAttr =t ;_gbbaf .ValAttr =_c .String (val );_ccbf ._aggd .Cfvo =append (_ccbf ._aggd .Cfvo ,_gbbaf );};func (_fcbf *Sheet )slideCellsLeft (_bdeb []*_bcd .CT_Cell )[]*_bcd .CT_Cell {for _ ,_ebef :=range _bdeb {_feag ,_fegeg :=_gdc .ParseCellReference (*_ebef .RAttr );
if _fegeg !=nil {return _bdeb ;};_fbcd :=_feag .ColumnIdx -1;_ade :=_gdc .IndexToColumn (_fbcd )+_ebb .Sprintf ("\u0025\u0064",_feag .RowIdx );_ebef .RAttr =&_ade ;};return _bdeb ;};

// SetWidth sets the width of the anchored object.
func (_gcbd OneCellAnchor )SetWidth (w _ge .Distance ){_gcbd ._acg .Ext .CxAttr =int64 (w /_ge .EMU )};

// AddFill creates a new empty Fill style.
func (_cfdge Fills )AddFill ()Fill {_ebbb :=_bcd .NewCT_Fill ();return Fill {_ebbb ,_cfdge ._cda }};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_gff DataValidationCompare )SetValue (v string ){_gff ._ccga .Formula1 =&v };

// ClearAutoFilter removes the autofilters from the sheet.
func (_dffef *Sheet )ClearAutoFilter (){_dffef ._gbef .AutoFilter =nil ;_ebfd :="\u0027"+_dffef .Name ()+"\u0027\u0021";for _ ,_dde :=range _dffef ._feaa .DefinedNames (){if _dde .Name ()==_edde {if _fg .HasPrefix (_dde .Content (),_ebfd ){_dffef ._feaa .RemoveDefinedName (_dde );
break ;};};};};

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_dge Cell )SetBool (v bool ){_dge .clearValue ();_dge ._de .V =_c .String (_cc .Itoa (_bac (v )));_dge ._de .TAttr =_bcd .ST_CellTypeB ;};

// SetPriority sets the rule priority
func (_acd ConditionalFormattingRule )SetPriority (p int32 ){_acd ._faa .PriorityAttr =p };

// Sheets returns the sheets from the workbook.
func (_daagg *Workbook )Sheets ()[]Sheet {_egega :=[]Sheet {};for _eafd ,_bggca :=range _daagg ._agbbg {_ddbd :=_daagg ._dfdc .Sheets .Sheet [_eafd ];_bbcc :=Sheet {_daagg ,_ddbd ,_bggca };_egega =append (_egega ,_bbcc );};return _egega ;};func (_abda Fill )Index ()uint32 {if _abda ._bbfa ==nil {return 0;
};for _ddb ,_adfg :=range _abda ._bbfa .Fill {if _abda ._cggag ==_adfg {return uint32 (_ddb );};};return 0;};

// SetLocked sets cell locked or not.
func (_gfbd *evalContext )SetLocked (cellRef string ,locked bool ){_gfbd ._bge .Cell (cellRef ).setLocked (locked );};const (DVOpGreater =_bcd .ST_DataValidationOperatorGreaterThanOrEqual ;);var _fgc =_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .SharedStringsType ,0);
type DifferentialStyle struct{_bbb *_bcd .CT_Dxf ;_ffca *Workbook ;_ffga *_bcd .CT_Dxfs ;};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_edgfa TwoCellAnchor )SetHeightCells (h int32 ){_edgfa .SetHeight (0);_efbg :=_edgfa .TopLeft ();_bfdfc :=_edgfa .BottomRight ();_bfdfc .SetRow (_efbg .Row ()+h );};

// SetHeightAuto sets the row height to be automatically determined.
func (_afge Row )SetHeightAuto (){_afge ._dddc .HtAttr =nil ;_afge ._dddc .CustomHeightAttr =nil };

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_cbg Cell )SetCachedFormulaResult (s string ){_cbg ._de .V =&s };

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_dbgc Cell )GetString ()string {switch _dbgc ._de .TAttr {case _bcd .ST_CellTypeInlineStr :if _dbgc ._de .Is !=nil &&_dbgc ._de .Is .T !=nil {return *_dbgc ._de .Is .T ;};if _dbgc ._de .V !=nil {return *_dbgc ._de .V ;};case _bcd .ST_CellTypeS :if _dbgc ._de .V ==nil {return "";
};_ffcb ,_fbd :=_cc .Atoi (*_dbgc ._de .V );if _fbd !=nil {return "";};_gab ,_fbd :=_dbgc ._fbc .SharedStrings .GetString (_ffcb );if _fbd !=nil {return "";};return _gab ;};if _dbgc ._de .V ==nil {return "";};return *_dbgc ._de .V ;};

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_eadb *Sheet )InitialView ()SheetView {if _eadb ._gbef .SheetViews ==nil ||len (_eadb ._gbef .SheetViews .SheetView )==0{return _eadb .AddView ();};return SheetView {_eadb ._gbef .SheetViews .SheetView [0]};};

// X returns the inner wrapped XML type.
func (_fdcd DefinedName )X ()*_bcd .CT_DefinedName {return _fdcd ._bcbee };

// GetFormula returns the formula for a cell.
func (_cgd Cell )GetFormula ()string {if _cgd ._de .F !=nil {return _cgd ._de .F .Content ;};return "";};

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_gebc Drawing )AddChart (at AnchorType )(_gcc .Chart ,Anchor ){_fda :=_cd .NewChartSpace ();_gebc ._cbfg ._bfda =append (_gebc ._cbfg ._bfda ,_fda );_bfbg :=_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .ChartContentType ,len (_gebc ._cbfg ._bfda ));
_gebc ._cbfg .ContentTypes .AddOverride (_bfbg ,_c .ChartContentType );var _cgb string ;for _bbfb ,_eca :=range _gebc ._cbfg ._edbf {if _eca ==_gebc ._bbaa {_bcgd :=_c .RelativeFilename (_c .DocTypeSpreadsheet ,_c .DrawingType ,_c .ChartType ,len (_gebc ._cbfg ._bfda ));
_faf :=_gebc ._cbfg ._fbfbf [_bbfb ].AddRelationship (_bcgd ,_c .ChartType );_cgb =_faf .ID ();break ;};};var _cadf Anchor ;var _eagf *_bgg .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_ccgb :=_efcb ();_gebc ._bbaa .EG_Anchor =append (_gebc ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {AbsoluteAnchor :_ccgb });
_ccgb .Choice =&_bgg .EG_ObjectChoicesChoice {};_ccgb .Choice .GraphicFrame =_bgg .NewCT_GraphicalObjectFrame ();_eagf =_ccgb .Choice .GraphicFrame ;_cadf =AbsoluteAnchor {_ccgb };case AnchorTypeOneCell :_gg :=_bfdf ();_gebc ._bbaa .EG_Anchor =append (_gebc ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {OneCellAnchor :_gg });
_gg .Choice =&_bgg .EG_ObjectChoicesChoice {};_gg .Choice .GraphicFrame =_bgg .NewCT_GraphicalObjectFrame ();_eagf =_gg .Choice .GraphicFrame ;_cadf =OneCellAnchor {_gg };case AnchorTypeTwoCell :_dcfg :=_fbfc ();_gebc ._bbaa .EG_Anchor =append (_gebc ._bbaa .EG_Anchor ,&_bgg .EG_Anchor {TwoCellAnchor :_dcfg });
_dcfg .Choice =&_bgg .EG_ObjectChoicesChoice {};_dcfg .Choice .GraphicFrame =_bgg .NewCT_GraphicalObjectFrame ();_eagf =_dcfg .Choice .GraphicFrame ;_cadf =TwoCellAnchor {_dcfg };};_eagf .NvGraphicFramePr =_bgg .NewCT_GraphicalObjectFrameNonVisual ();_eagf .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_gebc ._bbaa .EG_Anchor ));
_eagf .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_eagf .Graphic =_dg .NewGraphic ();_eagf .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";
_bbag :=_cd .NewChart ();_bbag .IdAttr =_cgb ;_eagf .Graphic .GraphicData .Any =[]_c .Any {_bbag };_ega :=_gcc .MakeChart (_fda );_ega .Properties ().SetSolidFill (_ffb .White );_ega .SetDisplayBlanksAs (_cd .ST_DispBlanksAsGap );return _ega ,_cadf ;};
var ErrorNotFound =_cf .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_fed PatternFill )SetFgColor (c _ffb .Color ){_fed ._bea .FgColor =_bcd .NewCT_Color ();_fed ._bea .FgColor .RgbAttr =c .AsRGBAString ();};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_ebdec DataValidationList )SetRange (cellRange string ){_ebdec ._gfdc .Formula1 =_c .String (cellRange );_ebdec ._gfdc .Formula2 =_c .String ("\u0030");};

// ColOffset returns the offset from the row cell.
func (_dbb CellMarker )ColOffset ()_ge .Distance {if _dbb ._dfd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ge .Distance (float64 (*_dbb ._dfd .ColOff .ST_CoordinateUnqualified )*_ge .EMU );};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_bbda CellStyle )HasNumberFormat ()bool {return _bbda ._cbc .NumFmtIdAttr !=nil &&_bbda ._cbc .ApplyNumberFormatAttr !=nil &&*_bbda ._cbc .ApplyNumberFormatAttr ;};

// Protection allows control over the workbook protections.
func (_gege *Workbook )Protection ()WorkbookProtection {if _gege ._dfdc .WorkbookProtection ==nil {_gege ._dfdc .WorkbookProtection =_bcd .NewCT_WorkbookProtection ();};return WorkbookProtection {_gege ._dfdc .WorkbookProtection };};

// AddString adds a string to the shared string cache.
func (_fcgg SharedStrings )AddString (v string )int {if _bdcdb ,_bbab :=_fcgg ._dcgd [v ];_bbab {return _bdcdb ;};_ccfc :=_bcd .NewCT_Rst ();_ccfc .T =_c .String (v );_fcgg ._aegbd .Si =append (_fcgg ._aegbd .Si ,_ccfc );_dbba :=len (_fcgg ._aegbd .Si )-1;
_fcgg ._dcgd [v ]=_dbba ;_fcgg ._aegbd .CountAttr =_c .Uint32 (uint32 (len (_fcgg ._aegbd .Si )));_fcgg ._aegbd .UniqueCountAttr =_fcgg ._aegbd .CountAttr ;return _dbba ;};func (_fcga *Sheet )removeColumnFromNamedRanges (_gadgc uint32 )error {for _ ,_bgcfb :=range _fcga ._feaa .DefinedNames (){_ffcg :=_bgcfb .Name ();
_eafa :=_bgcfb .Content ();_bggcc :=_fg .Split (_eafa ,"\u0021");if len (_bggcc )!=2{return _cf .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_eafa );};_baacd :=_bggcc [0];
if _fcga .Name ()==_baacd {_dagg :=_fcga ._feaa .RemoveDefinedName (_bgcfb );if _dagg !=nil {return _dagg ;};_egeg :=_befcg (_bggcc [1],_gadgc ,true );if _egeg !=""{_agcf :=_baacd +"\u0021"+_egeg ;_fcga ._feaa .AddDefinedName (_ffcg ,_agcf );};};};_dcfc :=0;
if _fcga ._gbef .TableParts !=nil &&_fcga ._gbef .TableParts .TablePart !=nil {_dcfc =len (_fcga ._gbef .TableParts .TablePart );};if _dcfc !=0{_cgde :=0;for _ ,_cgdc :=range _fcga ._feaa .Sheets (){if _cgdc .Name ()==_fcga .Name (){break ;}else {if _cgdc ._gbef .TableParts !=nil &&_cgdc ._gbef .TableParts .TablePart !=nil {_cgde +=len (_cgdc ._gbef .TableParts .TablePart );
};};};_cfbcb :=_fcga ._feaa ._cfgf [_cgde :_cgde +_dcfc ];for _ebefd ,_bfdc :=range _cfbcb {_bedd :=_bfdc ;_bedd .RefAttr =_befcg (_bedd .RefAttr ,_gadgc ,false );_fcga ._feaa ._cfgf [_cgde +_ebefd ]=_bedd ;};};return nil ;};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_aegbd *_bcd .Sst ;_dcgd map[string ]int ;};

// SetIcons sets the icon set to use for display.
func (_edgg IconScale )SetIcons (t _bcd .ST_IconSetType ){_edgg ._aggd .IconSetAttr =t };func (_fage SheetView )ensurePane (){if _fage ._adcgcf .Pane ==nil {_fage ._adcgcf .Pane =_bcd .NewCT_Pane ();_fage ._adcgcf .Pane .ActivePaneAttr =_bcd .ST_PaneBottomLeft ;
};};

// SetMinLength sets the minimum bar length in percent.
func (_aag DataBarScale )SetMinLength (l uint32 ){_aag ._gfe .MinLengthAttr =_c .Uint32 (l )};

// IsHidden returns whether the row is hidden or not.
func (_aed Row )IsHidden ()bool {return _aed ._dddc .HiddenAttr !=nil &&*_aed ._dddc .HiddenAttr };

// AddDataValidation adds a data validation rule to a sheet.
func (_adabd *Sheet )AddDataValidation ()DataValidation {if _adabd ._gbef .DataValidations ==nil {_adabd ._gbef .DataValidations =_bcd .NewCT_DataValidations ();};_dbgf :=_bcd .NewCT_DataValidation ();_dbgf .ShowErrorMessageAttr =_c .Bool (true );_adabd ._gbef .DataValidations .DataValidation =append (_adabd ._gbef .DataValidations .DataValidation ,_dbgf );
_adabd ._gbef .DataValidations .CountAttr =_c .Uint32 (uint32 (len (_adabd ._gbef .DataValidations .DataValidation )));return DataValidation {_dbgf };};

// TopLeft returns the top-left corner of the anchored object.
func (_fad OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_fad ._acg .From }};type WorkbookProtection struct{_deed *_bcd .CT_WorkbookProtection };

// X returns the inner wrapped XML type.
func (_eagb ConditionalFormatting )X ()*_bcd .CT_ConditionalFormatting {return _eagb ._ccb };

// SetConditionValue sets the condition value to be used for style applicaton.
func (_abdc ConditionalFormattingRule )SetConditionValue (v string ){_abdc ._faa .Formula =[]string {v }};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_gec Cell )AddHyperlink (url string ){for _cfb ,_dedf :=range _gec ._fbc ._agbbg {if _dedf ==_gec ._ebg ._gbef {_gec .SetHyperlink (_gec ._fbc ._dagcbb [_cfb ].AddHyperlink (url ));return ;};};};

// X returns the inner XML entity for a stylesheet.
func (_cbabf StyleSheet )X ()*_bcd .StyleSheet {return _cbabf ._gaff };

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_dee *Sheet )AddNumberedRow (rowNum uint32 )Row {_geeb :=_bcd .NewCT_Row ();_geeb .RAttr =_c .Uint32 (rowNum );_dee ._gbef .SheetData .Row =append (_dee ._gbef .SheetData .Row ,_geeb );_b .Slice (_dee ._gbef .SheetData .Row ,func (_cfac ,_bggba int )bool {_baf :=_dee ._gbef .SheetData .Row [_cfac ].RAttr ;
_adcfe :=_dee ._gbef .SheetData .Row [_bggba ].RAttr ;if _baf ==nil {return true ;};if _adcfe ==nil {return true ;};return *_baf < *_adcfe ;});return Row {_dee ._feaa ,_dee ,_geeb };};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_gbba Comment )CellReference ()string {return _gbba ._aaef .RefAttr };

// X returns the inner wrapped XML type.
func (_cac NumberFormat )X ()*_bcd .CT_NumFmt {return _cac ._ccge };

// MoveTo is a no-op.
func (_adg AbsoluteAnchor )MoveTo (x ,y int32 ){};

// Comments returns the comments for a sheet.
func (_badc *Sheet )Comments ()Comments {for _aacde ,_aaafe :=range _badc ._feaa ._agbbg {if _aaafe ==_badc ._gbef {if _badc ._feaa ._bfdfd [_aacde ]==nil {_badc ._feaa ._bfdfd [_aacde ]=_bcd .NewComments ();_badc ._feaa ._dagcbb [_aacde ].AddAutoRelationship (_c .DocTypeSpreadsheet ,_c .WorksheetType ,_aacde +1,_c .CommentsType );
_badc ._feaa .ContentTypes .AddOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .CommentsType ,_aacde +1),_c .CommentsContentType );};if len (_badc ._feaa ._fgga )==0{_badc ._feaa ._fgga =append (_badc ._feaa ._fgga ,_ed .NewCommentDrawing ());
_cfgc :=_badc ._feaa ._dagcbb [_aacde ].AddAutoRelationship (_c .DocTypeSpreadsheet ,_c .WorksheetType ,1,_c .VMLDrawingType );if _badc ._gbef .LegacyDrawing ==nil {_badc ._gbef .LegacyDrawing =_bcd .NewCT_LegacyDrawing ();};_badc ._gbef .LegacyDrawing .IdAttr =_cfgc .ID ();
};return Comments {_badc ._feaa ,_badc ._feaa ._bfdfd [_aacde ]};};};_cfa .Log .Debug ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");
return Comments {};};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};var (_gfab =[...]uint8 {0,21,46,61,76,91};_cacf =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_addd =[...]uint8 {0,16,32,48,64};_cacdc =[...]uint8 {0,16,32,48,64,80};);

// GetBorder gets a Border from a cell style.
func (_cfg CellStyle )GetBorder ()*_bcd .CT_Border {if _daf :=_cfg ._cbc .BorderIdAttr ;_daf !=nil {_efd :=_cfg ._edbc .StyleSheet .Borders ();if int (*_daf )< len (_efd ){return _efd [int (*_daf )].X ();};};return nil ;};

// AddCellStyle creates a new empty cell style.
func (_dgge StyleSheet )AddCellStyle ()CellStyle {_edge :=_bcd .NewCT_Xf ();return CellStyle {_dgge ._edgf ,_edge ,_dgge ._gaff .CellXfs };};func (_fegdb *Sheet )getAllCellsInFormulaArrays (_bgda bool )(map[string ]bool ,error ){_cca :=_acb .NewEvaluator ();
_fggb :=_fegdb .FormulaContext ();_ggbd :=map[string ]bool {};for _ ,_aead :=range _fegdb .Rows (){for _ ,_abbca :=range _aead .Cells (){if _abbca .X ().F !=nil {_egdee :=_abbca .X ().F .Content ;if _abbca .X ().F .TAttr ==_bcd .ST_CellFormulaTypeArray {_fcbga :=_cca .Eval (_fggb ,_egdee ).AsString ();
if _fcbga .Type ==_acb .ResultTypeError {_cfa .Log .Debug ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_egdee ,_fcbga .ErrorMessage );
_abbca .X ().V =nil ;};if _fcbga .Type ==_acb .ResultTypeArray {_gcad ,_bcgde :=_gdc .ParseCellReference (_abbca .Reference ());if _bcgde !=nil {return map[string ]bool {},_bcgde ;};if (_bgda &&len (_fcbga .ValueArray )==1)||(!_bgda &&len (_fcbga .ValueArray [0])==1){continue ;
};for _fabb ,_eecd :=range _fcbga .ValueArray {_gae :=_gcad .RowIdx +uint32 (_fabb );for _fbcda :=range _eecd {_ffbbg :=_gdc .IndexToColumn (_gcad .ColumnIdx +uint32 (_fbcda ));_ggbd [_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_ffbbg ,_gae )]=true ;};};
}else if _fcbga .Type ==_acb .ResultTypeList {_aebfe ,_fbgc :=_gdc .ParseCellReference (_abbca .Reference ());if _fbgc !=nil {return map[string ]bool {},_fbgc ;};if _bgda ||len (_fcbga .ValueList )==1{continue ;};_dgcde :=_aebfe .RowIdx ;for _eada :=range _fcbga .ValueList {_cecb :=_gdc .IndexToColumn (_aebfe .ColumnIdx +uint32 (_eada ));
_ggbd [_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_cecb ,_dgcde )]=true ;};};};};};};return _ggbd ,nil ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_cfafc *Workbook )DefinedNames ()[]DefinedName {if _cfafc ._dfdc .DefinedNames ==nil {return nil ;};_ecaa :=[]DefinedName {};for _ ,_ebfa :=range _cfafc ._dfdc .DefinedNames .DefinedName {_ecaa =append (_ecaa ,DefinedName {_ebfa });};return _ecaa ;
};

// X returns the inner wrapped XML type.
func (_cfab RichTextRun )X ()*_bcd .CT_RElt {return _cfab ._cegd };

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_fedff TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_fedff ._adee .To }};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_ace :=NumberFormat {_ccge :_bcd .NewCT_NumFmt ()};_ace ._ccge .NumFmtIdAttr =uint32 (id );_ace ._ccge .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";
switch id {case StandardFormat0 :_ace ._ccge .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_ace ._ccge .FormatCodeAttr ="\u0030";case StandardFormat2 :_ace ._ccge .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_ace ._ccge .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";
case StandardFormat4 :_ace ._ccge .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_ace ._ccge .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_ace ._ccge .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_ace ._ccge .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";
case StandardFormat12 :_ace ._ccge .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_ace ._ccge .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_ace ._ccge .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";
case StandardFormat15 :_ace ._ccge .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_ace ._ccge .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_ace ._ccge .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";
case StandardFormat18 :_ace ._ccge .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_ace ._ccge .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_ace ._ccge .FormatCodeAttr ="\u0068\u003a\u006d\u006d";
case StandardFormat21 :_ace ._ccge .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_ace ._ccge .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_ace ._ccge .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";
case StandardFormat38 :_ace ._ccge .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_ace ._ccge .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";
case StandardFormat40 :_ace ._ccge .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_ace ._ccge .FormatCodeAttr ="\u006d\u006d\u003as\u0073";
case StandardFormat46 :_ace ._ccge .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_ace ._ccge .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_ace ._ccge .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";
case StandardFormat49 :_ace ._ccge .FormatCodeAttr ="\u0040";};return _ace ;};func (_gbc Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _agbg ,_agfg ,_agaa ,_baab uint32 =1,1,0,0;for _ ,_decd :=range _gbc .Rows (){if _decd .RowNumber ()< _agbg {_agbg =_decd .RowNumber ();
}else if _decd .RowNumber ()> _agfg {_agfg =_decd .RowNumber ();};for _ ,_ege :=range _decd .Cells (){_ddge ,_eced :=_gdc .ParseCellReference (_ege .Reference ());if _eced ==nil {if _ddge .ColumnIdx < _agaa {_agaa =_ddge .ColumnIdx ;}else if _ddge .ColumnIdx > _baab {_baab =_ddge .ColumnIdx ;
};};};};return _gdc .IndexToColumn (_agaa ),_agbg ,_gdc .IndexToColumn (_baab ),_agfg ;};func _bfdf ()*_bgg .CT_OneCellAnchor {_gegb :=_bgg .NewCT_OneCellAnchor ();return _gegb };

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_gcda Row )Cells ()[]Cell {_bgcd :=[]Cell {};_ccgg :=-1;_gafcd :=append ([]*_bcd .CT_Cell {},_gcda ._dddc .C ...);for _ ,_gbagd :=range _gafcd {if _gbagd .RAttr ==nil {_cfa .Log .Debug ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_defe ,_adcd :=_gdc .ParseCellReference (*_gbagd .RAttr );if _adcd !=nil {_cfa .Log .Debug ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_gbagd .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");
continue ;};_dgca :=int (_defe .ColumnIdx );if _dgca -_ccgg > 1{for _ebfb :=_ccgg +1;_ebfb < _dgca ;_ebfb ++{_bgcd =append (_bgcd ,_gcda .Cell (_gdc .IndexToColumn (uint32 (_ebfb ))));};};_ccgg =_dgca ;_bgcd =append (_bgcd ,Cell {_gcda ._ecag ,_gcda ._dad ,_gcda ._dddc ,_gbagd });
};return _bgcd ;};

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_gf Cell )SetTime (d _acc .Time ){_gf .clearValue ();d =_ffc (d );_fec :=_gf ._fbc .Epoch ();if d .Before (_fec ){_cfa .Log .Debug ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_ebf :=d .Sub (_fec );_dgda :=new (_bgb .Float );_ded :=new (_bgb .Float );_ded .SetPrec (128);_ded .SetUint64 (uint64 (_ebf ));_ecd :=new (_bgb .Float );_ecd .SetUint64 (24*60*60*1e9);_dgda .Quo (_ded ,_ecd );_gf ._de .V =_c .String (_dgda .Text ('g',20));
};const (DVCompareOpEqual =DVCompareOp (_bcd .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_bcd .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_bcd .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_bcd .ST_DataValidationOperatorNotEqual );
DVCompareOpGreater =DVCompareOp (_bcd .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_bcd .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_bcd .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_bcd .ST_DataValidationOperatorLessThanOrEqual );
);

// RemoveDefinedName removes an existing defined name.
func (_bcfa *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _cf .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");
};for _cgdd ,_bbcd :=range _bcfa ._dfdc .DefinedNames .DefinedName {if _bbcd ==dn .X (){copy (_bcfa ._dfdc .DefinedNames .DefinedName [_cgdd :],_bcfa ._dfdc .DefinedNames .DefinedName [_cgdd +1:]);_bcfa ._dfdc .DefinedNames .DefinedName [len (_bcfa ._dfdc .DefinedNames .DefinedName )-1]=nil ;
_bcfa ._dfdc .DefinedNames .DefinedName =_bcfa ._dfdc .DefinedNames .DefinedName [:len (_bcfa ._dfdc .DefinedNames .DefinedName )-1];return nil ;};};return _cf .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");
};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// IsNumber returns true if the cell is a number type cell.
func (_afa Cell )IsNumber ()bool {switch _afa ._de .TAttr {case _bcd .ST_CellTypeN :return true ;case _bcd .ST_CellTypeS ,_bcd .ST_CellTypeB :return false ;};return _afa ._de .V !=nil &&_gd .IsNumber (*_afa ._de .V );};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_ddfa *Workbook )AddDrawing ()Drawing {_cdfad :=_bgg .NewWsDr ();_ddfa ._edbf =append (_ddfa ._edbf ,_cdfad );_gagg :=_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .DrawingType ,len (_ddfa ._edbf ));_ddfa .ContentTypes .AddOverride (_gagg ,_c .DrawingContentType );
_ddfa ._fbfbf =append (_ddfa ._fbfbf ,_ad .NewRelationships ());return Drawing {_ddfa ,_cdfad };};

// SetWidthCells is a no-op.
func (_gadg OneCellAnchor )SetWidthCells (int32 ){};

// ClearBorder clears any border configuration from the cell style.
func (_dfff CellStyle )ClearBorder (){_dfff ._cbc .BorderIdAttr =nil ;_dfff ._cbc .ApplyBorderAttr =nil };func (_ceaf Fills )appendFill ()Fill {_gbde :=_bcd .NewCT_Fill ();_ceaf ._cda .Fill =append (_ceaf ._cda .Fill ,_gbde );_ceaf ._cda .CountAttr =_c .Uint32 (uint32 (len (_ceaf ._cda .Fill )));
return Fill {_gbde ,_ceaf ._cda };};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_dcb ConditionalFormattingRule )SetDataBar ()DataBarScale {_dcb .clear ();_dcb .SetType (_bcd .ST_CfTypeDataBar );_dcb ._faa .DataBar =_bcd .NewCT_DataBar ();_gcf :=DataBarScale {_dcb ._faa .DataBar };_gcf .SetShowValue (true );_gcf .SetMinLength (10);
_gcf .SetMaxLength (90);return _gcf ;};

// X returns the inner wrapped XML type.
func (_gccg SharedStrings )X ()*_bcd .Sst {return _gccg ._aegbd };const (_efcg ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";
_eaeg ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";
_cggaee ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";
_ccdd ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";
);type SheetProtection struct{_fggg *_bcd .CT_SheetProtection };

// X returns the inner wrapped XML type.
func (_eege DataValidation )X ()*_bcd .CT_DataValidation {return _eege ._aegb };

// SetHidden marks the defined name as hidden.
func (_dffg DefinedName )SetLocalSheetID (id uint32 ){_dffg ._bcbee .LocalSheetIdAttr =_c .Uint32 (id )};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_fdgb StyleSheet )AddNumberFormat ()NumberFormat {if _fdgb ._gaff .NumFmts ==nil {_fdgb ._gaff .NumFmts =_bcd .NewCT_NumFmts ();};_aacg :=_bcd .NewCT_NumFmt ();_aacg .NumFmtIdAttr =uint32 (200+len (_fdgb ._gaff .NumFmts .NumFmt ));_fdgb ._gaff .NumFmts .NumFmt =append (_fdgb ._gaff .NumFmts .NumFmt ,_aacg );
_fdgb ._gaff .NumFmts .CountAttr =_c .Uint32 (uint32 (len (_fdgb ._gaff .NumFmts .NumFmt )));return NumberFormat {_fdgb ._edgf ,_aacg };};const _afga ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";


// Type returns the type of anchor
func (_badf OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// Borders returns the list of borders defined in the stylesheet.
func (_aecc StyleSheet )Borders ()[]Border {_dfdf :=[]Border {};for _ ,_dadde :=range _aecc ._gaff .Borders .Border {_dfdf =append (_dfdf ,Border {_fa :_dadde });};return _dfdf ;};func (_bfag Fill )SetPatternFill ()PatternFill {_bfag ._cggag .GradientFill =nil ;
_bfag ._cggag .PatternFill =_bcd .NewCT_PatternFill ();_bfag ._cggag .PatternFill .PatternTypeAttr =_bcd .ST_PatternTypeSolid ;return PatternFill {_bfag ._cggag .PatternFill ,_bfag ._cggag };};

// CellStyles returns the list of defined cell styles
func (_bbed StyleSheet )CellStyles ()[]CellStyle {_bfgf :=[]CellStyle {};for _ ,_ccddd :=range _bbed ._gaff .CellXfs .Xf {_bfgf =append (_bfgf ,CellStyle {_bbed ._edgf ,_ccddd ,_bbed ._gaff .CellXfs });};return _bfgf ;};

// SetNumber sets the cell type to number, and the value to the given number
func (_gbd Cell )SetNumber (v float64 ){_gbd .clearValue ();if _ff .IsNaN (v )||_ff .IsInf (v ,0){_gbd ._de .TAttr =_bcd .ST_CellTypeE ;_gbd ._de .V =_c .String ("\u0023\u004e\u0055M\u0021");return ;};_gbd ._de .TAttr =_bcd .ST_CellTypeN ;_gbd ._de .V =_c .String (_cc .FormatFloat (v ,'f',-1,64));
};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_adbe Sheet )ValidateWithPath (path string )error {return _adbe ._gbef .ValidateWithPath (path )};

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// X returns the inner wrapped XML type.
func (_egb Comment )X ()*_bcd .CT_Comment {return _egb ._aaef };

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_gb *_bgg .CT_AbsoluteAnchor };

// X returns the inner wrapped XML type.
func (_afc Border )X ()*_bcd .CT_Border {return _afc ._fa };var _bfab =_c .RelativeFilename (_c .DocTypeSpreadsheet ,_c .OfficeDocumentType ,_c .SharedStringsType ,0);

// X returns the inner wrapped XML type.
func (_adfd Row )X ()*_bcd .CT_Row {return _adfd ._dddc };

// Workbook returns sheet's parent workbook.
func (_abfa *Sheet )Workbook ()*Workbook {return _abfa ._feaa };

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_bbcb *Sheet )Row (rowNum uint32 )Row {for _ ,_gfee :=range _bbcb ._gbef .SheetData .Row {if _gfee .RAttr !=nil &&*_gfee .RAttr ==rowNum {return Row {_bbcb ._feaa ,_bbcb ,_gfee };};};return _bbcb .AddNumberedRow (rowNum );};

// SetPattern sets the pattern of the fill.
func (_bdcdg PatternFill )SetPattern (p _bcd .ST_PatternType ){_bdcdg ._bea .PatternTypeAttr =p };func (_efb Comments )getOrCreateAuthor (_cbcf string )uint32 {for _gfb ,_cfdg :=range _efb ._bfcf .Authors .Author {if _cfdg ==_cbcf {return uint32 (_gfb );
};};_fgea :=uint32 (len (_efb ._bfcf .Authors .Author ));_efb ._bfcf .Authors .Author =append (_efb ._bfcf .Authors .Author ,_cbcf );return _fgea ;};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_dcaa ConditionalFormattingRule )SetIcons ()IconScale {_dcaa .clear ();_dcaa .SetType (_bcd .ST_CfTypeIconSet );_dcaa ._faa .IconSet =_bcd .NewCT_IconSet ();_dgcd :=IconScale {_dcaa ._faa .IconSet };_dgcd .SetIcons (_bcd .ST_IconSetType3TrafficLights1 );
return _dgcd ;};type Table struct{_eacdd *_bcd .Table };

// SetName sets the sheet name.
func (_dcbd *Sheet )SetName (name string ){_dcbd ._ceda .NameAttr =name };

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_cbfg *Workbook ;_bbaa *_bgg .WsDr ;};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_babd *Workbook )SetActiveSheetIndex (idx uint32 ){if _babd ._dfdc .BookViews ==nil {_babd ._dfdc .BookViews =_bcd .NewCT_BookViews ();};if len (_babd ._dfdc .BookViews .WorkbookView )==0{_babd ._dfdc .BookViews .WorkbookView =append (_babd ._dfdc .BookViews .WorkbookView ,_bcd .NewCT_BookView ());
};_babd ._dfdc .BookViews .WorkbookView [0].ActiveTabAttr =_c .Uint32 (idx );};

// SetUnderline controls if the run is underlined.
func (_ffe RichTextRun )SetUnderline (u _bcd .ST_UnderlineValues ){_ffe .ensureRpr ();_ffe ._cegd .RPr .U =_bcd .NewCT_UnderlineProperty ();_ffe ._cegd .RPr .U .ValAttr =u ;};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_cada *Sheet )FormulaContext ()_acb .Context {return _gag (_cada )};

// Operator returns the operator for the rule
func (_fdd ConditionalFormattingRule )Operator ()_bcd .ST_ConditionalFormattingOperator {return _fdd ._faa .OperatorAttr ;};

// Rows returns all of the rows in a sheet.
func (_adfgb *Sheet )Rows ()[]Row {_ffcbd :=[]Row {};for _ ,_gcce :=range _adfgb ._gbef .SheetData .Row {_ffcbd =append (_ffcbd ,Row {_adfgb ._feaa ,_adfgb ,_gcce });};return _ffcbd ;};

// LockSheet controls the locking of the sheet.
func (_bgfa SheetProtection )LockSheet (b bool ){if !b {_bgfa ._fggg .SheetAttr =nil ;}else {_bgfa ._fggg .SheetAttr =_c .Bool (true );};};

// LockObject controls the locking of the sheet objects.
func (_fedf SheetProtection )LockObject (b bool ){if !b {_fedf ._fggg .ObjectsAttr =nil ;}else {_fedf ._fggg .ObjectsAttr =_c .Bool (true );};};

// SetStyle sets the style to be used for conditional rules
func (_agd ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_agd ._faa .DxfIdAttr =_c .Uint32 (d .Index ());};

// SetWrapped configures the cell to wrap text.
func (_be CellStyle )SetWrapped (b bool ){if _be ._cbc .Alignment ==nil {_be ._cbc .Alignment =_bcd .NewCT_CellAlignment ();};if !b {_be ._cbc .Alignment .WrapTextAttr =nil ;}else {_be ._cbc .Alignment .WrapTextAttr =_c .Bool (true );_be ._cbc .ApplyAlignmentAttr =_c .Bool (true );
};};func (_cbed StyleSheet )appendFont ()Font {_ffeg :=_bcd .NewCT_Font ();_cbed ._gaff .Fonts .Font =append (_cbed ._gaff .Fonts .Font ,_ffeg );_cbed ._gaff .Fonts .CountAttr =_c .Uint32 (uint32 (len (_cbed ._gaff .Fonts .Font )));return Font {_ffeg ,_cbed ._gaff };
};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_aaed *Sheet )AddHyperlink (url string )_ad .Hyperlink {for _aebf ,_eacab :=range _aaed ._feaa ._agbbg {if _eacab ==_aaed ._gbef {return _aaed ._feaa ._dagcbb [_aebf ].AddHyperlink (url );};};return _ad .Hyperlink {};};

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_bcbeg *Sheet )GetDrawing ()(*_bgg .WsDr ,_ad .Relationships ){if _aabb :=_bcbeg ._gbef .Drawing ;_aabb !=nil {_aeab :=0;for _ ,_cbacd :=range _bcbeg ._feaa ._agbbg {if _dbae :=_cbacd .Drawing ;_dbae !=nil {if _cbacd ==_bcbeg ._gbef {return _bcbeg ._feaa ._edbf [_aeab ],_bcbeg ._feaa ._fbfbf [_aeab ];
};_aeab ++;};};};return nil ,_ad .Relationships {};};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_gfgg *Workbook )RemoveSheetByName (name string )error {_fcac :=-1;for _gccc ,_bfcfb :=range _gfgg .Sheets (){if name ==_bfcfb .Name (){_fcac =_gccc ;break ;};};if _fcac ==-1{return ErrorNotFound ;};return _gfgg .RemoveSheet (_fcac );};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_edb Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_edb .SetNumber (v );_edb .SetStyle (_edb ._fbc .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// IconScale maps values to icons.
type IconScale struct{_aggd *_bcd .CT_IconSet };type PatternFill struct{_bea *_bcd .CT_PatternFill ;_cadb *_bcd .CT_Fill ;};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;
StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;
StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;
StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;
StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;
StandardFormat49 StandardFormat =49;);

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_gfe *_bcd .CT_DataBar };func (_gee *evalContext )SetOffset (col ,row uint32 ){_gee ._dcdg =col ;_gee ._gbaf =row };

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_dgbe *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_fg .Replace (rangeRef ,"\u0024","",-1);_dgbe ._gbef .AutoFilter =_bcd .NewCT_AutoFilter ();_dgbe ._gbef .AutoFilter .RefAttr =_c .String (rangeRef );_aefc :="\u0027"+_dgbe .Name ()+"\u0027\u0021";
var _cdfe DefinedName ;for _ ,_cfdac :=range _dgbe ._feaa .DefinedNames (){if _cfdac .Name ()==_edde {if _fg .HasPrefix (_cfdac .Content (),_aefc ){_cdfe =_cfdac ;_cdfe .SetContent (_dgbe .RangeReference (rangeRef ));break ;};};};if _cdfe .X ()==nil {_cdfe =_dgbe ._feaa .AddDefinedName (_edde ,_dgbe .RangeReference (rangeRef ));
};for _cdbb ,_cbaa :=range _dgbe ._feaa ._agbbg {if _cbaa ==_dgbe ._gbef {_cdfe .SetLocalSheetID (uint32 (_cdbb ));};};};

// SetPasswordHash sets the password hash to the input.
func (_bgbf WorkbookProtection )SetPasswordHash (pwHash string ){_bgbf ._deed .WorkbookPasswordAttr =_c .String (pwHash );};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_cgad TwoCellAnchor )SetWidthCells (w int32 ){_bfee :=_cgad .TopLeft ();_fdec :=_cgad .BottomRight ();_fdec .SetCol (_bfee .Col ()+w );};func _debb (_cfc _acc .Time )_acc .Time {_cfc =_cfc .UTC ();return _acc .Date (_cfc .Year (),_cfc .Month (),_cfc .Day (),_cfc .Hour (),_cfc .Minute (),_cfc .Second (),_cfc .Nanosecond (),_acc .Local );
};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bgca StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _bgca ._gaff .Dxfs ==nil {_bgca ._gaff .Dxfs =_bcd .NewCT_Dxfs ();};_eddcf :=_bcd .NewCT_Dxf ();_bgca ._gaff .Dxfs .Dxf =append (_bgca ._gaff .Dxfs .Dxf ,_eddcf );_bgca ._gaff .Dxfs .CountAttr =_c .Uint32 (uint32 (len (_bgca ._gaff .Dxfs .Dxf )));
return DifferentialStyle {_eddcf ,_bgca ._edgf ,_bgca ._gaff .Dxfs };};

// IsBool returns true if the cell boolean value.
func (_ebfca *evalContext )IsBool (cellRef string )bool {return _ebfca ._bge .Cell (cellRef ).IsBool ()};func (_dd Border )SetTop (style _bcd .ST_BorderStyle ,c _ffb .Color ){if _dd ._fa .Top ==nil {_dd ._fa .Top =_bcd .NewCT_BorderPr ();};_dd ._fa .Top .Color =_bcd .NewCT_Color ();
_dd ._fa .Top .Color .RgbAttr =c .AsRGBAString ();_dd ._fa .Top .StyleAttr =style ;};

// BottomRight is a no-op.
func (_db AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_ccdb *Workbook )Save (w _ef .Writer )error {const _cebc ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_ca .GetLicenseKey ().IsLicensed ()&&!_aabd {_ebb .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");
_ebb .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");
return _cf .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_ccdb ._dabb )==0{_gdbf ,_agaf :=_ca .GenRefId ("\u0073\u0077");if _agaf !=nil {_cfa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_agaf );
return _agaf ;};_ccdb ._dabb =_gdbf ;};if _bfed :=_ca .Track (_ccdb ._dabb ,_cebc );_bfed !=nil {_cfa .Log .Error ("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v",_bfed );return _bfed ;};_edgeb :=_gc .NewWriter (w );defer _edgeb .Close ();_adce :=_c .DocTypeSpreadsheet ;
if _gcca :=_bc .MarshalXML (_edgeb ,_c .BaseRelsFilename ,_ccdb .Rels .X ());_gcca !=nil {return _gcca ;};if _fdfec :=_bc .MarshalXMLByType (_edgeb ,_adce ,_c .ExtendedPropertiesType ,_ccdb .AppProperties .X ());_fdfec !=nil {return _fdfec ;};if _ebab :=_bc .MarshalXMLByType (_edgeb ,_adce ,_c .CorePropertiesType ,_ccdb .CoreProperties .X ());
_ebab !=nil {return _ebab ;};_ggde :=_c .AbsoluteFilename (_adce ,_c .OfficeDocumentType ,0);if _afe :=_bc .MarshalXML (_edgeb ,_ggde ,_ccdb ._dfdc );_afe !=nil {return _afe ;};if _bfgc :=_bc .MarshalXML (_edgeb ,_bc .RelationsPathFor (_ggde ),_ccdb ._dcef .X ());
_bfgc !=nil {return _bfgc ;};if _ggbdb :=_bc .MarshalXMLByType (_edgeb ,_adce ,_c .StylesType ,_ccdb .StyleSheet .X ());_ggbdb !=nil {return _ggbdb ;};for _dfdb ,_bgcfbf :=range _ccdb ._gdba {if _agfb :=_bc .MarshalXMLByTypeIndex (_edgeb ,_adce ,_c .ThemeType ,_dfdb +1,_bgcfbf );
_agfb !=nil {return _agfb ;};};for _ceca ,_bcea :=range _ccdb ._agbbg {_bcea .Dimension .RefAttr =Sheet {_ccdb ,nil ,_bcea }.Extents ();_aaac :=_c .AbsoluteFilename (_adce ,_c .WorksheetType ,_ceca +1);_bc .MarshalXML (_edgeb ,_aaac ,_bcea );_bc .MarshalXML (_edgeb ,_bc .RelationsPathFor (_aaac ),_ccdb ._dagcbb [_ceca ].X ());
};if _dgcc :=_bc .MarshalXMLByType (_edgeb ,_adce ,_c .SharedStringsType ,_ccdb .SharedStrings .X ());_dgcc !=nil {return _dgcc ;};if _ccdb .CustomProperties .X ()!=nil {if _abdf :=_bc .MarshalXMLByType (_edgeb ,_adce ,_c .CustomPropertiesType ,_ccdb .CustomProperties .X ());
_abdf !=nil {return _abdf ;};};if _ccdb .Thumbnail !=nil {_acaa :=_c .AbsoluteFilename (_adce ,_c .ThumbnailType ,0);_dcdb ,_ggcgg :=_edgeb .Create (_acaa );if _ggcgg !=nil {return _ggcgg ;};if _cebb :=_g .Encode (_dcdb ,_ccdb .Thumbnail ,nil );_cebb !=nil {return _cebb ;
};};for _edfg ,_eccg :=range _ccdb ._bfda {_fgcf :=_c .AbsoluteFilename (_adce ,_c .ChartType ,_edfg +1);_bc .MarshalXML (_edgeb ,_fgcf ,_eccg );};for _ffbc ,_dgdd :=range _ccdb ._cfgf {_edec :=_c .AbsoluteFilename (_adce ,_c .TableType ,_ffbc +1);_bc .MarshalXML (_edgeb ,_edec ,_dgdd );
};for _aaacc ,_facca :=range _ccdb ._edbf {_dfgf :=_c .AbsoluteFilename (_adce ,_c .DrawingType ,_aaacc +1);_bc .MarshalXML (_edgeb ,_dfgf ,_facca );if !_ccdb ._fbfbf [_aaacc ].IsEmpty (){_bc .MarshalXML (_edgeb ,_bc .RelationsPathFor (_dfgf ),_ccdb ._fbfbf [_aaacc ].X ());
};};for _gbcg ,_ccgae :=range _ccdb ._fgga {_bc .MarshalXML (_edgeb ,_c .AbsoluteFilename (_adce ,_c .VMLDrawingType ,_gbcg +1),_ccgae );};for _faccab ,_cccg :=range _ccdb .Images {if _beb :=_ad .AddImageToZip (_edgeb ,_cccg ,_faccab +1,_c .DocTypeSpreadsheet );
_beb !=nil {return _beb ;};};if _bdef :=_bc .MarshalXML (_edgeb ,_c .ContentTypesFilename ,_ccdb .ContentTypes .X ());_bdef !=nil {return _bdef ;};for _afada ,_faacg :=range _ccdb ._bfdfd {if _faacg ==nil {continue ;};_bc .MarshalXML (_edgeb ,_c .AbsoluteFilename (_adce ,_c .CommentsType ,_afada +1),_faacg );
};if _fddbgb :=_ccdb .WriteExtraFiles (_edgeb );_fddbgb !=nil {return _fddbgb ;};return _edgeb .Close ();};

// ClearProtection clears all workbook protections.
func (_ccgd *Workbook )ClearProtection (){_ccgd ._dfdc .WorkbookProtection =nil };

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_gded *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_fgfb :=-1;for _bacf ,_efdba :=range _gded .Sheets (){if name ==_efdba .Name (){_fgfb =_bacf ;break ;};};if _fgfb ==-1{return Sheet {},ErrorNotFound ;};return _gded .CopySheet (_fgfb ,copiedSheetName );
};

// ClearFont clears any font configuration from the cell style.
func (_agg CellStyle )ClearFont (){_agg ._cbc .FontIdAttr =nil ;_agg ._cbc .ApplyFontAttr =nil };

// ClearFill clears any fill configuration from the cell style.
func (_aff CellStyle )ClearFill (){_aff ._cbc .FillIdAttr =nil ;_aff ._cbc .ApplyFillAttr =nil };

// X returns the inner wrapped XML type.
func (_edfc WorkbookProtection )X ()*_bcd .CT_WorkbookProtection {return _edfc ._deed };

// SetColor sets teh color of the databar.
func (_fgaa DataBarScale )SetColor (c _ffb .Color ){_fgaa ._gfe .Color =_bcd .NewCT_Color ();_fgaa ._gfe .Color .RgbAttr =c .AsRGBAString ();};func (_faca CellStyle )SetShrinkToFit (b bool ){if _faca ._cbc .Alignment ==nil {_faca ._cbc .Alignment =_bcd .NewCT_CellAlignment ();
};_faca ._cbc .ApplyAlignmentAttr =_c .Bool (true );if !b {_faca ._cbc .Alignment .ShrinkToFitAttr =nil ;}else {_faca ._cbc .Alignment .ShrinkToFitAttr =_c .Bool (b );};};

// SetTopLeft sets the top left visible cell after the split.
func (_cadbd SheetView )SetTopLeft (cellRef string ){_cadbd .ensurePane ();_cadbd ._adcgcf .Pane .TopLeftCellAttr =&cellRef ;};

// Type returns the type of anchor
func (_cg AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };func _gag (_cgff *Sheet )*evalContext {return &evalContext {_bge :_cgff ,_fbdf :make (map[string ]struct{})};};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_feb Comment )SetAuthor (author string ){_feb ._aaef .AuthorIdAttr =Comments {_feb ._fdg ,_feb ._add }.getOrCreateAuthor (author );};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_fcc DataValidation )SetRange (cellRange string ){_fcc ._aegb .SqrefAttr =_bcd .ST_Sqref {cellRange };};

// Comment is a single comment within a sheet.
type Comment struct{_fdg *Workbook ;_aaef *_bcd .CT_Comment ;_add *_bcd .Comments ;};

// X returns the inner wrapped XML type.
func (_ccd Sheet )X ()*_bcd .Worksheet {return _ccd ._gbef };func (_dff Cell )clearValue (){_dff ._de .F =nil ;_dff ._de .Is =nil ;_dff ._de .V =nil ;_dff ._de .TAttr =_bcd .ST_CellTypeUnset ;};func (_gdgf *Sheet )setArray (_geeba string ,_afbgg _acb .Result )error {_gbdc ,_dgec :=_gdc .ParseCellReference (_geeba );
if _dgec !=nil {return _dgec ;};for _cdfcb ,_fade :=range _afbgg .ValueArray {_fcbd :=_gdgf .Row (_gbdc .RowIdx +uint32 (_cdfcb ));for _gddd ,_dada :=range _fade {_fag :=_fcbd .Cell (_gdc .IndexToColumn (_gbdc .ColumnIdx +uint32 (_gddd )));if _dada .Type !=_acb .ResultTypeEmpty {if _dada .IsBoolean {_fag .SetBool (_dada .ValueNumber !=0);
}else {_fag .SetCachedFormulaResult (_dada .String ());};};};};return nil ;};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_agge SheetView )SetZoom (pct uint32 ){_agge ._adcgcf .ZoomScaleAttr =&pct };func (_agca SortOrder )String ()string {if _agca >=SortOrder (len (_gef )-1){return _ebb .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_agca );
};return _afga [_gef [_agca ]:_gef [_agca +1]];};func (_gabb Font )SetBold (b bool ){if b {_gabb ._fgd .B =[]*_bcd .CT_BooleanProperty {{}};}else {_gabb ._fgd .B =nil ;};};

// X returns the inner wrapped XML type.
func (_ebcf DifferentialStyle )X ()*_bcd .CT_Dxf {return _ebcf ._bbb };

// TopLeft is a no-op.
func (_aga AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};func (_bgcc PatternFill )ClearBgColor (){_bgcc ._bea .BgColor =nil };type ConditionalFormattingRule struct{_faa *_bcd .CT_CfRule };

// IsError returns true if the cell is an error type cell.
func (_bgad Cell )IsError ()bool {return _bgad ._de .TAttr ==_bcd .ST_CellTypeE };

// AddRule adds and returns a new rule that can be configured.
func (_bae ConditionalFormatting )AddRule ()ConditionalFormattingRule {_ebdfa :=_bcd .NewCT_CfRule ();_bae ._ccb .CfRule =append (_bae ._ccb .CfRule ,_ebdfa );_eded :=ConditionalFormattingRule {_ebdfa };_eded .InitializeDefaults ();_eded .SetPriority (int32 (len (_bae ._ccb .CfRule )+1));
return _eded ;};

// Priority returns the rule priority
func (_eab ConditionalFormattingRule )Priority ()int32 {return _eab ._faa .PriorityAttr };

// Type returns the type of the rule
func (_afbb ConditionalFormattingRule )Type ()_bcd .ST_CfType {return _afbb ._faa .TypeAttr };

// SetPasswordHash sets the password hash to the input.
func (_bdb SheetProtection )SetPasswordHash (pwHash string ){_bdb ._fggg .PasswordAttr =_c .String (pwHash );};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_fca Sheet )Extents ()string {_afag ,_dgdb ,_fecf ,_ebbc :=_fca .ExtentsIndex ();return _ebb .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_afag ,_dgdb ,_fecf ,_ebbc );};

// Col returns the column of the cell marker.
func (_adcg CellMarker )Col ()int32 {return _adcg ._dfd .Col };

// Border is a cell border configuraton.
type Border struct{_fa *_bcd .CT_Border ;_fb *_bcd .CT_Borders ;};

// GetFill gets a Fill from a cell style.
func (_cgf CellStyle )GetFill ()*_bcd .CT_Fill {if _dag :=_cgf ._cbc .FillIdAttr ;_dag !=nil {_cga :=_cgf ._edbc .StyleSheet .Fills ().X ().Fill ;if int (*_dag )< len (_cga ){return _cga [int (*_dag )];};};return nil ;};

// Protection controls the protection on an individual sheet.
func (_cbgg *Sheet )Protection ()SheetProtection {if _cbgg ._gbef .SheetProtection ==nil {_cbgg ._gbef .SheetProtection =_bcd .NewCT_SheetProtection ();};return SheetProtection {_cbgg ._gbef .SheetProtection };};

// SetOperator sets the operator for the rule.
func (_gdcb ConditionalFormattingRule )SetOperator (t _bcd .ST_ConditionalFormattingOperator ){_gdcb ._faa .OperatorAttr =t ;};

// X returns the inner wrapped XML type.
func (_egde Comments )X ()*_bcd .Comments {return _egde ._bfcf };

// X returns the inner wrapped XML type.
func (_gaeb SheetProtection )X ()*_bcd .CT_SheetProtection {return _gaeb ._fggg };

// Themes returns the array of workbook dml.Theme.
func (_dcfag *Workbook )Themes ()[]*_dg .Theme {return _dcfag ._gdba };

// SetPassword sets the password hash to a hash of the input password.
func (_eebfc WorkbookProtection )SetPassword (pw string ){_eebfc .SetPasswordHash (PasswordHash (pw ))};

// SetRow set the row of the cell marker.
func (_ede CellMarker )SetRow (row int32 ){_ede ._dfd .Row =row };

// SetFont sets the font name for a rich text run.
func (_daa RichTextRun )SetFont (s string ){_daa .ensureRpr ();_daa ._cegd .RPr .RFont =_bcd .NewCT_FontName ();_daa ._cegd .RPr .RFont .ValAttr =s ;};

// SetContent sets the defined name content.
func (_eegd DefinedName )SetContent (s string ){_eegd ._bcbee .Content =s };

// X returns the inner wrapped XML type.
func (_gad IconScale )X ()*_bcd .CT_IconSet {return _gad ._aggd };

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_bbbg Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_aacad :=[]Cell {};for _ffee :=uint32 (0);_ffee <=lastColIdx ;_ffee ++{_adca :=_bbbg .Cell (_gdc .IndexToColumn (_ffee ));_aacad =append (_aacad ,_adca );};return _aacad ;};

// SetHidden controls the visibility of a column.
func (_dcge Column )SetHidden (b bool ){if !b {_dcge ._gdg .HiddenAttr =nil ;}else {_dcge ._gdg .HiddenAttr =_c .Bool (true );};};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_bcd .Comments )Comments {return Comments {w ,x }};func (_ecfcg *Sheet )updateAfterRemove (_efeg uint32 ,_cef _df .UpdateAction )error {_bccca :=_ecfcg .Name ();_aagb :=&_df .UpdateQuery {UpdateType :_cef ,ColumnIdx :_efeg ,SheetToUpdate :_bccca };
for _ ,_bbg :=range _ecfcg ._feaa .Sheets (){_aagb .UpdateCurrentSheet =_bccca ==_bbg .Name ();for _ ,_eeca :=range _bbg .Rows (){for _ ,_fgbaa :=range _eeca .Cells (){if _fgbaa .X ().F !=nil {_fbag :=_fgbaa .X ().F .Content ;_adda :=_acb .ParseString (_fbag );
if _adda ==nil {_fgbaa .SetError ("\u0023\u0052\u0045F\u0021");}else {_bfbdg :=_adda .Update (_aagb );_fgbaa .X ().F .Content =_ebb .Sprintf ("\u003d\u0025\u0073",_bfbdg .String ());};};};};};return nil ;};

// X returns the inner wrapped XML type.
func (_dbg Cell )X ()*_bcd .CT_Cell {return _dbg ._de };

// SetHeightCells is a no-op.
func (_bbd AbsoluteAnchor )SetHeightCells (int32 ){};

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_accc CellStyle )SetNumberFormat (s string ){var _afca NumberFormat ;if _accc ._edbc .StyleSheet ._gaff .NumFmts ==nil {_accc ._edbc .StyleSheet ._gaff .NumFmts =_bcd .NewCT_NumFmts ();};_fea :=_accc ._edbc .StyleSheet ._gaff .NumFmts .NumFmt ;for _ ,_cfbc :=range _fea {if _eb .DeepEqual (_cfbc .FormatCodeAttr ,s ){_afca =NumberFormat {_accc ._edbc ,_cfbc };
_accc ._cbc .ApplyNumberFormatAttr =_c .Bool (true );_accc ._cbc .NumFmtIdAttr =_c .Uint32 (_afca .ID ());return ;};};_gea :=_bcd .NewCT_NumFmt ();_gea .NumFmtIdAttr =uint32 (200+len (_accc ._edbc .StyleSheet ._gaff .NumFmts .NumFmt ));_accc ._edbc .StyleSheet ._gaff .NumFmts .NumFmt =append (_accc ._edbc .StyleSheet ._gaff .NumFmts .NumFmt ,_gea );
_accc ._edbc .StyleSheet ._gaff .NumFmts .CountAttr =_c .Uint32 (uint32 (len (_accc ._edbc .StyleSheet ._gaff .NumFmts .NumFmt )));_afca =NumberFormat {_accc ._edbc ,_gea };_afca ._ccge .FormatCodeAttr =s ;_accc ._cbc .ApplyNumberFormatAttr =_c .Bool (true );
_accc ._cbc .NumFmtIdAttr =_c .Uint32 (_afca .ID ());};

// SetHeight sets the row height in points.
func (_ddfd Row )SetHeight (d _ge .Distance ){_ddfd ._dddc .HtAttr =_c .Float64 (float64 (d ));_ddfd ._dddc .CustomHeightAttr =_c .Bool (true );};

// CellMarker represents a cell position
type CellMarker struct{_dfd *_bgg .CT_Marker };

// SetDateWithStyle sets a date with the default date style applied.
func (_agb Cell )SetDateWithStyle (d _acc .Time ){_agb .SetDate (d );for _ ,_aea :=range _agb ._fbc .StyleSheet .CellStyles (){if _aea .HasNumberFormat ()&&_aea .NumberFormat ()==uint32 (StandardFormatDate ){_agb .SetStyle (_aea );return ;};};_aaeb :=_agb ._fbc .StyleSheet .AddCellStyle ();
_aaeb .SetNumberFormatStandard (StandardFormatDate );_agb .SetStyle (_aaeb );};

// Clear clears the cell's value and type.
func (_dcd Cell )Clear (){_dcd .clearValue ();_dcd ._de .TAttr =_bcd .ST_CellTypeUnset };

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_fgd *_bcd .CT_Font ;_dbbf *_bcd .StyleSheet ;};

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ggbb Row )AddNamedCell (col string )Cell {_dffe :=_bcd .NewCT_Cell ();_dffe .RAttr =_c .Stringf ("\u0025\u0073\u0025\u0064",col ,_ggbb .RowNumber ());_gdbg :=-1;_cgbc :=_gdc .ColumnToIndex (col );for _gede ,_defc :=range _ggbb ._dddc .C {_fgbcc ,_beab :=_gdc .ParseCellReference (*_defc .RAttr );
if _beab !=nil {return Cell {};};if _cgbc < _fgbcc .ColumnIdx {_gdbg =_gede ;break ;};};if _gdbg ==-1{_ggbb ._dddc .C =append (_ggbb ._dddc .C ,_dffe );}else {_ggbb ._dddc .C =append (_ggbb ._dddc .C [:_gdbg ],append ([]*_bcd .CT_Cell {_dffe },_ggbb ._dddc .C [_gdbg :]...)...);
};return Cell {_ggbb ._ecag ,_ggbb ._dad ,_ggbb ._dddc ,_dffe };};

// GetString retrieves a string from the shared strings table by index.
func (_agec SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_ebb .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );
};if id > len (_agec ._aegbd .Si )-1{return "",_ebb .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_agec ._aegbd .Si ));
};_aecd :=_agec ._aegbd .Si [id ];if _aecd .T !=nil {return *_aecd .T ,nil ;};_ggd :="";for _ ,_eaee :=range _aecd .R {if _eaee .T !=""{_ggd +=_eaee .T ;};};return _ggd ,nil ;};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_dgbdd *Sheet )ClearSheetViews (){_dgbdd ._gbef .SheetViews =nil };

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_cadbg *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_ccad :=range _cadbg .Sheets (){if _ccad .Name ()==name {return _ccad ,nil ;};};return Sheet {},ErrorNotFound ;};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_egbd *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _egbd .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _fggc _ad .Relationship ;for _ ,_gdff :=range _egbd ._dcef .Relationships (){if _gdff .ID ()==_egbd ._dfdc .Sheets .Sheet [ind ].IdAttr {var _defa bool ;
if _fggc ,_defa =_egbd ._dcef .CopyRelationship (_gdff .ID ());!_defa {return Sheet {},ErrorNotFound ;};break ;};};_egbd .ContentTypes .CopyOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .WorksheetContentType ,ind +1),_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .WorksheetContentType ,len (_egbd .ContentTypes .X ().Override )));
_ecdd :=*_egbd ._agbbg [ind ];_egbd ._agbbg =append (_egbd ._agbbg ,&_ecdd );var _cbca uint32 =0;for _ ,_febfa :=range _egbd ._dfdc .Sheets .Sheet {if _febfa .SheetIdAttr > _cbca {_cbca =_febfa .SheetIdAttr ;};};_cbca ++;_cffc :=*_egbd ._dfdc .Sheets .Sheet [ind ];
_cffc .IdAttr =_fggc .ID ();_cffc .NameAttr =copiedSheetName ;_cffc .SheetIdAttr =_cbca ;_egbd ._dfdc .Sheets .Sheet =append (_egbd ._dfdc .Sheets .Sheet ,&_cffc );_fdbc :=_ad .NewRelationshipsCopy (_egbd ._dagcbb [ind ]);_egbd ._dagcbb =append (_egbd ._dagcbb ,_fdbc );
_cebd :=_egbd ._bfdfd [ind ];if _cebd ==nil {_egbd ._bfdfd =append (_egbd ._bfdfd ,nil );}else {_fbdg :=*_cebd ;_egbd ._bfdfd =append (_egbd ._bfdfd ,&_fbdg );};_abef :=Sheet {_egbd ,&_cffc ,&_ecdd };return _abef ,nil ;};

// SetHeight sets the height of the anchored object.
func (_bga AbsoluteAnchor )SetHeight (h _ge .Distance ){_bga ._gb .Ext .CyAttr =int64 (h /_ge .EMU )};

// IsWindowLocked returns whether the workbook windows are locked.
func (_afbc WorkbookProtection )IsWindowLocked ()bool {return _afbc ._deed .LockWindowsAttr !=nil &&*_afbc ._deed .LockWindowsAttr ;};func (_febe DataValidation )SetList ()DataValidationList {_febe .clear ();_febe ._aegb .TypeAttr =_bcd .ST_DataValidationTypeList ;
_febe ._aegb .OperatorAttr =_bcd .ST_DataValidationOperatorEqual ;return DataValidationList {_febe ._aegb };};

// SaveToFile writes the workbook out to a file.
func (_bff *Workbook )SaveToFile (path string )error {_cfbcf ,_dcfee :=_e .Create (path );if _dcfee !=nil {return _dcfee ;};defer _cfbcf .Close ();return _bff .Save (_cfbcf );};

// SetColOffset sets a column offset in absolute distance.
func (_afb CellMarker )SetColOffset (m _ge .Distance ){_afb ._dfd .ColOff .ST_CoordinateUnqualified =_c .Int64 (int64 (m /_ge .EMU ));};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_febf ,_acgd :=_e .Open (filename );if _acgd !=nil {return nil ,_ebb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_acgd );};defer _febf .Close ();
_efag ,_acgd :=_e .Stat (filename );if _acgd !=nil {return nil ,_ebb .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_acgd );};_fbda ,_acgd :=Read (_febf ,_efag .Size ());if _acgd !=nil {return nil ,_acgd ;
};_fcfd ,_ :=_a .Abs (_a .Dir (filename ));_fbda ._dcde =_a .Join (_fcfd ,filename );return _fbda ,nil ;};

// SetRowOffset sets a column offset in absolute distance.
func (_fege CellMarker )SetRowOffset (m _ge .Distance ){_fege ._dfd .RowOff .ST_CoordinateUnqualified =_c .Int64 (int64 (m /_ge .EMU ));};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_bcbee *_bcd .CT_DefinedName };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_cgaa *Sheet )Column (idx uint32 )Column {for _ ,_cbab :=range _cgaa ._gbef .Cols {for _ ,_dfcb :=range _cbab .Col {if idx >=_dfcb .MinAttr &&idx <=_dfcb .MaxAttr {return Column {_dfcb };};};};var _dffc *_bcd .CT_Cols ;if len (_cgaa ._gbef .Cols )==0{_dffc =_bcd .NewCT_Cols ();
_cgaa ._gbef .Cols =append (_cgaa ._gbef .Cols ,_dffc );}else {_dffc =_cgaa ._gbef .Cols [0];};_afgg :=_bcd .NewCT_Col ();_afgg .MinAttr =idx ;_afgg .MaxAttr =idx ;_dffc .Col =append (_dffc .Col ,_afgg );return Column {_afgg };};func (_aged Sheet )validateMergedCells ()error {_ggbe :=map[uint64 ]struct{}{};
for _ ,_eagd :=range _aged .MergedCells (){_bfde ,_fabac ,_fdfe :=_gdc .ParseRangeReference (_eagd .Reference ());if _fdfe !=nil {return _ebb .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_aged .Name (),_eagd .Reference ());
};for _dbbe :=_bfde .RowIdx ;_dbbe <=_fabac .RowIdx ;_dbbe ++{for _beg :=_bfde .ColumnIdx ;_beg <=_fabac .ColumnIdx ;_beg ++{_begd :=uint64 (_dbbe )<<32|uint64 (_beg );if _ ,_eceg :=_ggbe [_begd ];_eceg {return _ebb .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_aged .Name ());
};_ggbe [_begd ]=struct{}{};};};};return nil ;};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_aac CellStyle )GetHorizontalAlignment ()_bcd .ST_HorizontalAlignment {if _aac ._cbc .Alignment ==nil {return _bcd .ST_HorizontalAlignmentUnset ;};return _aac ._cbc .Alignment .HorizontalAttr ;};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_dgd Cell )SetFormulaRaw (s string ){_dcab :=_acb .ParseString (s );if _dcab ==nil {return ;};_dgd .clearValue ();_dgd ._de .TAttr =_bcd .ST_CellTypeStr ;_dgd ._de .F =_bcd .NewCT_CellFormula ();_dgd ._de .F .Content =s ;};

// X returns the inner wrapped XML type.
func (_accf ColorScale )X ()*_bcd .CT_ColorScale {return _accf ._dcfbd };

// MoveTo moves the top-left of the anchored object.
func (_age OneCellAnchor )MoveTo (col ,row int32 ){_age .TopLeft ().SetCol (col );_age .TopLeft ().SetRow (row );};

// SetError sets the cell type to error and the value to the given error message.
func (_cgga Cell )SetError (msg string ){_cgga .clearValue ();_cgga ._de .V =_c .String (msg );_cgga ._de .TAttr =_bcd .ST_CellTypeE ;};

// Sheet is a single sheet within a workbook.
type Sheet struct{_feaa *Workbook ;_ceda *_bcd .CT_Sheet ;_gbef *_bcd .Worksheet ;};func (_ebfe PatternFill )X ()*_bcd .CT_PatternFill {return _ebfe ._bea };func NewFills ()Fills {return Fills {_bcd .NewCT_Fills ()}};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_afgc *Sheet )RemoveMergedCell (mc MergedCell ){for _agadd ,_adab :=range _afgc ._gbef .MergeCells .MergeCell {if _adab ==mc .X (){copy (_afgc ._gbef .MergeCells .MergeCell [_agadd :],_afgc ._gbef .MergeCells .MergeCell [_agadd +1:]);_afgc ._gbef .MergeCells .MergeCell [len (_afgc ._gbef .MergeCells .MergeCell )-1]=nil ;
_afgc ._gbef .MergeCells .MergeCell =_afgc ._gbef .MergeCells .MergeCell [:len (_afgc ._gbef .MergeCells .MergeCell )-1];};};};

// StyleSheet is a document style sheet.
type StyleSheet struct{_edgf *Workbook ;_gaff *_bcd .StyleSheet ;};func NewPatternFill (fills *_bcd .CT_Fills )PatternFill {_ggc :=_bcd .NewCT_Fill ();_ggc .PatternFill =_bcd .NewCT_PatternFill ();return PatternFill {_ggc .PatternFill ,_ggc };};func (_fbad *Sheet )addNumberedRowFast (_dddg uint32 )Row {_fdaf :=_bcd .NewCT_Row ();
_fdaf .RAttr =_c .Uint32 (_dddg );_fbad ._gbef .SheetData .Row =append (_fbad ._gbef .SheetData .Row ,_fdaf );return Row {_fbad ._feaa ,_fbad ,_fdaf };};func (_aaa CellStyle )Index ()uint32 {for _ebad ,_cabb :=range _aaa ._fcg .Xf {if _aaa ._cbc ==_cabb {return uint32 (_ebad );
};};return 0;};

// SetHeight sets the height of the anchored object.
func (_dfg OneCellAnchor )SetHeight (h _ge .Distance ){_dfg ._acg .Ext .CyAttr =int64 (h /_ge .EMU )};func (_fcd *evalContext )NamedRange (ref string )_acb .Reference {for _ ,_cgag :=range _fcd ._bge ._feaa .DefinedNames (){if _cgag .Name ()==ref {return _acb .MakeRangeReference (_cgag .Content ());
};};for _ ,_bcg :=range _fcd ._bge ._feaa .Tables (){if _bcg .Name ()==ref {return _acb .MakeRangeReference (_ebb .Sprintf ("\u0025\u0073\u0021%\u0073",_fcd ._bge .Name (),_bcg .Reference ()));};};return _acb .ReferenceInvalid ;};

// SetWidth controls the width of a column.
func (_ebgd Column )SetWidth (w _ge .Distance ){_ebgd ._gdg .WidthAttr =_c .Float64 (float64 (w /_ge .Character ));};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_dfb CellStyle )NumberFormat ()uint32 {if _dfb ._cbc .NumFmtIdAttr ==nil {return 0;};return *_dfb ._cbc .NumFmtIdAttr ;};

// SetColOffset sets the column offset of the top-left anchor.
func (_ead OneCellAnchor )SetColOffset (m _ge .Distance ){_ead .TopLeft ().SetColOffset (m )};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_facg *Workbook )AddDefinedName (name ,ref string )DefinedName {if _facg ._dfdc .DefinedNames ==nil {_facg ._dfdc .DefinedNames =_bcd .NewCT_DefinedNames ();};_gbaad :=_bcd .NewCT_DefinedName ();_gbaad .Content =ref ;_gbaad .NameAttr =name ;_facg ._dfdc .DefinedNames .DefinedName =append (_facg ._dfdc .DefinedNames .DefinedName ,_gbaad );
return DefinedName {_gbaad };};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_gdeca *Sheet )SheetViews ()[]SheetView {if _gdeca ._gbef .SheetViews ==nil {return nil ;};_affca :=[]SheetView {};for _ ,_ebcb :=range _gdeca ._gbef .SheetViews .SheetView {_affca =append (_affca ,SheetView {_ebcb });};return _affca ;};

// RowOffset returns the offset from the row cell.
func (_bdcd CellMarker )RowOffset ()_ge .Distance {if _bdcd ._dfd .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _ge .Distance (float64 (*_bdcd ._dfd .RowOff .ST_CoordinateUnqualified )*_ge .EMU );};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_eebeg Sheet )RangeReference (n string )string {_bdge :=_fg .Split (n ,"\u003a");_cbfgg ,_ :=_gdc .ParseCellReference (_bdge [0]);_facc :=_ebb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_cbfgg .Column ,_cbfgg .RowIdx );if len (_bdge )==1{return _ebb .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_eebeg .Name (),_facc );
};_accg ,_ :=_gdc .ParseCellReference (_bdge [1]);_ccba :=_ebb .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_accg .Column ,_accg .RowIdx );return _ebb .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_eebeg .Name (),_facc ,_ccba );
};func _fbfc ()*_bgg .CT_TwoCellAnchor {_dec :=_bgg .NewCT_TwoCellAnchor ();_dec .EditAsAttr =_bgg .ST_EditAsOneCell ;_dec .From .Col =5;_dec .From .Row =0;_dec .From .ColOff .ST_CoordinateUnqualified =_c .Int64 (0);_dec .From .RowOff .ST_CoordinateUnqualified =_c .Int64 (0);
_dec .To .Col =10;_dec .To .Row =20;_dec .To .ColOff .ST_CoordinateUnqualified =_c .Int64 (0);_dec .To .RowOff .ST_CoordinateUnqualified =_c .Int64 (0);return _dec ;};

// GetValueAsBool retrieves the cell's value as a boolean
func (_bce Cell )GetValueAsBool ()(bool ,error ){if _bce ._de .TAttr !=_bcd .ST_CellTypeB {return false ,_cf .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");
};if _bce ._de .V ==nil {return false ,_cf .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _cc .ParseBool (*_bce ._de .V );};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_aab *Sheet )AddRow ()Row {_bbeg :=uint32 (0);_eebe :=uint32 (len (_aab ._gbef .SheetData .Row ));if _eebe > 0&&_aab ._gbef .SheetData .Row [_eebe -1].RAttr !=nil &&*_aab ._gbef .SheetData .Row [_eebe -1].RAttr ==_eebe {return _aab .addNumberedRowFast (_eebe +1);
};for _ ,_cfda :=range _aab ._gbef .SheetData .Row {if _cfda .RAttr !=nil &&*_cfda .RAttr > _bbeg {_bbeg =*_cfda .RAttr ;};};return _aab .AddNumberedRow (_bbeg +1);};func (_aaea Cell )getRawSortValue ()(string ,bool ){if _aaea .HasFormula (){_fge :=_aaea .GetCachedFormulaResult ();
return _fge ,_gd .IsNumber (_fge );};_efaa ,_ :=_aaea .GetRawValue ();return _efaa ,_gd .IsNumber (_efaa );};

// AddView adds a sheet view.
func (_cfbec *Sheet )AddView ()SheetView {if _cfbec ._gbef .SheetViews ==nil {_cfbec ._gbef .SheetViews =_bcd .NewCT_SheetViews ();};_geea :=_bcd .NewCT_SheetView ();_cfbec ._gbef .SheetViews .SheetView =append (_cfbec ._gbef .SheetViews .SheetView ,_geea );
return SheetView {_geea };};

// GetValueAsNumber retrieves the cell's value as a number
func (_bgc Cell )GetValueAsNumber ()(float64 ,error ){if _bgc ._de .V ==nil &&_bgc ._de .Is ==nil {return 0,nil ;};if _bgc ._de .TAttr ==_bcd .ST_CellTypeS ||!_gd .IsNumber (*_bgc ._de .V ){return _ff .NaN (),_cf .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");
};return _cc .ParseFloat (*_bgc ._de .V ,64);};

// X returns the inner wrapped XML type.
func (_bad CellMarker )X ()*_bgg .CT_Marker {return _bad ._dfd };

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_efe Comments )AddComment (cellRef string ,author string )RichText {_afbf :=_bcd .NewCT_Comment ();_efe ._bfcf .CommentList .Comment =append (_efe ._bfcf .CommentList .Comment ,_afbf );_afbf .RefAttr =cellRef ;_afbf .AuthorIdAttr =_efe .getOrCreateAuthor (author );
_afbf .Text =_bcd .NewCT_Rst ();return RichText {_afbf .Text };};

// Wrapped returns true if the cell will wrap text.
func (_eag CellStyle )Wrapped ()bool {if _eag ._cbc .Alignment ==nil {return false ;};if _eag ._cbc .Alignment .WrapTextAttr ==nil {return false ;};return *_eag ._cbc .Alignment .WrapTextAttr ;};

// SetRowOffset sets the row offset of the two cell anchor
func (_gbfb TwoCellAnchor )SetRowOffset (m _ge .Distance ){_fddbg :=m -_gbfb .TopLeft ().RowOffset ();_gbfb .TopLeft ().SetRowOffset (m );_gbfb .BottomRight ().SetRowOffset (_gbfb .BottomRight ().RowOffset ()+_fddbg );};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_cec Border )InitializeDefaults (){_cec ._fa .Left =_bcd .NewCT_BorderPr ();_cec ._fa .Bottom =_bcd .NewCT_BorderPr ();_cec ._fa .Right =_bcd .NewCT_BorderPr ();_cec ._fa .Top =_bcd .NewCT_BorderPr ();_cec ._fa .Diagonal =_bcd .NewCT_BorderPr ();
};func (_fgf PatternFill )SetBgColor (c _ffb .Color ){_fgf ._bea .BgColor =_bcd .NewCT_Color ();_fgf ._bea .BgColor .RgbAttr =c .AsRGBAString ();};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_caea *Workbook )RemoveSheet (ind int )error {if _caea .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_cfea :=range _caea ._dcef .Relationships (){if _cfea .ID ()==_caea ._dfdc .Sheets .Sheet [ind ].IdAttr {_caea ._dcef .Remove (_cfea );break ;
};};_caea .ContentTypes .RemoveOverride (_c .AbsoluteFilename (_c .DocTypeSpreadsheet ,_c .WorksheetContentType ,ind +1));copy (_caea ._agbbg [ind :],_caea ._agbbg [ind +1:]);_caea ._agbbg =_caea ._agbbg [:len (_caea ._agbbg )-1];_ggcg :=_caea ._dfdc .Sheets .Sheet [ind ];
copy (_caea ._dfdc .Sheets .Sheet [ind :],_caea ._dfdc .Sheets .Sheet [ind +1:]);_caea ._dfdc .Sheets .Sheet =_caea ._dfdc .Sheets .Sheet [:len (_caea ._dfdc .Sheets .Sheet )-1];for _aadb :=range _caea ._dfdc .Sheets .Sheet {if _caea ._dfdc .Sheets .Sheet [_aadb ].SheetIdAttr > _ggcg .SheetIdAttr {_caea ._dfdc .Sheets .Sheet [_aadb ].SheetIdAttr --;
};};copy (_caea ._dagcbb [ind :],_caea ._dagcbb [ind +1:]);_caea ._dagcbb =_caea ._dagcbb [:len (_caea ._dagcbb )-1];copy (_caea ._bfdfd [ind :],_caea ._bfdfd [ind +1:]);_caea ._bfdfd =_caea ._bfdfd [:len (_caea ._bfdfd )-1];return nil ;};

// X returns the inner wrapped XML type.
func (_eece Font )X ()*_bcd .CT_Font {return _eece ._fgd };func (_egbf Font )SetItalic (b bool ){if b {_egbf ._fgd .I =[]*_bcd .CT_BooleanProperty {{}};}else {_egbf ._fgd .I =nil ;};};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_bbac *Workbook )GetFilename ()string {return _bbac ._dcde };

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_fc AbsoluteAnchor )SetColOffset (m _ge .Distance ){_fc ._gb .Pos .XAttr .ST_CoordinateUnqualified =_c .Int64 (int64 (m /_ge .EMU ));};var _gef =[...]uint8 {0,18,37};

// IsStructureLocked returns whether the workbook structure is locked.
func (_efea WorkbookProtection )IsStructureLocked ()bool {return _efea ._deed .LockStructureAttr !=nil &&*_efea ._deed .LockStructureAttr ;};

// SetShowRuler controls the visibility of the ruler
func (_fdcb SheetView )SetShowRuler (b bool ){if !b {_fdcb ._adcgcf .ShowRulerAttr =_c .Bool (false );}else {_fdcb ._adcgcf .ShowRulerAttr =nil ;};};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_fd Cell )SetRichTextString ()RichText {_fd .clearValue ();_fd ._de .Is =_bcd .NewCT_Rst ();_fd ._de .TAttr =_bcd .ST_CellTypeInlineStr ;return RichText {_fd ._de .Is };};

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_dedg *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_ebdc :=_bcd .NewCT_ConditionalFormatting ();_dedg ._gbef .ConditionalFormatting =append (_dedg ._gbef .ConditionalFormatting ,_ebdc );_ebfed :=make (_bcd .ST_Sqref ,0,0);
_ebdc .SqrefAttr =&_ebfed ;for _ ,_faac :=range cellRanges {*_ebdc .SqrefAttr =append (*_ebdc .SqrefAttr ,_faac );};return ConditionalFormatting {_ebdc };};func (_bdd Cell )getLabelPrefix ()string {if _bdd ._de .SAttr ==nil {return "";};_dbef :=*_bdd ._de .SAttr ;
_dcfe :=_bdd ._fbc .StyleSheet .GetCellStyle (_dbef );switch _dcfe ._cbc .Alignment .HorizontalAttr {case _bcd .ST_HorizontalAlignmentLeft :return "\u0027";case _bcd .ST_HorizontalAlignmentRight :return "\u0022";case _bcd .ST_HorizontalAlignmentCenter :return "\u005e";
case _bcd .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// Name returns the name of the table
func (_cdda Table )Name ()string {if _cdda ._eacdd .NameAttr !=nil {return *_cdda ._eacdd .NameAttr ;};return "";};

// SetColor sets the text color.
func (_fcdg RichTextRun )SetColor (c _ffb .Color ){_fcdg .ensureRpr ();_fcdg ._cegd .RPr .Color =_bcd .NewCT_Color ();_bfcc :="\u0066\u0066"+*c .AsRGBString ();_fcdg ._cegd .RPr .Color .RgbAttr =&_bfcc ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bfbe Row )RowNumber ()uint32 {if _bfbe ._dddc .RAttr !=nil {return *_bfbe ._dddc .RAttr ;};return 0;};

// Tables returns a slice of all defined tables in the workbook.
func (_becf *Workbook )Tables ()[]Table {if _becf ._cfgf ==nil {return nil ;};_adfaa :=[]Table {};for _ ,_dffb :=range _becf ._cfgf {_adfaa =append (_adfaa ,Table {_dffb });};return _adfaa ;};func (_adb DifferentialStyle )Fill ()Fill {if _adb ._bbb .Fill ==nil {_adb ._bbb .Fill =_bcd .NewCT_Fill ();
};return Fill {_adb ._bbb .Fill ,nil };};

// Reference returns the table reference (the cells within the table)
func (_gebg Table )Reference ()string {return _gebg ._eacdd .RefAttr };func (_dca Border )SetBottom (style _bcd .ST_BorderStyle ,c _ffb .Color ){if _dca ._fa .Bottom ==nil {_dca ._fa .Bottom =_bcd .NewCT_BorderPr ();};_dca ._fa .Bottom .Color =_bcd .NewCT_Color ();
_dca ._fa .Bottom .Color .RgbAttr =c .AsRGBAString ();_dca ._fa .Bottom .StyleAttr =style ;};

// IsSheetLocked returns whether the sheet objects are locked.
func (_edag SheetProtection )IsObjectLocked ()bool {return _edag ._fggg .ObjectsAttr !=nil &&*_edag ._fggg .ObjectsAttr ;};

// Comments is the container for comments for a single sheet.
type Comments struct{_faba *Workbook ;_bfcf *_bcd .Comments ;};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_fecd *Sheet )ClearCachedFormulaResults (){for _ ,_aeed :=range _fecd .Rows (){for _ ,_egddg :=range _aeed .Cells (){if _egddg .X ().F !=nil {_egddg .X ().V =nil ;};};};};

// SetSize sets the text size for a rich text run.
func (_aaaf RichTextRun )SetSize (m _ge .Distance ){_aaaf .ensureRpr ();_aaaf ._cegd .RPr .Sz =_bcd .NewCT_FontSize ();_aaaf ._cegd .RPr .Sz .ValAttr =float64 (m /_ge .Point );};func (_eagg Fills )X ()*_bcd .CT_Fills {return _eagg ._cda };

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_bbgg *Workbook )ClearCachedFormulaResults (){for _ ,_ddbc :=range _bbgg .Sheets (){_ddbc .ClearCachedFormulaResults ();};};

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_aeb CellStyle )GetVerticalAlignment ()_bcd .ST_VerticalAlignment {if _aeb ._cbc .Alignment ==nil {return _bcd .ST_VerticalAlignmentUnset ;};return _aeb ._cbc .Alignment .VerticalAttr ;};

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};func (_fagbb StyleSheet )GetCellStyle (id uint32 )CellStyle {for _gbfde ,_cdcac :=range _fagbb ._gaff .CellXfs .Xf {if uint32 (_gbfde )==id {return CellStyle {_fagbb ._edgf ,_cdcac ,_fagbb ._gaff .CellXfs };};};
return CellStyle {};};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_dcfbd *_bcd .CT_ColorScale };

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_fdab NumberFormat )ID ()uint32 {return _fdab ._ccge .NumFmtIdAttr };const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_fac Cell )Reference ()string {if _fac ._de .RAttr !=nil {return *_fac ._de .RAttr ;};return "";};func (_ddd Cell )getFormat ()string {if _ddd ._de .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_bdf :=*_ddd ._de .SAttr ;_cgg :=_ddd ._fbc .StyleSheet .GetCellStyle (_bdf );
_cfe :=_ddd ._fbc .StyleSheet .GetNumberFormat (_cgg .NumberFormat ());return _cfe .GetFormat ();};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_feg Cell )SetDate (d _acc .Time ){_feg .clearValue ();d =_ffc (d );_dgeb :=_feg ._fbc .Epoch ();if d .Before (_dgeb ){_cfa .Log .Debug ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");
return ;};_gbf :=d .Sub (_dgeb );_abe :=new (_bgb .Float );_agfe :=new (_bgb .Float );_agfe .SetPrec (128);_agfe .SetUint64 (uint64 (_gbf ));_ecdg :=new (_bgb .Float );_ecdg .SetUint64 (24*60*60*1e9);_abe .Quo (_agfe ,_ecdg );_cde ,_ :=_abe .Uint64 ();
_feg ._de .V =_c .Stringf ("\u0025\u0064",_cde );};

// AddMergedCells merges cells within a sheet.
func (_agbd *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _agbd ._gbef .MergeCells ==nil {_agbd ._gbef .MergeCells =_bcd .NewCT_MergeCells ();};_fdfb :=_bcd .NewCT_MergeCell ();_fdfb .RefAttr =_ebb .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );
_agbd ._gbef .MergeCells .MergeCell =append (_agbd ._gbef .MergeCells .MergeCell ,_fdfb );_agbd ._gbef .MergeCells .CountAttr =_c .Uint32 (uint32 (len (_agbd ._gbef .MergeCells .MergeCell )));return MergedCell {_agbd ._feaa ,_agbd ,_fdfb };};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_adee *_bgg .CT_TwoCellAnchor };func (_bade *Workbook )ensureSharedStringsRelationships (){_dffdg :=false ;for _ ,_baedd :=range _bade .ContentTypes .X ().Override {if _baedd .ContentTypeAttr ==_c .SharedStringsContentType {_dffdg =true ;
break ;};};if !_dffdg {_bade .ContentTypes .AddOverride (_fgc ,_c .SharedStringsContentType );};_cbad :=false ;for _ ,_gafg :=range _bade ._dcef .Relationships (){if _gafg .X ().TargetAttr ==_bfab {_cbad =true ;break ;};};if !_cbad {_bade ._dcef .AddRelationship (_bfab ,_c .SharedStringsType );
};};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_eabg *Sheet )SetBorder (cellRange string ,border Border )error {_cbfgb ,_dcdf ,_ebffb :=_gdc .ParseRangeReference (cellRange );if _ebffb !=nil {return _ebffb ;};_bccc :=_eabg ._feaa .StyleSheet .AddCellStyle ();_fcec :=_eabg ._feaa .StyleSheet .AddBorder ();
_bccc .SetBorder (_fcec );_fcec ._fa .Top =border ._fa .Top ;_fcec ._fa .Left =border ._fa .Left ;_effc :=_eabg ._feaa .StyleSheet .AddCellStyle ();_aadf :=_eabg ._feaa .StyleSheet .AddBorder ();_effc .SetBorder (_aadf );_aadf ._fa .Top =border ._fa .Top ;
_aadf ._fa .Right =border ._fa .Right ;_eegec :=_eabg ._feaa .StyleSheet .AddCellStyle ();_dbec :=_eabg ._feaa .StyleSheet .AddBorder ();_eegec .SetBorder (_dbec );_dbec ._fa .Top =border ._fa .Top ;_eafg :=_eabg ._feaa .StyleSheet .AddCellStyle ();_bacc :=_eabg ._feaa .StyleSheet .AddBorder ();
_eafg .SetBorder (_bacc );_bacc ._fa .Left =border ._fa .Left ;_dggad :=_eabg ._feaa .StyleSheet .AddCellStyle ();_aade :=_eabg ._feaa .StyleSheet .AddBorder ();_dggad .SetBorder (_aade );_aade ._fa .Right =border ._fa .Right ;_dfab :=_eabg ._feaa .StyleSheet .AddCellStyle ();
_eacd :=_eabg ._feaa .StyleSheet .AddBorder ();_dfab .SetBorder (_eacd );_eacd ._fa .Bottom =border ._fa .Bottom ;_daaf :=_eabg ._feaa .StyleSheet .AddCellStyle ();_dcfgb :=_eabg ._feaa .StyleSheet .AddBorder ();_daaf .SetBorder (_dcfgb );_dcfgb ._fa .Bottom =border ._fa .Bottom ;
_dcfgb ._fa .Left =border ._fa .Left ;_baac :=_eabg ._feaa .StyleSheet .AddCellStyle ();_cdd :=_eabg ._feaa .StyleSheet .AddBorder ();_baac .SetBorder (_cdd );_cdd ._fa .Bottom =border ._fa .Bottom ;_cdd ._fa .Right =border ._fa .Right ;_fcgb :=_cbfgb .RowIdx ;
_bgccg :=_cbfgb .ColumnIdx ;_cfbe :=_dcdf .RowIdx ;_gdadd :=_dcdf .ColumnIdx ;for _gfef :=_fcgb ;_gfef <=_cfbe ;_gfef ++{for _dbdfe :=_bgccg ;_dbdfe <=_gdadd ;_dbdfe ++{_dbbc :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_dbdfe ),_gfef );
switch {case _gfef ==_fcgb &&_dbdfe ==_bgccg :_eabg .Cell (_dbbc ).SetStyle (_bccc );case _gfef ==_fcgb &&_dbdfe ==_gdadd :_eabg .Cell (_dbbc ).SetStyle (_effc );case _gfef ==_cfbe &&_dbdfe ==_bgccg :_eabg .Cell (_dbbc ).SetStyle (_daaf );case _gfef ==_cfbe &&_dbdfe ==_gdadd :_eabg .Cell (_dbbc ).SetStyle (_baac );
case _gfef ==_fcgb :_eabg .Cell (_dbbc ).SetStyle (_eegec );case _gfef ==_cfbe :_eabg .Cell (_dbbc ).SetStyle (_dfab );case _dbdfe ==_bgccg :_eabg .Cell (_dbbc ).SetStyle (_eafg );case _dbdfe ==_gdadd :_eabg .Cell (_dbbc ).SetStyle (_dggad );};};};return nil ;
};func (_bcb Border )SetRight (style _bcd .ST_BorderStyle ,c _ffb .Color ){if _bcb ._fa .Right ==nil {_bcb ._fa .Right =_bcd .NewCT_BorderPr ();};_bcb ._fa .Right .Color =_bcd .NewCT_Color ();_bcb ._fa .Right .Color .RgbAttr =c .AsRGBAString ();_bcb ._fa .Right .StyleAttr =style ;
};

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_gaec StyleSheet )Fills ()Fills {return Fills {_gaec ._gaff .Fills }};

// SetXSplit sets the column split point
func (_fccg SheetView )SetXSplit (v float64 ){_fccg .ensurePane ();_fccg ._adcgcf .Pane .XSplitAttr =_c .Float64 (v );};func (_gca Border )SetLeft (style _bcd .ST_BorderStyle ,c _ffb .Color ){if _gca ._fa .Left ==nil {_gca ._fa .Left =_bcd .NewCT_BorderPr ();
};_gca ._fa .Left .Color =_bcd .NewCT_Color ();_gca ._fa .Left .Color .RgbAttr =c .AsRGBAString ();_gca ._fa .Left .StyleAttr =style ;};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_cgc Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _aacf ,_gfba Cell ;for _ ,_dbge :=range lhs .Cells (){_cbge ,_ :=_gdc .ParseCellReference (_dbge .Reference ());if _cbge .Column ==column {_aacf =_dbge ;break ;};};for _ ,_dae :=range rhs .Cells (){_aeace ,_ :=_gdc .ParseCellReference (_dae .Reference ());
if _aeace .Column ==column {_gfba =_dae ;break ;};};return _cgc .LessCells (_aacf ,_gfba );};func (_cggc Cell )getLocked ()bool {if _cggc ._de .SAttr ==nil {return false ;};_ged :=*_cggc ._de .SAttr ;_eec :=_cggc ._fbc .StyleSheet .GetCellStyle (_ged );
return *_eec ._cbc .Protection .LockedAttr ;};

// SheetCount returns the number of sheets in the workbook.
func (_dabdb Workbook )SheetCount ()int {return len (_dabdb ._agbbg )};func (_fgad *Sheet )setShared (_fdfa string ,_fccc ,_fdfg _gdc .CellReference ,_ebaa string ){_eebf :=_fgad .FormulaContext ();_gffg :=_acb .NewEvaluator ();for _eacg :=_fccc .RowIdx ;
_eacg <=_fdfg .RowIdx ;_eacg ++{for _aeec :=_fccc .ColumnIdx ;_aeec <=_fdfg .ColumnIdx ;_aeec ++{_ebe :=_eacg -_fccc .RowIdx ;_dffge :=_aeec -_fccc .ColumnIdx ;_eebf .SetOffset (_dffge ,_ebe );_fgdeg :=_gffg .Eval (_eebf ,_ebaa );_cfbcd :=_ebb .Sprintf ("\u0025\u0073\u0025\u0064",_gdc .IndexToColumn (_aeec ),_eacg );
_egag :=_fgad .Cell (_cfbcd );if _fgdeg .Type ==_acb .ResultTypeNumber {_egag .X ().TAttr =_bcd .ST_CellTypeN ;}else {_egag .X ().TAttr =_bcd .ST_CellTypeInlineStr ;};_egag .X ().V =_c .String (_fgdeg .Value ());};};_ =_gffg ;_ =_eebf ;};

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_cfeb *Sheet )InsertRow (rowNum int )Row {_gfcg :=uint32 (rowNum );for _ ,_gbbb :=range _cfeb .Rows (){if _gbbb ._dddc .RAttr !=nil &&*_gbbb ._dddc .RAttr >=_gfcg {*_gbbb ._dddc .RAttr ++;for _ ,_gcdc :=range _gbbb .Cells (){_ddgd ,_ecc :=_gdc .ParseCellReference (_gcdc .Reference ());
if _ecc !=nil {continue ;};_ddgd .RowIdx ++;_gcdc ._de .RAttr =_c .String (_ddgd .String ());};};};for _ ,_cbe :=range _cfeb .MergedCells (){_aaeg ,_bgadg ,_cdca :=_gdc .ParseRangeReference (_cbe .Reference ());if _cdca !=nil {continue ;};if int (_aaeg .RowIdx )>=rowNum {_aaeg .RowIdx ++;
};if int (_bgadg .RowIdx )>=rowNum {_bgadg .RowIdx ++;};_gdea :=_ebb .Sprintf ("\u0025\u0073\u003a%\u0073",_aaeg ,_bgadg );_cbe .SetReference (_gdea );};return _cfeb .AddNumberedRow (_gfcg );};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_ag AbsoluteAnchor )SetRowOffset (m _ge .Distance ){_ag ._gb .Pos .YAttr .ST_CoordinateUnqualified =_c .Int64 (int64 (m /_ge .EMU ));};

// SetText sets the text to be displayed.
func (_gegf RichTextRun )SetText (s string ){_gegf ._cegd .T =s };

// SetType sets the type of the rule.
func (_bfcb ConditionalFormattingRule )SetType (t _bcd .ST_CfType ){_bfcb ._faa .TypeAttr =t };

// SetBold causes the text to be displayed in bold.
func (_afcd RichTextRun )SetBold (b bool ){_afcd .ensureRpr ();_afcd ._cegd .RPr .B =_bcd .NewCT_BooleanProperty ();_afcd ._cegd .RPr .B .ValAttr =_c .Bool (b );};

// X returns the inner wrapped XML type.
func (_dede SheetView )X ()*_bcd .CT_SheetView {return _dede ._adcgcf };

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_gbdb *Workbook )RemoveCalcChain (){var _cfcf string ;for _ ,_accb :=range _gbdb ._dcef .Relationships (){if _accb .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_cfcf ="\u0078\u006c\u002f"+_accb .Target ();
_gbdb ._dcef .Remove (_accb );break ;};};if _cfcf ==""{return ;};_gbdb .ContentTypes .RemoveOverride (_cfcf );for _gbgb ,_adfdb :=range _gbdb .ExtraFiles {if _adfdb .ZipPath ==_cfcf {_gbdb .ExtraFiles [_gbgb ]=_gbdb .ExtraFiles [len (_gbdb .ExtraFiles )-1];
_gbdb .ExtraFiles =_gbdb .ExtraFiles [:len (_gbdb .ExtraFiles )-1];return ;};};};

// Text returns text from the workbook as one string separated with line breaks.
func (_baa *WorkbookText )Text ()string {_dbbb :=_ac .NewBuffer ([]byte {});for _ ,_gbae :=range _baa .Sheets {_dbbb .WriteString (_gbae .Text ());};return _dbbb .String ();};

// LockStructure controls the locking of the workbook structure.
func (_bfgb WorkbookProtection )LockStructure (b bool ){if !b {_bfgb ._deed .LockStructureAttr =nil ;}else {_bfgb ._deed .LockStructureAttr =_c .Bool (true );};};