//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet ;import (_gc "archive/zip";_ggg "bytes";_ccd "errors";_bf "fmt";_g "github.com/unidoc/unioffice";_ba "github.com/unidoc/unioffice/chart";_bag "github.com/unidoc/unioffice/color";_cgb "github.com/unidoc/unioffice/common";_cea "github.com/unidoc/unioffice/common/tempstorage";_ae "github.com/unidoc/unioffice/internal/license";_daeg "github.com/unidoc/unioffice/measurement";_aef "github.com/unidoc/unioffice/schema/soo/dml";_dg "github.com/unidoc/unioffice/schema/soo/dml/chart";_fa "github.com/unidoc/unioffice/schema/soo/dml/spreadsheetDrawing";_db "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ccg "github.com/unidoc/unioffice/schema/soo/sml";_ef "github.com/unidoc/unioffice/spreadsheet/format";_fe "github.com/unidoc/unioffice/spreadsheet/formula";_cd "github.com/unidoc/unioffice/spreadsheet/reference";_ee "github.com/unidoc/unioffice/spreadsheet/update";_cab "github.com/unidoc/unioffice/vmldrawing";_fg "github.com/unidoc/unioffice/zippkg";_f "image";_d "image/jpeg";_cc "io";_bb "log";_dae "math";_cg "math/big";_gg "os";_e "path";_ce "path/filepath";_a "regexp";_c "sort";_gf "strconv";_da "strings";_ca "time";);

// Borders returns the list of borders defined in the stylesheet.
func (_addc StyleSheet )Borders ()[]Border {_gbcg :=[]Border {};for _ ,_agfb :=range _addc ._dcae .Borders .Border {_gbcg =append (_gbcg ,Border {_cb :_agfb });};return _gbcg ;};

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_acg Cell )SetRichTextString ()RichText {_acg .clearValue ();_acg ._debc .Is =_ccg .NewCT_Rst ();_acg ._debc .TAttr =_ccg .ST_CellTypeInlineStr ;return RichText {_acg ._debc .Is };};

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_fac Cell )GetString ()string {switch _fac ._debc .TAttr {case _ccg .ST_CellTypeInlineStr :if _fac ._debc .Is !=nil &&_fac ._debc .Is .T !=nil {return *_fac ._debc .Is .T ;};if _fac ._debc .V !=nil {return *_fac ._debc .V ;};case _ccg .ST_CellTypeS :if _fac ._debc .V ==nil {return "";};_gcb ,_ccc :=_gf .Atoi (*_fac ._debc .V );if _ccc !=nil {return "";};_ff ,_ccc :=_fac ._ebb .SharedStrings .GetString (_gcb );if _ccc !=nil {return "";};return _ff ;};if _fac ._debc .V ==nil {return "";};return *_fac ._debc .V ;};func (_fdefe *Workbook )onNewRelationship (_badae *_fg .DecodeMap ,_bbgge ,_ccfe string ,_cdgd []*_gc .File ,_fcddc *_db .Relationship ,_edaff _fg .Target )error {_beca :=_g .DocTypeSpreadsheet ;switch _ccfe {case _g .OfficeDocumentType :_fdefe ._acbg =_ccg .NewWorkbook ();_badae .AddTarget (_bbgge ,_fdefe ._acbg ,_ccfe ,0);_fdefe ._gbaf =_cgb .NewRelationships ();_badae .AddTarget (_fg .RelationsPathFor (_bbgge ),_fdefe ._gbaf .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .CorePropertiesType :_badae .AddTarget (_bbgge ,_fdefe .CoreProperties .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .CustomPropertiesType :_badae .AddTarget (_bbgge ,_fdefe .CustomProperties .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .ExtendedPropertiesType :_badae .AddTarget (_bbgge ,_fdefe .AppProperties .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .WorksheetType :_cddaac :=_ccg .NewWorksheet ();_dcfb :=uint32 (len (_fdefe ._acac ));_fdefe ._acac =append (_fdefe ._acac ,_cddaac );_badae .AddTarget (_bbgge ,_cddaac ,_ccfe ,_dcfb );_fagc :=_cgb .NewRelationships ();_badae .AddTarget (_fg .RelationsPathFor (_bbgge ),_fagc .X (),_ccfe ,0);_fdefe ._eabe =append (_fdefe ._eabe ,_fagc );_fdefe ._bgeff =append (_fdefe ._bgeff ,nil );_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._acac ));case _g .StylesType :_fdefe .StyleSheet =NewStyleSheet (_fdefe );_badae .AddTarget (_bbgge ,_fdefe .StyleSheet .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .ThemeType :_geaf :=_aef .NewTheme ();_fdefe ._fggfc =append (_fdefe ._fggfc ,_geaf );_badae .AddTarget (_bbgge ,_geaf ,_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._fggfc ));case _g .SharedStringsType :_fdefe .SharedStrings =NewSharedStrings ();_badae .AddTarget (_bbgge ,_fdefe .SharedStrings .X (),_ccfe ,0);_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,0);case _g .ThumbnailType :for _cgfb ,_dddf :=range _cdgd {if _dddf ==nil {continue ;};if _dddf .Name ==_bbgge {_cace ,_aedaf :=_dddf .Open ();if _aedaf !=nil {return _bf .Errorf ("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073",_aedaf );};_fdefe .Thumbnail ,_ ,_aedaf =_f .Decode (_cace );_cace .Close ();if _aedaf !=nil {return _bf .Errorf ("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073",_aedaf );};_cdgd [_cgfb ]=nil ;};};case _g .ImageType :for _fegeg ,_gdc :=range _fdefe ._dgac {_efde :=_e .Clean (_bbgge );if _efde ==_fegeg {_fcddc .TargetAttr =_gdc ;return nil ;};};_gegd :=_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe .Images )+1);for _dedae ,_gccca :=range _cdgd {if _gccca ==nil {continue ;};if _gccca .Name ==_e .Clean (_bbgge ){_bgg ,_gfce :=_fg .ExtractToDiskTmp (_gccca ,_fdefe .TmpPath );if _gfce !=nil {return _gfce ;};_ccaca ,_gfce :=_cgb .ImageFromStorage (_bgg );if _gfce !=nil {return _gfce ;};_abcg :=_cgb .MakeImageRef (_ccaca ,&_fdefe .DocBase ,_fdefe ._gbaf );_abcg .SetTarget (_gegd );_fdefe ._dgac [_gccca .Name ]=_gegd ;_fdefe .Images =append (_fdefe .Images ,_abcg );_cdgd [_dedae ]=nil ;};};_fcddc .TargetAttr =_gegd ;case _g .DrawingType :_ebadd :=_fa .NewWsDr ();_bafa :=uint32 (len (_fdefe ._egddd ));_badae .AddTarget (_bbgge ,_ebadd ,_ccfe ,_bafa );_fdefe ._egddd =append (_fdefe ._egddd ,_ebadd );_decd :=_cgb .NewRelationships ();_badae .AddTarget (_fg .RelationsPathFor (_bbgge ),_decd .X (),_ccfe ,_bafa );_fdefe ._ebfeb =append (_fdefe ._ebfeb ,_decd );_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._egddd ));case _g .VMLDrawingType :_gfdab :=_cab .NewContainer ();_bef :=uint32 (len (_fdefe ._aaae ));_badae .AddTarget (_bbgge ,_gfdab ,_ccfe ,_bef );_fdefe ._aaae =append (_fdefe ._aaae ,_gfdab );case _g .CommentsType :_fdefe ._bgeff [_edaff .Index ]=_ccg .NewComments ();_badae .AddTarget (_bbgge ,_fdefe ._bgeff [_edaff .Index ],_ccfe ,_edaff .Index );_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._bgeff ));case _g .ChartType :_efabd :=_dg .NewChartSpace ();_fdbb :=uint32 (len (_fdefe ._bgaaf ));_badae .AddTarget (_bbgge ,_efabd ,_ccfe ,_fdbb );_fdefe ._bgaaf =append (_fdefe ._bgaaf ,_efabd );_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._bgaaf ));_fdefe ._begc [_fcddc .TargetAttr ]=_efabd ;case _g .TableType :_aegda :=_ccg .NewTable ();_cgff :=uint32 (len (_fdefe ._eegf ));_badae .AddTarget (_bbgge ,_aegda ,_ccfe ,_cgff );_fdefe ._eegf =append (_fdefe ._eegf ,_aegda );_fcddc .TargetAttr =_g .RelativeFilename (_beca ,_edaff .Typ ,_ccfe ,len (_fdefe ._eegf ));default:_g .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073",_bbgge ,_ccfe );};return nil ;};

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct{_cged *_ccg .Sst ;_bbgd map[string ]int ;};

// SetStyle sets the style to be used for conditional rules
func (_eaae ConditionalFormattingRule )SetStyle (d DifferentialStyle ){_eaae ._fdef .DxfIdAttr =_g .Uint32 (d .Index ());};func (_aeaa CellStyle )Index ()uint32 {for _fde ,_ace :=range _aeaa ._edac .Xf {if _aeaa ._bed ==_ace {return uint32 (_fde );};};return 0;};

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_gdaf *Sheet )SheetViews ()[]SheetView {if _gdaf ._ggac .SheetViews ==nil {return nil ;};_eadc :=[]SheetView {};for _ ,_degeb :=range _gdaf ._ggac .SheetViews .SheetView {_eadc =append (_eadc ,SheetView {_degeb });};return _eadc ;};

// IsDBCS returns if a workbook's default language is among DBCS.
func (_dgb *evalContext )IsDBCS ()bool {_fdgbd :=_dgb ._gdg ._facca .CoreProperties .X ().Language ;if _fdgbd ==nil {return false ;};_eafa :=string (_fdgbd .Data );for _ ,_adc :=range _dada {if _eafa ==_adc {return true ;};};return false ;};

// SetRow set the row of the cell marker.
func (_eab CellMarker )SetRow (row int32 ){_eab ._fee .Row =row };func NewPatternFill (fills *_ccg .CT_Fills )PatternFill {_egbcb :=_ccg .NewCT_Fill ();_egbcb .PatternFill =_ccg .NewCT_PatternFill ();return PatternFill {_egbcb .PatternFill ,_egbcb };};

// AddFormatValue adds a format value to be used to determine the cell background.
func (_egeg ColorScale )AddFormatValue (t _ccg .ST_CfvoType ,val string ){_dbc :=_ccg .NewCT_Cfvo ();_dbc .TypeAttr =t ;_dbc .ValAttr =_g .String (val );_egeg ._fede .Cfvo =append (_egeg ._fede .Cfvo ,_dbc );};

// SetPassword sets the password hash to a hash of the input password.
func (_ffac SheetProtection )SetPassword (pw string ){_ffac .SetPasswordHash (PasswordHash (pw ))};

// X returns the inner wrapped XML type.
func (_becg ConditionalFormatting )X ()*_ccg .CT_ConditionalFormatting {return _becg ._cf };func (_fgbe DataValidation )clear (){_fgbe ._fded .Formula1 =_g .String ("\u0030");_fgbe ._fded .Formula2 =_g .String ("\u0030");};

// IsNumber returns true if the cell is a number type cell.
func (_dce Cell )IsNumber ()bool {switch _dce ._debc .TAttr {case _ccg .ST_CellTypeN :return true ;case _ccg .ST_CellTypeS ,_ccg .ST_CellTypeB :return false ;};return _dce ._debc .V !=nil &&_ef .IsNumber (*_dce ._debc .V );};func (_gggg DifferentialStyle )Fill ()Fill {if _gggg ._dfab .Fill ==nil {_gggg ._dfab .Fill =_ccg .NewCT_Fill ();};return Fill {_gggg ._dfab .Fill ,nil };};

// HasFormula returns true if the cell contains formula.
func (_aggg *evalContext )HasFormula (cellRef string )bool {return _aggg ._gdg .Cell (cellRef ).HasFormula ();};

// SortOrder is a column sort order.
//go:generate stringer -type=SortOrder
type SortOrder byte ;

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{_ddgf *_ccg .CT_RElt };

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_dcdg *Sheet )AddNumberedRow (rowNum uint32 )Row {_fagg :=_ccg .NewCT_Row ();_fagg .RAttr =_g .Uint32 (rowNum );_dcdg ._ggac .SheetData .Row =append (_dcdg ._ggac .SheetData .Row ,_fagg );_c .Slice (_dcdg ._ggac .SheetData .Row ,func (_cdeg ,_badab int )bool {_bgaa :=_dcdg ._ggac .SheetData .Row [_cdeg ].RAttr ;_gebg :=_dcdg ._ggac .SheetData .Row [_badab ].RAttr ;if _bgaa ==nil {return true ;};if _gebg ==nil {return true ;};return *_bgaa < *_gebg ;});return Row {_dcdg ._facca ,_dcdg ,_fagg };};

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_dab Cell )SetNumberWithStyle (v float64 ,f StandardFormat ){_dab .SetNumber (v );_dab .SetStyle (_dab ._ebb .StyleSheet .GetOrCreateStandardNumberFormat (f ));};

// SaveToFile writes the workbook out to a file.
func (_badg *Workbook )SaveToFile (path string )error {_gbea ,_debbd :=_gg .Create (path );if _debbd !=nil {return _debbd ;};defer _gbea .Close ();return _badg .Save (_gbea );};

// X returns the inner wrapped XML type.
func (_aag ConditionalFormattingRule )X ()*_ccg .CT_CfRule {return _aag ._fdef };

// X returns the inner wrapped XML type.
func (_ceda DifferentialStyle )X ()*_ccg .CT_Dxf {return _ceda ._dfab };

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_bgba *Sheet )RemoveColumn (column string )error {_faae ,_efaef :=_bgba .getAllCellsInFormulaArraysForColumn ();if _efaef !=nil {return _efaef ;};_gcea :=_cd .ColumnToIndex (column );for _ ,_facb :=range _bgba .Rows (){_ggfe :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",column ,*_facb .X ().RAttr );if _ ,_dfgc :=_faae [_ggfe ];_dfgc {return nil ;};};for _ ,_cgbb :=range _bgba .Rows (){_ffa :=_cgbb ._gagf .C ;for _eefc ,_aecg :=range _ffa {_gdfe ,_cabc :=_cd .ParseCellReference (*_aecg .RAttr );if _cabc !=nil {return _cabc ;};if _gdfe .ColumnIdx ==_gcea {_cgbb ._gagf .C =append (_ffa [:_eefc ],_bgba .slideCellsLeft (_ffa [_eefc +1:])...);break ;}else if _gdfe .ColumnIdx > _gcea {_cgbb ._gagf .C =append (_ffa [:_eefc ],_bgba .slideCellsLeft (_ffa [_eefc :])...);break ;};};};_efaef =_bgba .updateAfterRemove (_gcea ,_ee .UpdateActionRemoveColumn );if _efaef !=nil {return _efaef ;};_efaef =_bgba .removeColumnFromNamedRanges (_gcea );if _efaef !=nil {return _efaef ;};_efaef =_bgba .removeColumnFromMergedCells (_gcea );if _efaef !=nil {return _efaef ;};for _ ,_cddaa :=range _bgba ._facca .Sheets (){_cddaa .RecalculateFormulas ();};return nil ;};func (_ddbg SortOrder )String ()string {if _ddbg >=SortOrder (len (_fgbdg )-1){return _bf .Sprintf ("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029",_ddbg );};return _eadf [_fgbdg [_ddbg ]:_fgbdg [_ddbg +1]];};

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct{_gaee *Workbook ;_ebba *_ccg .CT_NumFmt ;};

// SetReference sets the regin of cells that the merged cell applies to.
func (_fadd MergedCell )SetReference (ref string ){_fadd ._gce .RefAttr =ref };

// Workbook returns sheet's parent workbook.
func (_afad *Sheet )Workbook ()*Workbook {return _afad ._facca };func (_bage Cell )setLocked (_bcge bool ){_cbg :=_bage ._debc .SAttr ;if _cbg !=nil {_ddc :=_bage ._ebb .StyleSheet .GetCellStyle (*_cbg );if _ddc ._bed .Protection ==nil {_ddc ._bed .Protection =_ccg .NewCT_CellProtection ();};_ddc ._bed .Protection .LockedAttr =&_bcge ;};};

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_cad CellStyle )GetHorizontalAlignment ()_ccg .ST_HorizontalAlignment {if _cad ._bed .Alignment ==nil {return _ccg .ST_HorizontalAlignmentUnset ;};return _cad ._bed .Alignment .HorizontalAttr ;};func _fbbc (_fgcd string )bool {_fgcd =_da .Replace (_fgcd ,"\u0024","",-1);if _gdbf :=_ddec .FindStringSubmatch (_da .ToLower (_fgcd ));len (_gdbf )> 2{_beea :=_gdbf [1];_bdg ,_gebf :=_gf .Atoi (_gdbf [2]);if _gebf !=nil {return false ;};return _bdg <=1048576&&_beea <="\u007a\u007a";};return false ;};var ErrorNotFound =_ccd .New ("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed");

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_ffef *Sheet )InitialView ()SheetView {if _ffef ._ggac .SheetViews ==nil ||len (_ffef ._ggac .SheetViews .SheetView )==0{return _ffef .AddView ();};return SheetView {_ffef ._ggac .SheetViews .SheetView [0]};};

// DataValidation controls cell validation
type DataValidation struct{_fded *_ccg .CT_DataValidation };

// AddRule adds and returns a new rule that can be configured.
func (_cccg ConditionalFormatting )AddRule ()ConditionalFormattingRule {_eeca :=_ccg .NewCT_CfRule ();_cccg ._cf .CfRule =append (_cccg ._cf .CfRule ,_eeca );_cfa :=ConditionalFormattingRule {_eeca };_cfa .InitializeDefaults ();_cfa .SetPriority (int32 (len (_cccg ._cf .CfRule )+1));return _cfa ;};

// Col returns the column of the cell marker.
func (_cbbe CellMarker )Col ()int32 {return _cbbe ._fee .Col };func (_bbea *Sheet )getAllCellsInFormulaArrays (_ddff bool )(map[string ]bool ,error ){_ffca :=_fe .NewEvaluator ();_ccbdb :=_bbea .FormulaContext ();_gca :=map[string ]bool {};for _ ,_afga :=range _bbea .Rows (){for _ ,_daba :=range _afga .Cells (){if _daba .X ().F !=nil {_aeaac :=_daba .X ().F .Content ;if _daba .X ().F .TAttr ==_ccg .ST_CellFormulaTypeArray {_aeaf :=_ffca .Eval (_ccbdb ,_aeaac ).AsString ();if _aeaf .Type ==_fe .ResultTypeError {_g .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_aeaac ,_aeaf .ErrorMessage );_daba .X ().V =nil ;};if _aeaf .Type ==_fe .ResultTypeArray {_abge ,_ccegg :=_cd .ParseCellReference (_daba .Reference ());if _ccegg !=nil {return map[string ]bool {},_ccegg ;};if (_ddff &&len (_aeaf .ValueArray )==1)||(!_ddff &&len (_aeaf .ValueArray [0])==1){continue ;};for _afea ,_cbac :=range _aeaf .ValueArray {_adfaf :=_abge .RowIdx +uint32 (_afea );for _gcaf :=range _cbac {_fcae :=_cd .IndexToColumn (_abge .ColumnIdx +uint32 (_gcaf ));_gca [_bf .Sprintf ("\u0025\u0073\u0025\u0064",_fcae ,_adfaf )]=true ;};};}else if _aeaf .Type ==_fe .ResultTypeList {_eace ,_gedf :=_cd .ParseCellReference (_daba .Reference ());if _gedf !=nil {return map[string ]bool {},_gedf ;};if _ddff ||len (_aeaf .ValueList )==1{continue ;};_fgdc :=_eace .RowIdx ;for _dgfg :=range _aeaf .ValueList {_ggfef :=_cd .IndexToColumn (_eace .ColumnIdx +uint32 (_dgfg ));_gca [_bf .Sprintf ("\u0025\u0073\u0025\u0064",_ggfef ,_fgdc )]=true ;};};};};};};return _gca ,nil ;};

// X returns the inner wrapped XML type.
func (_ab Border )X ()*_ccg .CT_Border {return _ab ._cb };func (_deda DataValidation )SetList ()DataValidationList {_deda .clear ();_deda ._fded .TypeAttr =_ccg .ST_DataValidationTypeList ;_deda ._fded .OperatorAttr =_ccg .ST_DataValidationOperatorEqual ;return DataValidationList {_deda ._fded };};

// SetType sets the type of the rule.
func (_aefe ConditionalFormattingRule )SetType (t _ccg .ST_CfType ){_aefe ._fdef .TypeAttr =t };

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_cgdb *Sheet )Column (idx uint32 )Column {for _ ,_gdd :=range _cgdb ._ggac .Cols {for _ ,_ccgda :=range _gdd .Col {if idx >=_ccgda .MinAttr &&idx <=_ccgda .MaxAttr {return Column {_ccgda };};};};var _deec *_ccg .CT_Cols ;if len (_cgdb ._ggac .Cols )==0{_deec =_ccg .NewCT_Cols ();_cgdb ._ggac .Cols =append (_cgdb ._ggac .Cols ,_deec );}else {_deec =_cgdb ._ggac .Cols [0];};_dfag :=_ccg .NewCT_Col ();_dfag .MinAttr =idx ;_dfag .MaxAttr =idx ;_deec .Col =append (_deec .Col ,_dfag );return Column {_dfag };};

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_fgbd Comparer )LessRows (column string ,lhs ,rhs Row )bool {var _bcab ,_bff Cell ;for _ ,_cba :=range lhs .Cells (){_bfbb ,_ :=_cd .ParseCellReference (_cba .Reference ());if _bfbb .Column ==column {_bcab =_cba ;break ;};};for _ ,_gccc :=range rhs .Cells (){_dcc ,_ :=_cd .ParseCellReference (_gccc .Reference ());if _dcc .Column ==column {_bff =_gccc ;break ;};};return _fgbd .LessCells (_bcab ,_bff );};type Fills struct{_babc *_ccg .CT_Fills };

// IconScale maps values to icons.
type IconScale struct{_dee *_ccg .CT_IconSet };

// SetNumber sets the cell type to number, and the value to the given number
func (_afg Cell )SetNumber (v float64 ){_afg .clearValue ();if _dae .IsNaN (v )||_dae .IsInf (v ,0){_afg ._debc .TAttr =_ccg .ST_CellTypeE ;_afg ._debc .V =_g .String ("\u0023\u004e\u0055M\u0021");return ;};_afg ._debc .TAttr =_ccg .ST_CellTypeN ;_afg ._debc .V =_g .String (_gf .FormatFloat (v ,'f',-1,64));};

// SetHidden marks the defined name as hidden.
func (_ccgc DefinedName )SetLocalSheetID (id uint32 ){_ccgc ._cegfb .LocalSheetIdAttr =_g .Uint32 (id )};

// SetIcons sets the icon set to use for display.
func (_gcfa IconScale )SetIcons (t _ccg .ST_IconSetType ){_gcfa ._dee .IconSetAttr =t };

// IsBool returns true if the cell boolean value.
func (_feec *evalContext )IsBool (cellRef string )bool {return _feec ._gdg .Cell (cellRef ).IsBool ()};func (_cbbg Sheet )validateRowCellNumbers ()error {_ggfa :=map[uint32 ]struct{}{};for _ ,_eafb :=range _cbbg ._ggac .SheetData .Row {if _eafb .RAttr !=nil {if _ ,_fff :=_ggfa [*_eafb .RAttr ];_fff {return _bf .Errorf ("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064",_cbbg .Name (),*_eafb .RAttr );};_ggfa [*_eafb .RAttr ]=struct{}{};};_badb :=map[string ]struct{}{};for _ ,_edce :=range _eafb .C {if _edce .RAttr ==nil {continue ;};if _ ,_ddce :=_badb [*_edce .RAttr ];_ddce {return _bf .Errorf ("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073",_cbbg .Name (),*_edce .RAttr );};_badb [*_edce .RAttr ]=struct{}{};};};return nil ;};

// TopLeft is a no-op.
func (_ac AbsoluteAnchor )TopLeft ()CellMarker {return CellMarker {}};

// Tables returns a slice of all defined tables in the workbook.
func (_bgacd *Workbook )Tables ()[]Table {if _bgacd ._eegf ==nil {return nil ;};_abaa :=[]Table {};for _ ,_bcbf :=range _bgacd ._eegf {_abaa =append (_abaa ,Table {_bcbf });};return _abaa ;};

// PasswordHash returns the hash of the workbook password.
func (_gde SheetProtection )PasswordHash ()string {if _gde ._agge .PasswordAttr ==nil {return "";};return *_gde ._agge .PasswordAttr ;};

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{_eagb *_ccg .CT_Rst };

// CellStyles returns the list of defined cell styles
func (_dcbg StyleSheet )CellStyles ()[]CellStyle {_ebcd :=[]CellStyle {};for _ ,_abbec :=range _dcbg ._dcae .CellXfs .Xf {_ebcd =append (_ebcd ,CellStyle {_dcbg ._ecgcc ,_abbec ,_dcbg ._dcae .CellXfs });};return _ebcd ;};func CreateDefaultNumberFormat (id StandardFormat )NumberFormat {_feeg :=NumberFormat {_ebba :_ccg .NewCT_NumFmt ()};_feeg ._ebba .NumFmtIdAttr =uint32 (id );_feeg ._ebba .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";switch id {case StandardFormat0 :_feeg ._ebba .FormatCodeAttr ="\u0047e\u006e\u0065\u0072\u0061\u006c";case StandardFormat1 :_feeg ._ebba .FormatCodeAttr ="\u0030";case StandardFormat2 :_feeg ._ebba .FormatCodeAttr ="\u0030\u002e\u0030\u0030";case StandardFormat3 :_feeg ._ebba .FormatCodeAttr ="\u0023\u002c\u0023#\u0030";case StandardFormat4 :_feeg ._ebba .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030";case StandardFormat9 :_feeg ._ebba .FormatCodeAttr ="\u0030\u0025";case StandardFormat10 :_feeg ._ebba .FormatCodeAttr ="\u0030\u002e\u00300\u0025";case StandardFormat11 :_feeg ._ebba .FormatCodeAttr ="\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030";case StandardFormat12 :_feeg ._ebba .FormatCodeAttr ="\u0023\u0020\u003f/\u003f";case StandardFormat13 :_feeg ._ebba .FormatCodeAttr ="\u0023 \u003f\u003f\u002f\u003f\u003f";case StandardFormat14 :_feeg ._ebba .FormatCodeAttr ="\u006d\u002f\u0064\u002f\u0079\u0079";case StandardFormat15 :_feeg ._ebba .FormatCodeAttr ="\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat16 :_feeg ._ebba .FormatCodeAttr ="\u0064\u002d\u006dm\u006d";case StandardFormat17 :_feeg ._ebba .FormatCodeAttr ="\u006d\u006d\u006d\u002d\u0079\u0079";case StandardFormat18 :_feeg ._ebba .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat19 :_feeg ._ebba .FormatCodeAttr ="\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d";case StandardFormat20 :_feeg ._ebba .FormatCodeAttr ="\u0068\u003a\u006d\u006d";case StandardFormat21 :_feeg ._ebba .FormatCodeAttr ="\u0068:\u006d\u006d\u003a\u0073\u0073";case StandardFormat22 :_feeg ._ebba .FormatCodeAttr ="m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d";case StandardFormat37 :_feeg ._ebba .FormatCodeAttr ="\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029";case StandardFormat38 :_feeg ._ebba .FormatCodeAttr ="\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029";case StandardFormat39 :_feeg ._ebba .FormatCodeAttr ="\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat40 :_feeg ._ebba .FormatCodeAttr ="\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029";case StandardFormat45 :_feeg ._ebba .FormatCodeAttr ="\u006d\u006d\u003as\u0073";case StandardFormat46 :_feeg ._ebba .FormatCodeAttr ="\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s";case StandardFormat47 :_feeg ._ebba .FormatCodeAttr ="\u006dm\u003a\u0073\u0073\u002e\u0030";case StandardFormat48 :_feeg ._ebba .FormatCodeAttr ="\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030";case StandardFormat49 :_feeg ._ebba .FormatCodeAttr ="\u0040";};return _feeg ;};func (_cefd Cell )getLocked ()bool {if _cefd ._debc .SAttr ==nil {return false ;};_bac :=*_cefd ._debc .SAttr ;_affg :=_cefd ._ebb .StyleSheet .GetCellStyle (_bac );return *_affg ._bed .Protection .LockedAttr ;};

// DefinedNames returns a slice of all defined names in the workbook.
func (_bgfde *Workbook )DefinedNames ()[]DefinedName {if _bgfde ._acbg .DefinedNames ==nil {return nil ;};_efcg :=[]DefinedName {};for _ ,_gcdg :=range _bgfde ._acbg .DefinedNames .DefinedName {_efcg =append (_efcg ,DefinedName {_gcdg });};return _efcg ;};

// AddCommentWithStyle adds a new comment styled in a default way
func (_bgfd Comments )AddCommentWithStyle (cellRef string ,author string ,comment string )error {_fdfe :=_bgfd .AddComment (cellRef ,author );_dag :=_fdfe .AddRun ();_dag .SetBold (true );_dag .SetSize (10);_dag .SetColor (_bag .Black );_dag .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_dag .SetText (author +"\u003a");_dag =_fdfe .AddRun ();_dag .SetSize (10);_dag .SetFont ("\u0043a\u006c\u0069\u0062\u0072\u0069");_dag .SetColor (_bag .Black );_dag .SetText ("\u000d\u000a"+comment +"\u000d\u000a");_cca ,_egbc :=_cd .ParseCellReference (cellRef );if _egbc !=nil {return _egbc ;};_bgfd ._fdfa ._aaae [0].Shape =append (_bgfd ._fdfa ._aaae [0].Shape ,_cab .NewCommentShape (int64 (_cca .ColumnIdx ),int64 (_cca .RowIdx -1)));return nil ;};

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_fbbd *Workbook )Save (w _cc .Writer )error {const _cefg ="\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065";if !_ae .GetLicenseKey ().IsLicensed ()&&!_egbb {_bf .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_bf .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return _ccd .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};if len (_fbbd ._bebb )==0{_gbafa ,_fgff :=_ae .GenRefId ("\u0073\u0077");if _fgff !=nil {_g .Log ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_fgff );return _fgff ;};_fbbd ._bebb =_gbafa ;};if _edec :=_ae .Track (_fbbd ._bebb ,_cefg );_edec !=nil {_bf .Printf ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_edec );return _edec ;};_dgeb :=_gc .NewWriter (w );defer _dgeb .Close ();_cfaad :=_g .DocTypeSpreadsheet ;if _dcgab :=_fg .MarshalXML (_dgeb ,_g .BaseRelsFilename ,_fbbd .Rels .X ());_dcgab !=nil {return _dcgab ;};if _bbgg :=_fg .MarshalXMLByType (_dgeb ,_cfaad ,_g .ExtendedPropertiesType ,_fbbd .AppProperties .X ());_bbgg !=nil {return _bbgg ;};if _efcf :=_fg .MarshalXMLByType (_dgeb ,_cfaad ,_g .CorePropertiesType ,_fbbd .CoreProperties .X ());_efcf !=nil {return _efcf ;};_edfdb :=_g .AbsoluteFilename (_cfaad ,_g .OfficeDocumentType ,0);if _cade :=_fg .MarshalXML (_dgeb ,_edfdb ,_fbbd ._acbg );_cade !=nil {return _cade ;};if _adag :=_fg .MarshalXML (_dgeb ,_fg .RelationsPathFor (_edfdb ),_fbbd ._gbaf .X ());_adag !=nil {return _adag ;};if _ebfee :=_fg .MarshalXMLByType (_dgeb ,_cfaad ,_g .StylesType ,_fbbd .StyleSheet .X ());_ebfee !=nil {return _ebfee ;};for _agcca ,_aeba :=range _fbbd ._fggfc {if _effdb :=_fg .MarshalXMLByTypeIndex (_dgeb ,_cfaad ,_g .ThemeType ,_agcca +1,_aeba );_effdb !=nil {return _effdb ;};};for _fgeag ,_fgbae :=range _fbbd ._acac {_fgbae .Dimension .RefAttr =Sheet {_fbbd ,nil ,_fgbae }.Extents ();_ecfd :=_g .AbsoluteFilename (_cfaad ,_g .WorksheetType ,_fgeag +1);_fg .MarshalXML (_dgeb ,_ecfd ,_fgbae );_fg .MarshalXML (_dgeb ,_fg .RelationsPathFor (_ecfd ),_fbbd ._eabe [_fgeag ].X ());};if _bfgd :=_fg .MarshalXMLByType (_dgeb ,_cfaad ,_g .SharedStringsType ,_fbbd .SharedStrings .X ());_bfgd !=nil {return _bfgd ;};if _fbbd .CustomProperties .X ()!=nil {if _fafc :=_fg .MarshalXMLByType (_dgeb ,_cfaad ,_g .CustomPropertiesType ,_fbbd .CustomProperties .X ());_fafc !=nil {return _fafc ;};};if _fbbd .Thumbnail !=nil {_eecd :=_g .AbsoluteFilename (_cfaad ,_g .ThumbnailType ,0);_eacea ,_gecaa :=_dgeb .Create (_eecd );if _gecaa !=nil {return _gecaa ;};if _gceaf :=_d .Encode (_eacea ,_fbbd .Thumbnail ,nil );_gceaf !=nil {return _gceaf ;};};for _fcbd ,_ggacf :=range _fbbd ._bgaaf {_dadg :=_g .AbsoluteFilename (_cfaad ,_g .ChartType ,_fcbd +1);_fg .MarshalXML (_dgeb ,_dadg ,_ggacf );};for _bgff ,_gcca :=range _fbbd ._eegf {_bfaea :=_g .AbsoluteFilename (_cfaad ,_g .TableType ,_bgff +1);_fg .MarshalXML (_dgeb ,_bfaea ,_gcca );};for _dcgaa ,_aggba :=range _fbbd ._egddd {_cbdg :=_g .AbsoluteFilename (_cfaad ,_g .DrawingType ,_dcgaa +1);_fg .MarshalXML (_dgeb ,_cbdg ,_aggba );if !_fbbd ._ebfeb [_dcgaa ].IsEmpty (){_fg .MarshalXML (_dgeb ,_fg .RelationsPathFor (_cbdg ),_fbbd ._ebfeb [_dcgaa ].X ());};};for _fcf ,_ageef :=range _fbbd ._aaae {_fg .MarshalXML (_dgeb ,_g .AbsoluteFilename (_cfaad ,_g .VMLDrawingType ,_fcf +1),_ageef );};for _baac ,_aded :=range _fbbd .Images {if _fdb :=_cgb .AddImageToZip (_dgeb ,_aded ,_baac +1,_g .DocTypeSpreadsheet );_fdb !=nil {return _fdb ;};};if _fbfg :=_fg .MarshalXML (_dgeb ,_g .ContentTypesFilename ,_fbbd .ContentTypes .X ());_fbfg !=nil {return _fbfg ;};for _dgfc ,_egde :=range _fbbd ._bgeff {if _egde ==nil {continue ;};_fg .MarshalXML (_dgeb ,_g .AbsoluteFilename (_cfaad ,_g .CommentsType ,_dgfc +1),_egde );};if _agga :=_fbbd .WriteExtraFiles (_dgeb );_agga !=nil {return _agga ;};return _dgeb .Close ();};

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_be AbsoluteAnchor )SetRowOffset (m _daeg .Distance ){_be ._ec .Pos .YAttr .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_daeg .EMU ));};

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_gfg Drawing )AddImage (img _cgb .ImageRef ,at AnchorType )Anchor {_fbbg :=0;for _agfd ,_agd :=range _gfg ._afac .Images {if _agd ==img {_fbbg =_agfd +1;break ;};};var _bfab string ;for _aaf ,_acd :=range _gfg ._afac ._egddd {if _acd ==_gfg ._eceb {_afgc :=_bf .Sprintf ("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073",_fbbg ,img .Format ());_baf :=_gfg ._afac ._ebfeb [_aaf ].AddRelationship (_afgc ,_g .ImageType );_bfab =_baf .ID ();break ;};};var _dfdga Anchor ;var _cedd *_fa .CT_Picture ;switch at {case AnchorTypeAbsolute :_ddgg :=_ffgd ();_gfg ._eceb .EG_Anchor =append (_gfg ._eceb .EG_Anchor ,&_fa .EG_Anchor {AbsoluteAnchor :_ddgg });_ddgg .Choice =&_fa .EG_ObjectChoicesChoice {};_ddgg .Choice .Pic =_fa .NewCT_Picture ();_ddgg .Pos .XAttr .ST_CoordinateUnqualified =_g .Int64 (0);_ddgg .Pos .YAttr .ST_CoordinateUnqualified =_g .Int64 (0);_cedd =_ddgg .Choice .Pic ;_dfdga =AbsoluteAnchor {_ddgg };case AnchorTypeOneCell :_bceb :=_fdc ();_gfg ._eceb .EG_Anchor =append (_gfg ._eceb .EG_Anchor ,&_fa .EG_Anchor {OneCellAnchor :_bceb });_bceb .Choice =&_fa .EG_ObjectChoicesChoice {};_bceb .Choice .Pic =_fa .NewCT_Picture ();_cedd =_bceb .Choice .Pic ;_dfdga =OneCellAnchor {_bceb };case AnchorTypeTwoCell :_ebaa :=_ebffa ();_gfg ._eceb .EG_Anchor =append (_gfg ._eceb .EG_Anchor ,&_fa .EG_Anchor {TwoCellAnchor :_ebaa });_ebaa .Choice =&_fa .EG_ObjectChoicesChoice {};_ebaa .Choice .Pic =_fa .NewCT_Picture ();_cedd =_ebaa .Choice .Pic ;_dfdga =TwoCellAnchor {_ebaa };};_cedd .NvPicPr .CNvPr .IdAttr =uint32 (len (_gfg ._eceb .EG_Anchor ));_cedd .NvPicPr .CNvPr .NameAttr ="\u0049\u006d\u0061g\u0065";_cedd .BlipFill .Blip =_aef .NewCT_Blip ();_cedd .BlipFill .Blip .EmbedAttr =_g .String (_bfab );_cedd .BlipFill .Stretch =_aef .NewCT_StretchInfoProperties ();_cedd .SpPr =_aef .NewCT_ShapeProperties ();_cedd .SpPr .Xfrm =_aef .NewCT_Transform2D ();_cedd .SpPr .Xfrm .Off =_aef .NewCT_Point2D ();_cedd .SpPr .Xfrm .Off .XAttr .ST_CoordinateUnqualified =_g .Int64 (0);_cedd .SpPr .Xfrm .Off .YAttr .ST_CoordinateUnqualified =_g .Int64 (0);_cedd .SpPr .Xfrm .Ext =_aef .NewCT_PositiveSize2D ();_cedd .SpPr .Xfrm .Ext .CxAttr =int64 (float64 (img .Size ().X *_daeg .Pixel72 )/_daeg .EMU );_cedd .SpPr .Xfrm .Ext .CyAttr =int64 (float64 (img .Size ().Y *_daeg .Pixel72 )/_daeg .EMU );_cedd .SpPr .PrstGeom =_aef .NewCT_PresetGeometry2D ();_cedd .SpPr .PrstGeom .PrstAttr =_aef .ST_ShapeTypeRect ;_cedd .SpPr .Ln =_aef .NewCT_LineProperties ();_cedd .SpPr .Ln .NoFill =_aef .NewCT_NoFillProperties ();return _dfdga ;};

// Themes returns the array of workbook dml.Theme.
func (_fdbbe *Workbook )Themes ()[]*_aef .Theme {return _fdbbe ._fggfc };

// GetFill gets a Fill from a cell style.
func (_gbec CellStyle )GetFill ()*_ccg .CT_Fill {if _daac :=_gbec ._bed .FillIdAttr ;_daac !=nil {_bae :=_gbec ._gag .StyleSheet .Fills ().X ().Fill ;if int (*_daac )< len (_bae ){return _bae [int (*_daac )];};};return nil ;};func (_cbbd CellStyle )SetNumberFormat (s string ){_bdc :=_cbbd ._gag .StyleSheet .AddNumberFormat ();_bdc .SetFormat (s );_cbbd ._bed .ApplyNumberFormatAttr =_g .Bool (true );_cbbd ._bed .NumFmtIdAttr =_g .Uint32 (_bdc .ID ());};

// Cell returns the actual cell behind the merged region
func (_cage MergedCell )Cell ()Cell {_edaf :=_cage .Reference ();if _cgdd :=_da .Index (_cage .Reference (),"\u003a");_cgdd !=-1{_edaf =_edaf [0:_cgdd ];return _cage ._afaa .Cell (_edaf );};return Cell {};};

// X returns the inner wrapped XML type.
func (_aeae DataBarScale )X ()*_ccg .CT_DataBar {return _aeae ._cda };

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_fabc *Sheet )Sort (column string ,firstRow uint32 ,order SortOrder ){_cabd :=_fabc ._ggac .SheetData .Row ;_fdfdg :=_fabc .Rows ();for _dbecf ,_bfdb :=range _fdfdg {if _bfdb .RowNumber ()==firstRow {_cabd =_fabc ._ggac .SheetData .Row [_dbecf :];break ;};};_ccda :=Comparer {Order :order };_c .Slice (_cabd ,func (_gcge ,_debd int )bool {return _ccda .LessRows (column ,Row {_fabc ._facca ,_fabc ,_cabd [_gcge ]},Row {_fabc ._facca ,_fabc ,_cabd [_debd ]});});for _bcabd ,_bacb :=range _fabc .Rows (){_gdbfd :=uint32 (_bcabd +1);if _bacb .RowNumber ()!=_gdbfd {_bacb .renumberAs (_gdbfd );};};};

// SetYSplit sets the row split point
func (_ffdb SheetView )SetYSplit (v float64 ){_ffdb .ensurePane ();_ffdb ._fadc .Pane .YSplitAttr =_g .Float64 (v );};

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_fcd ConditionalFormattingRule )SetIcons ()IconScale {_fcd .clear ();_fcd .SetType (_ccg .ST_CfTypeIconSet );_fcd ._fdef .IconSet =_ccg .NewCT_IconSet ();_ebad :=IconScale {_fcd ._fdef .IconSet };_ebad .SetIcons (_ccg .ST_IconSetType3TrafficLights1 );return _ebad ;};

// X returns the inner wrapped XML type.
func (_ceae SharedStrings )X ()*_ccg .Sst {return _ceae ._cged };func (_fab Font )SetItalic (b bool ){if b {_fab ._fggf .I =[]*_ccg .CT_BooleanProperty {{}};}else {_fab ._fggf .I =nil ;};};

// SetMinLength sets the minimum bar length in percent.
func (_dfe DataBarScale )SetMinLength (l uint32 ){_dfe ._cda .MinLengthAttr =_g .Uint32 (l )};type ConditionalFormattingRule struct{_fdef *_ccg .CT_CfRule };

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_cabdf SheetView )SetState (st _ccg .ST_PaneState ){_cabdf .ensurePane ();_cabdf ._fadc .Pane .StateAttr =st ;};

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_bgdab *Workbook )AddDefinedName (name ,ref string )DefinedName {if _bgdab ._acbg .DefinedNames ==nil {_bgdab ._acbg .DefinedNames =_ccg .NewCT_DefinedNames ();};_egcgd :=_ccg .NewCT_DefinedName ();_egcgd .Content =ref ;_egcgd .NameAttr =name ;_bgdab ._acbg .DefinedNames .DefinedName =append (_bgdab ._acbg .DefinedNames .DefinedName ,_egcgd );return DefinedName {_egcgd };};

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_efabf DataValidation )SetRange (cellRange string ){_efabf ._fded .SqrefAttr =_ccg .ST_Sqref {cellRange };};

// ClearBorder clears any border configuration from the cell style.
func (_ffe CellStyle )ClearBorder (){_ffe ._bed .BorderIdAttr =nil ;_ffe ._bed .ApplyBorderAttr =nil };

// X returns the inner wrapped XML type.
func (_gebb SheetView )X ()*_ccg .CT_SheetView {return _gebb ._fadc };var _aacc =_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .SharedStringsType ,0);

// MaxColumnIdx returns the max used column of the sheet.
func (_cgcb Sheet )MaxColumnIdx ()uint32 {_cdeb :=uint32 (0);for _ ,_dda :=range _cgcb .Rows (){_baae :=_dda ._gagf .C ;if len (_baae )> 0{_dggaf :=_baae [len (_baae )-1];_dbba ,_ :=_cd .ParseCellReference (*_dggaf .RAttr );if _cdeb < _dbba .ColumnIdx {_cdeb =_dbba .ColumnIdx ;};};};return _cdeb ;};

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_ffcg *Sheet )FormulaContext ()_fe .Context {return _gbge (_ffcg )};

// X returns the inner wrapped XML type.
func (_cbf Column )X ()*_ccg .CT_Col {return _cbf ._fae };

// SetPasswordHash sets the password hash to the input.
func (_cdfa SheetProtection )SetPasswordHash (pwHash string ){_cdfa ._agge .PasswordAttr =_g .String (pwHash );};

// SetFont sets the font name for a rich text run.
func (_fdca RichTextRun )SetFont (s string ){_fdca .ensureRpr ();_fdca ._ddgf .RPr .RFont =_ccg .NewCT_FontName ();_fdca ._ddgf .RPr .RFont .ValAttr =s ;};

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_dgebg *Workbook )Close ()error {if _dgebg .TmpPath !=""{return _cea .RemoveAll (_dgebg .TmpPath );};return nil ;};

// Reference returns the table reference (the cells within the table)
func (_dacf Table )Reference ()string {return _dacf ._cfff .RefAttr };

// LockSheet controls the locking of the sheet.
func (_egdd SheetProtection )LockSheet (b bool ){if !b {_egdd ._agge .SheetAttr =nil ;}else {_egdd ._agge .SheetAttr =_g .Bool (true );};};func NewFills ()Fills {return Fills {_ccg .NewCT_Fills ()}};

// SetColOffset sets the column offset of the two cell anchor.
func (_ddca TwoCellAnchor )SetColOffset (m _daeg .Distance ){_aegc :=m -_ddca .TopLeft ().ColOffset ();_ddca .TopLeft ().SetColOffset (m );_ddca .BottomRight ().SetColOffset (_ddca .BottomRight ().ColOffset ()+_aegc );};

// SetText sets the text to be displayed.
func (_ecbg RichTextRun )SetText (s string ){_ecbg ._ddgf .T =s };

// Index returns the index of the border for use with a cell style.
func (_dgg Border )Index ()uint32 {for _bc ,_ga :=range _dgg ._aa .Border {if _ga ==_dgg ._cb {return uint32 (_bc );};};return 0;};

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_ggd AbsoluteAnchor )SetColOffset (m _daeg .Distance ){_ggd ._ec .Pos .XAttr .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_daeg .EMU ));};

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_cdca *Workbook )CopySheetByName (name ,copiedSheetName string )(Sheet ,error ){_eebg :=-1;for _afgf ,_abfa :=range _cdca .Sheets (){if name ==_abfa .Name (){_eebg =_afgf ;break ;};};if _eebg ==-1{return Sheet {},ErrorNotFound ;};return _cdca .CopySheet (_eebg ,copiedSheetName );};func (_ebag Fills )AddFill ()Fill {_gfba :=_ccg .NewCT_Fill ();_ebag ._babc .Fill =append (_ebag ._babc .Fill ,_gfba );_ebag ._babc .CountAttr =_g .Uint32 (uint32 (len (_ebag ._babc .Fill )));return Fill {_gfba ,_ebag ._babc };};

// Border is a cell border configuraton.
type Border struct{_cb *_ccg .CT_Border ;_aa *_ccg .CT_Borders ;};

// SetUnderline controls if the run is underlined.
func (_aee RichTextRun )SetUnderline (u _ccg .ST_UnderlineValues ){_aee .ensureRpr ();_aee ._ddgf .RPr .U =_ccg .NewCT_UnderlineProperty ();_aee ._ddgf .RPr .U .ValAttr =u ;};type SheetProtection struct{_agge *_ccg .CT_SheetProtection };

// SetConditionValue sets the condition value to be used for style applicaton.
func (_eaa ConditionalFormattingRule )SetConditionValue (v string ){_eaa ._fdef .Formula =[]string {v }};

// AddRun adds a new run of text to the cell.
func (_cceg RichText )AddRun ()RichTextRun {_dgaa :=_ccg .NewCT_RElt ();_cceg ._eagb .R =append (_cceg ._eagb .R ,_dgaa );return RichTextRun {_dgaa };};func (_caec SheetView )ensurePane (){if _caec ._fadc .Pane ==nil {_caec ._fadc .Pane =_ccg .NewCT_Pane ();_caec ._fadc .Pane .ActivePaneAttr =_ccg .ST_PaneBottomLeft ;};};

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{Sheets []*SheetText ;};

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_cce Comment )SetCellReference (cellRef string ){_cce ._gfa .RefAttr =cellRef };

// Comments returns the list of comments for this sheet
func (_afe Comments )Comments ()[]Comment {_ced :=[]Comment {};for _ ,_ddeg :=range _afe ._gdb .CommentList .Comment {_ced =append (_ced ,Comment {_afe ._fdfa ,_ddeg ,_afe ._gdb });};return _ced ;};

// SetBold causes the text to be displayed in bold.
func (_gfbe RichTextRun )SetBold (b bool ){_gfbe .ensureRpr ();_gfbe ._ddgf .RPr .B =_ccg .NewCT_BooleanProperty ();_gfbe ._ddgf .RPr .B .ValAttr =_g .Bool (b );};func _fca (_dcf _ca .Time )_ca .Time {_dcf =_dcf .UTC ();return _ca .Date (_dcf .Year (),_dcf .Month (),_dcf .Day (),_dcf .Hour (),_dcf .Minute (),_dcf .Second (),_dcf .Nanosecond (),_ca .Local );};func (_gbf ConditionalFormattingRule )InitializeDefaults (){_gbf .SetType (_ccg .ST_CfTypeCellIs );_gbf .SetOperator (_ccg .ST_ConditionalFormattingOperatorGreaterThan );_gbf .SetPriority (1);};

// SetHeightCells is a no-op.
func (_dac AbsoluteAnchor )SetHeightCells (int32 ){};const _cfe ="_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065";func (_df Border )SetLeft (style _ccg .ST_BorderStyle ,c _bag .Color ){if _df ._cb .Left ==nil {_df ._cb .Left =_ccg .NewCT_BorderPr ();};_df ._cb .Left .Color =_ccg .NewCT_Color ();_df ._cb .Left .Color .RgbAttr =c .AsRGBAString ();_df ._cb .Left .StyleAttr =style ;};func (_eaf *evalContext )Sheet (name string )_fe .Context {for _ ,_eacc :=range _eaf ._gdg ._facca .Sheets (){if _eacc .Name ()==name {return _eacc .FormulaContext ();};};return _fe .InvalidReferenceContext ;};

// Reference returns the region of cells that are merged.
func (_ccec MergedCell )Reference ()string {return _ccec ._gce .RefAttr };

// Comments is the container for comments for a single sheet.
type Comments struct{_fdfa *Workbook ;_gdb *_ccg .Comments ;};func (_aafb Font )SetColor (c _bag .Color ){_dbd :=_ccg .NewCT_Color ();_fgd :="\u0066\u0066"+*c .AsRGBString ();_dbd .RgbAttr =&_fgd ;_aafb ._fggf .Color =[]*_ccg .CT_Color {_dbd };};

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_fgga *Sheet )SetAutoFilter (rangeRef string ){rangeRef =_da .Replace (rangeRef ,"\u0024","",-1);_fgga ._ggac .AutoFilter =_ccg .NewCT_AutoFilter ();_fgga ._ggac .AutoFilter .RefAttr =_g .String (rangeRef );_gace :="\u0027"+_fgga .Name ()+"\u0027\u0021";var _bbgcf DefinedName ;for _ ,_cac :=range _fgga ._facca .DefinedNames (){if _cac .Name ()==_cfe {if _da .HasPrefix (_cac .Content (),_gace ){_bbgcf =_cac ;_bbgcf .SetContent (_fgga .RangeReference (rangeRef ));break ;};};};if _bbgcf .X ()==nil {_bbgcf =_fgga ._facca .AddDefinedName (_cfe ,_fgga .RangeReference (rangeRef ));};for _aafd ,_dea :=range _fgga ._facca ._acac {if _dea ==_fgga ._ggac {_bbgcf .SetLocalSheetID (uint32 (_aafd ));};};};

// AddCell adds a cell to a spreadsheet.
func (_gebd Row )AddCell ()Cell {_fdfg :=uint32 (len (_gebd ._gagf .C ));var _facc *string ;if _fdfg > 0{_febb :=_g .Stringf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_fdfg -1),_gebd .RowNumber ());if _gebd ._gagf .C [_fdfg -1].RAttr !=nil &&*_gebd ._gagf .C [_fdfg -1].RAttr ==*_febb {_facc =_g .Stringf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_fdfg ),_gebd .RowNumber ());};};_bgfc :=_ccg .NewCT_Cell ();_gebd ._gagf .C =append (_gebd ._gagf .C ,_bgfc );if _facc ==nil {_ecea :=uint32 (0);for _ ,_geg :=range _gebd ._gagf .C {if _geg .RAttr !=nil {_cgddb ,_ :=_cd .ParseCellReference (*_geg .RAttr );if _cgddb .ColumnIdx >=_ecea {_ecea =_cgddb .ColumnIdx +1;};};};_facc =_g .Stringf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_ecea ),_gebd .RowNumber ());};_bgfc .RAttr =_facc ;return Cell {_gebd ._ccccd ,_gebd ._bedc ,_gebd ._gagf ,_bgfc };};

// SetHeight sets the height of the anchored object.
func (_eb AbsoluteAnchor )SetHeight (h _daeg .Distance ){_eb ._ec .Ext .CyAttr =int64 (h /_daeg .EMU )};

// Sheets returns the sheets from the workbook.
func (_eaba *Workbook )Sheets ()[]Sheet {_abac :=[]Sheet {};for _efdg ,_geac :=range _eaba ._acac {_babg :=_eaba ._acbg .Sheets .Sheet [_efdg ];_dceb :=Sheet {_eaba ,_babg ,_geac };_abac =append (_abac ,_dceb );};return _abac ;};

// X returns the inner wrapped XML type.
func (_fggd IconScale )X ()*_ccg .CT_IconSet {return _fggd ._dee };

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings ()SharedStrings {return SharedStrings {_cged :_ccg .NewSst (),_bbgd :make (map[string ]int )};};

// Rows returns all of the rows in a sheet.
func (_cgf *Sheet )Rows ()[]Row {_abf :=[]Row {};for _ ,_aefb :=range _cgf ._ggac .SheetData .Row {_abf =append (_abf ,Row {_cgf ._facca ,_cgf ,_aefb });};return _abf ;};func (_egf Sheet )ExtentsIndex ()(string ,uint32 ,string ,uint32 ){var _egfe ,_ade ,_cbbdc ,_age uint32 =1,1,0,0;for _ ,_baba :=range _egf .Rows (){if _baba .RowNumber ()< _egfe {_egfe =_baba .RowNumber ();}else if _baba .RowNumber ()> _ade {_ade =_baba .RowNumber ();};for _ ,_aeda :=range _baba .Cells (){_efge ,_add :=_cd .ParseCellReference (_aeda .Reference ());if _add ==nil {if _efge .ColumnIdx < _cbbdc {_cbbdc =_efge .ColumnIdx ;}else if _efge .ColumnIdx > _age {_age =_efge .ColumnIdx ;};};};};return _cd .IndexToColumn (_cbbdc ),_egfe ,_cd .IndexToColumn (_age ),_ade ;};

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct{_cgb .DocBase ;_acbg *_ccg .Workbook ;StyleSheet StyleSheet ;SharedStrings SharedStrings ;_bgeff []*_ccg .Comments ;_acac []*_ccg .Worksheet ;_eabe []_cgb .Relationships ;_gbaf _cgb .Relationships ;_fggfc []*_aef .Theme ;_egddd []*_fa .WsDr ;_ebfeb []_cgb .Relationships ;_aaae []*_cab .Container ;_bgaaf []*_dg .ChartSpace ;_eegf []*_ccg .Table ;_dgdca string ;_dgac map[string ]string ;_begc map[string ]*_dg .ChartSpace ;_bebb string ;};const (AnchorTypeAbsolute AnchorType =iota ;AnchorTypeOneCell ;AnchorTypeTwoCell ;);

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_befg *Workbook )RemoveCalcChain (){var _acbd string ;for _ ,_ddece :=range _befg ._gbaf .Relationships (){if _ddece .Type ()=="ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e"{_acbd ="\u0078\u006c\u002f"+_ddece .Target ();_befg ._gbaf .Remove (_ddece );break ;};};if _acbd ==""{return ;};_befg .ContentTypes .RemoveOverride (_acbd );for _abgb ,_gbcc :=range _befg .ExtraFiles {if _gbcc .ZipPath ==_acbd {_befg .ExtraFiles [_abgb ]=_befg .ExtraFiles [len (_befg .ExtraFiles )-1];_befg .ExtraFiles =_befg .ExtraFiles [:len (_befg .ExtraFiles )-1];return ;};};};

// SetDateWithStyle sets a date with the default date style applied.
func (_ea Cell )SetDateWithStyle (d _ca .Time ){_ea .SetDate (d );for _ ,_agb :=range _ea ._ebb .StyleSheet .CellStyles (){if _agb .HasNumberFormat ()&&_agb .NumberFormat ()==uint32 (StandardFormatDate ){_ea .SetStyle (_agb );return ;};};_fcb :=_ea ._ebb .StyleSheet .AddCellStyle ();_fcb .SetNumberFormatStandard (StandardFormatDate );_ea .SetStyle (_fcb );};

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_bbf CellStyle )NumberFormat ()uint32 {if _bbf ._bed .NumFmtIdAttr ==nil {return 0;};return *_bbf ._bed .NumFmtIdAttr ;};func (_gec Cell )getFormat ()string {if _gec ._debc .SAttr ==nil {return "\u0047e\u006e\u0065\u0072\u0061\u006c";};_ceg :=*_gec ._debc .SAttr ;_ceaa :=_gec ._ebb .StyleSheet .GetCellStyle (_ceg );_gfd :=_gec ._ebb .StyleSheet .GetNumberFormat (_ceaa .NumberFormat ());return _gfd .GetFormat ();};type Fill struct{_aaca *_ccg .CT_Fill ;_fea *_ccg .CT_Fills ;};

// X returns the inner XML entity for a stylesheet.
func (_abef StyleSheet )X ()*_ccg .StyleSheet {return _abef ._dcae };func (_efg PatternFill )ClearBgColor (){_efg ._gdgf .BgColor =nil };

// SetHeightCells is a no-op.
func (_bfd OneCellAnchor )SetHeightCells (int32 ){};const (SortOrderAscending SortOrder =iota ;SortOrderDescending ;);

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_adgf *Sheet )AddConditionalFormatting (cellRanges []string )ConditionalFormatting {_cgfd :=_ccg .NewCT_ConditionalFormatting ();_adgf ._ggac .ConditionalFormatting =append (_adgf ._ggac .ConditionalFormatting ,_cgfd );_eded :=make (_ccg .ST_Sqref ,0,0);_cgfd .SqrefAttr =&_eded ;for _ ,_afcg :=range cellRanges {*_cgfd .SqrefAttr =append (*_cgfd .SqrefAttr ,_afcg );};return ConditionalFormatting {_cgfd };};type DifferentialStyle struct{_dfab *_ccg .CT_Dxf ;_aagd *Workbook ;_baa *_ccg .CT_Dxfs ;};

// SetWidth is a no-op.
func (_ecdf TwoCellAnchor )SetWidth (w _daeg .Distance ){};

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_ccbd Cell )SetString (s string )int {_ccbd ._ebb .ensureSharedStringsRelationships ();_ccbd .clearValue ();_gcf :=_ccbd ._ebb .SharedStrings .AddString (s );_ccbd ._debc .V =_g .String (_gf .Itoa (_gcf ));_ccbd ._debc .TAttr =_ccg .ST_CellTypeS ;return _gcf ;};

// X returns the inner wrapped XML type.
func (_bdcf ColorScale )X ()*_ccg .CT_ColorScale {return _bdcf ._fede };

// SetHeight sets the height of the anchored object.
func (_bgag OneCellAnchor )SetHeight (h _daeg .Distance ){_bgag ._bdab .Ext .CyAttr =int64 (h /_daeg .EMU )};func (_gbc PatternFill )ClearFgColor (){_gbc ._gdgf .FgColor =nil };

// Validate attempts to validate the structure of a workbook.
func (_ggbdb *Workbook )Validate ()error {if _ggbdb ==nil ||_ggbdb ._acbg ==nil {return _ccd .New ("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065");};_edfg :=uint32 (0);for _ ,_feae :=range _ggbdb ._acbg .Sheets .Sheet {if _feae .SheetIdAttr > _edfg {_edfg =_feae .SheetIdAttr ;};};if _edfg !=uint32 (len (_ggbdb ._acac )){return _bf .Errorf ("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073",_edfg ,len (_ggbdb ._acac ));};_gbeff :=map[string ]struct{}{};for _defgd ,_egbcd :=range _ggbdb ._acbg .Sheets .Sheet {_acgf :=Sheet {_ggbdb ,_egbcd ,_ggbdb ._acac [_defgd ]};if _ ,_afedf :=_gbeff [_acgf .Name ()];_afedf {return _bf .Errorf ("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027",_defgd ,_acgf .Name ());};_gbeff [_acgf .Name ()]=struct{}{};if _gcce :=_acgf .ValidateWithPath (_bf .Sprintf ("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d",_defgd ));_gcce !=nil {return _gcce ;};if _abdg :=_acgf .Validate ();_abdg !=nil {return _abdg ;};};return nil ;};const _gbg ="\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300";

// SetFont applies a font to a cell style. The font is referenced by its
// index so modifying the font afterward will affect all styles that reference
// it.
func (_ebf CellStyle )SetFont (f Font ){_ebf ._bed .FontIdAttr =_g .Uint32 (f .Index ());_ebf ._bed .ApplyFontAttr =_g .Bool (true );};

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_abgd Cell )SetCachedFormulaResult (s string ){_abgd ._debc .V =&s };

// GetLocked returns true if the cell is locked.
func (_eeea *evalContext )GetLocked (cellRef string )bool {return _eeea ._gdg .Cell (cellRef ).getLocked ()};

// New constructs a new workbook.
func New ()*Workbook {_ccge :=&Workbook {};_ccge ._acbg =_ccg .NewWorkbook ();_ccge .AppProperties =_cgb .NewAppProperties ();_ccge .CoreProperties =_cgb .NewCoreProperties ();_ccge .StyleSheet =NewStyleSheet (_ccge );_ccge .Rels =_cgb .NewRelationships ();_ccge ._gbaf =_cgb .NewRelationships ();_ccge .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .ExtendedPropertiesType ,0),_g .ExtendedPropertiesType );_ccge .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .CorePropertiesType ,0),_g .CorePropertiesType );_ccge .Rels .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,"",_g .OfficeDocumentType ,0),_g .OfficeDocumentType );_ccge ._gbaf .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .StylesType ,0),_g .StylesType );_ccge .ContentTypes =_cgb .NewContentTypes ();_ccge .ContentTypes .AddDefault ("\u0076\u006d\u006c",_g .VMLDrawingContentType );_ccge .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,0),"\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c");_ccge .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .StylesType ,0),_g .SMLStyleSheetContentType );_ccge .SharedStrings =NewSharedStrings ();_ccge .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .SharedStringsType ,0),_g .SharedStringsContentType );_ccge ._gbaf .AddRelationship (_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .SharedStringsType ,0),_g .SharedStringsType );_ccge ._dgac =map[string ]string {};return _ccge ;};func (_efdf *Sheet )addNumberedRowFast (_beec uint32 )Row {_ecbf :=_ccg .NewCT_Row ();_ecbf .RAttr =_g .Uint32 (_beec );_efdf ._ggac .SheetData .Row =append (_efdf ._ggac .SheetData .Row ,_ecbf );return Row {_efdf ._facca ,_efdf ,_ecbf };};

// SetBorder applies a border to a cell style. The border is referenced by its
// index so modifying the border afterward will affect all styles that reference
// it.
func (_fdgb CellStyle )SetBorder (b Border ){_fdgb ._bed .BorderIdAttr =_g .Uint32 (b .Index ());_fdgb ._bed .ApplyBorderAttr =_g .Bool (true );};

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{Order SortOrder ;};

// Content returns the content of the defined range (the range in most cases)/
func (_feg DefinedName )Content ()string {return _feg ._cegfb .Content };

// ClearProtection removes any protections applied to teh sheet.
func (_babf *Sheet )ClearProtection (){_babf ._ggac .SheetProtection =nil };

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_gbef NumberFormat )ID ()uint32 {return _gbef ._ebba .NumFmtIdAttr };

// SetColOffset sets a column offset in absolute distance.
func (_ecg CellMarker )SetColOffset (m _daeg .Distance ){_ecg ._fee .ColOff .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_daeg .EMU ));};

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_abea SheetView )SetZoom (pct uint32 ){_abea ._fadc .ZoomScaleAttr =&pct };func (_afcfe Fills )X ()*_ccg .CT_Fills {return _afcfe ._babc };

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_ccbab StyleSheet )Fills ()Fills {return Fills {_ccbab ._dcae .Fills }};

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_dbec DataValidationCompare )SetValue (v string ){_dbec ._gggb .Formula1 =&v };

// AddSheet adds a new sheet to a workbook.
func (_aeaee *Workbook )AddSheet ()Sheet {_bcbb :=_ccg .NewCT_Sheet ();_bcbb .SheetIdAttr =1;for _ ,_adgag :=range _aeaee ._acbg .Sheets .Sheet {if _bcbb .SheetIdAttr <=_adgag .SheetIdAttr {_bcbb .SheetIdAttr =_adgag .SheetIdAttr +1;};};_aeaee ._acbg .Sheets .Sheet =append (_aeaee ._acbg .Sheets .Sheet ,_bcbb );_bcbb .NameAttr =_bf .Sprintf ("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064",_bcbb .SheetIdAttr );_fabd :=_ccg .NewWorksheet ();_fabd .Dimension =_ccg .NewCT_SheetDimension ();_fabd .Dimension .RefAttr ="\u0041\u0031";_aeaee ._acac =append (_aeaee ._acac ,_fabd );_facba :=_cgb .NewRelationships ();_aeaee ._eabe =append (_aeaee ._eabe ,_facba );_fabd .SheetData =_ccg .NewCT_SheetData ();_aeaee ._bgeff =append (_aeaee ._bgeff ,nil );_ccaae :=_g .DocTypeSpreadsheet ;_bfbg :=_aeaee ._gbaf .AddAutoRelationship (_ccaae ,_g .OfficeDocumentType ,len (_aeaee ._acbg .Sheets .Sheet ),_g .WorksheetType );_bcbb .IdAttr =_bfbg .ID ();_aeaee .ContentTypes .AddOverride (_g .AbsoluteFilename (_ccaae ,_g .WorksheetContentType ,len (_aeaee ._acbg .Sheets .Sheet )),_g .WorksheetContentType );return Sheet {_aeaee ,_bcbb ,_fabd };};func (_agf Comments )getOrCreateAuthor (_agc string )uint32 {for _dded ,_dbad :=range _agf ._gdb .Authors .Author {if _dbad ==_agc {return uint32 (_dded );};};_afcf :=uint32 (len (_agf ._gdb .Authors .Author ));_agf ._gdb .Authors .Author =append (_agf ._gdb .Authors .Author ,_agc );return _afcf ;};

// GetWidth returns a worksheet's column width.
func (_edf *evalContext )GetWidth (colIdx int )float64 {colIdx ++;for _ ,_dbee :=range _edf ._gdg .X ().Cols [0].Col {if int (_dbee .MinAttr )<=colIdx &&colIdx <=int (_dbee .MaxAttr ){return float64 (int (*_dbee .WidthAttr ));};};return 0;};

// AddBorder creates a new empty border that can be applied to a cell style.
func (_cdbbf StyleSheet )AddBorder ()Border {_adef :=_ccg .NewCT_Border ();_cdbbf ._dcae .Borders .Border =append (_cdbbf ._dcae .Borders .Border ,_adef );_cdbbf ._dcae .Borders .CountAttr =_g .Uint32 (uint32 (len (_cdbbf ._dcae .Borders .Border )));return Border {_adef ,_cdbbf ._dcae .Borders };};

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_adbge *Sheet )SetFrozen (firstRow ,firstCol bool ){_adbge ._ggac .SheetViews =nil ;_fecda :=_adbge .AddView ();_fecda .SetState (_ccg .ST_PaneStateFrozen );switch {case firstRow &&firstCol :_fecda .SetYSplit (1);_fecda .SetXSplit (1);_fecda .SetTopLeft ("\u0042\u0032");case firstRow :_fecda .SetYSplit (1);_fecda .SetTopLeft ("\u0041\u0032");case firstCol :_fecda .SetXSplit (1);_fecda .SetTopLeft ("\u0042\u0031");};};

// Row returns the row of the cell marker.
func (_ecc CellMarker )Row ()int32 {return _ecc ._fee .Row };

// Sheet is a single sheet within a workbook.
type Sheet struct{_facca *Workbook ;_adb *_ccg .CT_Sheet ;_ggac *_ccg .Worksheet ;};

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_dgbf *Workbook )GetSheet (name string )(Sheet ,error ){for _ ,_ddege :=range _dgbf .Sheets (){if _ddege .Name ()==name {return _ddege ,nil ;};};return Sheet {},ErrorNotFound ;};

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte ;

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_cddae *Sheet )SetDrawing (d Drawing ){var _acbc _cgb .Relationships ;for _cga ,_cdbgg :=range _cddae ._facca ._acac {if _cdbgg ==_cddae ._ggac {_acbc =_cddae ._facca ._eabe [_cga ];break ;};};var _cfad string ;for _dgdc ,_acbf :=range d ._afac ._egddd {if _acbf ==d ._eceb {_edfda :=_acbc .AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,_dgdc +1,_g .DrawingType );_cfad =_edfda .ID ();break ;};};_cddae ._ggac .Drawing =_ccg .NewCT_Drawing ();_cddae ._ggac .Drawing .IdAttr =_cfad ;};

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_cacd StyleSheet )GetOrCreateStandardNumberFormat (f StandardFormat )CellStyle {for _ ,_efaea :=range _cacd .CellStyles (){if _efaea .HasNumberFormat ()&&_efaea .NumberFormat ()==uint32 (f ){return _efaea ;};};_daacc :=_cacd .AddCellStyle ();_daacc .SetNumberFormatStandard (f );return _daacc ;};func (_aefae DataValidation )SetComparison (t DVCompareType ,op DVCompareOp )DataValidationCompare {_aefae .clear ();_aefae ._fded .TypeAttr =_ccg .ST_DataValidationType (t );_aefae ._fded .OperatorAttr =_ccg .ST_DataValidationOperator (op );return DataValidationCompare {_aefae ._fded };};

// LockStructure controls the locking of the workbook structure.
func (_adca WorkbookProtection )LockStructure (b bool ){if !b {_adca ._gcde .LockStructureAttr =nil ;}else {_adca ._gcde .LockStructureAttr =_g .Bool (true );};};

// HasFormula returns true if the cell has an asoociated formula.
func (_edg Cell )HasFormula ()bool {return _edg ._debc .F !=nil };func _gee (_ffd bool )int {if _ffd {return 1;};return 0;};

// StandardFormat is a standard ECMA 376 number format.
//go:generate stringer -type=StandardFormat
type StandardFormat uint32 ;

// AddDataValidation adds a data validation rule to a sheet.
func (_ceec *Sheet )AddDataValidation ()DataValidation {if _ceec ._ggac .DataValidations ==nil {_ceec ._ggac .DataValidations =_ccg .NewCT_DataValidations ();};_egbf :=_ccg .NewCT_DataValidation ();_egbf .ShowErrorMessageAttr =_g .Bool (true );_ceec ._ggac .DataValidations .DataValidation =append (_ceec ._ggac .DataValidations .DataValidation ,_egbf );_ceec ._ggac .DataValidations .CountAttr =_g .Uint32 (uint32 (len (_ceec ._ggac .DataValidations .DataValidation )));return DataValidation {_egbf };};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_eeba *Workbook )ClearCachedFormulaResults (){for _ ,_bbef :=range _eeba .Sheets (){_bbef .ClearCachedFormulaResults ();};};

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_ad Cell )SetDate (d _ca .Time ){_ad .clearValue ();d =_ecd (d );_gad :=_ad ._ebb .Epoch ();if d .Before (_gad ){_g .Log ("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_bce :=d .Sub (_gad );_ccf :=new (_cg .Float );_abb :=new (_cg .Float );_abb .SetPrec (128);_abb .SetUint64 (uint64 (_bce ));_efa :=new (_cg .Float );_efa .SetUint64 (24*60*60*1e9);_ccf .Quo (_abb ,_efa );_aac ,_ :=_ccf .Uint64 ();_ad ._debc .V =_g .Stringf ("\u0025\u0064",_aac );};const (DVCompareOpEqual =DVCompareOp (_ccg .ST_DataValidationOperatorEqual );DVCompareOpBetween =DVCompareOp (_ccg .ST_DataValidationOperatorBetween );DVCompareOpNotBetween =DVCompareOp (_ccg .ST_DataValidationOperatorNotBetween );DVCompareOpNotEqual =DVCompareOp (_ccg .ST_DataValidationOperatorNotEqual );DVCompareOpGreater =DVCompareOp (_ccg .ST_DataValidationOperatorGreaterThan );DVCompareOpGreaterEqual =DVCompareOp (_ccg .ST_DataValidationOperatorGreaterThanOrEqual );DVCompareOpLess =DVCompareOp (_ccg .ST_DataValidationOperatorLessThan );DVCompareOpLessEqual =DVCompareOp (_ccg .ST_DataValidationOperatorLessThanOrEqual ););

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_gaf *Sheet )Cell (cellRef string )Cell {_fbdg ,_ddaa :=_cd .ParseCellReference (cellRef );if _ddaa !=nil {_g .Log ("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073",_ddaa );return _gaf .AddRow ().AddCell ();};return _gaf .Row (_fbdg .RowIdx ).Cell (_fbdg .Column );};

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{_ec *_fa .CT_AbsoluteAnchor };

// SetFill applies a fill to a cell style. The fill is referenced by its index
// so modifying the fill afterward will affect all styles that reference it.
func (_gggf CellStyle )SetFill (f Fill ){_gggf ._bed .FillIdAttr =_g .Uint32 (f .Index ());_gggf ._bed .ApplyFillAttr =_g .Bool (true );};

// Text returns text from the workbook as one string separated with line breaks.
func (_bbe *WorkbookText )Text ()string {_fge :=_ggg .NewBuffer ([]byte {});for _ ,_gac :=range _bbe .Sheets {_fge .WriteString (_gac .Text ());};return _fge .String ();};

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_dbeaf *Workbook )RemoveSheetByName (name string )error {_edd :=-1;for _caga ,_afgb :=range _dbeaf .Sheets (){if name ==_afgb .Name (){_edd =_caga ;break ;};};if _edd ==-1{return ErrorNotFound ;};return _dbeaf .RemoveSheet (_edd );};

// Clear clears the cell's value and type.
func (_cbb Cell )Clear (){_cbb .clearValue ();_cbb ._debc .TAttr =_ccg .ST_CellTypeUnset };

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_fdfb StyleSheet )RemoveFont (f Font )error {for _bgda ,_ebfe :=range _fdfb ._dcae .Fonts .Font {if _ebfe ==f .X (){_fdfb ._dcae .Fonts .Font =append (_fdfb ._dcae .Fonts .Font [:_bgda ],_fdfb ._dcae .Fonts .Font [_bgda +1:]...);return nil ;};};return _ccd .New ("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064");};

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_gdfae Row )CellsWithEmpty (lastColIdx uint32 )[]Cell {_cfc :=[]Cell {};for _dcad :=uint32 (0);_dcad <=lastColIdx ;_dcad ++{_bge :=_gdfae .Cell (_cd .IndexToColumn (_dcad ));_cfc =append (_cfc ,_bge );};return _cfc ;};

// CellMarker represents a cell position
type CellMarker struct{_fee *_fa .CT_Marker };

// Type returns the type of anchor
func (_gbba OneCellAnchor )Type ()AnchorType {return AnchorTypeOneCell };

// ColOffset returns the offset from the row cell.
func (_def CellMarker )ColOffset ()_daeg .Distance {if _def ._fee .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _daeg .Distance (float64 (*_def ._fee .ColOff .ST_CoordinateUnqualified )*_daeg .EMU );};func (_badd StyleSheet )GetNumberFormat (id uint32 )NumberFormat {if id >=0&&id < 50{return CreateDefaultNumberFormat (StandardFormat (id ));};for _ ,_gfda :=range _badd ._dcae .NumFmts .NumFmt {if _gfda .NumFmtIdAttr ==id {return NumberFormat {_badd ._ecgcc ,_gfda };};};return NumberFormat {};};

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_gdbd *Sheet )AddHyperlink (url string )_cgb .Hyperlink {for _gbcf ,_gade :=range _gdbd ._facca ._acac {if _gade ==_gdbd ._ggac {return _gdbd ._facca ._eabe [_gbcf ].AddHyperlink (url );};};return _cgb .Hyperlink {};};

// StyleSheet is a document style sheet.
type StyleSheet struct{_ecgcc *Workbook ;_dcae *_ccg .StyleSheet ;};

// BottomRight is a no-op.
func (_gefaf OneCellAnchor )BottomRight ()CellMarker {return CellMarker {}};

// RemoveDefinedName removes an existing defined name.
func (_deeag *Workbook )RemoveDefinedName (dn DefinedName )error {if dn .X ()==nil {return _ccd .New ("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065");};for _ccdcg ,_dggb :=range _deeag ._acbg .DefinedNames .DefinedName {if _dggb ==dn .X (){copy (_deeag ._acbg .DefinedNames .DefinedName [_ccdcg :],_deeag ._acbg .DefinedNames .DefinedName [_ccdcg +1:]);_deeag ._acbg .DefinedNames .DefinedName [len (_deeag ._acbg .DefinedNames .DefinedName )-1]=nil ;_deeag ._acbg .DefinedNames .DefinedName =_deeag ._acbg .DefinedNames .DefinedName [:len (_deeag ._acbg .DefinedNames .DefinedName )-1];return nil ;};};return _ccd .New ("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064");};

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_bbec Sheet )ValidateWithPath (path string )error {return _bbec ._ggac .ValidateWithPath (path )};

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_effa Comment )CellReference ()string {return _effa ._gfa .RefAttr };

// X returns the inner wrapped XML type.
func (_bda CellMarker )X ()*_fa .CT_Marker {return _bda ._fee };func (_fce *Sheet )removeColumnFromNamedRanges (_cbgg uint32 )error {for _ ,_fged :=range _fce ._facca .DefinedNames (){_fegb :=_fged .Name ();_ddbc :=_fged .Content ();_bgaf :=_da .Split (_ddbc ,"\u0021");if len (_bgaf )!=2{return _ccd .New ("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a"+_ddbc );};_aefeg :=_bgaf [0];if _fce .Name ()==_aefeg {_bagc :=_fce ._facca .RemoveDefinedName (_fged );if _bagc !=nil {return _bagc ;};_cfca :=_fgfcg (_bgaf [1],_cbgg ,true );if _cfca !=""{_bfae :=_aefeg +"\u0021"+_cfca ;_fce ._facca .AddDefinedName (_fegb ,_bfae );};};};_eed :=0;if _fce ._ggac .TableParts !=nil &&_fce ._ggac .TableParts .TablePart !=nil {_eed =len (_fce ._ggac .TableParts .TablePart );};if _eed !=0{_eefa :=0;for _ ,_abca :=range _fce ._facca .Sheets (){if _abca .Name ()==_fce .Name (){break ;}else {if _abca ._ggac .TableParts !=nil &&_abca ._ggac .TableParts .TablePart !=nil {_eefa +=len (_abca ._ggac .TableParts .TablePart );};};};_efef :=_fce ._facca ._eegf [_eefa :_eefa +_eed ];for _gfgc ,_gdff :=range _efef {_dfga :=_gdff ;_dfga .RefAttr =_fgfcg (_dfga .RefAttr ,_cbgg ,false );_fce ._facca ._eegf [_eefa +_gfgc ]=_dfga ;};};return nil ;};

// X returns the inner wrapped XML type.
func (_eee Comment )X ()*_ccg .CT_Comment {return _eee ._gfa };

// SetStyle sets the cell style for an entire column.
func (_egb Column )SetStyle (cs CellStyle ){_egb ._fae .StyleAttr =_g .Uint32 (cs .Index ())};

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_bgef TwoCellAnchor )SetHeightCells (h int32 ){_bgef .SetHeight (0);_abbg :=_bgef .TopLeft ();_daag :=_bgef .BottomRight ();_daag .SetRow (_abbg .Row ()+h );};func (_cbbda Row )renumberAs (_ddb uint32 ){_cbbda ._gagf .RAttr =_g .Uint32 (_ddb );for _ ,_cefde :=range _cbbda .Cells (){_ecgc ,_caea :=_cd .ParseCellReference (_cefde .Reference ());if _caea ==nil {_aabg :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",_ecgc .Column ,_ddb );_cefde ._debc .RAttr =_g .String (_aabg );};};};func (_geca RichTextRun )ensureRpr (){if _geca ._ddgf .RPr ==nil {_geca ._ddgf .RPr =_ccg .NewCT_RPrElt ();};};

// Name returns the name of the defined name.
func (_dbga DefinedName )Name ()string {return _dbga ._cegfb .NameAttr };

// IsEmpty checks if the cell style contains nothing.
func (_bee CellStyle )IsEmpty ()bool {return _bee ._gag ==nil ||_bee ._bed ==nil ||_bee ._edac ==nil ||_bee ._edac .Xf ==nil ;};

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gbgd Comments )AddComment (cellRef string ,author string )RichText {_dafe :=_ccg .NewCT_Comment ();_gbgd ._gdb .CommentList .Comment =append (_gbgd ._gdb .CommentList .Comment ,_dafe );_dafe .RefAttr =cellRef ;_dafe .AuthorIdAttr =_gbgd .getOrCreateAuthor (author );_dafe .Text =_ccg .NewCT_Rst ();return RichText {_dafe .Text };};func _fgfcg (_ecbdd string ,_aacea uint32 ,_bdcg bool )string {_bcae ,_afb ,_ddee :=_cd .ParseRangeReference (_ecbdd );if _ddee ==nil {_dffe ,_fgea :=_bcae .ColumnIdx ,_afb .ColumnIdx ;if _aacea >=_dffe &&_aacea <=_fgea {if _dffe ==_fgea {if _bdcg {return "";}else {return _ecbdd ;};}else {_ededf :=_afb .Update (_ee .UpdateActionRemoveColumn );return _bf .Sprintf ("\u0025\u0073\u003a%\u0073",_bcae .String (),_ededf .String ());};}else if _aacea < _dffe {_gcfc :=_bcae .Update (_ee .UpdateActionRemoveColumn );_cgda :=_afb .Update (_ee .UpdateActionRemoveColumn );return _bf .Sprintf ("\u0025\u0073\u003a%\u0073",_gcfc .String (),_cgda .String ());};}else {_agee ,_gacg ,_dcaa :=_cd .ParseColumnRangeReference (_ecbdd );if _dcaa !=nil {return "";};_adde ,_bbeb :=_agee .ColumnIdx ,_gacg .ColumnIdx ;if _aacea >=_adde &&_aacea <=_bbeb {if _adde ==_bbeb {if _bdcg {return "";}else {return _ecbdd ;};}else {_bcf :=_gacg .Update (_ee .UpdateActionRemoveColumn );return _bf .Sprintf ("\u0025\u0073\u003a%\u0073",_agee .String (),_bcf .String ());};}else if _aacea < _adde {_ebce :=_agee .Update (_ee .UpdateActionRemoveColumn );_gagb :=_gacg .Update (_ee .UpdateActionRemoveColumn );return _bf .Sprintf ("\u0025\u0073\u003a%\u0073",_ebce .String (),_gagb .String ());};};return "";};

// SetWidthCells is a no-op.
func (_de AbsoluteAnchor )SetWidthCells (int32 ){};

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_fgc CellStyle )SetNumberFormatStandard (s StandardFormat ){_fgc ._bed .NumFmtIdAttr =_g .Uint32 (uint32 (s ));_fgc ._bed .ApplyNumberFormatAttr =_g .Bool (true );};

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_gaffb *Workbook )AddDrawing ()Drawing {_geff :=_fa .NewWsDr ();_gaffb ._egddd =append (_gaffb ._egddd ,_geff );_gdggg :=_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .DrawingType ,len (_gaffb ._egddd ));_gaffb .ContentTypes .AddOverride (_gdggg ,_g .DrawingContentType );_gaffb ._ebfeb =append (_gaffb ._ebfeb ,_cgb .NewRelationships ());return Drawing {_gaffb ,_geff };};func (_fdafd Sheet )validateMergedCells ()error {_eeb :=map[uint64 ]struct{}{};for _ ,_bbdb :=range _fdafd .MergedCells (){_gbcb ,_acf ,_cbaf :=_cd .ParseRangeReference (_bbdb .Reference ());if _cbaf !=nil {return _bf .Errorf ("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073",_fdafd .Name (),_bbdb .Reference ());};for _fgec :=_gbcb .RowIdx ;_fgec <=_acf .RowIdx ;_fgec ++{for _gced :=_gbcb .ColumnIdx ;_gced <=_acf .ColumnIdx ;_gced ++{_defg :=uint64 (_fgec )<<32|uint64 (_gced );if _ ,_gegg :=_eeb [_defg ];_gegg {return _bf .Errorf ("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065",_fdafd .Name ());};_eeb [_defg ]=struct{}{};};};};return nil ;};

// AddHyperlink creates and sets a hyperlink on a cell.
func (_bec Cell )AddHyperlink (url string ){for _ebd ,_bdd :=range _bec ._ebb ._acac {if _bdd ==_bec ._bgf ._ggac {_bec .SetHyperlink (_bec ._ebb ._eabe [_ebd ].AddHyperlink (url ));return ;};};};

// ExtractText returns text from the sheet as a SheetText object.
func (_dcb *Sheet )ExtractText ()*SheetText {_ebfca :=[]CellText {};for _ ,_adf :=range _dcb .Rows (){for _ ,_dcbd :=range _adf .Cells (){if !_dcbd .IsEmpty (){if _fbaa :=_dcbd .GetFormattedValue ();_fbaa !=""{_ebfca =append (_ebfca ,CellText {Text :_fbaa ,Cell :_dcbd });};};};};return &SheetText {Cells :_ebfca };};

// MoveTo repositions the anchor without changing the objects size.
func (_fdedf TwoCellAnchor )MoveTo (col ,row int32 ){_gegb :=_fdedf .TopLeft ();_aefc :=_fdedf .BottomRight ();_baaeb :=_aefc .Col ()-_gegb .Col ();_afbc :=_aefc .Row ()-_gegb .Row ();_gegb .SetCol (col );_gegb .SetRow (row );_aefc .SetCol (col +_baaeb );_aefc .SetRow (row +_afbc );};

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_cbec PatternFill )SetFgColor (c _bag .Color ){_cbec ._gdgf .FgColor =_ccg .NewCT_Color ();_cbec ._gdgf .FgColor .RgbAttr =c .AsRGBAString ();};

// LockObject controls the locking of the sheet objects.
func (_bcea SheetProtection )LockObject (b bool ){if !b {_bcea ._agge .ObjectsAttr =nil ;}else {_bcea ._agge .ObjectsAttr =_g .Bool (true );};};

// IsStructureLocked returns whether the workbook structure is locked.
func (_gcbc WorkbookProtection )IsStructureLocked ()bool {return _gcbc ._gcde .LockStructureAttr !=nil &&*_gcbc ._gcde .LockStructureAttr ;};

// Priority returns the rule priority
func (_ecb ConditionalFormattingRule )Priority ()int32 {return _ecb ._fdef .PriorityAttr };

// X returns the inner wrapped XML type.
func (_dbgf NumberFormat )X ()*_ccg .CT_NumFmt {return _dbgf ._ebba };func (_cdda Sheet )IsValid ()bool {return _cdda ._ggac !=nil };func (_edef Font )SetSize (size float64 ){_edef ._fggf .Sz =[]*_ccg .CT_FontSize {{ValAttr :size }}};

// Comment is a single comment within a sheet.
type Comment struct{_egc *Workbook ;_gfa *_ccg .CT_Comment ;_gccdg *_ccg .Comments ;};

// ClearFill clears any fill configuration from the cell style.
func (_aaa CellStyle )ClearFill (){_aaa ._bed .FillIdAttr =nil ;_aaa ._bed .ApplyFillAttr =nil };

// GetFont gets a Font from a cell style.
func (_cbgc CellStyle )GetFont ()*_ccg .CT_Font {if _gga :=_cbgc ._bed .FontIdAttr ;_gga !=nil {_aeg :=_cbgc ._gag .StyleSheet .Fonts ();if int (*_gga )< len (_aeg ){return _aeg [int (*_gga )].X ();};};return nil ;};

// X returns the inner wrapped XML type.
func (_eacg Font )X ()*_ccg .CT_Font {return _eacg ._fggf };type PatternFill struct{_gdgf *_ccg .CT_PatternFill ;_cbab *_ccg .CT_Fill ;};

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bcbd StyleSheet )AddDifferentialStyle ()DifferentialStyle {if _bcbd ._dcae .Dxfs ==nil {_bcbd ._dcae .Dxfs =_ccg .NewCT_Dxfs ();};_acbb :=_ccg .NewCT_Dxf ();_bcbd ._dcae .Dxfs .Dxf =append (_bcbd ._dcae .Dxfs .Dxf ,_acbb );_bcbd ._dcae .Dxfs .CountAttr =_g .Uint32 (uint32 (len (_bcbd ._dcae .Dxfs .Dxf )));return DifferentialStyle {_acbb ,_bcbd ._ecgcc ,_bcbd ._dcae .Dxfs };};

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_aab ConditionalFormattingRule )SetDataBar ()DataBarScale {_aab .clear ();_aab .SetType (_ccg .ST_CfTypeDataBar );_aab ._fdef .DataBar =_ccg .NewCT_DataBar ();_cadg :=DataBarScale {_aab ._fdef .DataBar };_cadg .SetShowValue (true );_cadg .SetMinLength (10);_cadg .SetMaxLength (90);return _cadg ;};

// X returns the inner wrapped XML type.
func (_acee WorkbookProtection )X ()*_ccg .CT_WorkbookProtection {return _acee ._gcde };

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_acgga *Sheet )Row (rowNum uint32 )Row {for _ ,_ggbd :=range _acgga ._ggac .SheetData .Row {if _ggbd .RAttr !=nil &&*_ggbd .RAttr ==rowNum {return Row {_acgga ._facca ,_acgga ,_ggbd };};};return _acgga .AddNumberedRow (rowNum );};

// SetCol set the column of the cell marker.
func (_bca CellMarker )SetCol (col int32 ){_bca ._fee .Col =col };

// X returns the inner wrapped XML type.
func (_dbgab SheetProtection )X ()*_ccg .CT_SheetProtection {return _dbgab ._agge };func (_eacb ConditionalFormattingRule )clear (){_eacb ._fdef .OperatorAttr =_ccg .ST_ConditionalFormattingOperatorUnset ;_eacb ._fdef .ColorScale =nil ;_eacb ._fdef .IconSet =nil ;_eacb ._fdef .Formula =nil ;};

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash (s string )string {_dcd :=uint16 (0);if len (s )> 0{for _fdcc :=len (s )-1;_fdcc >=0;_fdcc --{_ggb :=s [_fdcc ];_dcd =((_dcd >>14)&0x01)|((_dcd <<1)&0x7fff);_dcd ^=uint16 (_ggb );};_dcd =((_dcd >>14)&0x01)|((_dcd <<1)&0x7fff);_dcd ^=uint16 (len (s ));_dcd ^=(0x8000|('N'<<8)|'K');};return _bf .Sprintf ("\u0025\u0030\u0034\u0058",uint64 (_dcd ));};type evalContext struct{_gdg *Sheet ;_gdfd ,_dec uint32 ;_efc map[string ]struct{};};

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_bfb Cell )GetCachedFormulaResult ()string {if _bfb ._debc .V !=nil {return *_bfb ._debc .V ;};return "";};const (_cgege ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034";_agba ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065";_fbba ="\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030";_cgdc ="\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039";);

// GetFormula returns the formula for a cell.
func (_bfa Cell )GetFormula ()string {if _bfa ._debc .F !=nil {return _bfa ._debc .F .Content ;};return "";};

// Name returns the name of the table
func (_efcc Table )Name ()string {if _efcc ._cfff .NameAttr !=nil {return *_efcc ._cfff .NameAttr ;};return "";};type Table struct{_cfff *_ccg .Table };

// SetFormat sets the number format code.
func (_fadg NumberFormat )SetFormat (f string ){_fadg ._ebba .FormatCodeAttr =f };

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_ddecb *Sheet )InsertRow (rowNum int )Row {_debb :=uint32 (rowNum );for _ ,_cagef :=range _ddecb .Rows (){if _cagef ._gagf .RAttr !=nil &&*_cagef ._gagf .RAttr >=_debb {*_cagef ._gagf .RAttr ++;for _ ,_ggf :=range _cagef .Cells (){_faggc ,_dbfcc :=_cd .ParseCellReference (_ggf .Reference ());if _dbfcc !=nil {continue ;};_faggc .RowIdx ++;_ggf ._debc .RAttr =_g .String (_faggc .String ());};};};for _ ,_bgb :=range _ddecb .MergedCells (){_eacd ,_fcgaf ,_eea :=_cd .ParseRangeReference (_bgb .Reference ());if _eea !=nil {continue ;};if int (_eacd .RowIdx )>=rowNum {_eacd .RowIdx ++;};if int (_fcgaf .RowIdx )>=rowNum {_fcgaf .RowIdx ++;};_ebbd :=_bf .Sprintf ("\u0025\u0073\u003a%\u0073",_eacd ,_fcgaf );_bgb .SetReference (_ebbd );};return _ddecb .AddNumberedRow (_debb );};

// SetInlineString adds a string inline instead of in the shared strings table.
func (_gef Cell )SetInlineString (s string ){_gef .clearValue ();_gef ._debc .Is =_ccg .NewCT_Rst ();_gef ._debc .Is .T =_g .String (s );_gef ._debc .TAttr =_ccg .ST_CellTypeInlineStr ;};

// SetHeightAuto sets the row height to be automatically determined.
func (_ggaf Row )SetHeightAuto (){_ggaf ._gagf .HtAttr =nil ;_ggaf ._gagf .CustomHeightAttr =nil };func _ebffa ()*_fa .CT_TwoCellAnchor {_agcc :=_fa .NewCT_TwoCellAnchor ();_agcc .EditAsAttr =_fa .ST_EditAsOneCell ;_agcc .From .Col =5;_agcc .From .Row =0;_agcc .From .ColOff .ST_CoordinateUnqualified =_g .Int64 (0);_agcc .From .RowOff .ST_CoordinateUnqualified =_g .Int64 (0);_agcc .To .Col =10;_agcc .To .Row =20;_agcc .To .ColOff .ST_CoordinateUnqualified =_g .Int64 (0);_agcc .To .RowOff .ST_CoordinateUnqualified =_g .Int64 (0);return _agcc ;};func (_bgc Border )SetTop (style _ccg .ST_BorderStyle ,c _bag .Color ){if _bgc ._cb .Top ==nil {_bgc ._cb .Top =_ccg .NewCT_BorderPr ();};_bgc ._cb .Top .Color =_ccg .NewCT_Color ();_bgc ._cb .Top .Color .RgbAttr =c .AsRGBAString ();_bgc ._cb .Top .StyleAttr =style ;};func (_eacdd *Sheet )updateAfterRemove (_ecbd uint32 ,_bgcg _ee .UpdateAction )error {_bffa :=_eacdd .Name ();_dcfg :=&_ee .UpdateQuery {UpdateType :_bgcg ,ColumnIdx :_ecbd ,SheetToUpdate :_bffa };for _ ,_ebde :=range _eacdd ._facca .Sheets (){_dcfg .UpdateCurrentSheet =_bffa ==_ebde .Name ();for _ ,_cbc :=range _ebde .Rows (){for _ ,_gbgg :=range _cbc .Cells (){if _gbgg .X ().F !=nil {_baee :=_gbgg .X ().F .Content ;_babad :=_fe .ParseString (_baee );if _babad ==nil {_gbgg .SetError ("\u0023\u0052\u0045F\u0021");}else {_fcgc :=_babad .Update (_dcfg );_gbgg .X ().F .Content =_bf .Sprintf ("\u003d\u0025\u0073",_fcgc .String ());};};};};};return nil ;};

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_gccb *Sheet )RemoveMergedCell (mc MergedCell ){for _becb ,_bfbbg :=range _gccb ._ggac .MergeCells .MergeCell {if _bfbbg ==mc .X (){copy (_gccb ._ggac .MergeCells .MergeCell [_becb :],_gccb ._ggac .MergeCells .MergeCell [_becb +1:]);_gccb ._ggac .MergeCells .MergeCell [len (_gccb ._ggac .MergeCells .MergeCell )-1]=nil ;_gccb ._ggac .MergeCells .MergeCell =_gccb ._ggac .MergeCells .MergeCell [:len (_gccb ._ggac .MergeCells .MergeCell )-1];};};};func (_bd Cell )clearValue (){_bd ._debc .F =nil ;_bd ._debc .Is =nil ;_bd ._debc .V =nil ;_bd ._debc .TAttr =_ccg .ST_CellTypeUnset ;};

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_cge *evalContext )GetLabelPrefix (cellRef string )string {return _cge ._gdg .Cell (cellRef ).getLabelPrefix ();};

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_bbbe *Workbook )AddImage (i _cgb .Image )(_cgb .ImageRef ,error ){_dagc :=_cgb .MakeImageRef (i ,&_bbbe .DocBase ,_bbbe ._gbaf );if i .Data ==nil &&i .Path ==""{return _dagc ,_ccd .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068");};if i .Format ==""{return _dagc ,_ccd .New ("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074");};if i .Size .X ==0||i .Size .Y ==0{return _dagc ,_ccd .New ("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065");};if i .Path !=""{_eece :=_cea .Add (i .Path );if _eece !=nil {return _dagc ,_eece ;};};_bbbe .Images =append (_bbbe .Images ,_dagc );return _dagc ,nil ;};const (DVCompareTypeWholeNumber =DVCompareType (_ccg .ST_DataValidationTypeWhole );DVCompareTypeDecimal =DVCompareType (_ccg .ST_DataValidationTypeDecimal );DVCompareTypeDate =DVCompareType (_ccg .ST_DataValidationTypeDate );DVCompareTypeTime =DVCompareType (_ccg .ST_DataValidationTypeTime );DVompareTypeTextLength =DVCompareType (_ccg .ST_DataValidationTypeTextLength ););

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_agdf *Sheet )GetDrawing ()(*_fa .WsDr ,_cgb .Relationships ){if _cdg :=_agdf ._ggac .Drawing ;_cdg !=nil {_dagf :=0;for _ ,_gegf :=range _agdf ._facca ._acac {if _bcgeg :=_gegf .Drawing ;_bcgeg !=nil {if _gegf ==_agdf ._ggac {return _agdf ._facca ._egddd [_dagf ],_agdf ._facca ._ebfeb [_dagf ];};_dagf ++;};};};return nil ,_cgb .Relationships {};};

// GetValueAsNumber retrieves the cell's value as a number
func (_dbfa Cell )GetValueAsNumber ()(float64 ,error ){if _dbfa ._debc .V ==nil &&_dbfa ._debc .Is ==nil {return 0,nil ;};if _dbfa ._debc .TAttr ==_ccg .ST_CellTypeS ||!_ef .IsNumber (*_dbfa ._debc .V ){return _dae .NaN (),_ccd .New ("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065");};return _gf .ParseFloat (*_dbfa ._debc .V ,64);};

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_eec Cell )Reference ()string {if _eec ._debc .RAttr !=nil {return *_eec ._debc .RAttr ;};return "";};

// SetContent sets the defined name content.
func (_feded DefinedName )SetContent (s string ){_feded ._cegfb .Content =s };func (_cgeg PatternFill )SetBgColor (c _bag .Color ){_cgeg ._gdgf .BgColor =_ccg .NewCT_Color ();_cgeg ._gdgf .BgColor .RgbAttr =c .AsRGBAString ();};

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface{

// BottomRight returns the CellMaker for the bottom right corner of the
// anchor.
BottomRight ()CellMarker ;

// TopLeft returns the CellMaker for the top left corner of the anchor.
TopLeft ()CellMarker ;

// MoveTo repositions the anchor without changing the objects size.
MoveTo (_deb ,_fc int32 );

// SetWidth sets the width of the anchored object. It is not compatible with
// SetWidthCells.
SetWidth (_bbg _daeg .Distance );

// SetWidthCells sets the height the anchored object by moving the right
// hand side. It is not compatible with SetWidth.
SetWidthCells (_gd int32 );

// SetHeight sets the height of the anchored object. It is not compatible
// with SetHeightCells.
SetHeight (_aefa _daeg .Distance );

// SetHeightCells sets the height the anchored object by moving the bottom.
// It is not compatible with SetHeight.
SetHeightCells (_dad int32 );

// SetColOffset sets the column offset of the top-left anchor.
SetColOffset (_bg _daeg .Distance );

// SetRowOffset sets the row offset of the top-left anchor.
SetRowOffset (_cag _daeg .Distance );

// Type returns the type of anchor
Type ()AnchorType ;};

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_efd Cell )GetFormattedValue ()string {_deg :=_efd .getFormat ();switch _efd ._debc .TAttr {case _ccg .ST_CellTypeB :_agg ,_ :=_efd .GetValueAsBool ();if _agg {return "\u0054\u0052\u0055\u0045";};return "\u0046\u0041\u004cS\u0045";case _ccg .ST_CellTypeN :_dba ,_ :=_efd .GetValueAsNumber ();return _ef .Number (_dba ,_deg );case _ccg .ST_CellTypeE :if _efd ._debc .V !=nil {return *_efd ._debc .V ;};return "";case _ccg .ST_CellTypeS ,_ccg .ST_CellTypeInlineStr :return _ef .String (_efd .GetString (),_deg );case _ccg .ST_CellTypeStr :_fed :=_efd .GetString ();if _ef .IsNumber (_fed ){_cbe ,_ :=_gf .ParseFloat (_fed ,64);return _ef .Number (_cbe ,_deg );};return _ef .String (_fed ,_deg );case _ccg .ST_CellTypeUnset :fallthrough;default:_geb ,_ :=_efd .GetRawValue ();if len (_geb )==0{return "";};_dca ,_gbe :=_efd .GetValueAsNumber ();if _gbe ==nil {return _ef .Number (_dca ,_deg );};return _ef .String (_geb ,_deg );};};

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_daf Cell )SetStyleIndex (idx uint32 ){_daf ._debc .SAttr =_g .Uint32 (idx )};

// X returns the inner wrapped XML type.
func (_aadc Comments )X ()*_ccg .Comments {return _aadc ._gdb };

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gfc CellStyle )SetHorizontalAlignment (a _ccg .ST_HorizontalAlignment ){if _gfc ._bed .Alignment ==nil {_gfc ._bed .Alignment =_ccg .NewCT_CellAlignment ();};_gfc ._bed .Alignment .HorizontalAttr =a ;_gfc ._bed .ApplyAlignmentAttr =_g .Bool (true );};

// SetHyperlink sets a hyperlink on a cell.
func (_gbeg Cell )SetHyperlink (hl _cgb .Hyperlink ){_aedc :=_gbeg ._bgf ._ggac ;if _aedc .Hyperlinks ==nil {_aedc .Hyperlinks =_ccg .NewCT_Hyperlinks ();};_aad :=_cgb .Relationship (hl );_gcg :=_ccg .NewCT_Hyperlink ();_gcg .RefAttr =_gbeg .Reference ();_gcg .IdAttr =_g .String (_aad .ID ());_aedc .Hyperlinks .Hyperlink =append (_aedc .Hyperlinks .Hyperlink ,_gcg );};

// Column returns the cell column
func (_fba Cell )Column ()(string ,error ){_daa ,_dbf :=_cd .ParseCellReference (_fba .Reference ());if _dbf !=nil {return "",_dbf ;};return _daa .Column ,nil ;};

// IsSheetLocked returns whether the sheet is locked.
func (_dddc SheetProtection )IsSheetLocked ()bool {return _dddc ._agge .SheetAttr !=nil &&*_dddc ._agge .SheetAttr ;};

// SetPasswordHash sets the password hash to the input.
func (_fcda WorkbookProtection )SetPasswordHash (pwHash string ){_fcda ._gcde .WorkbookPasswordAttr =_g .String (pwHash );};func (_fbd Cell )GetRawValue ()(string ,error ){switch _fbd ._debc .TAttr {case _ccg .ST_CellTypeInlineStr :if _fbd ._debc .Is ==nil ||_fbd ._debc .Is .T ==nil {return "",nil ;};return *_fbd ._debc .Is .T ,nil ;case _ccg .ST_CellTypeS :if _fbd ._debc .V ==nil {return "",nil ;};_ece ,_ecdc :=_gf .Atoi (*_fbd ._debc .V );if _ecdc !=nil {return "",_ecdc ;};return _fbd ._ebb .SharedStrings .GetString (_ece );case _ccg .ST_CellTypeStr :if _fbd ._debc .F !=nil {return _fbd ._debc .F .Content ,nil ;};};if _fbd ._debc .V ==nil {return "",nil ;};return *_fbd ._debc .V ,nil ;};

// SetHeight is a nop-op.
func (_ffee TwoCellAnchor )SetHeight (h _daeg .Distance ){};func (_beeag Fill )SetPatternFill ()PatternFill {_beeag ._aaca .GradientFill =nil ;_beeag ._aaca .PatternFill =_ccg .NewCT_PatternFill ();_beeag ._aaca .PatternFill .PatternTypeAttr =_ccg .ST_PatternTypeSolid ;return PatternFill {_beeag ._aaca .PatternFill ,_beeag ._aaca };};

// AddGradientStop adds a color gradient stop.
func (_gdf ColorScale )AddGradientStop (color _bag .Color ){_gfe :=_ccg .NewCT_Color ();_gfe .RgbAttr =color .AsRGBAString ();_gdf ._fede .Color =append (_gdf ._fede .Color ,_gfe );};

// RemoveSheet removes the sheet with the given index from the workbook.
func (_caaf *Workbook )RemoveSheet (ind int )error {if _caaf .SheetCount ()<=ind {return ErrorNotFound ;};for _ ,_gdee :=range _caaf ._gbaf .Relationships (){if _gdee .ID ()==_caaf ._acbg .Sheets .Sheet [ind ].IdAttr {_caaf ._gbaf .Remove (_gdee );break ;};};_caaf .ContentTypes .RemoveOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,ind +1));copy (_caaf ._acac [ind :],_caaf ._acac [ind +1:]);_caaf ._acac =_caaf ._acac [:len (_caaf ._acac )-1];_cafc :=_caaf ._acbg .Sheets .Sheet [ind ];copy (_caaf ._acbg .Sheets .Sheet [ind :],_caaf ._acbg .Sheets .Sheet [ind +1:]);_caaf ._acbg .Sheets .Sheet =_caaf ._acbg .Sheets .Sheet [:len (_caaf ._acbg .Sheets .Sheet )-1];for _acedg :=range _caaf ._acbg .Sheets .Sheet {if _caaf ._acbg .Sheets .Sheet [_acedg ].SheetIdAttr > _cafc .SheetIdAttr {_caaf ._acbg .Sheets .Sheet [_acedg ].SheetIdAttr --;};};copy (_caaf ._eabe [ind :],_caaf ._eabe [ind +1:]);_caaf ._eabe =_caaf ._eabe [:len (_caaf ._eabe )-1];copy (_caaf ._bgeff [ind :],_caaf ._bgeff [ind +1:]);_caaf ._bgeff =_caaf ._bgeff [:len (_caaf ._bgeff )-1];return nil ;};

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_gbb Cell )SetStringByID (id int ){_gbb ._ebb .ensureSharedStringsRelationships ();_gbb .clearValue ();_gbb ._debc .V =_g .String (_gf .Itoa (id ));_gbb ._debc .TAttr =_ccg .ST_CellTypeS ;};func (_dgge *Sheet )removeColumnFromMergedCells (_dcgb uint32 )error {if _dgge ._ggac .MergeCells ==nil ||_dgge ._ggac .MergeCells .MergeCell ==nil {return nil ;};_cdbb :=[]*_ccg .CT_MergeCell {};for _ ,_gdbdg :=range _dgge .MergedCells (){_ecca :=_fgfcg (_gdbdg .Reference (),_dcgb ,true );if _ecca !=""{_gdbdg .SetReference (_ecca );_cdbb =append (_cdbb ,_gdbdg .X ());};};_dgge ._ggac .MergeCells .MergeCell =_cdbb ;return nil ;};

// SetPriority sets the rule priority
func (_eag ConditionalFormattingRule )SetPriority (p int32 ){_eag ._fdef .PriorityAttr =p };var _egbb =false ;

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_bfad *Workbook )Uses1904Dates ()bool {if _bfad ._acbg .WorkbookPr ==nil ||_bfad ._acbg .WorkbookPr .Date1904Attr ==nil {return false ;};return *_bfad ._acbg .WorkbookPr .Date1904Attr ;};

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct{Text string ;Cell Cell ;};

// Row is a row within a spreadsheet.
type Row struct{_ccccd *Workbook ;_bedc *Sheet ;_gagf *_ccg .CT_Row ;};

// SetColor sets the text color.
func (_egdg RichTextRun )SetColor (c _bag .Color ){_egdg .ensureRpr ();_egdg ._ddgf .RPr .Color =_ccg .NewCT_Color ();_cfaa :="\u0066\u0066"+*c .AsRGBString ();_egdg ._ddgf .RPr .Color .RgbAttr =&_cfaa ;};

// ExtractText returns text from the workbook as a WorkbookText object.
func (_fcdd *Workbook )ExtractText ()*WorkbookText {_aeca :=[]*SheetText {};for _ ,_fbf :=range _fcdd .Sheets (){_aeca =append (_aeca ,&SheetText {Cells :_fbf .ExtractText ().Cells });};return &WorkbookText {Sheets :_aeca };};func (_efe Font )Index ()uint32 {for _fade ,_gffb :=range _efe ._gdfa .Fonts .Font {if _efe ._fggf ==_gffb {return uint32 (_fade );};};return 0;};

// IsBool returns true if the cell is a boolean type cell.
func (_ddfb Cell )IsBool ()bool {return _ddfb ._debc .TAttr ==_ccg .ST_CellTypeB };func (_daaa *evalContext )NamedRange (ref string )_fe .Reference {for _ ,_cegf :=range _daaa ._gdg ._facca .DefinedNames (){if _cegf .Name ()==ref {return _fe .MakeRangeReference (_cegf .Content ());};};for _ ,_bcabc :=range _daaa ._gdg ._facca .Tables (){if _bcabc .Name ()==ref {return _fe .MakeRangeReference (_bf .Sprintf ("\u0025\u0073\u0021%\u0073",_daaa ._gdg .Name (),_bcabc .Reference ()));};};return _fe .ReferenceInvalid ;};

// X returns the inner wrapped XML type.
func (_gbgf RichTextRun )X ()*_ccg .CT_RElt {return _gbgf ._ddgf };func (_beda Font )SetName (name string ){_beda ._fggf .Name =[]*_ccg .CT_FontName {{ValAttr :name }}};

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_ceed *Workbook )SetActiveSheetIndex (idx uint32 ){if _ceed ._acbg .BookViews ==nil {_ceed ._acbg .BookViews =_ccg .NewCT_BookViews ();};if len (_ceed ._acbg .BookViews .WorkbookView )==0{_ceed ._acbg .BookViews .WorkbookView =append (_ceed ._acbg .BookViews .WorkbookView ,_ccg .NewCT_BookView ());};_ceed ._acbg .BookViews .WorkbookView [0].ActiveTabAttr =_g .Uint32 (idx );};

// SetMaxLength sets the maximum bar length in percent.
func (_gae DataBarScale )SetMaxLength (l uint32 ){_gae ._cda .MaxLengthAttr =_g .Uint32 (l )};func _ecd (_fbc _ca .Time )_ca .Time {_fbc =_fbc .Local ();return _ca .Date (_fbc .Year (),_fbc .Month (),_fbc .Day (),_fbc .Hour (),_fbc .Minute (),_fbc .Second (),_fbc .Nanosecond (),_ca .UTC );};

// SetRowOffset sets the row offset of the two cell anchor
func (_egff TwoCellAnchor )SetRowOffset (m _daeg .Distance ){_ecdg :=m -_egff .TopLeft ().RowOffset ();_egff .TopLeft ().SetRowOffset (m );_egff .BottomRight ().SetRowOffset (_egff .BottomRight ().RowOffset ()+_ecdg );};

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_fagcc *Workbook )SetActiveSheet (s Sheet ){for _beed ,_ebea :=range _fagcc ._acac {if s ._ggac ==_ebea {_fagcc .SetActiveSheetIndex (uint32 (_beed ));};};};

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_egd CellStyle )SetVerticalAlignment (a _ccg .ST_VerticalAlignment ){if _egd ._bed .Alignment ==nil {_egd ._bed .Alignment =_ccg .NewCT_CellAlignment ();};_egd ._bed .ApplyAlignmentAttr =_g .Bool (true );_egd ._bed .Alignment .VerticalAttr =a ;};

// SetShowValue controls if the cell value is displayed.
func (_ccdc DataBarScale )SetShowValue (b bool ){_ccdc ._cda .ShowValueAttr =_g .Bool (b )};

// IsEmpty returns true if the cell is empty.
func (_eda Cell )IsEmpty ()bool {return _eda ._debc .TAttr ==_ccg .ST_CellTypeUnset &&_eda ._debc .V ==nil &&_eda ._debc .F ==nil ;};func (_gff Cell )getLabelPrefix ()string {if _gff ._debc .SAttr ==nil {return "";};_ceac :=*_gff ._debc .SAttr ;_gfdd :=_gff ._ebb .StyleSheet .GetCellStyle (_ceac );switch _gfdd ._bed .Alignment .HorizontalAttr {case _ccg .ST_HorizontalAlignmentLeft :return "\u0027";case _ccg .ST_HorizontalAlignmentRight :return "\u0022";case _ccg .ST_HorizontalAlignmentCenter :return "\u005e";case _ccg .ST_HorizontalAlignmentFill :return "\u005c";default:return "";};};

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_ged Comparer )LessCells (lhs ,rhs Cell )bool {if _ged .Order ==SortOrderDescending {lhs ,rhs =rhs ,lhs ;};if lhs .X ()==nil {if rhs .X ()==nil {return false ;};return true ;};if rhs .X ()==nil {return false ;};_ebg ,_fef :=lhs .getRawSortValue ();_ffc ,_ded :=rhs .getRawSortValue ();switch {case _fef &&_ded :_cgbf ,_ :=_gf .ParseFloat (_ebg ,64);_ffdd ,_ :=_gf .ParseFloat (_ffc ,64);return _cgbf < _ffdd ;case _fef :return true ;case _ded :return false ;};_ebg =lhs .GetFormattedValue ();_ffc =rhs .GetFormattedValue ();return _ebg < _ffc ;};type WorkbookProtection struct{_gcde *_ccg .CT_WorkbookProtection };

// GetFilename returns the filename of the context's workbook.
func (_ddfe *evalContext )GetFilename ()string {return _ddfe ._gdg ._facca .GetFilename ()};

// AddString adds a string to the shared string cache.
func (_fedf SharedStrings )AddString (v string )int {if _effd ,_edfd :=_fedf ._bbgd [v ];_edfd {return _effd ;};_fecd :=_ccg .NewCT_Rst ();_fecd .T =_g .String (v );_fedf ._cged .Si =append (_fedf ._cged .Si ,_fecd );_edeg :=len (_fedf ._cged .Si )-1;_fedf ._bbgd [v ]=_edeg ;_fedf ._cged .CountAttr =_g .Uint32 (uint32 (len (_fedf ._cged .Si )));_fedf ._cged .UniqueCountAttr =_fedf ._cged .CountAttr ;return _edeg ;};

// MoveTo is a no-op.
func (_cdb AbsoluteAnchor )MoveTo (x ,y int32 ){};

// SetHidden marks the defined name as hidden.
func (_faec DefinedName )SetHidden (b bool ){_faec ._cegfb .HiddenAttr =_g .Bool (b )};

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_aace DataValidationList )SetRange (cellRange string ){_aace ._ebfc .Formula1 =_g .String (cellRange );_aace ._ebfc .Formula2 =_g .String ("\u0030");};

// Protection allows control over the workbook protections.
func (_fbcb *Workbook )Protection ()WorkbookProtection {if _fbcb ._acbg .WorkbookProtection ==nil {_fbcb ._acbg .WorkbookProtection =_ccg .NewCT_WorkbookProtection ();};return WorkbookProtection {_fbcb ._acbg .WorkbookProtection };};

// X returns the inner wrapped XML type.
func (_acaa Sheet )X ()*_ccg .Worksheet {return _acaa ._ggac };

// MoveTo moves the top-left of the anchored object.
func (_dagb OneCellAnchor )MoveTo (col ,row int32 ){_dagb .TopLeft ().SetCol (col );_dagb .TopLeft ().SetRow (row );};func (_deac StyleSheet )GetCellStyle (id uint32 )CellStyle {for _gdfag ,_deaa :=range _deac ._dcae .CellXfs .Xf {if uint32 (_gdfag )==id {return CellStyle {_deac ._ecgcc ,_deaa ,_deac ._dcae .CellXfs };};};return CellStyle {};};

// Cell is a single cell within a sheet.
type Cell struct{_ebb *Workbook ;_bgf *Sheet ;_ge *_ccg .CT_Row ;_debc *_ccg .CT_Cell ;};func _fdc ()*_fa .CT_OneCellAnchor {_cagc :=_fa .NewCT_OneCellAnchor ();return _cagc };

// SetWrapped configures the cell to wrap text.
func (_gccd CellStyle )SetWrapped (b bool ){if _gccd ._bed .Alignment ==nil {_gccd ._bed .Alignment =_ccg .NewCT_CellAlignment ();};if !b {_gccd ._bed .Alignment .WrapTextAttr =nil ;}else {_gccd ._bed .Alignment .WrapTextAttr =_g .Bool (true );_gccd ._bed .ApplyAlignmentAttr =_g .Bool (true );};};func (_adgc *Sheet )setList (_cddg string ,_edacd _fe .Result )error {_bccc ,_bbab :=_cd .ParseCellReference (_cddg );if _bbab !=nil {return _bbab ;};_gbcdg :=_adgc .Row (_bccc .RowIdx );for _gafc ,_cgddbc :=range _edacd .ValueList {_bacee :=_gbcdg .Cell (_cd .IndexToColumn (_bccc .ColumnIdx +uint32 (_gafc )));if _cgddbc .Type !=_fe .ResultTypeEmpty {if _cgddbc .IsBoolean {_bacee .SetBool (_cgddbc .ValueNumber !=0);}else {_bacee .SetCachedFormulaResult (_cgddbc .String ());};};};return nil ;};

// SetSize sets the text size for a rich text run.
func (_caad RichTextRun )SetSize (m _daeg .Distance ){_caad .ensureRpr ();_caad ._ddgf .RPr .Sz =_ccg .NewCT_FontSize ();_caad ._ddgf .RPr .Sz .ValAttr =float64 (m /_daeg .Point );};

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct{_fggf *_ccg .CT_Font ;_gdfa *_ccg .StyleSheet ;};func (_fcga Font )SetBold (b bool ){if b {_fcga ._fggf .B =[]*_ccg .CT_BooleanProperty {{}};}else {_fcga ._fggf .B =nil ;};};

// Comments returns the comments for a sheet.
func (_fgeg *Sheet )Comments ()Comments {for _ecee ,_bgd :=range _fgeg ._facca ._acac {if _bgd ==_fgeg ._ggac {if _fgeg ._facca ._bgeff [_ecee ]==nil {_fgeg ._facca ._bgeff [_ecee ]=_ccg .NewComments ();_fgeg ._facca ._eabe [_ecee ].AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,_ecee +1,_g .CommentsType );_fgeg ._facca .ContentTypes .AddOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .CommentsType ,_ecee +1),_g .CommentsContentType );};if len (_fgeg ._facca ._aaae )==0{_fgeg ._facca ._aaae =append (_fgeg ._facca ._aaae ,_cab .NewCommentDrawing ());_dcgc :=_fgeg ._facca ._eabe [_ecee ].AddAutoRelationship (_g .DocTypeSpreadsheet ,_g .WorksheetType ,1,_g .VMLDrawingType );if _fgeg ._ggac .LegacyDrawing ==nil {_fgeg ._ggac .LegacyDrawing =_ccg .NewCT_LegacyDrawing ();};_fgeg ._ggac .LegacyDrawing .IdAttr =_dcgc .ID ();};return Comments {_fgeg ._facca ,_fgeg ._facca ._bgeff [_ecee ]};};};_g .Log ("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t");return Comments {};};

// HasNumberFormat returns true if the cell style has a number format applied.
func (_eff CellStyle )HasNumberFormat ()bool {return _eff ._bed .NumFmtIdAttr !=nil &&_eff ._bed .ApplyNumberFormatAttr !=nil &&*_eff ._bed .ApplyNumberFormatAttr ;};

// SetWidth sets the width of the anchored object.
func (_fb AbsoluteAnchor )SetWidth (w _daeg .Distance ){_fb ._ec .Ext .CxAttr =int64 (w /_daeg .EMU )};

// SetWidthCells is a no-op.
func (_aead OneCellAnchor )SetWidthCells (int32 ){};

// SetPassword sets the password hash to a hash of the input password.
func (_fcgg WorkbookProtection )SetPassword (pw string ){_fcgg .SetPasswordHash (PasswordHash (pw ))};

// RowOffset returns the offset from the row cell.
func (_bdb CellMarker )RowOffset ()_daeg .Distance {if _bdb ._fee .RowOff .ST_CoordinateUnqualified ==nil {return 0;};return _daeg .Distance (float64 (*_bdb ._fee .RowOff .ST_CoordinateUnqualified )*_daeg .EMU );};

// GetValueAsBool retrieves the cell's value as a boolean
func (_gcc Cell )GetValueAsBool ()(bool ,error ){if _gcc ._debc .TAttr !=_ccg .ST_CellTypeB {return false ,_ccd .New ("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065");};if _gcc ._debc .V ==nil {return false ,_ccd .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};return _gf .ParseBool (*_gcc ._debc .V );};

// GetFormat returns a cell data format.
func (_cdbg *evalContext )GetFormat (cellRef string )string {return _cdbg ._gdg .Cell (cellRef ).getFormat ();};

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_ccad TwoCellAnchor )TopLeft ()CellMarker {return CellMarker {_ccad ._bfbc .From }};

// GetString retrieves a string from the shared strings table by index.
func (_efcd SharedStrings )GetString (id int )(string ,error ){if id < 0{return "",_bf .Errorf ("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030",id );};if id > len (_efcd ._cged .Si ){return "",_bf .Errorf ("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073",id ,len (_efcd ._cged .Si ));};_aegf :=_efcd ._cged .Si [id ];if _aegf .T !=nil {return *_aegf .T ,nil ;};return "",nil ;};

// AddCellStyle adds a new empty cell style to the stylesheet.
func (_gfece StyleSheet )AddCellStyle ()CellStyle {_bdbg :=_ccg .NewCT_Xf ();_gfece ._dcae .CellXfs .Xf =append (_gfece ._dcae .CellXfs .Xf ,_bdbg );_gfece ._dcae .CellXfs .CountAttr =_g .Uint32 (uint32 (len (_gfece ._dcae .CellXfs .Xf )));return CellStyle {_gfece ._ecgcc ,_bdbg ,_gfece ._dcae .CellXfs };};

// SetWidth sets the width of the anchored object.
func (_bgagb OneCellAnchor )SetWidth (w _daeg .Distance ){_bgagb ._bdab .Ext .CxAttr =int64 (w /_daeg .EMU );};

// Type returns the type of the rule
func (_bdba ConditionalFormattingRule )Type ()_ccg .ST_CfType {return _bdba ._fdef .TypeAttr };var (_cafd =[...]uint8 {0,21,46,61,76,91};_baed =[...]uint8 {0,21,37,53,69,85,103,119,135,151,167,185,201,217,239};_ega =[...]uint8 {0,16,32,48,64};_bbca =[...]uint8 {0,16,32,48,64,80};);

// Author returns the author of the comment
func (_cccc Comment )Author ()string {if _cccc ._gfa .AuthorIdAttr < uint32 (len (_cccc ._gccdg .Authors .Author )){return _cccc ._gccdg .Authors .Author [_cccc ._gfa .AuthorIdAttr ];};return "";};

// MakeComments constructs a new Comments wrapper.
func MakeComments (w *Workbook ,x *_ccg .Comments )Comments {return Comments {w ,x }};

// X returns the inner wrapped XML type.
func (_beb Cell )X ()*_ccg .CT_Cell {return _beb ._debc };func (_gage *evalContext )SetOffset (col ,row uint32 ){_gage ._gdfd =col ;_gage ._dec =row };

// X returns the inner wrapped XML type.
func (_dcaad Table )X ()*_ccg .Table {return _dcaad ._cfff };

// GetBorder gets a Border from a cell style.
func (_ffg CellStyle )GetBorder ()*_ccg .CT_Border {if _bfe :=_ffg ._bed .BorderIdAttr ;_bfe !=nil {_cbd :=_ffg ._gag .StyleSheet .Borders ();if int (*_bfe )< len (_cbd ){return _cbd [int (*_bfe )].X ();};};return nil ;};type MergedCell struct{_aafc *Workbook ;_afaa *Sheet ;_gce *_ccg .CT_MergeCell ;};

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_fbfe StyleSheet )AddNumberFormat ()NumberFormat {if _fbfe ._dcae .NumFmts ==nil {_fbfe ._dcae .NumFmts =_ccg .NewCT_NumFmts ();};_cbafb :=_ccg .NewCT_NumFmt ();_cbafb .NumFmtIdAttr =uint32 (200+len (_fbfe ._dcae .NumFmts .NumFmt ));_fbfe ._dcae .NumFmts .NumFmt =append (_fbfe ._dcae .NumFmts .NumFmt ,_cbafb );_fbfe ._dcae .NumFmts .CountAttr =_g .Uint32 (uint32 (len (_fbfe ._dcae .NumFmts .NumFmt )));return NumberFormat {_fbfe ._ecgcc ,_cbafb };};

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_efae ConditionalFormattingRule )SetColorScale ()ColorScale {_efae .clear ();_efae .SetType (_ccg .ST_CfTypeColorScale );_efae ._fdef .ColorScale =_ccg .NewCT_ColorScale ();return ColorScale {_efae ._fdef .ColorScale };};

// SetColor sets teh color of the databar.
func (_ecde DataBarScale )SetColor (c _bag .Color ){_ecde ._cda .Color =_ccg .NewCT_Color ();_ecde ._cda .Color .RgbAttr =c .AsRGBAString ();};

// SetOperator sets the operator for the rule.
func (_eba ConditionalFormattingRule )SetOperator (t _ccg .ST_ConditionalFormattingOperator ){_eba ._fdef .OperatorAttr =t ;};

// X returns the inner wrapped XML type.
func (_cfd Drawing )X ()*_fa .WsDr {return _cfd ._eceb };func _gbge (_fcaf *Sheet )*evalContext {return &evalContext {_gdg :_fcaf ,_efc :make (map[string ]struct{})};};

// AddMergedCells merges cells within a sheet.
func (_fggab *Sheet )AddMergedCells (fromRef ,toRef string )MergedCell {if _fggab ._ggac .MergeCells ==nil {_fggab ._ggac .MergeCells =_ccg .NewCT_MergeCells ();};_adcc :=_ccg .NewCT_MergeCell ();_adcc .RefAttr =_bf .Sprintf ("\u0025\u0073\u003a%\u0073",fromRef ,toRef );_fggab ._ggac .MergeCells .MergeCell =append (_fggab ._ggac .MergeCells .MergeCell ,_adcc );_fggab ._ggac .MergeCells .CountAttr =_g .Uint32 (uint32 (len (_fggab ._ggac .MergeCells .MergeCell )));return MergedCell {_fggab ._facca ,_fggab ,_adcc };};func (_dfb PatternFill )X ()*_ccg .CT_PatternFill {return _dfb ._gdgf };func (_aaea StandardFormat )String ()string {switch {case 0<=_aaea &&_aaea <=4:return _cgege [_cafd [_aaea ]:_cafd [_aaea +1]];case 9<=_aaea &&_aaea <=22:_aaea -=9;return _agba [_baed [_aaea ]:_baed [_aaea +1]];case 37<=_aaea &&_aaea <=40:_aaea -=37;return _fbba [_ega [_aaea ]:_ega [_aaea +1]];case 45<=_aaea &&_aaea <=49:_aaea -=45;return _cgdc [_bbca [_aaea ]:_bbca [_aaea +1]];default:return _bf .Sprintf ("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029",_aaea );};};

// SetRowOffset sets the row offset of the top-left anchor.
func (_ddd OneCellAnchor )SetRowOffset (m _daeg .Distance ){_ddd .TopLeft ().SetRowOffset (m )};

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_daegg *Sheet )ClearCachedFormulaResults (){for _ ,_ddac :=range _daegg .Rows (){for _ ,_ffdgg :=range _ddac .Cells (){if _ffdgg .X ().F !=nil {_ffdgg .X ().V =nil ;};};};};

// TopLeft returns the top-left corner of the anchored object.
func (_dfdd OneCellAnchor )TopLeft ()CellMarker {return CellMarker {_dfdd ._bdab .From }};

// X returns the inner wrapped XML type.
func (_ebff DefinedName )X ()*_ccg .CT_DefinedName {return _ebff ._cegfb };

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{_gggb *_ccg .CT_DataValidation };

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_aggb Cell )SetBool (v bool ){_aggb .clearValue ();_aggb ._debc .V =_g .String (_gf .Itoa (_gee (v )));_aggb ._debc .TAttr =_ccg .ST_CellTypeB ;};

// Wrapped returns true if the cell will wrap text.
func (_dcg CellStyle )Wrapped ()bool {if _dcg ._bed .Alignment ==nil {return false ;};if _dcg ._bed .Alignment .WrapTextAttr ==nil {return false ;};return *_dcg ._bed .Alignment .WrapTextAttr ;};

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_acfg *Workbook )CopySheet (ind int ,copiedSheetName string )(Sheet ,error ){if _acfg .SheetCount ()<=ind {return Sheet {},ErrorNotFound ;};var _eafae _cgb .Relationship ;for _ ,_fbca :=range _acfg ._gbaf .Relationships (){if _fbca .ID ()==_acfg ._acbg .Sheets .Sheet [ind ].IdAttr {var _geeb bool ;if _eafae ,_geeb =_acfg ._gbaf .CopyRelationship (_fbca .ID ());!_geeb {return Sheet {},ErrorNotFound ;};break ;};};_acfg .ContentTypes .CopyOverride (_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,ind +1),_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .WorksheetContentType ,len (_acfg .ContentTypes .X ().Override )));_efged :=*_acfg ._acac [ind ];_acfg ._acac =append (_acfg ._acac ,&_efged );var _bebc uint32 =0;for _ ,_bded :=range _acfg ._acbg .Sheets .Sheet {if _bded .SheetIdAttr > _bebc {_bebc =_bded .SheetIdAttr ;};};_bebc ++;_ddaee :=*_acfg ._acbg .Sheets .Sheet [ind ];_ddaee .IdAttr =_eafae .ID ();_ddaee .NameAttr =copiedSheetName ;_ddaee .SheetIdAttr =_bebc ;_acfg ._acbg .Sheets .Sheet =append (_acfg ._acbg .Sheets .Sheet ,&_ddaee );_dgdb :=_cgb .NewRelationshipsCopy (_acfg ._eabe [ind ]);_acfg ._eabe =append (_acfg ._eabe ,_dgdb );_dage :=_acfg ._bgeff [ind ];if _dage ==nil {_acfg ._bgeff =append (_acfg ._bgeff ,nil );}else {_efce :=*_dage ;_acfg ._bgeff =append (_acfg ._bgeff ,&_efce );};_bffae :=Sheet {_acfg ,&_ddaee ,&_efged };return _bffae ,nil ;};

// Protection controls the protection on an individual sheet.
func (_edeae *Sheet )Protection ()SheetProtection {if _edeae ._ggac .SheetProtection ==nil {_edeae ._ggac .SheetProtection =_ccg .NewCT_SheetProtection ();};return SheetProtection {_edeae ._ggac .SheetProtection };};

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_acgg Cell )GetValueAsTime ()(_ca .Time ,error ){if _acgg ._debc .TAttr !=_ccg .ST_CellTypeUnset {return _ca .Time {},_ccd .New ("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t");};if _acgg ._debc .V ==nil {return _ca .Time {},_ccd .New ("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065");};_dgga ,_ ,_cgd :=_cg .ParseFloat (*_acgg ._debc .V ,10,128,_cg .ToNearestEven );if _cgd !=nil {return _ca .Time {},_cgd ;};_ddf :=new (_cg .Float );_ddf .SetUint64 (uint64 (24*_ca .Hour ));_dgga .Mul (_dgga ,_ddf );_bbb ,_ :=_dgga .Uint64 ();_aec :=_acgg ._ebb .Epoch ().Add (_ca .Duration (_bbb ));return _fca (_aec ),nil ;};

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_ffcd *Sheet )SetBorder (cellRange string ,border Border )error {_cafb ,_beg ,_fffa :=_cd .ParseRangeReference (cellRange );if _fffa !=nil {return _fffa ;};_gadg :=_ffcd ._facca .StyleSheet .AddCellStyle ();_cdfb :=_ffcd ._facca .StyleSheet .AddBorder ();_gadg .SetBorder (_cdfb );_cdfb ._cb .Top =border ._cb .Top ;_cdfb ._cb .Left =border ._cb .Left ;_gcbd :=_ffcd ._facca .StyleSheet .AddCellStyle ();_egcg :=_ffcd ._facca .StyleSheet .AddBorder ();_gcbd .SetBorder (_egcg );_egcg ._cb .Top =border ._cb .Top ;_egcg ._cb .Right =border ._cb .Right ;_aeab :=_ffcd ._facca .StyleSheet .AddCellStyle ();_afed :=_ffcd ._facca .StyleSheet .AddBorder ();_aeab .SetBorder (_afed );_afed ._cb .Top =border ._cb .Top ;_agdb :=_ffcd ._facca .StyleSheet .AddCellStyle ();_abdf :=_ffcd ._facca .StyleSheet .AddBorder ();_agdb .SetBorder (_abdf );_abdf ._cb .Left =border ._cb .Left ;_aabge :=_ffcd ._facca .StyleSheet .AddCellStyle ();_ebe :=_ffcd ._facca .StyleSheet .AddBorder ();_aabge .SetBorder (_ebe );_ebe ._cb .Right =border ._cb .Right ;_bcb :=_ffcd ._facca .StyleSheet .AddCellStyle ();_cffb :=_ffcd ._facca .StyleSheet .AddBorder ();_bcb .SetBorder (_cffb );_cffb ._cb .Bottom =border ._cb .Bottom ;_egega :=_ffcd ._facca .StyleSheet .AddCellStyle ();_ecge :=_ffcd ._facca .StyleSheet .AddBorder ();_egega .SetBorder (_ecge );_ecge ._cb .Bottom =border ._cb .Bottom ;_ecge ._cb .Left =border ._cb .Left ;_fdfge :=_ffcd ._facca .StyleSheet .AddCellStyle ();_afce :=_ffcd ._facca .StyleSheet .AddBorder ();_fdfge .SetBorder (_afce );_afce ._cb .Bottom =border ._cb .Bottom ;_afce ._cb .Right =border ._cb .Right ;_ecfe :=_cafb .RowIdx ;_bafb :=_cafb .ColumnIdx ;_fgfc :=_beg .RowIdx ;_acggg :=_beg .ColumnIdx ;for _dcce :=_ecfe ;_dcce <=_fgfc ;_dcce ++{for _fbg :=_bafb ;_fbg <=_acggg ;_fbg ++{_dfee :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_fbg ),_dcce );switch {case _dcce ==_ecfe &&_fbg ==_bafb :_ffcd .Cell (_dfee ).SetStyle (_gadg );case _dcce ==_ecfe &&_fbg ==_acggg :_ffcd .Cell (_dfee ).SetStyle (_gcbd );case _dcce ==_fgfc &&_fbg ==_bafb :_ffcd .Cell (_dfee ).SetStyle (_egega );case _dcce ==_fgfc &&_fbg ==_acggg :_ffcd .Cell (_dfee ).SetStyle (_fdfge );case _dcce ==_ecfe :_ffcd .Cell (_dfee ).SetStyle (_aeab );case _dcce ==_fgfc :_ffcd .Cell (_dfee ).SetStyle (_bcb );case _fbg ==_bafb :_ffcd .Cell (_dfee ).SetStyle (_agdb );case _fbg ==_acggg :_ffcd .Cell (_dfee ).SetStyle (_aabge );};};};return nil ;};

// Operator returns the operator for the rule
func (_aagc ConditionalFormattingRule )Operator ()_ccg .ST_ConditionalFormattingOperator {return _aagc ._fdef .OperatorAttr ;};

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{_ebfc *_ccg .CT_DataValidation };

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_caa CellStyle )GetVerticalAlignment ()_ccg .ST_VerticalAlignment {if _caa ._bed .Alignment ==nil {return _ccg .ST_VerticalAlignmentUnset ;};return _caa ._bed .Alignment .VerticalAttr ;};

// X returns the inner wrapped XML type.
func (_egg RichText )X ()*_ccg .CT_Rst {return _egg ._eagb };

// IsWindowLocked returns whether the workbook windows are locked.
func (_fffag WorkbookProtection )IsWindowLocked ()bool {return _fffag ._gcde .LockWindowsAttr !=nil &&*_fffag ._gcde .LockWindowsAttr ;};func (_dfeg *Sheet )getAllCellsInFormulaArraysForColumn ()(map[string ]bool ,error ){return _dfeg .getAllCellsInFormulaArrays (false );};func (_cfac *Workbook )ensureSharedStringsRelationships (){_fdgg :=false ;for _ ,_ccegc :=range _cfac .ContentTypes .X ().Override {if _ccegc .ContentTypeAttr ==_g .SharedStringsContentType {_fdgg =true ;break ;};};if !_fdgg {_cfac .ContentTypes .AddOverride (_aacc ,_g .SharedStringsContentType );};_ccgg :=false ;for _ ,_bccag :=range _cfac ._gbaf .Relationships (){if _bccag .X ().TargetAttr ==_gcda {_ccgg =true ;break ;};};if !_ccgg {_cfac ._gbaf .AddRelationship (_gcda ,_g .SharedStringsType );};};

// ClearFont clears any font configuration from the cell style.
func (_fddc CellStyle )ClearFont (){_fddc ._bed .FontIdAttr =nil ;_fddc ._bed .ApplyFontAttr =nil };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_bbad *Sheet )RecalculateFormulas (){_bgfdb :=_fe .NewEvaluator ();_eced :=_bbad .FormulaContext ();for _ ,_dafa :=range _bbad .Rows (){for _ ,_aabe :=range _dafa .Cells (){if _aabe .X ().F !=nil {_edgb :=_aabe .X ().F .Content ;if _aabe .X ().F .TAttr ==_ccg .ST_CellFormulaTypeShared &&len (_edgb )==0{continue ;};_cedac :=_bgfdb .Eval (_eced ,_edgb ).AsString ();if _cedac .Type ==_fe .ResultTypeError {_g .Log ("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073",_edgb ,_cedac .ErrorMessage );_aabe .X ().V =nil ;}else {if _cedac .Type ==_fe .ResultTypeNumber {_aabe .X ().TAttr =_ccg .ST_CellTypeN ;}else {_aabe .X ().TAttr =_ccg .ST_CellTypeInlineStr ;};_aabe .X ().V =_g .String (_cedac .Value ());if _aabe .X ().F .TAttr ==_ccg .ST_CellFormulaTypeArray {if _cedac .Type ==_fe .ResultTypeArray {_bbad .setArray (_aabe .Reference (),_cedac );}else if _cedac .Type ==_fe .ResultTypeList {_bbad .setList (_aabe .Reference (),_cedac );};}else if _aabe .X ().F .TAttr ==_ccg .ST_CellFormulaTypeShared &&_aabe .X ().F .RefAttr !=nil {_cdfe ,_cdebb ,_gfcc :=_cd .ParseRangeReference (*_aabe .X ().F .RefAttr );if _gfcc !=nil {_bb .Printf ("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073",_gfcc );continue ;};_bbad .setShared (_aabe .Reference (),_cdfe ,_cdebb ,_edgb );};};};};};};const (StandardFormatGeneral StandardFormat =0;StandardFormat0 StandardFormat =0;StandardFormatWholeNumber StandardFormat =1;StandardFormat1 StandardFormat =1;StandardFormat2 StandardFormat =2;StandardFormat3 StandardFormat =3;StandardFormat4 StandardFormat =4;StandardFormatPercent StandardFormat =9;StandardFormat9 StandardFormat =9;StandardFormat10 StandardFormat =10;StandardFormat11 StandardFormat =11;StandardFormat12 StandardFormat =12;StandardFormat13 StandardFormat =13;StandardFormatDate StandardFormat =14;StandardFormat14 StandardFormat =14;StandardFormat15 StandardFormat =15;StandardFormat16 StandardFormat =16;StandardFormat17 StandardFormat =17;StandardFormat18 StandardFormat =18;StandardFormatTime StandardFormat =19;StandardFormat19 StandardFormat =19;StandardFormat20 StandardFormat =20;StandardFormat21 StandardFormat =21;StandardFormatDateTime StandardFormat =22;StandardFormat22 StandardFormat =22;StandardFormat37 StandardFormat =37;StandardFormat38 StandardFormat =38;StandardFormat39 StandardFormat =39;StandardFormat40 StandardFormat =40;StandardFormat45 StandardFormat =45;StandardFormat46 StandardFormat =46;StandardFormat47 StandardFormat =47;StandardFormat48 StandardFormat =48;StandardFormat49 StandardFormat =49;);

// SetXSplit sets the column split point
func (_gea SheetView )SetXSplit (v float64 ){_gea .ensurePane ();_gea ._fadc .Pane .XSplitAttr =_g .Float64 (v );};

// SetHeight sets the row height in points.
func (_bfg Row )SetHeight (d _daeg .Distance ){_bfg ._gagf .HtAttr =_g .Float64 (float64 (d ));_bfg ._gagf .CustomHeightAttr =_g .Bool (true );};func (_fcg Cell )getRawSortValue ()(string ,bool ){if _fcg .HasFormula (){_bcg :=_fcg .GetCachedFormulaResult ();return _bcg ,_ef .IsNumber (_bcg );};_aca ,_ :=_fcg .GetRawValue ();return _aca ,_ef .IsNumber (_aca );};

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_fgfd *Sheet )AddRow ()Row {_febc :=uint32 (0);_cageb :=uint32 (len (_fgfd ._ggac .SheetData .Row ));if _cageb > 0&&_fgfd ._ggac .SheetData .Row [_cageb -1].RAttr !=nil &&*_fgfd ._ggac .SheetData .Row [_cageb -1].RAttr ==_cageb {return _fgfd .addNumberedRowFast (_cageb +1);};for _ ,_fadaa :=range _fgfd ._ggac .SheetData .Row {if _fadaa .RAttr !=nil &&*_fadaa .RAttr > _febc {_febc =*_fadaa .RAttr ;};};return _fgfd .AddNumberedRow (_febc +1);};

// SetStyle applies a style to the cell.  This style is referenced in the
// generated XML via CellStyle.Index().
func (_dfd Cell )SetStyle (cs CellStyle ){_dfd .SetStyleIndex (cs .Index ())};

// AddFont adds a new empty font to the stylesheet.
func (_eabg StyleSheet )AddFont ()Font {_bege :=_ccg .NewCT_Font ();_eabg ._dcae .Fonts .Font =append (_eabg ._dcae .Fonts .Font ,_bege );_eabg ._dcae .Fonts .CountAttr =_g .Uint32 (uint32 (len (_eabg ._dcae .Fonts .Font )));return Font {_bege ,_eabg ._dcae };};func (_dgad Fill )Index ()uint32 {if _dgad ._fea ==nil {return 0;};for _aced ,_bbd :=range _dgad ._fea .Fill {if _dgad ._aaca ==_bbd {return uint32 (_aced );};};return 0;};

// Type returns the type of anchor
func (_fefc TwoCellAnchor )Type ()AnchorType {return AnchorTypeTwoCell };var _fgbdg =[...]uint8 {0,18,37};

// IsError returns true if the cell is an error type cell.
func (_faa Cell )IsError ()bool {return _faa ._debc .TAttr ==_ccg .ST_CellTypeE };func (_abg Border )SetDiagonal (style _ccg .ST_BorderStyle ,c _bag .Color ,up ,down bool ){if _abg ._cb .Diagonal ==nil {_abg ._cb .Diagonal =_ccg .NewCT_BorderPr ();};_abg ._cb .Diagonal .Color =_ccg .NewCT_Color ();_abg ._cb .Diagonal .Color .RgbAttr =c .AsRGBAString ();_abg ._cb .Diagonal .StyleAttr =style ;if up {_abg ._cb .DiagonalUpAttr =_g .Bool (true );};if down {_abg ._cb .DiagonalDownAttr =_g .Bool (true );};};

// IsSheetLocked returns whether the sheet objects are locked.
func (_fddb SheetProtection )IsObjectLocked ()bool {return _fddb ._agge .ObjectsAttr !=nil &&*_fddb ._agge .ObjectsAttr ;};

// InitializeDefaults initializes a border to its defaulte empty values.
func (_eg Border )InitializeDefaults (){_eg ._cb .Left =_ccg .NewCT_BorderPr ();_eg ._cb .Bottom =_ccg .NewCT_BorderPr ();_eg ._cb .Right =_ccg .NewCT_BorderPr ();_eg ._cb .Top =_ccg .NewCT_BorderPr ();_eg ._cb .Diagonal =_ccg .NewCT_BorderPr ();};func (_edb *Sheet )slideCellsLeft (_faba []*_ccg .CT_Cell )[]*_ccg .CT_Cell {for _ ,_gaff :=range _faba {_gfcf ,_bddg :=_cd .ParseCellReference (*_gaff .RAttr );if _bddg !=nil {return _faba ;};_cfcg :=_gfcf .ColumnIdx -1;_acba :=_cd .IndexToColumn (_cfcg )+_bf .Sprintf ("\u0025\u0064",_gfcf .RowIdx );_gaff .RAttr =&_acba ;};return _faba ;};

// DefinedName is a named range, formula, etc.
type DefinedName struct{_cegfb *_ccg .CT_DefinedName };var _dada []string =[]string {"\u007a\u0068\u002dH\u004b","\u007a\u0068\u002dM\u004f","\u007a\u0068\u002dC\u004e","\u007a\u0068\u002dS\u0047","\u007a\u0068\u002dT\u0057","\u006a\u0061\u002dJ\u0050","\u006b\u006f\u002dK\u0052"};func (_beba *evalContext )Cell (ref string ,ev _fe .Evaluator )_fe .Result {if !_fbbc (ref ){return _fe .MakeErrorResultType (_fe .ErrorTypeName ,"");};_degd :=_beba ._gdg .Name ()+"\u0021"+ref ;if _gecg ,_bdf :=ev .GetFromCache (_degd );_bdf {return _gecg ;};_dcec ,_bad :=_cd .ParseCellReference (ref );if _bad !=nil {return _fe .MakeErrorResult (_bf .Sprintf ("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",ref ,_bad ));};if _beba ._gdfd !=0&&!_dcec .AbsoluteColumn {_dcec .ColumnIdx +=_beba ._gdfd ;_dcec .Column =_cd .IndexToColumn (_dcec .ColumnIdx );};if _beba ._dec !=0&&!_dcec .AbsoluteRow {_dcec .RowIdx +=_beba ._dec ;};_faaf :=_beba ._gdg .Cell (_dcec .String ());if _faaf .HasFormula (){if _ ,_fec :=_beba ._efc [ref ];_fec {return _fe .MakeErrorResult ("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020"+ref );};_beba ._efc [ref ]=struct{}{};_cefe :=ev .Eval (_beba ,_faaf .GetFormula ());delete (_beba ._efc ,ref );ev .SetCache (_degd ,_cefe );return _cefe ;};if _faaf .IsEmpty (){_becd :=_fe .MakeEmptyResult ();ev .SetCache (_degd ,_becd );return _becd ;}else if _faaf .IsNumber (){_gab ,_ :=_faaf .GetValueAsNumber ();_bada :=_fe .MakeNumberResult (_gab );ev .SetCache (_degd ,_bada );return _bada ;}else if _faaf .IsBool (){_aegd ,_ :=_faaf .GetValueAsBool ();_cbbb :=_fe .MakeBoolResult (_aegd );ev .SetCache (_degd ,_cbbb );return _cbbb ;};_fcdf ,_ :=_faaf .GetRawValue ();if _faaf .IsError (){_efab :=_fe .MakeErrorResult ("");_efab .ValueString =_fcdf ;ev .SetCache (_degd ,_efab );return _efab ;};_abbc :=_fe .MakeStringResult (_fcdf );ev .SetCache (_degd ,_abbc );return _abbc ;};

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_gfddc TwoCellAnchor )SetWidthCells (w int32 ){_fega :=_gfddc .TopLeft ();_fbab :=_gfddc .BottomRight ();_fbab .SetCol (_fega .Col ()+w );};

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_dbg Cell )SetFormulaArray (s string ){_aea :=_fe .ParseString (s );if _aea ==nil {return ;};_dbg .clearValue ();_dbg ._debc .TAttr =_ccg .ST_CellTypeStr ;_dbg ._debc .F =_ccg .NewCT_CellFormula ();_dbg ._debc .F .TAttr =_ccg .ST_CellFormulaTypeArray ;_dbg ._debc .F .Content =s ;};func (_gbgb Sheet )validateSheetNames ()error {if len (_gbgb .Name ())> 31{return _bf .Errorf ("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331",_gbgb .Name (),len (_gbgb .Name ()));};return nil ;};

// SetItalic causes the text to be displayed in italic.
func (_ddfed RichTextRun )SetItalic (b bool ){_ddfed .ensureRpr ();_ddfed ._ddgf .RPr .I =_ccg .NewCT_BooleanProperty ();_ddfed ._ddgf .RPr .I .ValAttr =_g .Bool (b );};

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet (wb *Workbook )StyleSheet {_gcfg :=_ccg .NewStyleSheet ();_gcfg .CellStyleXfs =_ccg .NewCT_CellStyleXfs ();_gcfg .CellXfs =_ccg .NewCT_CellXfs ();_gcfg .CellStyles =_ccg .NewCT_CellStyles ();_bbgce :=_ccg .NewCT_CellStyle ();_bbgce .NameAttr =_g .String ("\u004e\u006f\u0072\u006d\u0061\u006c");_bbgce .XfIdAttr =0;_bbgce .BuiltinIdAttr =_g .Uint32 (0);_gcfg .CellStyles .CellStyle =append (_gcfg .CellStyles .CellStyle ,_bbgce );_gcfg .CellStyles .CountAttr =_g .Uint32 (uint32 (len (_gcfg .CellStyles .CellStyle )));_degb :=_ccg .NewCT_Xf ();_degb .NumFmtIdAttr =_g .Uint32 (0);_degb .FontIdAttr =_g .Uint32 (0);_degb .FillIdAttr =_g .Uint32 (0);_degb .BorderIdAttr =_g .Uint32 (0);_gcfg .CellStyleXfs .Xf =append (_gcfg .CellStyleXfs .Xf ,_degb );_gcfg .CellStyleXfs .CountAttr =_g .Uint32 (uint32 (len (_gcfg .CellStyleXfs .Xf )));_bddb :=NewFills ();_gcfg .Fills =_bddb .X ();_ebfb :=_bddb .AddFill ().SetPatternFill ();_ebfb .SetPattern (_ccg .ST_PatternTypeNone );_ebfb =_bddb .AddFill ().SetPatternFill ();_ebfb .SetPattern (_ccg .ST_PatternTypeGray125 );_gcfg .Fonts =_ccg .NewCT_Fonts ();_gcfg .Borders =_ccg .NewCT_Borders ();_abfe :=StyleSheet {wb ,_gcfg };_abfe .AddBorder ().InitializeDefaults ();_gdffc :=_abfe .AddFont ();_gdffc .SetName ("\u0043a\u006c\u0069\u0062\u0072\u0069");_gdffc .SetSize (11);_bcca :=_ccg .NewCT_Xf ();*_bcca =*_degb ;_bcca .XfIdAttr =_g .Uint32 (0);_gcfg .CellXfs .Xf =append (_gcfg .CellXfs .Xf ,_bcca );_gcfg .CellXfs .CountAttr =_g .Uint32 (uint32 (len (_gcfg .CellXfs .Xf )));return _abfe ;};

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_bbae *Workbook )Epoch ()_ca .Time {if _bbae .Uses1904Dates (){_ca .Date (1904,1,1,0,0,0,0,_ca .UTC );};return _ca .Date (1899,12,30,0,0,0,0,_ca .UTC );};

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_afc Comment )SetAuthor (author string ){_afc ._gfa .AuthorIdAttr =Comments {_afc ._egc ,_afc ._gccdg }.getOrCreateAuthor (author );};

// SetName sets the sheet name.
func (_ebfa *Sheet )SetName (name string ){_ebfa ._adb .NameAttr =name };func (_cgc DataValidationCompare )SetValue2 (v string ){_cgc ._gggb .Formula2 =&v };

// SetValues sets the possible values. This is incompatible with SetRange.
func (_efb DataValidationList )SetValues (values []string ){_efb ._ebfc .Formula1 =_g .String ("\u0022"+_da .Join (values ,"\u002c")+"\u0022");_efb ._ebfc .Formula2 =_g .String ("\u0030");};

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_eeg *evalContext )LastColumn (rowFrom ,rowTo int )string {_dfa :=_eeg ._gdg ;_dbb :=1;for _edff :=rowFrom ;_edff <=rowTo ;_edff ++{_bga :=len (_dfa .Row (uint32 (_edff )).Cells ());if _bga > _dbb {_dbb =_bga ;};};return _cd .IndexToColumn (uint32 (_dbb -1));};func (_ead *Sheet )setArray (_agfc string ,_gbcd _fe .Result )error {_ecgee ,_cbge :=_cd .ParseCellReference (_agfc );if _cbge !=nil {return _cbge ;};for _fafad ,_bbfd :=range _gbcd .ValueArray {_beddf :=_ead .Row (_ecgee .RowIdx +uint32 (_fafad ));for _gedd ,_aafcg :=range _bbfd {_edga :=_beddf .Cell (_cd .IndexToColumn (_ecgee .ColumnIdx +uint32 (_gedd )));if _aafcg .Type !=_fe .ResultTypeEmpty {if _aafcg .IsBoolean {_edga .SetBool (_aafcg .ValueNumber !=0);}else {_edga .SetCachedFormulaResult (_aafcg .String ());};};};};return nil ;};

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_bfbe Row )RowNumber ()uint32 {if _bfbe ._gagf .RAttr !=nil {return *_bfbe ._gagf .RAttr ;};return 0;};

// Fonts returns the list of fonts defined in the stylesheet.
func (_defgg StyleSheet )Fonts ()[]Font {_cbea :=[]Font {};for _ ,_ggdg :=range _defgg ._dcae .Fonts .Font {_cbea =append (_cbea ,Font {_ggdg ,_defgg ._dcae });};return _cbea ;};func (_fd Border )SetBottom (style _ccg .ST_BorderStyle ,c _bag .Color ){if _fd ._cb .Bottom ==nil {_fd ._cb .Bottom =_ccg .NewCT_BorderPr ();};_fd ._cb .Bottom .Color =_ccg .NewCT_Color ();_fd ._cb .Bottom .Color .RgbAttr =c .AsRGBAString ();_fd ._cb .Bottom .StyleAttr =style ;};

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_cdd IconScale )AddFormatValue (t _ccg .ST_CfvoType ,val string ){_dbdd :=_ccg .NewCT_Cfvo ();_dbdd .TypeAttr =t ;_dbdd .ValAttr =_g .String (val );_cdd ._dee .Cfvo =append (_cdd ._dee .Cfvo ,_dbdd );};

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{_fede *_ccg .CT_ColorScale };

// SetLocked sets cell locked or not.
func (_ede *evalContext )SetLocked (cellRef string ,locked bool ){_ede ._gdg .Cell (cellRef ).setLocked (locked );};

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{_bfbc *_fa .CT_TwoCellAnchor };

// Type returns the type of anchor
func (_af AbsoluteAnchor )Type ()AnchorType {return AnchorTypeAbsolute };var _gcda =_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .OfficeDocumentType ,_g .SharedStringsType ,0);

// ClearProtection clears all workbook protections.
func (_bea *Workbook )ClearProtection (){_bea ._acbg .WorkbookProtection =nil };var _ddec *_a .Regexp =_a .MustCompile ("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024");

// SetWidth controls the width of a column.
func (_egea Column )SetWidth (w _daeg .Distance ){_egea ._fae .WidthAttr =_g .Float64 (float64 (w /_daeg .Character ));};

// MergedCells returns the merged cell regions within the sheet.
func (_ecaf *Sheet )MergedCells ()[]MergedCell {if _ecaf ._ggac .MergeCells ==nil {return nil ;};_fgba :=[]MergedCell {};for _ ,_bace :=range _ecaf ._ggac .MergeCells .MergeCell {_fgba =append (_fgba ,MergedCell {_ecaf ._facca ,_ecaf ,_bace });};return _fgba ;};

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct{_gag *Workbook ;_bed *_ccg .CT_Xf ;_edac *_ccg .CT_CellXfs ;};

// X returns the inner wrapped XML type.
func (_cfee *Workbook )X ()*_ccg .Workbook {return _cfee ._acbg };

// Name returns the sheet name
func (_bcc Sheet )Name ()string {return _bcc ._adb .NameAttr };

// Text returns text from the sheet as one string separated with line breaks.
func (_edge *SheetText )Text ()string {_bbc :=_ggg .NewBuffer ([]byte {});for _ ,_gecf :=range _edge .Cells {if _gecf .Text !=""{_bbc .WriteString (_gecf .Text );_bbc .WriteString ("\u000a");};};return _bbc .String ();};

// Read reads a workbook from an io.Reader(.xlsx).
func Read (r _cc .ReaderAt ,size int64 )(*Workbook ,error ){const _deea ="\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064";if !_ae .GetLicenseKey ().IsLicensed ()&&!_egbb {_bf .Println ("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065");_bf .Println ("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f");return nil ,_ccd .New ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064");};_gdgg :=New ();_cfb ,_ccac :=_ae .GenRefId ("\u0073\u0072");if _ccac !=nil {_g .Log ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_ccac );return nil ,_ccac ;};_gdgg ._bebb =_cfb ;if _bdeg :=_ae .Track (_gdgg ._bebb ,_deea );_bdeg !=nil {_bf .Printf ("\u0045\u0052\u0052\u004f\u0052\u003a\u0020\u0025\u0076\u000a",_bdeg );return nil ,_bdeg ;};_bbdc ,_ccac :=_cea .TempDir ("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078");if _ccac !=nil {return nil ,_ccac ;};_gdgg .TmpPath =_bbdc ;_abbe ,_ccac :=_gc .NewReader (r ,size );if _ccac !=nil {return nil ,_bf .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073",_ccac );};_agce :=[]*_gc .File {};_agce =append (_agce ,_abbe .File ...);_dadae :=false ;for _ ,_gffg :=range _agce {if _gffg .FileHeader .Name =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_dadae =true ;break ;};};if _dadae {_gdgg .CreateCustomProperties ();};_bbgc :=_fg .DecodeMap {};_bbgc .SetOnNewRelationshipFunc (_gdgg .onNewRelationship );_bbgc .AddTarget (_g .ContentTypesFilename ,_gdgg .ContentTypes .X (),"",0);_bbgc .AddTarget (_g .BaseRelsFilename ,_gdgg .Rels .X (),"",0);if _fggg :=_bbgc .Decode (_agce );_fggg !=nil {return nil ,_fggg ;};for _ ,_gagg :=range _agce {if _gagg ==nil {continue ;};if _eaag :=_gdgg .AddExtraFileFromZip (_gagg );_eaag !=nil {return nil ,_eaag ;};};if _dadae {_dgfa :=false ;for _ ,_fgf :=range _gdgg .Rels .X ().Relationship {if _fgf .TargetAttr =="\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c"{_dgfa =true ;break ;};};if !_dgfa {_gdgg .AddCustomRelationships ();};};return _gdgg ,nil ;};

// AddView adds a sheet view.
func (_gbbg *Sheet )AddView ()SheetView {if _gbbg ._ggac .SheetViews ==nil {_gbbg ._ggac .SheetViews =_ccg .NewCT_SheetViews ();};_efga :=_ccg .NewCT_SheetView ();_gbbg ._ggac .SheetViews .SheetView =append (_gbbg ._ggac .SheetViews .SheetView ,_efga );return SheetView {_efga };};

// X returns the inner wrapped XML type.
func (_aba DataValidation )X ()*_ccg .CT_DataValidation {return _aba ._fded };

// PasswordHash returns the hash of the workbook password.
func (_aeea WorkbookProtection )PasswordHash ()string {if _aeea ._gcde .WorkbookPasswordAttr ==nil {return "";};return *_aeea ._gcde .WorkbookPasswordAttr ;};

// IsHidden returns whether the row is hidden or not.
func (_ffcb Row )IsHidden ()bool {return _ffcb ._gagf .HiddenAttr !=nil &&*_ffcb ._gagf .HiddenAttr };

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_dde Cell )SetTime (d _ca .Time ){_dde .clearValue ();d =_ecd (d );_ebc :=_dde ._ebb .Epoch ();if d .Before (_ebc ){_g .Log ("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064");return ;};_fgb :=d .Sub (_ebc );_aedb :=new (_cg .Float );_faf :=new (_cg .Float );_faf .SetPrec (128);_faf .SetUint64 (uint64 (_fgb ));_dgf :=new (_cg .Float );_dgf .SetUint64 (24*60*60*1e9);_aedb .Quo (_faf ,_dgf );_dde ._debc .V =_g .String (_aedb .Text ('g',20));};

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{_fadc *_ccg .CT_SheetView };

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_cec Drawing )AddChart (at AnchorType )(_ba .Chart ,Anchor ){_cbbf :=_dg .NewChartSpace ();_cec ._afac ._bgaaf =append (_cec ._afac ._bgaaf ,_cbbf );_dfdg :=_g .AbsoluteFilename (_g .DocTypeSpreadsheet ,_g .ChartContentType ,len (_cec ._afac ._bgaaf ));_cec ._afac .ContentTypes .AddOverride (_dfdg ,_g .ChartContentType );var _gbae string ;for _bedb ,_ebdd :=range _cec ._afac ._egddd {if _ebdd ==_cec ._eceb {_fag :=_g .RelativeFilename (_g .DocTypeSpreadsheet ,_g .DrawingType ,_g .ChartType ,len (_cec ._afac ._bgaaf ));_eae :=_cec ._afac ._ebfeb [_bedb ].AddRelationship (_fag ,_g .ChartType );_gbae =_eae .ID ();break ;};};var _gefg Anchor ;var _gffa *_fa .CT_GraphicalObjectFrame ;switch at {case AnchorTypeAbsolute :_dbea :=_ffgd ();_cec ._eceb .EG_Anchor =append (_cec ._eceb .EG_Anchor ,&_fa .EG_Anchor {AbsoluteAnchor :_dbea });_dbea .Choice =&_fa .EG_ObjectChoicesChoice {};_dbea .Choice .GraphicFrame =_fa .NewCT_GraphicalObjectFrame ();_gffa =_dbea .Choice .GraphicFrame ;_gefg =AbsoluteAnchor {_dbea };case AnchorTypeOneCell :_dgba :=_fdc ();_cec ._eceb .EG_Anchor =append (_cec ._eceb .EG_Anchor ,&_fa .EG_Anchor {OneCellAnchor :_dgba });_dgba .Choice =&_fa .EG_ObjectChoicesChoice {};_dgba .Choice .GraphicFrame =_fa .NewCT_GraphicalObjectFrame ();_gffa =_dgba .Choice .GraphicFrame ;_gefg =OneCellAnchor {_dgba };case AnchorTypeTwoCell :_dbfc :=_ebffa ();_cec ._eceb .EG_Anchor =append (_cec ._eceb .EG_Anchor ,&_fa .EG_Anchor {TwoCellAnchor :_dbfc });_dbfc .Choice =&_fa .EG_ObjectChoicesChoice {};_dbfc .Choice .GraphicFrame =_fa .NewCT_GraphicalObjectFrame ();_gffa =_dbfc .Choice .GraphicFrame ;_gefg =TwoCellAnchor {_dbfc };};_gffa .NvGraphicFramePr =_fa .NewCT_GraphicalObjectFrameNonVisual ();_gffa .NvGraphicFramePr .CNvPr .IdAttr =uint32 (len (_cec ._eceb .EG_Anchor ));_gffa .NvGraphicFramePr .CNvPr .NameAttr ="\u0043\u0068\u0061r\u0074";_gffa .Graphic =_aef .NewGraphic ();_gffa .Graphic .GraphicData .UriAttr ="\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074";_dbgg :=_dg .NewChart ();_dbgg .IdAttr =_gbae ;_gffa .Graphic .GraphicData .Any =[]_g .Any {_dbgg };_faad :=_ba .MakeChart (_cbbf );_faad .Properties ().SetSolidFill (_bag .White );_faad .SetDisplayBlanksAs (_dg .ST_DispBlanksAsGap );return _faad ,_gefg ;};

// BottomRight is a no-op.
func (_ccb AbsoluteAnchor )BottomRight ()CellMarker {return CellMarker {}};

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{_cda *_ccg .CT_DataBar };

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_dd Cell )SetFormulaShared (formulaStr string ,rows ,cols uint32 )error {_fad :=_fe .ParseString (formulaStr );if _fad ==nil {return _ccd .New (_bf .Sprintf ("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073",formulaStr ));};_dd .clearValue ();_dd ._debc .TAttr =_ccg .ST_CellTypeStr ;_dd ._debc .F =_ccg .NewCT_CellFormula ();_dd ._debc .F .TAttr =_ccg .ST_CellFormulaTypeShared ;_dd ._debc .F .Content =formulaStr ;_ed ,_fdf :=_cd .ParseCellReference (_dd .Reference ());if _fdf !=nil {return _fdf ;};_aed :=uint32 (0);for _ ,_gaa :=range _dd ._bgf .Rows (){for _ ,_ccdf :=range _gaa ._gagf .C {if _ccdf .F !=nil &&_ccdf .F .SiAttr !=nil &&*_ccdf .F .SiAttr >=_aed {_aed =*_ccdf .F .SiAttr ;};};};_aed ++;_ag :=_bf .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_ed .Column ,_ed .RowIdx ,_cd .IndexToColumn (_ed .ColumnIdx +cols ),_ed .RowIdx +rows );_dd ._debc .F .RefAttr =_g .String (_ag );_dd ._debc .F .SiAttr =_g .Uint32 (_aed );_dbe :=Sheet {_dd ._ebb ,_dd ._bgf ._adb ,_dd ._bgf ._ggac };for _fada :=_ed .RowIdx ;_fada <=_ed .RowIdx +rows ;_fada ++{for _gda :=_ed .ColumnIdx ;_gda <=_ed .ColumnIdx +cols ;_gda ++{if _fada ==_ed .RowIdx &&_gda ==_ed .ColumnIdx {continue ;};_ege :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_gda ),_fada );_dbe .Cell (_ege ).Clear ();_dbe .Cell (_ege ).X ().F =_ccg .NewCT_CellFormula ();_dbe .Cell (_ege ).X ().F .TAttr =_ccg .ST_CellFormulaTypeShared ;_dbe .Cell (_ege ).X ().F .SiAttr =_g .Uint32 (_aed );};};return nil ;};

// AddFormatValue adds a format value (databars require two).
func (_baca DataBarScale )AddFormatValue (t _ccg .ST_CfvoType ,val string ){_ccba :=_ccg .NewCT_Cfvo ();_ccba .TypeAttr =t ;_ccba .ValAttr =_g .String (val );_baca ._cda .Cfvo =append (_baca ._cda .Cfvo ,_ccba );};const (DVOpGreater =_ccg .ST_DataValidationOperatorGreaterThanOrEqual ;);

// ClearAutoFilter removes the autofilters from the sheet.
func (_dabc *Sheet )ClearAutoFilter (){_dabc ._ggac .AutoFilter =nil ;_cff :="\u0027"+_dabc .Name ()+"\u0027\u0021";for _ ,_edea :=range _dabc ._facca .DefinedNames (){if _edea .Name ()==_cfe {if _da .HasPrefix (_edea .Content (),_cff ){_dabc ._facca .RemoveDefinedName (_edea );break ;};};};};func (_fdd CellStyle )SetShrinkToFit (b bool ){if _fdd ._bed .Alignment ==nil {_fdd ._bed .Alignment =_ccg .NewCT_CellAlignment ();};_fdd ._bed .ApplyAlignmentAttr =_g .Bool (true );if !b {_fdd ._bed .Alignment .ShrinkToFitAttr =nil ;}else {_fdd ._bed .Alignment .ShrinkToFitAttr =_g .Bool (b );};};

// SetColOffset sets the column offset of the top-left anchor.
func (_cecc OneCellAnchor )SetColOffset (m _daeg .Distance ){_cecc .TopLeft ().SetColOffset (m )};

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_ddcg *Workbook )GetFilename ()string {return _ddcg ._dgdca };const _eadf ="\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067";

// SetError sets the cell type to error and the value to the given error message.
func (_bbga Cell )SetError (msg string ){_bbga .clearValue ();_bbga ._debc .V =_g .String (msg );_bbga ._debc .TAttr =_ccg .ST_CellTypeE ;};

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte ;

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_bbfa Row )Cells ()[]Cell {_gfec :=[]Cell {};_cedae :=-1;_fadf :=append ([]*_ccg .CT_Cell {},_bbfa ._gagf .C ...);for _ ,_efgf :=range _fadf {if _efgf .RAttr ==nil {_g .Log ("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_cdf ,_adg :=_cd .ParseCellReference (*_efgf .RAttr );if _adg !=nil {_g .Log ("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020"+*_efgf .RAttr +",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e");continue ;};_ddgc :=int (_cdf .ColumnIdx );if _ddgc -_cedae > 1{for _bbge :=_cedae +1;_bbge < _ddgc ;_bbge ++{_gfec =append (_gfec ,_bbfa .Cell (_cd .IndexToColumn (uint32 (_bbge ))));};};_cedae =_ddgc ;_gfec =append (_gfec ,Cell {_bbfa ._ccccd ,_bbfa ._bedc ,_bbfa ._gagf ,_efgf });};return _gfec ;};

// SetPattern sets the pattern of the fill.
func (_bdbc PatternFill )SetPattern (p _ccg .ST_PatternType ){_bdbc ._gdgf .PatternTypeAttr =p };func _ffgd ()*_fa .CT_AbsoluteAnchor {_fdgbb :=_fa .NewCT_AbsoluteAnchor ();return _fdgbb };

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{Cells []CellText ;};

// LockWindow controls the locking of the workbook windows.
func (_ggdb WorkbookProtection )LockWindow (b bool ){if !b {_ggdb ._gcde .LockWindowsAttr =nil ;}else {_ggdb ._gcde .LockWindowsAttr =_g .Bool (true );};};

// SetShowRuler controls the visibility of the ruler
func (_aeb SheetView )SetShowRuler (b bool ){if !b {_aeb ._fadc .ShowRulerAttr =_g .Bool (false );}else {_aeb ._fadc .ShowRulerAttr =nil ;};};

// X returns the inner wrapped XML type.
func (_efcb Row )X ()*_ccg .CT_Row {return _efcb ._gagf };

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_bdgc *Workbook )RecalculateFormulas (){for _ ,_ebda :=range _bdgc .Sheets (){_ebda .RecalculateFormulas ();};};

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_aff Cell )SetFormulaRaw (s string ){_cef :=_fe .ParseString (s );if _cef ==nil {return ;};_aff .clearValue ();_aff ._debc .TAttr =_ccg .ST_CellTypeStr ;_aff ._debc .F =_ccg .NewCT_CellFormula ();_aff ._debc .F .Content =s ;};

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{_fae *_ccg .CT_Col };

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_fgg *evalContext )LastRow (col string )int {_aege :=_fgg ._gdg ;_bfff :=int (_cd .ColumnToIndex (col ));_fcgf :=1;for _ ,_bedd :=range _aege ._ggac .SheetData .Row {if _bedd .RAttr !=nil {_bab :=Row {_aege ._facca ,_aege ,_bedd };_ada :=len (_bab .Cells ());if _ada > _bfff {_fcgf =int (_bab .RowNumber ());};};};return _fcgf ;};

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct{_afac *Workbook ;_eceb *_fa .WsDr ;};

// SheetCount returns the number of sheets in the workbook.
func (_cdgb Workbook )SheetCount ()int {return len (_cdgb ._acac )};

// SetRowOffset sets a column offset in absolute distance.
func (_fbe CellMarker )SetRowOffset (m _daeg .Distance ){_fbe ._fee .RowOff .ST_CoordinateUnqualified =_g .Int64 (int64 (m /_daeg .EMU ));};

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_bbda Sheet )RangeReference (n string )string {_bdcb :=_da .Split (n ,"\u003a");_dddd ,_ :=_cd .ParseCellReference (_bdcb [0]);_cgcf :=_bf .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_dddd .Column ,_dddd .RowIdx );if len (_bdcb )==1{return _bf .Sprintf ("\u0027%\u0073\u0027\u0021\u0025\u0073",_bbda .Name (),_cgcf );};_dege ,_ :=_cd .ParseCellReference (_bdcb [1]);_dfeb :=_bf .Sprintf ("\u0024\u0025\u0073\u0024\u0025\u0064",_dege .Column ,_dege .RowIdx );return _bf .Sprintf ("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073",_bbda .Name (),_cgcf ,_dfeb );};func (_gb Border )SetRight (style _ccg .ST_BorderStyle ,c _bag .Color ){if _gb ._cb .Right ==nil {_gb ._cb .Right =_ccg .NewCT_BorderPr ();};_gb ._cb .Right .Color =_ccg .NewCT_Color ();_gb ._cb .Right .Color .RgbAttr =c .AsRGBAString ();_gb ._cb .Right .StyleAttr =style ;};

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_feb CellStyle )SetProtection (protected bool ,hidden bool ){_feb ._bed .Protection =&_ccg .CT_CellProtection {LockedAttr :&protected ,HiddenAttr :&hidden };};

// SetHidden controls the visibility of a column.
func (_fdaf Column )SetHidden (b bool ){if !b {_fdaf ._fae .HiddenAttr =nil ;}else {_fdaf ._fae .HiddenAttr =_g .Bool (true );};};

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_bebab *Sheet )ClearSheetViews (){_bebab ._ggac .SheetViews =nil };

// SetAllowBlank controls if blank values are accepted.
func (_bgac DataValidation )SetAllowBlank (b bool ){if !b {_bgac ._fded .AllowBlankAttr =nil ;}else {_bgac ._fded .AllowBlankAttr =_g .Bool (true );};};

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_ffgf *Workbook )GetChartByTargetId (targetAttr string )*_dg .ChartSpace {return _ffgf ._begc [targetAttr ];};

// GetEpoch returns a workbook's time epoch.
func (_dgd *evalContext )GetEpoch ()_ca .Time {return _dgd ._gdg ._facca .Epoch ()};

// GetFormat sets the number format code.
func (_ggae NumberFormat )GetFormat ()string {return _ggae ._ebba .FormatCodeAttr };

// Index returns the index of the differential style.
func (_eegg DifferentialStyle )Index ()uint32 {for _dga ,_bde :=range _eegg ._baa .Dxf {if _eegg ._dfab ==_bde {return uint32 (_dga );};};return 0;};

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_gge Sheet )Extents ()string {_efgfc ,_fbdgb ,_ffgc ,_caf :=_gge .ExtentsIndex ();return _bf .Sprintf ("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d",_efgfc ,_fbdgb ,_ffgc ,_caf );};

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct{_cf *_ccg .CT_ConditionalFormatting ;};

// Open opens and reads a workbook from a file (.xlsx).
func Open (filename string )(*Workbook ,error ){_bdfb ,_fbde :=_gg .Open (filename );if _fbde !=nil {return nil ,_bf .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fbde );};defer _bdfb .Close ();_gbed ,_fbde :=_gg .Stat (filename );if _fbde !=nil {return nil ,_bf .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",filename ,_fbde );};_cde ,_fbde :=Read (_bdfb ,_gbed .Size ());if _fbde !=nil {return nil ,_fbde ;};_dgc ,_ :=_ce .Abs (_ce .Dir (filename ));_cde ._dgdca =_ce .Join (_dgc ,filename );return _cde ,nil ;};

// X returns the inner wrapped XML type.
func (_bdgb MergedCell )X ()*_ccg .CT_MergeCell {return _bdgb ._gce };

// AnchorType is the type of anchor.
type AnchorType byte ;

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_dbde Row )AddNamedCell (col string )Cell {_bdfba :=_ccg .NewCT_Cell ();_bdfba .RAttr =_g .Stringf ("\u0025\u0073\u0025\u0064",col ,_dbde .RowNumber ());_edc :=-1;_daab :=_cd .ColumnToIndex (col );for _gbce ,_abe :=range _dbde ._gagf .C {_cee ,_adaf :=_cd .ParseCellReference (*_abe .RAttr );if _adaf !=nil {return Cell {};};if _daab < _cee .ColumnIdx {_edc =_gbce ;break ;};};if _edc ==-1{_dbde ._gagf .C =append (_dbde ._gagf .C ,_bdfba );}else {_dbde ._gagf .C =append (_dbde ._gagf .C [:_edc ],append ([]*_ccg .CT_Cell {_bdfba },_dbde ._gagf .C [_edc :]...)...);};return Cell {_dbde ._ccccd ,_dbde ._bedc ,_dbde ._gagf ,_bdfba };};

// SetHidden hides or unhides the row
func (_gfdb Row )SetHidden (hidden bool ){if !hidden {_gfdb ._gagf .HiddenAttr =nil ;}else {_gfdb ._gagf .HiddenAttr =_g .Bool (true );};};func (_efaf *Sheet )setShared (_eef string ,_cbeg ,_fabb _cd .CellReference ,_cgfdb string ){_ccbc :=_efaf .FormulaContext ();_bceg :=_fe .NewEvaluator ();for _egdf :=_cbeg .RowIdx ;_egdf <=_fabb .RowIdx ;_egdf ++{for _fbdf :=_cbeg .ColumnIdx ;_fbdf <=_fabb .ColumnIdx ;_fbdf ++{_dfg :=_egdf -_cbeg .RowIdx ;_bddf :=_fbdf -_cbeg .ColumnIdx ;_ccbc .SetOffset (_bddf ,_dfg );_gdbb :=_bceg .Eval (_ccbc ,_cgfdb );_dfef :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",_cd .IndexToColumn (_fbdf ),_egdf );_degdd :=_efaf .Cell (_dfef );if _gdbb .Type ==_fe .ResultTypeNumber {_degdd .X ().TAttr =_ccg .ST_CellTypeN ;}else {_degdd .X ().TAttr =_ccg .ST_CellTypeInlineStr ;};_degdd .X ().V =_g .String (_gdbb .Value ());};};_ =_bceg ;_ =_ccbc ;};

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_ebgf TwoCellAnchor )BottomRight ()CellMarker {return CellMarker {_ebgf ._bfbc .To }};

// SetTopLeft sets the top left visible cell after the split.
func (_ebdc SheetView )SetTopLeft (cellRef string ){_ebdc .ensurePane ();_ebdc ._fadc .Pane .TopLeftCellAttr =&cellRef ;};

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_cdaa Sheet )Validate ()error {_dgbd :=[]func ()error {_cdaa .validateRowCellNumbers ,_cdaa .validateMergedCells ,_cdaa .validateSheetNames };for _ ,_daefd :=range _dgbd {if _egegf :=_daefd ();_egegf !=nil {return _egegf ;};};if _gcccc :=_cdaa ._ggac .Validate ();_gcccc !=nil {return _gcccc ;};return _cdaa ._ggac .Validate ();};

// SetRotation configures the cell to be rotated.
func (_afa CellStyle )SetRotation (deg uint8 ){if _afa ._bed .Alignment ==nil {_afa ._bed .Alignment =_ccg .NewCT_CellAlignment ();};_afa ._bed .ApplyAlignmentAttr =_g .Bool (true );_afa ._bed .Alignment .TextRotationAttr =_g .Uint8 (deg );};

// ClearNumberFormat removes any number formatting from the style.
func (_ddg CellStyle )ClearNumberFormat (){_ddg ._bed .NumFmtIdAttr =nil ;_ddg ._bed .ApplyNumberFormatAttr =nil ;};

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{_bdab *_fa .CT_OneCellAnchor };

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_bfabd Row )Cell (col string )Cell {_gffe :=_bf .Sprintf ("\u0025\u0073\u0025\u0064",col ,_bfabd .RowNumber ());for _ ,_caeb :=range _bfabd ._gagf .C {if _caeb .RAttr !=nil &&*_caeb .RAttr ==_gffe {return Cell {_bfabd ._ccccd ,_bfabd ._bedc ,_bfabd ._gagf ,_caeb };};};return _bfabd .AddNamedCell (col );};