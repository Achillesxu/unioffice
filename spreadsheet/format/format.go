//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_fa "bytes";_c "fmt";_cd "github.com/unidoc/unioffice";_d "io";_g "math";_db "strconv";_f "strings";_e "time";);const _cc ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";const _aggg int =0;

// AddToken adds a format token to the format.
func (_aa *Format )AddToken (t FmtType ,l []byte ){if _aa ._dgc {_aa ._dgc =false ;return ;};switch t {case FmtTypeDecimal :_aa ._cf =true ;case FmtTypeUnderscore :_aa ._dgc =true ;case FmtTypeText :_aa .Whole =append (_aa .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_aa .Whole =append (_aa .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_aa ._cdg =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_eb :=range l {if _aa .IsExponential {_aa .Exponent =append (_aa .Exponent ,Token {Type :t ,Literal :_eb });}else if !_aa ._cf {_aa .Whole =append (_aa .Whole ,Token {Type :t ,Literal :_eb });}else {_aa .Fractional =append (_aa .Fractional ,Token {Type :t ,Literal :_eb });};};case FmtTypeDigitOptThousands :_aa ._ed =true ;case FmtTypeFraction :_ec :=_f .Split (string (l ),"\u002f");if len (_ec )==2{_aa ._b =true ;_aa ._ef ,_ =_db .ParseInt (_ec [1],10,64);for _ ,_fg :=range _ec [1]{if _fg =='?'||_fg =='0'{_aa ._ca ++;};};};default:_cd .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};func _bfb (_ceb ,_aaa float64 ,_dbdg Format )[]byte {if len (_dbdg .Whole )==0{return nil ;};_ae :=_e .Date (1899,12,30,0,0,0,0,_e .UTC );_cff :=_ae .Add (_e .Duration (_aaa *float64 (24*_e .Hour )));_cff =_bffd (_cff );_efa :=_db .AppendFloat (nil ,_ceb ,'f',-1,64);_ebc :=make ([]byte ,0,len (_efa ));_ggeg :=0;_af :=1;_eff :for _bad :=len (_dbdg .Whole )-1;_bad >=0;_bad --{_edf :=len (_efa )-1-_ggeg ;_aae :=_dbdg .Whole [_bad ];switch _aae .Type {case FmtTypeDigit :if _edf >=0{_ebc =append (_ebc ,_efa [_edf ]);_ggeg ++;_af =_bad ;}else {_ebc =append (_ebc ,'0');};case FmtTypeDigitOpt :if _edf >=0{_ebc =append (_ebc ,_efa [_edf ]);_ggeg ++;_af =_bad ;}else {for _dfd :=_bad ;_dfd >=0;_dfd --{_agg :=_dbdg .Whole [_dfd ];if _agg .Type ==FmtTypeLiteral {_ebc =append (_ebc ,_agg .Literal );};};break _eff ;};case FmtTypeDollar :for _gca :=_ggeg ;_gca < len (_efa );_gca ++{_ebc =append (_ebc ,_efa [len (_efa )-1-_gca ]);_ggeg ++;};_ebc =append (_ebc ,'$');case FmtTypeComma :if !_dbdg ._ed {_ebc =append (_ebc ,',');};case FmtTypeLiteral :_ebc =append (_ebc ,_aae .Literal );case FmtTypeDate :_ebc =append (_ebc ,_eeb (_edg (_cff ,_aae .DateTime ))...);case FmtTypeTime :_ebc =append (_ebc ,_eeb (_de (_cff ,_aaa ,_aae .DateTime ))...);default:_cd .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_aae );};};_gab :=_eeb (_ebc );if _ggeg < len (_efa )&&(_ggeg !=0||_dbdg ._cf ){_ffa :=len (_efa )-_ggeg ;_fgd :=make ([]byte ,len (_gab )+_ffa );copy (_fgd ,_gab [0:_af ]);copy (_fgd [_af :],_efa [0:]);copy (_fgd [_af +_ffa :],_gab [_af :]);_gab =_fgd ;};if _dbdg ._ed {_cce :=_fa .Buffer {};_bg :=0;for _agd :=len (_gab )-1;_agd >=0;_agd --{if !(_gab [_agd ]>='0'&&_gab [_agd ]<='9'){_bg ++;}else {break ;};};for _bd :=0;_bd < len (_gab );_bd ++{_bc :=(len (_gab )-_bd -_bg );if _bc %3==0&&_bc !=0&&_bd !=0{_cce .WriteByte (',');};_cce .WriteByte (_gab [_bd ]);};_gab =_cce .Bytes ();};return _gab ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const _ce =1e11;

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_faf :=Parse (f );if len (_faf )==1{return _cdgg (v ,_faf [0],false );}else if len (_faf )> 1&&v < 0{return _cdgg (v ,_faf [1],true );}else if len (_faf )> 2&&v ==0{return _cdgg (v ,_faf [2],false );};return _cdgg (v ,_faf [0],false );};const _ab =1e-10;

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_fb :=Parse (f );var _ee Format ;if len (_fb )==1{_ee =_fb [0];}else if len (_fb )==4{_ee =_fb [3];};_eba :=false ;for _ ,_aaf :=range _ee .Whole {if _aaf .Type ==FmtTypeText {_eba =true ;};};if !_eba {return v ;};_ba :=_fa .Buffer {};for _ ,_cdc :=range _ee .Whole {switch _cdc .Type {case FmtTypeLiteral :_ba .WriteByte (_cdc .Literal );case FmtTypeText :_ba .WriteString (v );};};return _ba .String ();};var _ga =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func _cb (_baf float64 )string {_edeg :=_db .FormatFloat (_baf ,'E',-1,64);_ffd :=_db .FormatFloat (_baf ,'E',5,64);if len (_edeg )< len (_ffd ){return _db .FormatFloat (_baf ,'E',2,64);};return _ffd ;};func _eeg (_dfe ,_bgf float64 ,_cde Format )[]byte {if len (_cde .Fractional )==0{return nil ;};_ggd :=_db .AppendFloat (nil ,_dfe ,'f',-1,64);if len (_ggd )> 2{_ggd =_ggd [2:];}else {_ggd =nil ;};_bge :=make ([]byte ,0,len (_ggd ));_bge =append (_bge ,'.');_ece :=0;_cdcd :for _ge :=0;_ge < len (_cde .Fractional );_ge ++{_eed :=_ge ;_cfb :=_cde .Fractional [_ge ];switch _cfb .Type {case FmtTypeDigit :if _eed < len (_ggd ){_bge =append (_bge ,_ggd [_eed ]);_ece ++;}else {_bge =append (_bge ,'0');};case FmtTypeDigitOpt :if _eed >=0{_bge =append (_bge ,_ggd [_eed ]);_ece ++;}else {break _cdcd ;};case FmtTypeLiteral :_bge =append (_bge ,_cfb .Literal );default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_cfb );};};return _bge ;};func _eeb (_ad []byte )[]byte {for _be :=0;_be < len (_ad )/2;_be ++{_add :=len (_ad )-1-_be ;_ad [_be ],_ad [_add ]=_ad [_add ],_ad [_be ];};return _ad ;};const _abb int =-1;const _gdd int =34;func _dfge (_gdc []byte )[]byte {_ebe :=len (_gdc );_cec :=false ;_aec :=false ;for _ffe :=len (_gdc )-1;_ffe >=0;_ffe --{if _gdc [_ffe ]=='0'&&!_aec &&!_cec {_ebe =_ffe ;}else if _gdc [_ffe ]=='.'{_cec =true ;}else {_aec =true ;};};if _cec &&_aec {if _gdc [_ebe -1]=='.'{_ebe --;};return _gdc [0:_ebe ];};return _gdc ;};const _ecee int =34;type Lexer struct{_cbc Format ;_dca []Format ;};func IsNumber (data string )(_bbcb bool ){_ggegd ,_cbe ,_cdb :=0,0,len (data );_eac :=len (data );_cffc ,_gb ,_aff :=0,0,0;_ =_gb ;_ =_aff ;_ =_cffc ;{_ggegd =_gff ;_cffc =0;_gb =0;_aff =0;};{if _cbe ==_cdb {goto _cffg ;};switch _ggegd {case 0:goto _dag ;case 1:goto _ccb ;case 2:goto _bbca ;case 3:goto _deb ;case 4:goto _degd ;case 5:goto _gcd ;case 6:goto _ged ;case 7:goto _dac ;};goto _gefe ;_fgg :_gb =_cbe ;_cbe --;{_bbcb =false ;};goto _cbeg ;_fac :_gb =_cbe ;_cbe --;{_bbcb =_gb ==len (data );};goto _cbeg ;_fbdb :_gb =_cbe ;_cbe --;{_bbcb =_gb ==len (data );};goto _cbeg ;_fae :switch _aff {case 2:{_cbe =(_gb )-1;_bbcb =_gb ==len (data );};case 3:{_cbe =(_gb )-1;_bbcb =false ;};};goto _cbeg ;_cbeg :_cffc =0;if _cbe ++;_cbe ==_cdb {goto _cecc ;};_dag :_cffc =_cbe ;switch data [_cbe ]{case 43:goto _cfeg ;case 45:goto _cfeg ;};if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _aee ;};goto _egc ;_egc :if _cbe ++;_cbe ==_cdb {goto _fag ;};_ccb :goto _egc ;_cfeg :if _cbe ++;_cbe ==_cdb {goto _bcc ;};_bbca :if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _aee ;};goto _egc ;_aee :if _cbe ++;_cbe ==_cdb {goto _eae ;};_deb :if data [_cbe ]==46{goto _efc ;};if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _aee ;};goto _egc ;_efc :if _cbe ++;_cbe ==_cdb {goto _afg ;};_degd :if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _fdb ;};goto _egc ;_fdb :if _cbe ++;_cbe ==_cdb {goto _bca ;};_gcd :if data [_cbe ]==69{goto _aafd ;};if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _fdb ;};goto _egc ;_aafd :if _cbe ++;_cbe ==_cdb {goto _cacb ;};_ged :switch data [_cbe ]{case 43:goto _fbbe ;case 45:goto _fbbe ;};goto _egc ;_fbbe :_gb =_cbe +1;_aff =3;goto _cac ;_gffe :_gb =_cbe +1;_aff =2;goto _cac ;_cac :if _cbe ++;_cbe ==_cdb {goto _edfa ;};_dac :if 48<=data [_cbe ]&&data [_cbe ]<=57{goto _gffe ;};goto _egc ;_gefe :_cecc :_ggegd =0;goto _cffg ;_fag :_ggegd =1;goto _cffg ;_bcc :_ggegd =2;goto _cffg ;_eae :_ggegd =3;goto _cffg ;_afg :_ggegd =4;goto _cffg ;_bca :_ggegd =5;goto _cffg ;_cacb :_ggegd =6;goto _cffg ;_edfa :_ggegd =7;goto _cffg ;_cffg :{};if _cbe ==_eac {switch _ggegd {case 1:goto _fgg ;case 2:goto _fgg ;case 3:goto _fac ;case 4:goto _fgg ;case 5:goto _fbdb ;case 6:goto _fgg ;case 7:goto _fae ;};};};if _ggegd ==_abb {return false ;};return ;};func _de (_bce _e .Time ,_ecb float64 ,_cca string )[]byte {_deg :=[]byte {};_gefc :=0;for _dff :=0;_dff < len (_cca );_dff ++{var _cbd string ;if _cca [_dff ]==':'{_cbd =string (_cca [_gefc :_dff ]);_gefc =_dff +1;}else if _dff ==len (_cca )-1{_cbd =string (_cca [_gefc :_dff +1]);}else {continue ;};switch _cbd {case "\u0064":_deg =_bce .AppendFormat (_deg ,"\u0032");case "\u0068":_deg =_bce .AppendFormat (_deg ,"\u0033");case "\u0068\u0068":_deg =_bce .AppendFormat (_deg ,"\u0031\u0035");case "\u006d":_deg =_bce .AppendFormat (_deg ,"\u0034");case "\u006d\u006d":_deg =_bce .AppendFormat (_deg ,"\u0030\u0034");case "\u0073":_deg =_bce .Round (_e .Second ).AppendFormat (_deg ,"\u0035");case "\u0073\u002e\u0030":_deg =_bce .Round (_e .Second /10).AppendFormat (_deg ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_deg =_bce .Round (_e .Second /100).AppendFormat (_deg ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_deg =_bce .Round (_e .Second /1000).AppendFormat (_deg ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_deg =_bce .Round (_e .Second ).AppendFormat (_deg ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_deg =_bce .Round (_e .Second /10).AppendFormat (_deg ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_deg =_bce .Round (_e .Second /100).AppendFormat (_deg ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_deg =_bce .Round (_e .Second /1000).AppendFormat (_deg ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_deg =_bce .AppendFormat (_deg ,"\u0050\u004d");case "\u005b\u0068\u005d":_deg =_db .AppendInt (_deg ,int64 (_ecb *24),10);case "\u005b\u006d\u005d":_deg =_db .AppendInt (_deg ,int64 (_ecb *24*60),10);case "\u005b\u0073\u005d":_deg =_db .AppendInt (_deg ,int64 (_ecb *24*60*60),10);case "":default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_cbd );};if _cca [_dff ]==':'{_deg =append (_deg ,':');};};return _deg ;};func _cdcb (_dab int64 )int64 {if _dab < 0{return -_dab ;};return _dab ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_gg ,_ :=_db .ParseFloat (v ,64);return Number (_gg ,f );};return String (v ,f );};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_b bool ;_cdg bool ;_df bool ;_ed bool ;_dgc bool ;_cf bool ;_ef int64 ;_ca int ;};func _gf (_ede int64 ,_fbd Format )[]byte {if !_fbd .IsExponential ||len (_fbd .Exponent )==0{return nil ;};_fbb :=_db .AppendInt (nil ,_cdcb (_ede ),10);_adg :=make ([]byte ,0,len (_fbb )+2);_adg =append (_adg ,'E');if _ede >=0{_adg =append (_adg ,'+');}else {_adg =append (_adg ,'-');_ede *=-1;};_aeb :=0;_dgb :for _dfg :=len (_fbd .Exponent )-1;_dfg >=0;_dfg --{_gdeb :=len (_fbb )-1-_aeb ;_bbc :=_fbd .Exponent [_dfg ];switch _bbc .Type {case FmtTypeDigit :if _gdeb >=0{_adg =append (_adg ,_fbb [_gdeb ]);_aeb ++;}else {_adg =append (_adg ,'0');};case FmtTypeDigitOpt :if _gdeb >=0{_adg =append (_adg ,_fbb [_gdeb ]);_aeb ++;}else {for _gef :=_dfg ;_gef >=0;_gef --{_fdc :=_fbd .Exponent [_gef ];if _fdc .Type ==FmtTypeLiteral {_adg =append (_adg ,_fdc .Literal );};};break _dgb ;};case FmtTypeLiteral :_adg =append (_adg ,_bbc .Literal );default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_bbc );};};if _aeb < len (_fbb ){_adg =append (_adg ,_fbb [len (_fbb )-_aeb -1:_aeb -1]...);};_eeb (_adg [2:]);return _adg ;};func _bffd (_fgf _e .Time )_e .Time {_fgf =_fgf .UTC ();return _e .Date (_fgf .Year (),_fgf .Month (),_fgf .Day (),_fgf .Hour (),_fgf .Minute (),_fgf .Second (),_fgf .Nanosecond (),_e .Local );};func (_dbg *Lexer )nextFmt (){_dbg ._dca =append (_dbg ._dca ,_dbg ._cbc );_dbg ._cbc =Format {}};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _g .Abs (v )>=_ce ||_g .Abs (v )<=_ab &&v !=0{return _cb (v );};_dcg :=make ([]byte ,0,15);_dcg =_db .AppendFloat (_dcg ,v ,'f',-1,64);if len (_dcg )> 11{_afb :=_dcg [11]-'0';if _afb >=5&&_afb <=9{_dcg [10]++;_dcg =_dcg [0:11];_dcg =_beb (_dcg );};_dcg =_dcg [0:11];}else if len (_dcg )==11{if _dcg [len (_dcg )-1]=='9'{_dcg [len (_dcg )-1]++;_dcg =_beb (_dcg );};};_dcg =_dfge (_dcg );return string (_dcg );};func _edg (_cfe _e .Time ,_bgg string )[]byte {_bef :=[]byte {};_afbe :=0;for _acg :=0;_acg < len (_bgg );_acg ++{var _eea string ;if _bgg [_acg ]=='/'{_eea =string (_bgg [_afbe :_acg ]);_afbe =_acg +1;}else if _acg ==len (_bgg )-1{_eea =string (_bgg [_afbe :_acg +1]);}else {continue ;};switch _eea {case "\u0079\u0079":_bef =_cfe .AppendFormat (_bef ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_bef =_cfe .AppendFormat (_bef ,"\u0032\u0030\u0030\u0036");case "\u006d":_bef =_cfe .AppendFormat (_bef ,"\u0031");case "\u006d\u006d":_bef =_cfe .AppendFormat (_bef ,"\u0030\u0031");case "\u006d\u006d\u006d":_bef =_cfe .AppendFormat (_bef ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_bef =_cfe .AppendFormat (_bef ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _cfe .Month (){case _e .January ,_e .July ,_e .June :_bef =append (_bef ,'J');case _e .February :_bef =append (_bef ,'M');case _e .March ,_e .May :_bef =append (_bef ,'M');case _e .April ,_e .August :_bef =append (_bef ,'A');case _e .September :_bef =append (_bef ,'S');case _e .October :_bef =append (_bef ,'O');case _e .November :_bef =append (_bef ,'N');case _e .December :_bef =append (_bef ,'D');};case "\u0064":_bef =_cfe .AppendFormat (_bef ,"\u0032");case "\u0064\u0064":_bef =_cfe .AppendFormat (_bef ,"\u0030\u0032");case "\u0064\u0064\u0064":_bef =_cfe .AppendFormat (_bef ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_bef =_cfe .AppendFormat (_bef ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_cd .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_eea );};if _bgg [_acg ]=='/'{_bef =append (_bef ,'/');};};return _bef ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};const _cdcbc int =-1;const _ega int =0;func _beb (_fda []byte )[]byte {for _bafc :=len (_fda )-1;_bafc > 0;_bafc --{if _fda [_bafc ]=='9'+1{_fda [_bafc ]='0';if _fda [_bafc -1]=='.'{_bafc --;};_fda [_bafc -1]++;};};if _fda [0]=='9'+1{_fda [0]='0';copy (_fda [1:],_fda [0:]);_fda [0]='1';};return _fda ;};func _cdgg (_ff float64 ,_ggc Format ,_ac bool )string {if _ggc ._df {return NumberGeneric (_ff );};_fd :=make ([]byte ,0,20);_da :=_g .Signbit (_ff );_bb :=_g .Abs (_ff );_gd :=int64 (0);_dcf :=int64 (0);if _ggc .IsExponential {for _bb >=10{_dcf ++;_bb /=10;};for _bb < 1{_dcf --;_bb *=10;};}else if _ggc ._cdg {_bb *=100;}else if _ggc ._b {if _ggc ._ef ==0{_fe :=_g .Pow (10,float64 (_ggc ._ca ));_eda ,_eef :=1.0,1.0;_ =_eda ;for _fec :=1.0;_fec < _fe ;_fec ++{_ ,_eg :=_g .Modf (_bb *float64 (_fec ));if _eg < _eef {_eef =_eg ;_eda =_fec ;if _eg ==0{break ;};};};_ggc ._ef =int64 (_eda );};_gd =int64 (_bb *float64 (_ggc ._ef )+0.5);if len (_ggc .Whole )> 0&&_gd > _ggc ._ef {_gd =int64 (_bb *float64 (_ggc ._ef ))%_ggc ._ef ;_bb -=float64 (_gd )/float64 (_ggc ._ef );}else {_bb -=float64 (_gd )/float64 (_ggc ._ef );if _g .Abs (_bb )< 1{_ggf :=true ;for _ ,_bbe :=range _ggc .Whole {if _bbe .Type ==FmtTypeDigitOpt {continue ;};if _bbe .Type ==FmtTypeLiteral &&_bbe .Literal ==' '{continue ;};_ggf =false ;};if _ggf {_ggc .Whole =nil ;};};};};_cg :=1;for _ ,_gc :=range _ggc .Fractional {if _gc .Type ==FmtTypeDigit ||_gc .Type ==FmtTypeDigitOpt {_cg ++;};};_bb +=5*_g .Pow10 (-_cg );_gcg ,_gde :=_g .Modf (_bb );_fd =append (_fd ,_bfb (_gcg ,_ff ,_ggc )...);_fd =append (_fd ,_eeg (_gde ,_ff ,_ggc )...);_fd =append (_fd ,_gf (_dcf ,_ggc )...);if _ggc ._b {_fd =_db .AppendInt (_fd ,_gd ,10);_fd =append (_fd ,'/');_fd =_db .AppendInt (_fd ,_ggc ._ef ,10);};if !_ac &&_da {return "\u002d"+string (_fd );};return string (_fd );};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func (_dbc *Lexer )Lex (r _d .Reader ){_gda ,_bab ,_dcb :=0,0,0;_fecf :=-1;_cfg ,_ggb ,_cbb :=0,0,0;_ =_ggb ;_ =_cbb ;_ebb :=1;_ =_ebb ;_cgc :=make ([]byte ,4096);_dcaa :=false ;for !_dcaa {_bag :=0;if _cfg > 0{_bag =_bab -_cfg ;};_bab =0;_gad ,_bfbb :=r .Read (_cgc [_bag :]);if _gad ==0||_bfbb !=nil {_dcaa =true ;};_dcb =_gad +_bag ;if _dcb < len (_cgc ){_fecf =_dcb ;};{_gda =_gdd ;_cfg =0;_ggb =0;_cbb =0;};{if _bab ==_dcb {goto _gdeg ;};switch _gda {case 34:goto _bgff ;case 35:goto _cfc ;case 0:goto _beec ;case 36:goto _bda ;case 37:goto _egg ;case 1:goto _aba ;case 2:goto _ceae ;case 38:goto _bfg ;case 3:goto _dee ;case 4:goto _dbgg ;case 39:goto _faeb ;case 5:goto _dec ;case 6:goto _bade ;case 7:goto _bae ;case 8:goto _gae ;case 40:goto _fee ;case 9:goto _bfa ;case 41:goto _fge ;case 10:goto _gbga ;case 42:goto _adca ;case 11:goto _eag ;case 43:goto _abba ;case 44:goto _egaf ;case 45:goto _bdeg ;case 12:goto _dfef ;case 46:goto _aaeb ;case 13:goto _eaea ;case 14:goto _bbf ;case 15:goto _ecc ;case 16:goto _acb ;case 47:goto _ceg ;case 17:goto _dga ;case 48:goto _gfg ;case 18:goto _gbb ;case 19:goto _bgb ;case 20:goto _cag ;case 49:goto _bbb ;case 50:goto _ffaa ;case 21:goto _aeeg ;case 22:goto _fab ;case 23:goto _gedf ;case 24:goto _fdbf ;case 25:goto _acbc ;case 51:goto _dacd ;case 26:goto _adcc ;case 52:goto _aga ;case 53:goto _ccee ;case 54:goto _afa ;case 55:goto _fefd ;case 56:goto _bdef ;case 57:goto _beeb ;case 27:goto _gcge ;case 28:goto _gac ;case 29:goto _ade ;case 30:goto _ebaga ;case 31:goto _aea ;case 58:goto _gdec ;case 32:goto _beba ;case 59:goto _caf ;case 33:goto _cdea ;case 60:goto _daf ;case 61:goto _adcd ;case 62:goto _acga ;};goto _aceb ;_gada :switch _cbb {case 2:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeDigit ,nil );};case 3:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_bab =(_ggb )-1;};case 8:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypePercent ,nil );};case 13:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeFraction ,_cgc [_cfg :_ggb ]);};case 14:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeDate ,_cgc [_cfg :_ggb ]);};case 15:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeTime ,_cgc [_cfg :_ggb ]);};case 16:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeTime ,_cgc [_cfg :_ggb ]);};case 18:{_bab =(_ggb )-1;};case 20:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg :_ggb ]);};case 21:{_bab =(_ggb )-1;_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg +1:_ggb -1]);};};goto _bec ;_cea :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeFraction ,_cgc [_cfg :_ggb ]);};goto _bec ;_fcg :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeDigitOpt ,nil );};goto _bec ;_cbce :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeDigitOptThousands ,nil );};goto _bec ;_bfc :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypePercent ,nil );};goto _bec ;_faee :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeDate ,_cgc [_cfg :_ggb ]);};goto _bec ;_edae :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeDigit ,nil );};goto _bec ;_bdc :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeTime ,_cgc [_cfg :_ggb ]);};goto _bec ;_dgf :_bab =(_ggb )-1;{_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg :_ggb ]);};goto _bec ;_dd :_ggb =_bab +1;{_dbc ._cbc ._df =true ;};goto _bec ;_eceb :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg :_ggb ]);};goto _bec ;_aad :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeDollar ,nil );};goto _bec ;_cda :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeComma ,nil );};goto _bec ;_dcgg :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeDecimal ,nil );};goto _bec ;_dcd :_ggb =_bab +1;{_dbc .nextFmt ();};goto _bec ;_ebcc :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeText ,nil );};goto _bec ;_gbg :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeUnderscore ,nil );};goto _bec ;_bbcg :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg :_ggb ]);};goto _bec ;_daca :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg +1:_ggb -1]);};goto _bec ;_gdcb :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeDigitOpt ,nil );};goto _bec ;_fef :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeFraction ,_cgc [_cfg :_ggb ]);};goto _bec ;_gcgf :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypePercent ,nil );};goto _bec ;_ecg :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeDate ,_cgc [_cfg :_ggb ]);};goto _bec ;_bde :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeDigit ,nil );};goto _bec ;_acd :_ggb =_bab ;_bab --;{_dbc ._cbc .AddToken (FmtTypeTime ,_cgc [_cfg :_ggb ]);};goto _bec ;_edc :_ggb =_bab ;_bab --;{};goto _bec ;_dbgc :_ggb =_bab +1;{_dbc ._cbc .IsExponential =true ;};goto _bec ;_edb :_ggb =_bab +1;{_dbc ._cbc .AddToken (FmtTypeLiteral ,_cgc [_cfg +1:_ggb ]);};goto _bec ;_bec :_cfg =0;if _bab ++;_bab ==_dcb {goto _acbg ;};_bgff :_cfg =_bab ;switch _cgc [_bab ]{case 34:goto _ebf ;case 35:goto _aaeg ;case 36:goto _aad ;case 37:goto _agbg ;case 44:goto _cda ;case 46:goto _dcgg ;case 47:goto _eggc ;case 48:goto _fbc ;case 58:goto _gbgf ;case 59:goto _dcd ;case 63:goto _eaf ;case 64:goto _ebcc ;case 65:goto _aag ;case 69:goto _agggc ;case 71:goto _aab ;case 91:goto _bcef ;case 92:goto _edfe ;case 95:goto _gbg ;case 100:goto _eggc ;case 104:goto _gbgf ;case 109:goto _bcea ;case 115:goto _fba ;case 121:goto _gee ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfa ;};goto _eceb ;_ebf :_ggb =_bab +1;_cbb =20;goto _gdcf ;_gdcf :if _bab ++;_bab ==_dcb {goto _ecbb ;};_cfc :if _cgc [_bab ]==34{goto _ddg ;};goto _aaaf ;_aaaf :if _bab ++;_bab ==_dcb {goto _beea ;};_beec :if _cgc [_bab ]==34{goto _ddg ;};goto _aaaf ;_ddg :_ggb =_bab +1;_cbb =21;goto _gcb ;_gcb :if _bab ++;_bab ==_dcb {goto _gacc ;};_bda :if _cgc [_bab ]==34{goto _aaaf ;};goto _daca ;_aaeg :_ggb =_bab +1;_cbb =3;goto _adf ;_adf :if _bab ++;_bab ==_dcb {goto _fbcd ;};_egg :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _acc ;case 44:goto _dad ;case 47:goto _bcab ;case 48:goto _acc ;case 63:goto _acc ;};goto _gdcb ;_acc :if _bab ++;_bab ==_dcb {goto _ceaa ;};_aba :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _acc ;case 47:goto _bcab ;case 48:goto _acc ;case 63:goto _acc ;};goto _gada ;_bcab :if _bab ++;_bab ==_dcb {goto _ggfc ;};_ceae :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _cbbb ;case 48:goto _fgbe ;case 63:goto _dcfb ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _dage ;};goto _gada ;_dcfb :_ggb =_bab +1;goto _dgd ;_dgd :if _bab ++;_bab ==_dcb {goto _cdbg ;};_bfg :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _dcfb ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _dcfb ;case 63:goto _dcfb ;case 65:goto _faef ;};goto _fef ;_faef :if _bab ++;_bab ==_dcb {goto _dgbd ;};_dee :switch _cgc [_bab ]{case 47:goto _cbf ;case 77:goto _cfef ;};goto _cea ;_cbf :if _bab ++;_bab ==_dcb {goto _acbcc ;};_dbgg :if _cgc [_bab ]==80{goto _adfa ;};goto _cea ;_adfa :_ggb =_bab +1;goto _agba ;_agba :if _bab ++;_bab ==_dcb {goto _efd ;};_faeb :if _cgc [_bab ]==65{goto _faef ;};goto _fef ;_cfef :if _bab ++;_bab ==_dcb {goto _cgbe ;};_dec :if _cgc [_bab ]==47{goto _eeba ;};goto _cea ;_eeba :if _bab ++;_bab ==_dcb {goto _fgde ;};_bade :if _cgc [_bab ]==80{goto _ecd ;};goto _cea ;_ecd :if _bab ++;_bab ==_dcb {goto _aac ;};_bae :if _cgc [_bab ]==77{goto _adfa ;};goto _cea ;_cbbb :if _bab ++;_bab ==_dcb {goto _aaba ;};_gae :switch _cgc [_bab ]{case 35:goto _bfd ;case 37:goto _fgb ;case 63:goto _bfd ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfc ;};goto _gada ;_bfd :_ggb =_bab +1;goto _caa ;_caa :if _bab ++;_bab ==_dcb {goto _cffb ;};_fee :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _cgb ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _dcfb ;case 63:goto _dcfb ;case 65:goto _faef ;};goto _fef ;_cgb :if _bab ++;_bab ==_dcb {goto _faff ;};_bfa :switch _cgc [_bab ]{case 35:goto _dae ;case 44:goto _dae ;case 46:goto _dae ;case 48:goto _dae ;case 63:goto _dae ;};goto _cea ;_dae :_ggb =_bab +1;goto _gbgc ;_gbgc :if _bab ++;_bab ==_dcb {goto _cdeac ;};_fge :switch _cgc [_bab ]{case 35:goto _dae ;case 44:goto _dae ;case 46:goto _dae ;case 48:goto _dae ;case 63:goto _dae ;case 65:goto _faef ;};goto _fef ;_fgb :if _bab ++;_bab ==_dcb {goto _abad ;};_gbga :if _cgc [_bab ]==37{goto _fgb ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfc ;};goto _gada ;_gfc :_ggb =_bab +1;_cbb =13;goto _adc ;_adc :if _bab ++;_bab ==_dcb {goto _gec ;};_adca :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _ace ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _bbeb ;case 63:goto _dcfb ;case 65:goto _faef ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfc ;};goto _fef ;_ace :if _bab ++;_bab ==_dcb {goto _befg ;};_eag :switch _cgc [_bab ]{case 35:goto _dae ;case 37:goto _fgb ;case 44:goto _dae ;case 46:goto _dae ;case 63:goto _dae ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfc ;};goto _cea ;_bbeb :_ggb =_bab +1;goto _edee ;_edee :if _bab ++;_bab ==_dcb {goto _bggg ;};_abba :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _bbeb ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _bbeb ;case 63:goto _dcfb ;case 65:goto _faef ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gfc ;};goto _fef ;_fgbe :_ggb =_bab +1;goto _egf ;_egf :if _bab ++;_bab ==_dcb {goto _agbe ;};_egaf :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _bbeb ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _fgbe ;case 63:goto _dcfb ;case 65:goto _faef ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _dage ;};goto _fef ;_dage :_ggb =_bab +1;goto _dbb ;_dbb :if _bab ++;_bab ==_dcb {goto _cad ;};_bdeg :switch _cgc [_bab ]{case 35:goto _dcfb ;case 37:goto _gfc ;case 44:goto _dcfb ;case 46:goto _dcfb ;case 48:goto _fgbe ;case 63:goto _dcfb ;case 65:goto _faef ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _dage ;};goto _fef ;_dad :if _bab ++;_bab ==_dcb {goto _bbd ;};_dfef :if _cgc [_bab ]==35{goto _cbce ;};goto _fcg ;_agbg :_ggb =_bab +1;_cbb =8;goto _accf ;_accf :if _bab ++;_bab ==_dcb {goto _egb ;};_aaeb :switch _cgc [_bab ]{case 35:goto _dba ;case 37:goto _gbd ;case 48:goto _efe ;case 63:goto _dba ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadf ;};goto _gcgf ;_dba :if _bab ++;_bab ==_dcb {goto _aca ;};_eaea :switch _cgc [_bab ]{case 35:goto _dba ;case 47:goto _bcab ;case 48:goto _dba ;case 63:goto _dba ;};goto _bfc ;_gbd :if _bab ++;_bab ==_dcb {goto _ddd ;};_bbf :if _cgc [_bab ]==37{goto _gbd ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadf ;};goto _gada ;_gadf :if _bab ++;_bab ==_dcb {goto _gbgcc ;};_ecc :switch _cgc [_bab ]{case 37:goto _gbd ;case 47:goto _bcab ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadf ;};goto _gada ;_efe :if _bab ++;_bab ==_dcb {goto _fff ;};_acb :switch _cgc [_bab ]{case 35:goto _dba ;case 37:goto _gbd ;case 47:goto _bcab ;case 48:goto _efe ;case 63:goto _dba ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadf ;};goto _bfc ;_eggc :_ggb =_bab +1;goto _bdca ;_bdca :if _bab ++;_bab ==_dcb {goto _gba ;};_ceg :switch _cgc [_bab ]{case 47:goto _eggc ;case 100:goto _eggc ;case 109:goto _eggc ;case 121:goto _egac ;};goto _ecg ;_egac :if _bab ++;_bab ==_dcb {goto _dgdc ;};_dga :if _cgc [_bab ]==121{goto _eggc ;};goto _faee ;_fbc :_ggb =_bab +1;_cbb =2;goto _fbf ;_fbf :if _bab ++;_bab ==_dcb {goto _ddf ;};_gfg :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _agbb ;case 47:goto _bcab ;case 48:goto _dbce ;case 63:goto _acc ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadd ;};goto _bde ;_agbb :if _bab ++;_bab ==_dcb {goto _ecda ;};_gbb :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _agbb ;case 47:goto _bcab ;case 48:goto _agbb ;case 63:goto _acc ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadf ;};goto _edae ;_dbce :if _bab ++;_bab ==_dcb {goto _gfgb ;};_bgb :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _agbb ;case 47:goto _bcab ;case 48:goto _dbce ;case 63:goto _acc ;};if 49<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadd ;};goto _edae ;_gadd :if _bab ++;_bab ==_dcb {goto _dcfbc ;};_cag :switch _cgc [_bab ]{case 37:goto _gadf ;case 47:goto _bcab ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadd ;};goto _gada ;_gfa :_ggb =_bab +1;_cbb =20;goto _bdb ;_bdb :if _bab ++;_bab ==_dcb {goto _afe ;};_bbb :switch _cgc [_bab ]{case 37:goto _gadf ;case 47:goto _bcab ;};if 48<=_cgc [_bab ]&&_cgc [_bab ]<=57{goto _gadd ;};goto _bbcg ;_gbgf :_ggb =_bab +1;_cbb =15;goto _eec ;_eec :if _bab ++;_bab ==_dcb {goto _edcc ;};_ffaa :switch _cgc [_bab ]{case 58:goto _gbgf ;case 65:goto _fea ;case 104:goto _gbgf ;case 109:goto _gbgf ;case 115:goto _fba ;};goto _acd ;_fea :if _bab ++;_bab ==_dcb {goto _edfac ;};_aeeg :switch _cgc [_bab ]{case 47:goto _cgg ;case 77:goto _bcf ;};goto _gada ;_cgg :if _bab ++;_bab ==_dcb {goto _dcdd ;};_fab :if _cgc [_bab ]==80{goto _gbgf ;};goto _gada ;_bcf :if _bab ++;_bab ==_dcb {goto _dbe ;};_gedf :if _cgc [_bab ]==47{goto _afbg ;};goto _gada ;_afbg :if _bab ++;_bab ==_dcb {goto _edcf ;};_fdbf :if _cgc [_bab ]==80{goto _dadd ;};goto _gada ;_dadd :if _bab ++;_bab ==_dcb {goto _ffc ;};_acbc :if _cgc [_bab ]==77{goto _gbgf ;};goto _gada ;_fba :_ggb =_bab +1;_cbb =15;goto _dbdc ;_dbdc :if _bab ++;_bab ==_dcb {goto _decd ;};_dacd :switch _cgc [_bab ]{case 46:goto _agga ;case 58:goto _gbgf ;case 65:goto _fea ;case 104:goto _gbgf ;case 109:goto _gbgf ;case 115:goto _fba ;};goto _acd ;_agga :if _bab ++;_bab ==_dcb {goto _abe ;};_adcc :if _cgc [_bab ]==48{goto _ddgf ;};goto _bdc ;_ddgf :_ggb =_bab +1;_cbb =15;goto _gedg ;_gedg :if _bab ++;_bab ==_dcb {goto _def ;};_aga :switch _cgc [_bab ]{case 48:goto _dffg ;case 58:goto _gbgf ;case 65:goto _fea ;case 104:goto _gbgf ;case 109:goto _gbgf ;case 115:goto _fba ;};goto _acd ;_dffg :_ggb =_bab +1;_cbb =15;goto _aafdb ;_aafdb :if _bab ++;_bab ==_dcb {goto _edccd ;};_ccee :switch _cgc [_bab ]{case 48:goto _gbgf ;case 58:goto _gbgf ;case 65:goto _fea ;case 104:goto _gbgf ;case 109:goto _gbgf ;case 115:goto _fba ;};goto _acd ;_eaf :_ggb =_bab +1;_cbb =5;goto _ebag ;_ebag :if _bab ++;_bab ==_dcb {goto _ddc ;};_afa :switch _cgc [_bab ]{case 35:goto _acc ;case 37:goto _acc ;case 47:goto _bcab ;case 48:goto _acc ;case 63:goto _acc ;};goto _edc ;_aag :_ggb =_bab +1;_cbb =20;goto _cggb ;_cggb :if _bab ++;_bab ==_dcb {goto _befb ;};_fefd :switch _cgc [_bab ]{case 47:goto _cgg ;case 77:goto _bcf ;};goto _bbcg ;_agggc :if _bab ++;_bab ==_dcb {goto _afea ;};_bdef :switch _cgc [_bab ]{case 43:goto _dbgc ;case 45:goto _dbgc ;};goto _bbcg ;_aab :_ggb =_bab +1;goto _afdd ;_afdd :if _bab ++;_bab ==_dcb {goto _bff ;};_beeb :if _cgc [_bab ]==101{goto _edbg ;};goto _bbcg ;_edbg :if _bab ++;_bab ==_dcb {goto _afc ;};_gcge :if _cgc [_bab ]==110{goto _bfe ;};goto _dgf ;_bfe :if _bab ++;_bab ==_dcb {goto _aafg ;};_gac :if _cgc [_bab ]==101{goto _cced ;};goto _dgf ;_cced :if _bab ++;_bab ==_dcb {goto _gfgd ;};_ade :if _cgc [_bab ]==114{goto _eefb ;};goto _dgf ;_eefb :if _bab ++;_bab ==_dcb {goto _defe ;};_ebaga :if _cgc [_bab ]==97{goto _cgd ;};goto _dgf ;_cgd :if _bab ++;_bab ==_dcb {goto _bdce ;};_aea :if _cgc [_bab ]==108{goto _dd ;};goto _dgf ;_bcef :_ggb =_bab +1;_cbb =20;goto _cggd ;_cggd :if _bab ++;_bab ==_dcb {goto _ccbe ;};_gdec :switch _cgc [_bab ]{case 104:goto _ecce ;case 109:goto _ecce ;case 115:goto _ecce ;};goto _bbef ;_bbef :if _bab ++;_bab ==_dcb {goto _eaeac ;};_beba :if _cgc [_bab ]==93{goto _gedc ;};goto _bbef ;_gedc :_ggb =_bab +1;_cbb =18;goto _ebeb ;_bbfb :_ggb =_bab +1;_cbb =16;goto _ebeb ;_ebeb :if _bab ++;_bab ==_dcb {goto _cfa ;};_caf :if _cgc [_bab ]==93{goto _gedc ;};goto _bbef ;_ecce :if _bab ++;_bab ==_dcb {goto _ecca ;};_cdea :if _cgc [_bab ]==93{goto _bbfb ;};goto _bbef ;_edfe :if _bab ++;_bab ==_dcb {goto _fagd ;};_daf :goto _edb ;_bcea :_ggb =_bab +1;_cbb =14;goto _gffd ;_gffd :if _bab ++;_bab ==_dcb {goto _abf ;};_adcd :switch _cgc [_bab ]{case 47:goto _eggc ;case 58:goto _gbgf ;case 65:goto _fea ;case 100:goto _eggc ;case 104:goto _gbgf ;case 109:goto _bcea ;case 115:goto _fba ;case 121:goto _egac ;};goto _ecg ;_gee :if _bab ++;_bab ==_dcb {goto _eage ;};_acga :if _cgc [_bab ]==121{goto _eggc ;};goto _bbcg ;_aceb :_acbg :_gda =34;goto _gdeg ;_ecbb :_gda =35;goto _gdeg ;_beea :_gda =0;goto _gdeg ;_gacc :_gda =36;goto _gdeg ;_fbcd :_gda =37;goto _gdeg ;_ceaa :_gda =1;goto _gdeg ;_ggfc :_gda =2;goto _gdeg ;_cdbg :_gda =38;goto _gdeg ;_dgbd :_gda =3;goto _gdeg ;_acbcc :_gda =4;goto _gdeg ;_efd :_gda =39;goto _gdeg ;_cgbe :_gda =5;goto _gdeg ;_fgde :_gda =6;goto _gdeg ;_aac :_gda =7;goto _gdeg ;_aaba :_gda =8;goto _gdeg ;_cffb :_gda =40;goto _gdeg ;_faff :_gda =9;goto _gdeg ;_cdeac :_gda =41;goto _gdeg ;_abad :_gda =10;goto _gdeg ;_gec :_gda =42;goto _gdeg ;_befg :_gda =11;goto _gdeg ;_bggg :_gda =43;goto _gdeg ;_agbe :_gda =44;goto _gdeg ;_cad :_gda =45;goto _gdeg ;_bbd :_gda =12;goto _gdeg ;_egb :_gda =46;goto _gdeg ;_aca :_gda =13;goto _gdeg ;_ddd :_gda =14;goto _gdeg ;_gbgcc :_gda =15;goto _gdeg ;_fff :_gda =16;goto _gdeg ;_gba :_gda =47;goto _gdeg ;_dgdc :_gda =17;goto _gdeg ;_ddf :_gda =48;goto _gdeg ;_ecda :_gda =18;goto _gdeg ;_gfgb :_gda =19;goto _gdeg ;_dcfbc :_gda =20;goto _gdeg ;_afe :_gda =49;goto _gdeg ;_edcc :_gda =50;goto _gdeg ;_edfac :_gda =21;goto _gdeg ;_dcdd :_gda =22;goto _gdeg ;_dbe :_gda =23;goto _gdeg ;_edcf :_gda =24;goto _gdeg ;_ffc :_gda =25;goto _gdeg ;_decd :_gda =51;goto _gdeg ;_abe :_gda =26;goto _gdeg ;_def :_gda =52;goto _gdeg ;_edccd :_gda =53;goto _gdeg ;_ddc :_gda =54;goto _gdeg ;_befb :_gda =55;goto _gdeg ;_afea :_gda =56;goto _gdeg ;_bff :_gda =57;goto _gdeg ;_afc :_gda =27;goto _gdeg ;_aafg :_gda =28;goto _gdeg ;_gfgd :_gda =29;goto _gdeg ;_defe :_gda =30;goto _gdeg ;_bdce :_gda =31;goto _gdeg ;_ccbe :_gda =58;goto _gdeg ;_eaeac :_gda =32;goto _gdeg ;_cfa :_gda =59;goto _gdeg ;_ecca :_gda =33;goto _gdeg ;_fagd :_gda =60;goto _gdeg ;_abf :_gda =61;goto _gdeg ;_eage :_gda =62;goto _gdeg ;_gdeg :{};if _bab ==_fecf {switch _gda {case 35:goto _bbcg ;case 0:goto _gada ;case 36:goto _daca ;case 37:goto _gdcb ;case 1:goto _gada ;case 2:goto _gada ;case 38:goto _fef ;case 3:goto _cea ;case 4:goto _cea ;case 39:goto _fef ;case 5:goto _cea ;case 6:goto _cea ;case 7:goto _cea ;case 8:goto _gada ;case 40:goto _fef ;case 9:goto _cea ;case 41:goto _fef ;case 10:goto _gada ;case 42:goto _fef ;case 11:goto _cea ;case 43:goto _fef ;case 44:goto _fef ;case 45:goto _fef ;case 12:goto _fcg ;case 46:goto _gcgf ;case 13:goto _bfc ;case 14:goto _gada ;case 15:goto _gada ;case 16:goto _bfc ;case 47:goto _ecg ;case 17:goto _faee ;case 48:goto _bde ;case 18:goto _edae ;case 19:goto _edae ;case 20:goto _gada ;case 49:goto _bbcg ;case 50:goto _acd ;case 21:goto _gada ;case 22:goto _gada ;case 23:goto _gada ;case 24:goto _gada ;case 25:goto _gada ;case 51:goto _acd ;case 26:goto _bdc ;case 52:goto _acd ;case 53:goto _acd ;case 54:goto _edc ;case 55:goto _bbcg ;case 56:goto _bbcg ;case 57:goto _bbcg ;case 27:goto _dgf ;case 28:goto _dgf ;case 29:goto _dgf ;case 30:goto _dgf ;case 31:goto _dgf ;case 58:goto _bbcg ;case 32:goto _gada ;case 59:goto _gada ;case 33:goto _dgf ;case 60:goto _bbcg ;case 61:goto _ecg ;case 62:goto _bbcg ;};};};if _cfg > 0{copy (_cgc [0:],_cgc [_cfg :]);};};_ =_fecf ;if _gda ==_abb {_cd .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func (_dg FmtType )String ()string {if _dg >=FmtType (len (_ga )-1){return _c .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_dg );};return _cc [_ga [_dg ]:_ga [_dg +1]];};func Parse (s string )[]Format {_dfc :=Lexer {};_dfc .Lex (_f .NewReader (s ));_dfc ._dca =append (_dfc ._dca ,_dfc ._cbc );return _dfc ._dca ;};const _cebg int =34;const _gff int =0;