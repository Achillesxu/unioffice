//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_ef "bytes";_f "fmt";_cc "github.com/unidoc/unioffice/common/logger";_g "io";_d "math";_a "strconv";_c "strings";_ff "time";);func _cef (_aaa _ff .Time ,_dbcf float64 ,_dfg string )[]byte {_faf :=[]byte {};_ged :=0;for _fafa :=0;_fafa < len (_dfg );_fafa ++{var _aga string ;if _dfg [_fafa ]==':'{_aga =string (_dfg [_ged :_fafa ]);_ged =_fafa +1;}else if _fafa ==len (_dfg )-1{_aga =string (_dfg [_ged :_fafa +1]);}else {continue ;};switch _aga {case "\u0064":_faf =_aaa .AppendFormat (_faf ,"\u0032");case "\u0068":_faf =_aaa .AppendFormat (_faf ,"\u0033");case "\u0068\u0068":_faf =_aaa .AppendFormat (_faf ,"\u0031\u0035");case "\u006d":_faf =_aaa .AppendFormat (_faf ,"\u0034");case "\u006d\u006d":_faf =_aaa .AppendFormat (_faf ,"\u0030\u0034");case "\u0073":_faf =_aaa .Round (_ff .Second ).AppendFormat (_faf ,"\u0035");case "\u0073\u002e\u0030":_faf =_aaa .Round (_ff .Second /10).AppendFormat (_faf ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_faf =_aaa .Round (_ff .Second /100).AppendFormat (_faf ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_faf =_aaa .Round (_ff .Second /1000).AppendFormat (_faf ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_faf =_aaa .Round (_ff .Second ).AppendFormat (_faf ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_faf =_aaa .Round (_ff .Second /10).AppendFormat (_faf ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_faf =_aaa .Round (_ff .Second /100).AppendFormat (_faf ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_faf =_aaa .Round (_ff .Second /1000).AppendFormat (_faf ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_faf =_aaa .AppendFormat (_faf ,"\u0050\u004d");case "\u005b\u0068\u005d":_faf =_a .AppendInt (_faf ,int64 (_dbcf *24),10);case "\u005b\u006d\u005d":_faf =_a .AppendInt (_faf ,int64 (_dbcf *24*60),10);case "\u005b\u0073\u005d":_faf =_a .AppendInt (_faf ,int64 (_dbcf *24*60*60),10);case "":default:_cc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_aga );};if _dfg [_fafa ]==':'{_faf =append (_faf ,':');};};return _faf ;};func _ce (_dbc ,_bd float64 ,_ggf Format )[]byte {if len (_ggf .Fractional )==0{return nil ;};_ge :=_a .AppendFloat (nil ,_dbc ,'f',-1,64);if len (_ge )> 2{_ge =_ge [2:];}else {_ge =nil ;};_caf :=make ([]byte ,0,len (_ge ));_caf =append (_caf ,'.');_edb :=0;_aec :for _abgg :=0;_abgg < len (_ggf .Fractional );_abgg ++{_cacd :=_abgg ;_cda :=_ggf .Fractional [_abgg ];switch _cda .Type {case FmtTypeDigit :if _cacd < len (_ge ){_caf =append (_caf ,_ge [_cacd ]);_edb ++;}else {_caf =append (_caf ,'0');};case FmtTypeDigitOpt :if _cacd >=0{_caf =append (_caf ,_ge [_cacd ]);_edb ++;}else {break _aec ;};case FmtTypeLiteral :_caf =append (_caf ,_cda .Literal );default:_cc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_cda );};};return _caf ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_df bool ;_bc bool ;_cd bool ;_aba bool ;_gg bool ;_bca bool ;_gd int64 ;_cg int ;};func _fg (_gdg float64 ,_cgb Format ,_ga bool )string {if _cgb ._cd {return NumberGeneric (_gdg );};_fb :=make ([]byte ,0,20);_de :=_d .Signbit (_gdg );_aad :=_d .Abs (_gdg );_ace :=int64 (0);_ae :=int64 (0);if _cgb .IsExponential {for _aad >=10{_ae ++;_aad /=10;};for _aad < 1{_ae --;_aad *=10;};}else if _cgb ._bc {_aad *=100;}else if _cgb ._df {if _cgb ._gd ==0{_ee :=_d .Pow (10,float64 (_cgb ._cg ));_cce ,_abc :=1.0,1.0;_ =_cce ;for _bb :=1.0;_bb < _ee ;_bb ++{_ ,_ed :=_d .Modf (_aad *float64 (_bb ));if _ed < _abc {_abc =_ed ;_cce =_bb ;if _ed ==0{break ;};};};_cgb ._gd =int64 (_cce );};_ace =int64 (_aad *float64 (_cgb ._gd )+0.5);if len (_cgb .Whole )> 0&&_ace > _cgb ._gd {_ace =int64 (_aad *float64 (_cgb ._gd ))%_cgb ._gd ;_aad -=float64 (_ace )/float64 (_cgb ._gd );}else {_aad -=float64 (_ace )/float64 (_cgb ._gd );if _d .Abs (_aad )< 1{_ede :=true ;for _ ,_eb :=range _cgb .Whole {if _eb .Type ==FmtTypeDigitOpt {continue ;};if _eb .Type ==FmtTypeLiteral &&_eb .Literal ==' '{continue ;};_ede =false ;};if _ede {_cgb .Whole =nil ;};};};};_gaf :=1;for _ ,_cfe :=range _cgb .Fractional {if _cfe .Type ==FmtTypeDigit ||_cfe .Type ==FmtTypeDigitOpt {_gaf ++;};};_aad +=5*_d .Pow10 (-_gaf );_fgf ,_bbc :=_d .Modf (_aad );_fb =append (_fb ,_dba (_fgf ,_gdg ,_cgb )...);_fb =append (_fb ,_ce (_bbc ,_gdg ,_cgb )...);_fb =append (_fb ,_aee (_ae ,_cgb )...);if _cgb ._df {_fb =_a .AppendInt (_fb ,_ace ,10);_fb =append (_fb ,'/');_fb =_a .AppendInt (_fb ,_cgb ._gd ,10);};if !_ga &&_de {return "\u002d"+string (_fb );};return string (_fb );};func _cac (_cga []byte )[]byte {for _fdg :=0;_fdg < len (_cga )/2;_fdg ++{_ac :=len (_cga )-1-_fdg ;_cga [_fdg ],_cga [_ac ]=_cga [_ac ],_cga [_fdg ];};return _cga ;};func _dag (_bfg []byte )[]byte {for _eec :=len (_bfg )-1;_eec > 0;_eec --{if _bfg [_eec ]=='9'+1{_bfg [_eec ]='0';if _bfg [_eec -1]=='.'{_eec --;};_bfg [_eec -1]++;};};if _bfg [0]=='9'+1{_bfg [0]='0';copy (_bfg [1:],_bfg [0:]);_bfg [0]='1';};return _bfg ;};const _ecge int =-1;func _dba (_gf ,_gcf float64 ,_dad Format )[]byte {if len (_dad .Whole )==0{return nil ;};_bcb :=_ff .Date (1899,12,30,0,0,0,0,_ff .UTC );_bcdf :=_bcb .Add (_ff .Duration (_gcf *float64 (24*_ff .Hour )));_bcdf =_cfc (_bcdf );_efd :=_a .AppendFloat (nil ,_gf ,'f',-1,64);_cag :=make ([]byte ,0,len (_efd ));_ecg :=0;_be :=1;_daa :for _fc :=len (_dad .Whole )-1;_fc >=0;_fc --{_eg :=len (_efd )-1-_ecg ;_efa :=_dad .Whole [_fc ];switch _efa .Type {case FmtTypeDigit :if _eg >=0{_cag =append (_cag ,_efd [_eg ]);_ecg ++;_be =_fc ;}else {_cag =append (_cag ,'0');};case FmtTypeDigitOpt :if _eg >=0{_cag =append (_cag ,_efd [_eg ]);_ecg ++;_be =_fc ;}else {for _aceb :=_fc ;_aceb >=0;_aceb --{_cgg :=_dad .Whole [_aceb ];if _cgg .Type ==FmtTypeLiteral {_cag =append (_cag ,_cgg .Literal );};};break _daa ;};case FmtTypeDollar :for _ecf :=_ecg ;_ecf < len (_efd );_ecf ++{_cag =append (_cag ,_efd [len (_efd )-1-_ecf ]);_ecg ++;};_cag =append (_cag ,'$');case FmtTypeComma :if !_dad ._aba {_cag =append (_cag ,',');};case FmtTypeLiteral :_cag =append (_cag ,_efa .Literal );case FmtTypeDate :_cag =append (_cag ,_cac (_cggde (_bcdf ,_efa .DateTime ))...);case FmtTypeTime :_cag =append (_cag ,_cac (_cef (_bcdf ,_gcf ,_efa .DateTime ))...);default:_cc .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_efa );};};_cggd :=_cac (_cag );if _ecg < len (_efd )&&(_ecg !=0||_dad ._bca ){_cb :=len (_efd )-_ecg ;_dga :=make ([]byte ,len (_cggd )+_cb );copy (_dga ,_cggd [0:_be ]);copy (_dga [_be :],_efd [0:]);copy (_dga [_be +_cb :],_cggd [_be :]);_cggd =_dga ;};if _dad ._aba {_ccg :=_ef .Buffer {};_dfe :=0;for _dgae :=len (_cggd )-1;_dgae >=0;_dgae --{if !(_cggd [_dgae ]>='0'&&_cggd [_dgae ]<='9'){_dfe ++;}else {break ;};};for _afg :=0;_afg < len (_cggd );_afg ++{_gdc :=(len (_cggd )-_afg -_dfe );if _gdc %3==0&&_gdc !=0&&_afg !=0{_ccg .WriteByte (',');};_ccg .WriteByte (_cggd [_afg ]);};_cggd =_ccg .Bytes ();};return _cggd ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func Parse (s string )[]Format {_eef :=Lexer {};_eef .Lex (_c .NewReader (s ));_eef ._cff =append (_eef ._cff ,_eef ._ddd );return _eef ._cff ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _d .Abs (v )>=_af ||_d .Abs (v )<=_b &&v !=0{return _ddb (v );};_gaa :=make ([]byte ,0,15);_gaa =_a .AppendFloat (_gaa ,v ,'f',-1,64);if len (_gaa )> 11{_fgb :=_gaa [11]-'0';if _fgb >=5&&_fgb <=9{_gaa [10]++;_gaa =_gaa [0:11];_gaa =_dag (_gaa );};_gaa =_gaa [0:11];}else if len (_gaa )==11{if _gaa [len (_gaa )-1]=='9'{_gaa [len (_gaa )-1]++;_gaa =_dag (_gaa );};};_gaa =_efg (_gaa );return string (_gaa );};var _gb =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};type Lexer struct{_ddd Format ;_cff []Format ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_dd :=Parse (f );if len (_dd )==1{return _fg (v ,_dd [0],false );}else if len (_dd )> 1&&v < 0{return _fg (v ,_dd [1],true );}else if len (_dd )> 2&&v ==0{return _fg (v ,_dd [2],false );};return _fg (v ,_dd [0],false );};func (_ea FmtType )String ()string {if _ea >=FmtType (len (_gb )-1){return _f .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_ea );};return _ab [_gb [_ea ]:_gb [_ea +1]];};const _aece int =0;func _ddb (_fee float64 )string {_feb :=_a .FormatFloat (_fee ,'E',-1,64);_gga :=_a .FormatFloat (_fee ,'E',5,64);if len (_feb )< len (_gga ){return _a .FormatFloat (_fee ,'E',2,64);};return _gga ;};func (_cfd *Lexer )Lex (r _g .Reader ){_cab ,_gad ,_bfb :=0,0,0;_fcd :=-1;_eba ,_abcf ,_bda :=0,0,0;_ =_abcf ;_ =_bda ;_agc :=1;_ =_agc ;_gaac :=make ([]byte ,4096);_dgc :=false ;for !_dgc {_dfge :=0;if _eba > 0{_dfge =_gad -_eba ;};_gad =0;_abdb ,_gedc :=r .Read (_gaac [_dfge :]);if _abdb ==0||_gedc !=nil {_dgc =true ;};_bfb =_abdb +_dfge ;if _bfb < len (_gaac ){_fcd =_bfb ;};{_cab =_eee ;_eba =0;_abcf =0;_bda =0;};{if _gad ==_bfb {goto _geeg ;};switch _cab {case 34:goto _edd ;case 35:goto _fbc ;case 0:goto _bba ;case 36:goto _fdd ;case 37:goto _acc ;case 1:goto _gbe ;case 2:goto _fgg ;case 38:goto _ccde ;case 3:goto _aeeab ;case 4:goto _fed ;case 39:goto _cgba ;case 5:goto _eagc ;case 6:goto _bdd ;case 7:goto _egd ;case 8:goto _cgac ;case 40:goto _faag ;case 9:goto _accf ;case 41:goto _dgg ;case 10:goto _ccc ;case 42:goto _adg ;case 11:goto _eage ;case 43:goto _dfaa ;case 44:goto _ddfd ;case 45:goto _dddc ;case 12:goto _aag ;case 46:goto _egdg ;case 13:goto _fbb ;case 14:goto _eagb ;case 15:goto _efab ;case 16:goto _dbaa ;case 47:goto _feec ;case 17:goto _ddda ;case 48:goto _ecgb ;case 18:goto _bdf ;case 19:goto _gefe ;case 20:goto _gfe ;case 49:goto _bbge ;case 50:goto _dgcb ;case 21:goto _ffa ;case 22:goto _afe ;case 23:goto _beeb ;case 24:goto _gdbb ;case 25:goto _edf ;case 51:goto _abe ;case 26:goto _aae ;case 52:goto _ecdc ;case 53:goto _egda ;case 54:goto _cgbab ;case 55:goto _bfdg ;case 56:goto _dcf ;case 57:goto _gge ;case 27:goto _ebea ;case 28:goto _dff ;case 29:goto _befb ;case 30:goto _gda ;case 31:goto _gfd ;case 58:goto _fgab ;case 32:goto _bdb ;case 59:goto _cccd ;case 33:goto _cdca ;case 60:goto _fgc ;case 61:goto _gcbc ;case 62:goto _ffea ;};goto _dab ;_eeb :switch _bda {case 2:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeDigit ,nil );};case 3:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_gad =(_abcf )-1;};case 8:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypePercent ,nil );};case 13:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeFraction ,_gaac [_eba :_abcf ]);};case 14:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeDate ,_gaac [_eba :_abcf ]);};case 15:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeTime ,_gaac [_eba :_abcf ]);};case 16:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeTime ,_gaac [_eba :_abcf ]);};case 18:{_gad =(_abcf )-1;};case 20:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba :_abcf ]);};case 21:{_gad =(_abcf )-1;_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba +1:_abcf -1]);};};goto _eadg ;_eca :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeFraction ,_gaac [_eba :_abcf ]);};goto _eadg ;_efdd :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeDigitOpt ,nil );};goto _eadg ;_ffe :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeDigitOptThousands ,nil );};goto _eadg ;_ebe :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypePercent ,nil );};goto _eadg ;_cbd :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeDate ,_gaac [_eba :_abcf ]);};goto _eadg ;_cggdeb :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeDigit ,nil );};goto _eadg ;_ffg :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeTime ,_gaac [_eba :_abcf ]);};goto _eadg ;_cbg :_gad =(_abcf )-1;{_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba :_abcf ]);};goto _eadg ;_eab :_abcf =_gad +1;{_cfd ._ddd ._cd =true ;};goto _eadg ;_gadd :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba :_abcf ]);};goto _eadg ;_bbb :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeDollar ,nil );};goto _eadg ;_gaaa :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeComma ,nil );};goto _eadg ;_afc :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeDecimal ,nil );};goto _eadg ;_bcc :_abcf =_gad +1;{_cfd .nextFmt ();};goto _eadg ;_bbg :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeText ,nil );};goto _eadg ;_fdb :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeUnderscore ,nil );};goto _eadg ;_cgbb :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba :_abcf ]);};goto _eadg ;_ggd :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba +1:_abcf -1]);};goto _eadg ;_abacg :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeDigitOpt ,nil );};goto _eadg ;_bbf :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeFraction ,_gaac [_eba :_abcf ]);};goto _eadg ;_dge :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypePercent ,nil );};goto _eadg ;_faa :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeDate ,_gaac [_eba :_abcf ]);};goto _eadg ;_gac :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeDigit ,nil );};goto _eadg ;_ebc :_abcf =_gad ;_gad --;{_cfd ._ddd .AddToken (FmtTypeTime ,_gaac [_eba :_abcf ]);};goto _eadg ;_aaf :_abcf =_gad ;_gad --;{};goto _eadg ;_cad :_abcf =_gad +1;{_cfd ._ddd .IsExponential =true ;};goto _eadg ;_bgc :_abcf =_gad +1;{_cfd ._ddd .AddToken (FmtTypeLiteral ,_gaac [_eba +1:_abcf ]);};goto _eadg ;_eadg :_eba =0;if _gad ++;_gad ==_bfb {goto _caeb ;};_edd :_eba =_gad ;switch _gaac [_gad ]{case 34:goto _ecd ;case 35:goto _gec ;case 36:goto _bbb ;case 37:goto _fdbf ;case 44:goto _gaaa ;case 46:goto _afc ;case 47:goto _beaf ;case 48:goto _cefa ;case 58:goto _abf ;case 59:goto _bcc ;case 63:goto _gebc ;case 64:goto _bbg ;case 65:goto _bbe ;case 69:goto _aef ;case 71:goto _edec ;case 91:goto _bffd ;case 92:goto _fgfg ;case 95:goto _fdb ;case 100:goto _beaf ;case 104:goto _abf ;case 109:goto _fcec ;case 115:goto _fgac ;case 121:goto _gfg ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _bfd ;};goto _gadd ;_ecd :_abcf =_gad +1;_bda =20;goto _gcc ;_gcc :if _gad ++;_gad ==_bfb {goto _ebf ;};_fbc :if _gaac [_gad ]==34{goto _ecgc ;};goto _geee ;_geee :if _gad ++;_gad ==_bfb {goto _fbca ;};_bba :if _gaac [_gad ]==34{goto _ecgc ;};goto _geee ;_ecgc :_abcf =_gad +1;_bda =21;goto _cfb ;_cfb :if _gad ++;_gad ==_bfb {goto _bfc ;};_fdd :if _gaac [_gad ]==34{goto _geee ;};goto _ggd ;_gec :_abcf =_gad +1;_bda =3;goto _ggfb ;_ggfb :if _gad ++;_gad ==_bfb {goto _efef ;};_acc :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _gaaf ;case 44:goto _ccgf ;case 47:goto _geb ;case 48:goto _gaaf ;case 63:goto _gaaf ;};goto _abacg ;_gaaf :if _gad ++;_gad ==_bfb {goto _ggag ;};_gbe :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _gaaf ;case 47:goto _geb ;case 48:goto _gaaf ;case 63:goto _gaaf ;};goto _eeb ;_geb :if _gad ++;_gad ==_bfb {goto _efgce ;};_fgg :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _cabg ;case 48:goto _ddbc ;case 63:goto _edee ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _agg ;};goto _eeb ;_edee :_abcf =_gad +1;goto _cbdd ;_cbdd :if _gad ++;_gad ==_bfb {goto _gdcd ;};_ccde :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _edee ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _edee ;case 63:goto _edee ;case 65:goto _dgd ;};goto _bbf ;_dgd :if _gad ++;_gad ==_bfb {goto _dec ;};_aeeab :switch _gaac [_gad ]{case 47:goto _gcba ;case 77:goto _fea ;};goto _eca ;_gcba :if _gad ++;_gad ==_bfb {goto _aaec ;};_fed :if _gaac [_gad ]==80{goto _eagf ;};goto _eca ;_eagf :_abcf =_gad +1;goto _bdca ;_bdca :if _gad ++;_gad ==_bfb {goto _edbe ;};_cgba :if _gaac [_gad ]==65{goto _dgd ;};goto _bbf ;_fea :if _gad ++;_gad ==_bfb {goto _aab ;};_eagc :if _gaac [_gad ]==47{goto _ceb ;};goto _eca ;_ceb :if _gad ++;_gad ==_bfb {goto _fafg ;};_bdd :if _gaac [_gad ]==80{goto _dfa ;};goto _eca ;_dfa :if _gad ++;_gad ==_bfb {goto _fbbc ;};_egd :if _gaac [_gad ]==77{goto _eagf ;};goto _eca ;_cabg :if _gad ++;_gad ==_bfb {goto _gfga ;};_cgac :switch _gaac [_gad ]{case 35:goto _dgad ;case 37:goto _cbe ;case 63:goto _dgad ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _abab ;};goto _eeb ;_dgad :_abcf =_gad +1;goto _faad ;_faad :if _gad ++;_gad ==_bfb {goto _gcca ;};_faag :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _gbeg ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _edee ;case 63:goto _edee ;case 65:goto _dgd ;};goto _bbf ;_gbeg :if _gad ++;_gad ==_bfb {goto _aff ;};_accf :switch _gaac [_gad ]{case 35:goto _ffd ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _ffd ;case 63:goto _ffd ;};goto _eca ;_ffd :_abcf =_gad +1;goto _fbf ;_fbf :if _gad ++;_gad ==_bfb {goto _afb ;};_dgg :switch _gaac [_gad ]{case 35:goto _ffd ;case 44:goto _ffd ;case 46:goto _ffd ;case 48:goto _ffd ;case 63:goto _ffd ;case 65:goto _dgd ;};goto _bbf ;_cbe :if _gad ++;_gad ==_bfb {goto _bbag ;};_ccc :if _gaac [_gad ]==37{goto _cbe ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _abab ;};goto _eeb ;_abab :_abcf =_gad +1;_bda =13;goto _befd ;_befd :if _gad ++;_gad ==_bfb {goto _age ;};_adg :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _dce ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _aeeg ;case 63:goto _edee ;case 65:goto _dgd ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _abab ;};goto _bbf ;_dce :if _gad ++;_gad ==_bfb {goto _cdf ;};_eage :switch _gaac [_gad ]{case 35:goto _ffd ;case 37:goto _cbe ;case 44:goto _ffd ;case 46:goto _ffd ;case 63:goto _ffd ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _abab ;};goto _eca ;_aeeg :_abcf =_gad +1;goto _gfb ;_gfb :if _gad ++;_gad ==_bfb {goto _gcbac ;};_dfaa :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _aeeg ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _aeeg ;case 63:goto _edee ;case 65:goto _dgd ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _abab ;};goto _bbf ;_ddbc :_abcf =_gad +1;goto _ffga ;_ffga :if _gad ++;_gad ==_bfb {goto _affe ;};_ddfd :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _aeeg ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _ddbc ;case 63:goto _edee ;case 65:goto _dgd ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _agg ;};goto _bbf ;_agg :_abcf =_gad +1;goto _dbf ;_dbf :if _gad ++;_gad ==_bfb {goto _ffb ;};_dddc :switch _gaac [_gad ]{case 35:goto _edee ;case 37:goto _abab ;case 44:goto _edee ;case 46:goto _edee ;case 48:goto _ddbc ;case 63:goto _edee ;case 65:goto _dgd ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _agg ;};goto _bbf ;_ccgf :if _gad ++;_gad ==_bfb {goto _ggdg ;};_aag :if _gaac [_gad ]==35{goto _ffe ;};goto _efdd ;_fdbf :_abcf =_gad +1;_bda =8;goto _gde ;_gde :if _gad ++;_gad ==_bfb {goto _bbgg ;};_egdg :switch _gaac [_gad ]{case 35:goto _bab ;case 37:goto _ccdg ;case 48:goto _cde ;case 63:goto _bab ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _efbb ;};goto _dge ;_bab :if _gad ++;_gad ==_bfb {goto _bad ;};_fbb :switch _gaac [_gad ]{case 35:goto _bab ;case 47:goto _geb ;case 48:goto _bab ;case 63:goto _bab ;};goto _ebe ;_ccdg :if _gad ++;_gad ==_bfb {goto _bfde ;};_eagb :if _gaac [_gad ]==37{goto _ccdg ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _efbb ;};goto _eeb ;_efbb :if _gad ++;_gad ==_bfb {goto _fgfge ;};_efab :switch _gaac [_gad ]{case 37:goto _ccdg ;case 47:goto _geb ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _efbb ;};goto _eeb ;_cde :if _gad ++;_gad ==_bfb {goto _ebg ;};_dbaa :switch _gaac [_gad ]{case 35:goto _bab ;case 37:goto _ccdg ;case 47:goto _geb ;case 48:goto _cde ;case 63:goto _bab ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _efbb ;};goto _ebe ;_beaf :_abcf =_gad +1;goto _ggfe ;_ggfe :if _gad ++;_gad ==_bfb {goto _ecad ;};_feec :switch _gaac [_gad ]{case 47:goto _beaf ;case 100:goto _beaf ;case 109:goto _beaf ;case 121:goto _bbbg ;};goto _faa ;_bbbg :if _gad ++;_gad ==_bfb {goto _fbbcb ;};_ddda :if _gaac [_gad ]==121{goto _beaf ;};goto _cbd ;_cefa :_abcf =_gad +1;_bda =2;goto _bff ;_bff :if _gad ++;_gad ==_bfb {goto _gcg ;};_ecgb :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _efee ;case 47:goto _geb ;case 48:goto _fbcc ;case 63:goto _gaaf ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _egf ;};goto _gac ;_efee :if _gad ++;_gad ==_bfb {goto _gfdd ;};_bdf :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _efee ;case 47:goto _geb ;case 48:goto _efee ;case 63:goto _gaaf ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _efbb ;};goto _cggdeb ;_fbcc :if _gad ++;_gad ==_bfb {goto _bbec ;};_gefe :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _efee ;case 47:goto _geb ;case 48:goto _fbcc ;case 63:goto _gaaf ;};if 49<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _egf ;};goto _cggdeb ;_egf :if _gad ++;_gad ==_bfb {goto _geda ;};_gfe :switch _gaac [_gad ]{case 37:goto _efbb ;case 47:goto _geb ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _egf ;};goto _eeb ;_bfd :_abcf =_gad +1;_bda =20;goto _dca ;_dca :if _gad ++;_gad ==_bfb {goto _gccaf ;};_bbge :switch _gaac [_gad ]{case 37:goto _efbb ;case 47:goto _geb ;};if 48<=_gaac [_gad ]&&_gaac [_gad ]<=57{goto _egf ;};goto _cgbb ;_abf :_abcf =_gad +1;_bda =15;goto _bce ;_bce :if _gad ++;_gad ==_bfb {goto _gbbf ;};_dgcb :switch _gaac [_gad ]{case 58:goto _abf ;case 65:goto _dcaf ;case 104:goto _abf ;case 109:goto _abf ;case 115:goto _fgac ;};goto _ebc ;_dcaf :if _gad ++;_gad ==_bfb {goto _cefab ;};_ffa :switch _gaac [_gad ]{case 47:goto _dbb ;case 77:goto _gdbf ;};goto _eeb ;_dbb :if _gad ++;_gad ==_bfb {goto _beee ;};_afe :if _gaac [_gad ]==80{goto _abf ;};goto _eeb ;_gdbf :if _gad ++;_gad ==_bfb {goto _ddbe ;};_beeb :if _gaac [_gad ]==47{goto _bdfc ;};goto _eeb ;_bdfc :if _gad ++;_gad ==_bfb {goto _cdab ;};_gdbb :if _gaac [_gad ]==80{goto _adc ;};goto _eeb ;_adc :if _gad ++;_gad ==_bfb {goto _caa ;};_edf :if _gaac [_gad ]==77{goto _abf ;};goto _eeb ;_fgac :_abcf =_gad +1;_bda =15;goto _dddf ;_dddf :if _gad ++;_gad ==_bfb {goto _gfdc ;};_abe :switch _gaac [_gad ]{case 46:goto _cbf ;case 58:goto _abf ;case 65:goto _dcaf ;case 104:goto _abf ;case 109:goto _abf ;case 115:goto _fgac ;};goto _ebc ;_cbf :if _gad ++;_gad ==_bfb {goto _ebcb ;};_aae :if _gaac [_gad ]==48{goto _fbg ;};goto _ffg ;_fbg :_abcf =_gad +1;_bda =15;goto _fce ;_fce :if _gad ++;_gad ==_bfb {goto _acbe ;};_ecdc :switch _gaac [_gad ]{case 48:goto _daag ;case 58:goto _abf ;case 65:goto _dcaf ;case 104:goto _abf ;case 109:goto _abf ;case 115:goto _fgac ;};goto _ebc ;_daag :_abcf =_gad +1;_bda =15;goto _egaf ;_egaf :if _gad ++;_gad ==_bfb {goto _badd ;};_egda :switch _gaac [_gad ]{case 48:goto _abf ;case 58:goto _abf ;case 65:goto _dcaf ;case 104:goto _abf ;case 109:goto _abf ;case 115:goto _fgac ;};goto _ebc ;_gebc :_abcf =_gad +1;_bda =5;goto _dcb ;_dcb :if _gad ++;_gad ==_bfb {goto _fab ;};_cgbab :switch _gaac [_gad ]{case 35:goto _gaaf ;case 37:goto _gaaf ;case 47:goto _geb ;case 48:goto _gaaf ;case 63:goto _gaaf ;};goto _aaf ;_bbe :_abcf =_gad +1;_bda =20;goto _afed ;_afed :if _gad ++;_gad ==_bfb {goto _bfdf ;};_bfdg :switch _gaac [_gad ]{case 47:goto _dbb ;case 77:goto _gdbf ;};goto _cgbb ;_aef :if _gad ++;_gad ==_bfb {goto _bbdd ;};_dcf :switch _gaac [_gad ]{case 43:goto _cad ;case 45:goto _cad ;};goto _cgbb ;_edec :_abcf =_gad +1;goto _dbbf ;_dbbf :if _gad ++;_gad ==_bfb {goto _febb ;};_gge :if _gaac [_gad ]==101{goto _bgba ;};goto _cgbb ;_bgba :if _gad ++;_gad ==_bfb {goto _dgf ;};_ebea :if _gaac [_gad ]==110{goto _beca ;};goto _cbg ;_beca :if _gad ++;_gad ==_bfb {goto _caaa ;};_dff :if _gaac [_gad ]==101{goto _eda ;};goto _cbg ;_eda :if _gad ++;_gad ==_bfb {goto _dcafd ;};_befb :if _gaac [_gad ]==114{goto _gfea ;};goto _cbg ;_gfea :if _gad ++;_gad ==_bfb {goto _dadc ;};_gda :if _gaac [_gad ]==97{goto _agf ;};goto _cbg ;_agf :if _gad ++;_gad ==_bfb {goto _cdg ;};_gfd :if _gaac [_gad ]==108{goto _eab ;};goto _cbg ;_bffd :_abcf =_gad +1;_bda =20;goto _efaa ;_efaa :if _gad ++;_gad ==_bfb {goto _acga ;};_fgab :switch _gaac [_gad ]{case 104:goto _eeca ;case 109:goto _eeca ;case 115:goto _eeca ;};goto _eabf ;_eabf :if _gad ++;_gad ==_bfb {goto _eae ;};_bdb :if _gaac [_gad ]==93{goto _egdc ;};goto _eabf ;_egdc :_abcf =_gad +1;_bda =18;goto _gaae ;_fge :_abcf =_gad +1;_bda =16;goto _gaae ;_gaae :if _gad ++;_gad ==_bfb {goto _cgd ;};_cccd :if _gaac [_gad ]==93{goto _egdc ;};goto _eabf ;_eeca :if _gad ++;_gad ==_bfb {goto _ebcd ;};_cdca :if _gaac [_gad ]==93{goto _fge ;};goto _eabf ;_fgfg :if _gad ++;_gad ==_bfb {goto _aecc ;};_fgc :goto _bgc ;_fcec :_abcf =_gad +1;_bda =14;goto _cbga ;_cbga :if _gad ++;_gad ==_bfb {goto _bed ;};_gcbc :switch _gaac [_gad ]{case 47:goto _beaf ;case 58:goto _abf ;case 65:goto _dcaf ;case 100:goto _beaf ;case 104:goto _abf ;case 109:goto _fcec ;case 115:goto _fgac ;case 121:goto _bbbg ;};goto _faa ;_gfg :if _gad ++;_gad ==_bfb {goto _cbbf ;};_ffea :if _gaac [_gad ]==121{goto _beaf ;};goto _cgbb ;_dab :_caeb :_cab =34;goto _geeg ;_ebf :_cab =35;goto _geeg ;_fbca :_cab =0;goto _geeg ;_bfc :_cab =36;goto _geeg ;_efef :_cab =37;goto _geeg ;_ggag :_cab =1;goto _geeg ;_efgce :_cab =2;goto _geeg ;_gdcd :_cab =38;goto _geeg ;_dec :_cab =3;goto _geeg ;_aaec :_cab =4;goto _geeg ;_edbe :_cab =39;goto _geeg ;_aab :_cab =5;goto _geeg ;_fafg :_cab =6;goto _geeg ;_fbbc :_cab =7;goto _geeg ;_gfga :_cab =8;goto _geeg ;_gcca :_cab =40;goto _geeg ;_aff :_cab =9;goto _geeg ;_afb :_cab =41;goto _geeg ;_bbag :_cab =10;goto _geeg ;_age :_cab =42;goto _geeg ;_cdf :_cab =11;goto _geeg ;_gcbac :_cab =43;goto _geeg ;_affe :_cab =44;goto _geeg ;_ffb :_cab =45;goto _geeg ;_ggdg :_cab =12;goto _geeg ;_bbgg :_cab =46;goto _geeg ;_bad :_cab =13;goto _geeg ;_bfde :_cab =14;goto _geeg ;_fgfge :_cab =15;goto _geeg ;_ebg :_cab =16;goto _geeg ;_ecad :_cab =47;goto _geeg ;_fbbcb :_cab =17;goto _geeg ;_gcg :_cab =48;goto _geeg ;_gfdd :_cab =18;goto _geeg ;_bbec :_cab =19;goto _geeg ;_geda :_cab =20;goto _geeg ;_gccaf :_cab =49;goto _geeg ;_gbbf :_cab =50;goto _geeg ;_cefab :_cab =21;goto _geeg ;_beee :_cab =22;goto _geeg ;_ddbe :_cab =23;goto _geeg ;_cdab :_cab =24;goto _geeg ;_caa :_cab =25;goto _geeg ;_gfdc :_cab =51;goto _geeg ;_ebcb :_cab =26;goto _geeg ;_acbe :_cab =52;goto _geeg ;_badd :_cab =53;goto _geeg ;_fab :_cab =54;goto _geeg ;_bfdf :_cab =55;goto _geeg ;_bbdd :_cab =56;goto _geeg ;_febb :_cab =57;goto _geeg ;_dgf :_cab =27;goto _geeg ;_caaa :_cab =28;goto _geeg ;_dcafd :_cab =29;goto _geeg ;_dadc :_cab =30;goto _geeg ;_cdg :_cab =31;goto _geeg ;_acga :_cab =58;goto _geeg ;_eae :_cab =32;goto _geeg ;_cgd :_cab =59;goto _geeg ;_ebcd :_cab =33;goto _geeg ;_aecc :_cab =60;goto _geeg ;_bed :_cab =61;goto _geeg ;_cbbf :_cab =62;goto _geeg ;_geeg :{};if _gad ==_fcd {switch _cab {case 35:goto _cgbb ;case 0:goto _eeb ;case 36:goto _ggd ;case 37:goto _abacg ;case 1:goto _eeb ;case 2:goto _eeb ;case 38:goto _bbf ;case 3:goto _eca ;case 4:goto _eca ;case 39:goto _bbf ;case 5:goto _eca ;case 6:goto _eca ;case 7:goto _eca ;case 8:goto _eeb ;case 40:goto _bbf ;case 9:goto _eca ;case 41:goto _bbf ;case 10:goto _eeb ;case 42:goto _bbf ;case 11:goto _eca ;case 43:goto _bbf ;case 44:goto _bbf ;case 45:goto _bbf ;case 12:goto _efdd ;case 46:goto _dge ;case 13:goto _ebe ;case 14:goto _eeb ;case 15:goto _eeb ;case 16:goto _ebe ;case 47:goto _faa ;case 17:goto _cbd ;case 48:goto _gac ;case 18:goto _cggdeb ;case 19:goto _cggdeb ;case 20:goto _eeb ;case 49:goto _cgbb ;case 50:goto _ebc ;case 21:goto _eeb ;case 22:goto _eeb ;case 23:goto _eeb ;case 24:goto _eeb ;case 25:goto _eeb ;case 51:goto _ebc ;case 26:goto _ffg ;case 52:goto _ebc ;case 53:goto _ebc ;case 54:goto _aaf ;case 55:goto _cgbb ;case 56:goto _cgbb ;case 57:goto _cgbb ;case 27:goto _cbg ;case 28:goto _cbg ;case 29:goto _cbg ;case 30:goto _cbg ;case 31:goto _cbg ;case 58:goto _cgbb ;case 32:goto _eeb ;case 59:goto _eeb ;case 33:goto _cbg ;case 60:goto _cgbb ;case 61:goto _faa ;case 62:goto _cgbb ;};};};if _eba > 0{copy (_gaac [0:],_gaac [_eba :]);};};_ =_fcd ;if _cab ==_gbd {_cc .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};const _acg int =0;func _cggde (_aeea _ff .Time ,_cgc string )[]byte {_bee :=[]byte {};_edg :=0;for _ffcd :=0;_ffcd < len (_cgc );_ffcd ++{var _ggb string ;if _cgc [_ffcd ]=='/'{_ggb =string (_cgc [_edg :_ffcd ]);_edg =_ffcd +1;}else if _ffcd ==len (_cgc )-1{_ggb =string (_cgc [_edg :_ffcd +1]);}else {continue ;};switch _ggb {case "\u0079\u0079":_bee =_aeea .AppendFormat (_bee ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_bee =_aeea .AppendFormat (_bee ,"\u0032\u0030\u0030\u0036");case "\u006d":_bee =_aeea .AppendFormat (_bee ,"\u0031");case "\u006d\u006d":_bee =_aeea .AppendFormat (_bee ,"\u0030\u0031");case "\u006d\u006d\u006d":_bee =_aeea .AppendFormat (_bee ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_bee =_aeea .AppendFormat (_bee ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _aeea .Month (){case _ff .January ,_ff .July ,_ff .June :_bee =append (_bee ,'J');case _ff .February :_bee =append (_bee ,'M');case _ff .March ,_ff .May :_bee =append (_bee ,'M');case _ff .April ,_ff .August :_bee =append (_bee ,'A');case _ff .September :_bee =append (_bee ,'S');case _ff .October :_bee =append (_bee ,'O');case _ff .November :_bee =append (_bee ,'N');case _ff .December :_bee =append (_bee ,'D');};case "\u0064":_bee =_aeea .AppendFormat (_bee ,"\u0032");case "\u0064\u0064":_bee =_aeea .AppendFormat (_bee ,"\u0030\u0032");case "\u0064\u0064\u0064":_bee =_aeea .AppendFormat (_bee ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_bee =_aeea .AppendFormat (_bee ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_cc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_ggb );};if _cgc [_ffcd ]=='/'{_bee =append (_bee ,'/');};};return _bee ;};func _cfc (_fbgd _ff .Time )_ff .Time {_fbgd =_fbgd .UTC ();return _ff .Date (_fbgd .Year (),_fbgd .Month (),_fbgd .Day (),_fbgd .Hour (),_fbgd .Minute (),_fbgd .Second (),_fbgd .Nanosecond (),_ff .Local );};func _aee (_ega int64 ,_bdc Format )[]byte {if !_bdc .IsExponential ||len (_bdc .Exponent )==0{return nil ;};_ggce :=_a .AppendInt (nil ,_dc (_ega ),10);_bef :=make ([]byte ,0,len (_ggce )+2);_bef =append (_bef ,'E');if _ega >=0{_bef =append (_bef ,'+');}else {_bef =append (_bef ,'-');_ega *=-1;};_bge :=0;_ece :for _gcb :=len (_bdc .Exponent )-1;_gcb >=0;_gcb --{_acb :=len (_ggce )-1-_bge ;_gae :=_bdc .Exponent [_gcb ];switch _gae .Type {case FmtTypeDigit :if _acb >=0{_bef =append (_bef ,_ggce [_acb ]);_bge ++;}else {_bef =append (_bef ,'0');};case FmtTypeDigitOpt :if _acb >=0{_bef =append (_bef ,_ggce [_acb ]);_bge ++;}else {for _ddf :=_gcb ;_ddf >=0;_ddf --{_cceb :=_bdc .Exponent [_ddf ];if _cceb .Type ==FmtTypeLiteral {_bef =append (_bef ,_cceb .Literal );};};break _ece ;};case FmtTypeLiteral :_bef =append (_bef ,_gae .Literal );default:_cc .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_gae );};};if _bge < len (_ggce ){_bef =append (_bef ,_ggce [len (_ggce )-_bge -1:_bge -1]...);};_cac (_bef [2:]);return _bef ;};const _ab ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_da ,_ :=_a .ParseFloat (v ,64);return Number (_da ,f );};return String (v ,f );};const _b =1e-10;const _gbd int =-1;

// AddToken adds a format token to the format.
func (_bcd *Format )AddToken (t FmtType ,l []byte ){if _bcd ._gg {_bcd ._gg =false ;return ;};switch t {case FmtTypeDecimal :_bcd ._bca =true ;case FmtTypeUnderscore :_bcd ._gg =true ;case FmtTypeText :_bcd .Whole =append (_bcd .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_bcd .Whole =append (_bcd .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_bcd ._bc =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_fd :=range l {if _bcd .IsExponential {_bcd .Exponent =append (_bcd .Exponent ,Token {Type :t ,Literal :_fd });}else if !_bcd ._bca {_bcd .Whole =append (_bcd .Whole ,Token {Type :t ,Literal :_fd });}else {_bcd .Fractional =append (_bcd .Fractional ,Token {Type :t ,Literal :_fd });};};case FmtTypeDigitOptThousands :_bcd ._aba =true ;case FmtTypeFraction :_aa :=_c .Split (string (l ),"\u002f");if len (_aa )==2{_bcd ._df =true ;_bcd ._gd ,_ =_a .ParseInt (_aa [1],10,64);for _ ,_gdb :=range _aa [1]{if _gdb =='?'||_gdb =='0'{_bcd ._cg ++;};};};default:_cc .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};const _cae int =34;

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_gbb :=Parse (f );var _ffc Format ;if len (_gbb )==1{_ffc =_gbb [0];}else if len (_gbb )==4{_ffc =_gbb [3];};_db :=false ;for _ ,_ad :=range _ffc .Whole {if _ad .Type ==FmtTypeText {_db =true ;};};if !_db {return v ;};_abg :=_ef .Buffer {};for _ ,_ec :=range _ffc .Whole {switch _ec .Type {case FmtTypeLiteral :_abg .WriteByte (_ec .Literal );case FmtTypeText :_abg .WriteString (v );};};return _abg .String ();};const _eac int =34;func _dc (_ggc int64 )int64 {if _ggc < 0{return -_ggc ;};return _ggc ;};func _efg (_fga []byte )[]byte {_aac :=len (_fga );_fa :=false ;_ag :=false ;for _efe :=len (_fga )-1;_efe >=0;_efe --{if _fga [_efe ]=='0'&&!_ag &&!_fa {_aac =_efe ;}else if _fga [_efe ]=='.'{_fa =true ;}else {_ag =true ;};};if _fa &&_ag {if _fga [_aac -1]=='.'{_aac --;};return _fga [0:_aac ];};return _fga ;};func IsNumber (data string )(_cca bool ){_fafb ,_bea ,_fdf :=0,0,len (data );_ded :=len (data );_deg ,_abd ,_gbc :=0,0,0;_ =_abd ;_ =_gbc ;_ =_deg ;{_fafb =_aece ;_deg =0;_abd =0;_gbc =0;};{if _bea ==_fdf {goto _cee ;};switch _fafb {case 0:goto _cbc ;case 1:goto _gef ;case 2:goto _gdd ;case 3:goto _befa ;case 4:goto _fdgd ;case 5:goto _efgc ;case 6:goto _abge ;case 7:goto _bec ;};goto _acf ;_cdc :_abd =_bea ;_bea --;{_cca =false ;};goto _cbb ;_dbe :_abd =_bea ;_bea --;{_cca =_abd ==len (data );};goto _cbb ;_eag :_abd =_bea ;_bea --;{_cca =_abd ==len (data );};goto _cbb ;_fda :switch _gbc {case 2:{_bea =(_abd )-1;_cca =_abd ==len (data );};case 3:{_bea =(_abd )-1;_cca =false ;};};goto _cbb ;_cbb :_deg =0;if _bea ++;_bea ==_fdf {goto _ddbf ;};_cbc :_deg =_bea ;switch data [_bea ]{case 43:goto _aaad ;case 45:goto _aaad ;};if 48<=data [_bea ]&&data [_bea ]<=57{goto _dbd ;};goto _ba ;_ba :if _bea ++;_bea ==_fdf {goto _ecb ;};_gef :goto _ba ;_aaad :if _bea ++;_bea ==_fdf {goto _dbg ;};_gdd :if 48<=data [_bea ]&&data [_bea ]<=57{goto _dbd ;};goto _ba ;_dbd :if _bea ++;_bea ==_fdf {goto _fff ;};_befa :if data [_bea ]==46{goto _eed ;};if 48<=data [_bea ]&&data [_bea ]<=57{goto _dbd ;};goto _ba ;_eed :if _bea ++;_bea ==_fdf {goto _fec ;};_fdgd :if 48<=data [_bea ]&&data [_bea ]<=57{goto _dda ;};goto _ba ;_dda :if _bea ++;_bea ==_fdf {goto _gcd ;};_efgc :if data [_bea ]==69{goto _ead ;};if 48<=data [_bea ]&&data [_bea ]<=57{goto _dda ;};goto _ba ;_ead :if _bea ++;_bea ==_fdf {goto _cgbe ;};_abge :switch data [_bea ]{case 43:goto _bdce ;case 45:goto _bdce ;};goto _ba ;_bdce :_abd =_bea +1;_gbc =3;goto _gee ;_bgb :_abd =_bea +1;_gbc =2;goto _gee ;_gee :if _bea ++;_bea ==_fdf {goto _ccd ;};_bec :if 48<=data [_bea ]&&data [_bea ]<=57{goto _bgb ;};goto _ba ;_acf :_ddbf :_fafb =0;goto _cee ;_ecb :_fafb =1;goto _cee ;_dbg :_fafb =2;goto _cee ;_fff :_fafb =3;goto _cee ;_fec :_fafb =4;goto _cee ;_gcd :_fafb =5;goto _cee ;_cgbe :_fafb =6;goto _cee ;_ccd :_fafb =7;goto _cee ;_cee :{};if _bea ==_ded {switch _fafb {case 1:goto _cdc ;case 2:goto _cdc ;case 3:goto _dbe ;case 4:goto _cdc ;case 5:goto _eag ;case 6:goto _cdc ;case 7:goto _fda ;};};};if _fafb ==_gbd {return false ;};return ;};const _efb int =0;const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);const _eee int =34;

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const _af =1e11;func (_dfd *Lexer )nextFmt (){_dfd ._cff =append (_dfd ._cff ,_dfd ._ddd );_dfd ._ddd =Format {}};