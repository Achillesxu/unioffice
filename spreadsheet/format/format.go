//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_be "bytes";_c "fmt";_eb "github.com/unidoc/unioffice/common/logger";_g "io";_ec "math";_gd "strconv";_f "strings";_e "time";);const _cda int =0;func _cge (_fb int64 ,_efa Format )[]byte {if !_efa .IsExponential ||len (_efa .Exponent )==0{return nil ;};_eae :=_gd .AppendInt (nil ,_fdf (_fb ),10);_bbg :=make ([]byte ,0,len (_eae )+2);_bbg =append (_bbg ,'E');if _fb >=0{_bbg =append (_bbg ,'+');}else {_bbg =append (_bbg ,'-');_fb *=-1;};_afec :=0;_gaf :for _gg :=len (_efa .Exponent )-1;_gg >=0;_gg --{_cdc :=len (_eae )-1-_afec ;_dgeg :=_efa .Exponent [_gg ];switch _dgeg .Type {case FmtTypeDigit :if _cdc >=0{_bbg =append (_bbg ,_eae [_cdc ]);_afec ++;}else {_bbg =append (_bbg ,'0');};case FmtTypeDigitOpt :if _cdc >=0{_bbg =append (_bbg ,_eae [_cdc ]);_afec ++;}else {for _baf :=_gg ;_baf >=0;_baf --{_ade :=_efa .Exponent [_baf ];if _ade .Type ==FmtTypeLiteral {_bbg =append (_bbg ,_ade .Literal );};};break _gaf ;};case FmtTypeLiteral :_bbg =append (_bbg ,_dgeg .Literal );default:_eb .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_dgeg );};};if _afec < len (_eae ){_bbg =append (_bbg ,_eae [len (_eae )-_afec -1:_afec -1]...);};_bbd (_bbg [2:]);return _bbg ;};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_fed :=Parse (f );var _ea Format ;if len (_fed )==1{_ea =_fed [0];}else if len (_fed )==4{_ea =_fed [3];};_efc :=false ;for _ ,_ca :=range _ea .Whole {if _ca .Type ==FmtTypeText {_efc =true ;};};if !_efc {return v ;};_af :=_be .Buffer {};for _ ,_aa :=range _ea .Whole {switch _aa .Type {case FmtTypeLiteral :_af .WriteByte (_aa .Literal );case FmtTypeText :_af .WriteString (v );};};return _af .String ();};func IsNumber (data string )(_bdg bool ){_aadc ,_baa ,_de :=0,0,len (data );_gbg :=len (data );_ebf ,_age ,_bega :=0,0,0;_ =_age ;_ =_bega ;_ =_ebf ;{_aadc =_gfd ;_ebf =0;_age =0;_bega =0;};{if _baa ==_de {goto _gae ;};switch _aadc {case 0:goto _bcf ;case 1:goto _ecc ;case 2:goto _cged ;case 3:goto _gafb ;case 4:goto _ggc ;case 5:goto _daadf ;case 6:goto _fba ;case 7:goto _adf ;};goto _ceda ;_fef :_age =_baa ;_baa --;{_bdg =false ;};goto _fgfd ;_cbfe :_age =_baa ;_baa --;{_bdg =_age ==len (data );};goto _fgfd ;_cegb :_age =_baa ;_baa --;{_bdg =_age ==len (data );};goto _fgfd ;_gbb :switch _bega {case 2:{_baa =(_age )-1;_bdg =_age ==len (data );};case 3:{_baa =(_age )-1;_bdg =false ;};};goto _fgfd ;_fgfd :_ebf =0;if _baa ++;_baa ==_de {goto _aba ;};_bcf :_ebf =_baa ;switch data [_baa ]{case 43:goto _fcfg ;case 45:goto _fcfg ;};if 48<=data [_baa ]&&data [_baa ]<=57{goto _fae ;};goto _bf ;_bf :if _baa ++;_baa ==_de {goto _dda ;};_ecc :goto _bf ;_fcfg :if _baa ++;_baa ==_de {goto _gbe ;};_cged :if 48<=data [_baa ]&&data [_baa ]<=57{goto _fae ;};goto _bf ;_fae :if _baa ++;_baa ==_de {goto _ece ;};_gafb :if data [_baa ]==46{goto _abec ;};if 48<=data [_baa ]&&data [_baa ]<=57{goto _fae ;};goto _bf ;_abec :if _baa ++;_baa ==_de {goto _bdc ;};_ggc :if 48<=data [_baa ]&&data [_baa ]<=57{goto _fccf ;};goto _bf ;_fccf :if _baa ++;_baa ==_de {goto _aeg ;};_daadf :if data [_baa ]==69{goto _febdd ;};if 48<=data [_baa ]&&data [_baa ]<=57{goto _fccf ;};goto _bf ;_febdd :if _baa ++;_baa ==_de {goto _cfg ;};_fba :switch data [_baa ]{case 43:goto _fab ;case 45:goto _fab ;};goto _bf ;_fab :_age =_baa +1;_bega =3;goto _cbg ;_bga :_age =_baa +1;_bega =2;goto _cbg ;_cbg :if _baa ++;_baa ==_de {goto _aaa ;};_adf :if 48<=data [_baa ]&&data [_baa ]<=57{goto _bga ;};goto _bf ;_ceda :_aba :_aadc =0;goto _gae ;_dda :_aadc =1;goto _gae ;_gbe :_aadc =2;goto _gae ;_ece :_aadc =3;goto _gae ;_bdc :_aadc =4;goto _gae ;_aeg :_aadc =5;goto _gae ;_cfg :_aadc =6;goto _gae ;_aaa :_aadc =7;goto _gae ;_gae :{};if _baa ==_gbg {switch _aadc {case 1:goto _fef ;case 2:goto _fef ;case 3:goto _cbfe ;case 4:goto _fef ;case 5:goto _cegb ;case 6:goto _fef ;case 7:goto _gbb ;};};};if _aadc ==_bdge {return false ;};return ;};func _ga (_bbc float64 ,_fcf Format ,_eg bool )string {if _fcf ._bee {return NumberGeneric (_bbc );};_fee :=make ([]byte ,0,20);_ad :=_ec .Signbit (_bbc );_ced :=_ec .Abs (_bbc );_aab :=int64 (0);_eca :=int64 (0);if _fcf .IsExponential {for _ced >=10{_eca ++;_ced /=10;};for _ced < 1{_eca --;_ced *=10;};}else if _fcf ._ceg {_ced *=100;}else if _fcf ._ce {if _fcf ._cg ==0{_bg :=_ec .Pow (10,float64 (_fcf ._dc ));_cea ,_beb :=1.0,1.0;_ =_cea ;for _cf :=1.0;_cf < _bg ;_cf ++{_ ,_ba :=_ec .Modf (_ced *float64 (_cf ));if _ba < _beb {_beb =_ba ;_cea =_cf ;if _ba ==0{break ;};};};_fcf ._cg =int64 (_cea );};_aab =int64 (_ced *float64 (_fcf ._cg )+0.5);if len (_fcf .Whole )> 0&&_aab > _fcf ._cg {_aab =int64 (_ced *float64 (_fcf ._cg ))%_fcf ._cg ;_ced -=float64 (_aab )/float64 (_fcf ._cg );}else {_ced -=float64 (_aab )/float64 (_fcf ._cg );if _ec .Abs (_ced )< 1{_gc :=true ;for _ ,_fdc :=range _fcf .Whole {if _fdc .Type ==FmtTypeDigitOpt {continue ;};if _fdc .Type ==FmtTypeLiteral &&_fdc .Literal ==' '{continue ;};_gc =false ;};if _gc {_fcf .Whole =nil ;};};};};_ceb :=1;for _ ,_eag :=range _fcf .Fractional {if _eag .Type ==FmtTypeDigit ||_eag .Type ==FmtTypeDigitOpt {_ceb ++;};};_ced +=5*_ec .Pow10 (-_ceb );_bdd ,_gdc :=_ec .Modf (_ced );_fee =append (_fee ,_fg (_bdd ,_bbc ,_fcf )...);_fee =append (_fee ,_fde (_gdc ,_bbc ,_fcf )...);_fee =append (_fee ,_cge (_eca ,_fcf )...);if _fcf ._ce {_fee =_gd .AppendInt (_fee ,_aab ,10);_fee =append (_fee ,'/');_fee =_gd .AppendInt (_fee ,_fcf ._cg ,10);};if !_eg &&_ad {return "\u002d"+string (_fee );};return string (_fee );};func (_ef FmtType )String ()string {if _ef >=FmtType (len (_a )-1){return _c .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_ef );};return _bc [_a [_ef ]:_a [_ef +1]];};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_cd ,_ :=_gd .ParseFloat (v ,64);return Number (_cd ,f );};return String (v ,f );};func Parse (s string )[]Format {_cgc :=Lexer {};_cgc .Lex (_f .NewReader (s ));_cgc ._fcdg =append (_cgc ._fcdg ,_cgc ._cgg );return _cgc ._fcdg ;};func (_fgg *Lexer )nextFmt (){_fgg ._fcdg =append (_fgg ._fcdg ,_fgg ._cgg );_fgg ._cgg =Format {}};const _eef int =0;func _fde (_acd ,_gca float64 ,_fgd Format )[]byte {if len (_fgd .Fractional )==0{return nil ;};_febd :=_gd .AppendFloat (nil ,_acd ,'f',-1,64);if len (_febd )> 2{_febd =_febd [2:];}else {_febd =nil ;};_gfb :=make ([]byte ,0,len (_febd ));_gfb =append (_gfb ,'.');_aad :=0;_ddc :for _fgb :=0;_fgb < len (_fgd .Fractional );_fgb ++{_edg :=_fgb ;_ceag :=_fgd .Fractional [_fgb ];switch _ceag .Type {case FmtTypeDigit :if _edg < len (_febd ){_gfb =append (_gfb ,_febd [_edg ]);_aad ++;}else {_gfb =append (_gfb ,'0');};case FmtTypeDigitOpt :if _edg >=0{_gfb =append (_gfb ,_febd [_edg ]);_aad ++;}else {break _ddc ;};case FmtTypeLiteral :_gfb =append (_gfb ,_ceag .Literal );default:_eb .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_ceag );};};return _gfb ;};const _dae int =34;var _a =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func _ffg (_bgb _e .Time ,_eeb string )[]byte {_ffb :=[]byte {};_gga :=0;for _gaa :=0;_gaa < len (_eeb );_gaa ++{var _fdca string ;if _eeb [_gaa ]=='/'{_fdca =string (_eeb [_gga :_gaa ]);_gga =_gaa +1;}else if _gaa ==len (_eeb )-1{_fdca =string (_eeb [_gga :_gaa +1]);}else {continue ;};switch _fdca {case "\u0079\u0079":_ffb =_bgb .AppendFormat (_ffb ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_ffb =_bgb .AppendFormat (_ffb ,"\u0032\u0030\u0030\u0036");case "\u006d":_ffb =_bgb .AppendFormat (_ffb ,"\u0031");case "\u006d\u006d":_ffb =_bgb .AppendFormat (_ffb ,"\u0030\u0031");case "\u006d\u006d\u006d":_ffb =_bgb .AppendFormat (_ffb ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_ffb =_bgb .AppendFormat (_ffb ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _bgb .Month (){case _e .January ,_e .July ,_e .June :_ffb =append (_ffb ,'J');case _e .February :_ffb =append (_ffb ,'M');case _e .March ,_e .May :_ffb =append (_ffb ,'M');case _e .April ,_e .August :_ffb =append (_ffb ,'A');case _e .September :_ffb =append (_ffb ,'S');case _e .October :_ffb =append (_ffb ,'O');case _e .November :_ffb =append (_ffb ,'N');case _e .December :_ffb =append (_ffb ,'D');};case "\u0064":_ffb =_bgb .AppendFormat (_ffb ,"\u0032");case "\u0064\u0064":_ffb =_bgb .AppendFormat (_ffb ,"\u0030\u0032");case "\u0064\u0064\u0064":_ffb =_bgb .AppendFormat (_ffb ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_ffb =_bgb .AppendFormat (_ffb ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_eb .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_fdca );};if _eeb [_gaa ]=='/'{_ffb =append (_ffb ,'/');};};return _ffb ;};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ec .Abs (v )>=_cb ||_ec .Abs (v )<=_d &&v !=0{return _ggd (v );};_daad :=make ([]byte ,0,15);_daad =_gd .AppendFloat (_daad ,v ,'f',-1,64);if len (_daad )> 11{_acf :=_daad [11]-'0';if _acf >=5&&_acf <=9{_daad [10]++;_daad =_daad [0:11];_daad =_ccb (_daad );};_daad =_daad [0:11];}else if len (_daad )==11{if _daad [len (_daad )-1]=='9'{_daad [len (_daad )-1]++;_daad =_ccb (_daad );};};_daad =_ge (_daad );return string (_daad );};func _fg (_ada ,_ae float64 ,_fgf Format )[]byte {if len (_fgf .Whole )==0{return nil ;};_cgd :=_e .Date (1899,12,30,0,0,0,0,_e .UTC );_dge :=_cgd .Add (_e .Duration (_ae *float64 (24*_e .Hour )));_dge =_gbgf (_dge );_ff :=_gd .AppendFloat (nil ,_ada ,'f',-1,64);_ag :=make ([]byte ,0,len (_ff ));_da :=0;_abe :=1;_eagd :for _dfd :=len (_fgf .Whole )-1;_dfd >=0;_dfd --{_bab :=len (_ff )-1-_da ;_feg :=_fgf .Whole [_dfd ];switch _feg .Type {case FmtTypeDigit :if _bab >=0{_ag =append (_ag ,_ff [_bab ]);_da ++;_abe =_dfd ;}else {_ag =append (_ag ,'0');};case FmtTypeDigitOpt :if _bab >=0{_ag =append (_ag ,_ff [_bab ]);_da ++;_abe =_dfd ;}else {for _dfa :=_dfd ;_dfa >=0;_dfa --{_dfdd :=_fgf .Whole [_dfa ];if _dfdd .Type ==FmtTypeLiteral {_ag =append (_ag ,_dfdd .Literal );};};break _eagd ;};case FmtTypeDollar :for _aed :=_da ;_aed < len (_ff );_aed ++{_ag =append (_ag ,_ff [len (_ff )-1-_aed ]);_da ++;};_ag =append (_ag ,'$');case FmtTypeComma :if !_fgf ._beg {_ag =append (_ag ,',');};case FmtTypeLiteral :_ag =append (_ag ,_feg .Literal );case FmtTypeDate :_ag =append (_ag ,_bbd (_ffg (_dge ,_feg .DateTime ))...);case FmtTypeTime :_ag =append (_ag ,_bbd (_eac (_dge ,_ae ,_feg .DateTime ))...);default:_eb .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_feg );};};_ed :=_bbd (_ag );if _da < len (_ff )&&(_da !=0||_fgf ._bb ){_gb :=len (_ff )-_da ;_gcd :=make ([]byte ,len (_ed )+_gb );copy (_gcd ,_ed [0:_abe ]);copy (_gcd [_abe :],_ff [0:]);copy (_gcd [_abe +_gb :],_ed [_abe :]);_ed =_gcd ;};if _fgf ._beg {_fcd :=_be .Buffer {};_daa :=0;for _afeg :=len (_ed )-1;_afeg >=0;_afeg --{if !(_ed [_afeg ]>='0'&&_ed [_afeg ]<='9'){_daa ++;}else {break ;};};for _gf :=0;_gf < len (_ed );_gf ++{_aec :=(len (_ed )-_gf -_daa );if _aec %3==0&&_aec !=0&&_gf !=0{_fcd .WriteByte (',');};_fcd .WriteByte (_ed [_gf ]);};_ed =_fcd .Bytes ();};return _ed ;};type Lexer struct{_cgg Format ;_fcdg []Format ;};const _bc ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";func _bbd (_feb []byte )[]byte {for _cc :=0;_cc < len (_feb )/2;_cc ++{_afe :=len (_feb )-1-_cc ;_feb [_cc ],_feb [_afe ]=_feb [_afe ],_feb [_cc ];};return _feb ;};

// AddToken adds a format token to the format.
func (_fc *Format )AddToken (t FmtType ,l []byte ){if _fc ._bd {_fc ._bd =false ;return ;};switch t {case FmtTypeDecimal :_fc ._bb =true ;case FmtTypeUnderscore :_fc ._bd =true ;case FmtTypeText :_fc .Whole =append (_fc .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_fc .Whole =append (_fc .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_fc ._ceg =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_fe :=range l {if _fc .IsExponential {_fc .Exponent =append (_fc .Exponent ,Token {Type :t ,Literal :_fe });}else if !_fc ._bb {_fc .Whole =append (_fc .Whole ,Token {Type :t ,Literal :_fe });}else {_fc .Fractional =append (_fc .Fractional ,Token {Type :t ,Literal :_fe });};};case FmtTypeDigitOptThousands :_fc ._beg =true ;case FmtTypeFraction :_eea :=_f .Split (string (l ),"\u002f");if len (_eea )==2{_fc ._ce =true ;_fc ._cg ,_ =_gd .ParseInt (_eea [1],10,64);for _ ,_df :=range _eea [1]{if _df =='?'||_df =='0'{_fc ._dc ++;};};};default:_eb .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};func _eac (_cgb _e .Time ,_cfd float64 ,_aef string )[]byte {_aea :=[]byte {};_abf :=0;for _cag :=0;_cag < len (_aef );_cag ++{var _cbc string ;if _aef [_cag ]==':'{_cbc =string (_aef [_abf :_cag ]);_abf =_cag +1;}else if _cag ==len (_aef )-1{_cbc =string (_aef [_abf :_cag +1]);}else {continue ;};switch _cbc {case "\u0064":_aea =_cgb .AppendFormat (_aea ,"\u0032");case "\u0068":_aea =_cgb .AppendFormat (_aea ,"\u0033");case "\u0068\u0068":_aea =_cgb .AppendFormat (_aea ,"\u0031\u0035");case "\u006d":_aea =_cgb .AppendFormat (_aea ,"\u0034");case "\u006d\u006d":_aea =_cgb .AppendFormat (_aea ,"\u0030\u0034");case "\u0073":_aea =_cgb .Round (_e .Second ).AppendFormat (_aea ,"\u0035");case "\u0073\u002e\u0030":_aea =_cgb .Round (_e .Second /10).AppendFormat (_aea ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_aea =_cgb .Round (_e .Second /100).AppendFormat (_aea ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_aea =_cgb .Round (_e .Second /1000).AppendFormat (_aea ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_aea =_cgb .Round (_e .Second ).AppendFormat (_aea ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_aea =_cgb .Round (_e .Second /10).AppendFormat (_aea ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_aea =_cgb .Round (_e .Second /100).AppendFormat (_aea ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_aea =_cgb .Round (_e .Second /1000).AppendFormat (_aea ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_aea =_cgb .AppendFormat (_aea ,"\u0050\u004d");case "\u005b\u0068\u005d":_aea =_gd .AppendInt (_aea ,int64 (_cfd *24),10);case "\u005b\u006d\u005d":_aea =_gd .AppendInt (_aea ,int64 (_cfd *24*60),10);case "\u005b\u0073\u005d":_aea =_gd .AppendInt (_aea ,int64 (_cfd *24*60*60),10);case "":default:_eb .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_cbc );};if _aef [_cag ]==':'{_aea =append (_aea ,':');};};return _aea ;};func _ccb (_ede []byte )[]byte {for _bag :=len (_ede )-1;_bag > 0;_bag --{if _ede [_bag ]=='9'+1{_ede [_bag ]='0';if _ede [_bag -1]=='.'{_bag --;};_ede [_bag -1]++;};};if _ede [0]=='9'+1{_ede [0]='0';copy (_ede [1:],_ede [0:]);_ede [0]='1';};return _ede ;};const _cb =1e11;const _bac int =34;const _bdge int =-1;

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_cece :=Parse (f );if len (_cece )==1{return _ga (v ,_cece [0],false );}else if len (_cece )> 1&&v < 0{return _ga (v ,_cece [1],true );}else if len (_cece )> 2&&v ==0{return _ga (v ,_cece [2],false );};return _ga (v ,_cece [0],false );};func _ggd (_agg float64 )string {_bca :=_gd .FormatFloat (_agg ,'E',-1,64);_eaa :=_gd .FormatFloat (_agg ,'E',5,64);if len (_bca )< len (_eaa ){return _gd .FormatFloat (_agg ,'E',2,64);};return _eaa ;};const _fga int =34;func _gbgf (_dbff _e .Time )_e .Time {_dbff =_dbff .UTC ();return _e .Date (_dbff .Year (),_dbff .Month (),_dbff .Day (),_dbff .Hour (),_dbff .Minute (),_dbff .Second (),_dbff .Nanosecond (),_e .Local );};const _gfd int =0;

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};const _fa int =-1;func (_gfa *Lexer )Lex (r _g .Reader ){_afa ,_gafc ,_eec :=0,0,0;_aeag :=-1;_gge ,_edb ,_efab :=0,0,0;_ =_edb ;_ =_efab ;_fag :=1;_ =_fag ;_gda :=make ([]byte ,4096);_aeb :=false ;for !_aeb {_caa :=0;if _gge > 0{_caa =_gafc -_gge ;};_gafc =0;_db ,_beec :=r .Read (_gda [_caa :]);if _db ==0||_beec !=nil {_aeb =true ;};_eec =_db +_caa ;if _eec < len (_gda ){_aeag =_eec ;};{_afa =_dae ;_gge =0;_edb =0;_efab =0;};{if _gafc ==_eec {goto _gbc ;};switch _afa {case 34:goto _gcb ;case 35:goto _eab ;case 0:goto _bda ;case 36:goto _agee ;case 37:goto _aagf ;case 1:goto _cedad ;case 2:goto _aagfd ;case 38:goto _agag ;case 3:goto _eeag ;case 4:goto _aae ;case 39:goto _fgbc ;case 5:goto _dbd ;case 6:goto _fbaa ;case 7:goto _bcfb ;case 8:goto _eaae ;case 40:goto _cdcb ;case 9:goto _fff ;case 41:goto _afag ;case 10:goto _dagf ;case 42:goto _ffbb ;case 11:goto _edf ;case 43:goto _daaa ;case 44:goto _dee ;case 45:goto _gcc ;case 12:goto _dga ;case 46:goto _bec ;case 13:goto _fge ;case 14:goto _agad ;case 15:goto _bgf ;case 16:goto _fdcb ;case 47:goto _dgc ;case 17:goto _ddcbe ;case 48:goto _aaga ;case 18:goto _bgfd ;case 19:goto _fbe ;case 20:goto _faaf ;case 49:goto _ddg ;case 50:goto _ffed ;case 21:goto _fgac ;case 22:goto _dadg ;case 23:goto _ebd ;case 24:goto _feeg ;case 25:goto _cfc ;case 51:goto _gce ;case 26:goto _gdf ;case 52:goto _caf ;case 53:goto _gdde ;case 54:goto _bfd ;case 55:goto _bcg ;case 56:goto _egf ;case 57:goto _cfa ;case 27:goto _bgab ;case 28:goto _dea ;case 29:goto _ecbc ;case 30:goto _cbe ;case 31:goto _dfce ;case 58:goto _eace ;case 32:goto _bgfc ;case 59:goto _bfa ;case 33:goto _bgg ;case 60:goto _cgbg ;case 61:goto _dgae ;case 62:goto _fgfcc ;};goto _faed ;_edd :switch _efab {case 2:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeDigit ,nil );};case 3:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_gafc =(_edb )-1;};case 8:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypePercent ,nil );};case 13:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeFraction ,_gda [_gge :_edb ]);};case 14:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeDate ,_gda [_gge :_edb ]);};case 15:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeTime ,_gda [_gge :_edb ]);};case 16:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeTime ,_gda [_gge :_edb ]);};case 18:{_gafc =(_edb )-1;};case 20:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge :_edb ]);};case 21:{_gafc =(_edb )-1;_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge +1:_edb -1]);};};goto _ebg ;_gcf :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeFraction ,_gda [_gge :_edb ]);};goto _ebg ;_cbgf :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeDigitOpt ,nil );};goto _ebg ;_faa :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeDigitOptThousands ,nil );};goto _ebg ;_dad :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypePercent ,nil );};goto _ebg ;_bef :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeDate ,_gda [_gge :_edb ]);};goto _ebg ;_dbf :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeDigit ,nil );};goto _ebg ;_cba :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeTime ,_gda [_gge :_edb ]);};goto _ebg ;_ecb :_gafc =(_edb )-1;{_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge :_edb ]);};goto _ebg ;_cecf :_edb =_gafc +1;{_gfa ._cgg ._bee =true ;};goto _ebg ;_cae :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge :_edb ]);};goto _ebg ;_daga :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeDollar ,nil );};goto _ebg ;_cab :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeComma ,nil );};goto _ebg ;_gea :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeDecimal ,nil );};goto _ebg ;_eeaf :_edb =_gafc +1;{_gfa .nextFmt ();};goto _ebg ;_aga :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeText ,nil );};goto _ebg ;_cfe :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeUnderscore ,nil );};goto _ebg ;_afd :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge :_edb ]);};goto _ebg ;_gafe :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge +1:_edb -1]);};goto _ebg ;_fbb :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeDigitOpt ,nil );};goto _ebg ;_acb :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeFraction ,_gda [_gge :_edb ]);};goto _ebg ;_fcg :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypePercent ,nil );};goto _ebg ;_gcg :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeDate ,_gda [_gge :_edb ]);};goto _ebg ;_aag :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeDigit ,nil );};goto _ebg ;_bdf :_edb =_gafc ;_gafc --;{_gfa ._cgg .AddToken (FmtTypeTime ,_gda [_gge :_edb ]);};goto _ebg ;_dbfg :_edb =_gafc ;_gafc --;{};goto _ebg ;_agf :_edb =_gafc +1;{_gfa ._cgg .IsExponential =true ;};goto _ebg ;_bcd :_edb =_gafc +1;{_gfa ._cgg .AddToken (FmtTypeLiteral ,_gda [_gge +1:_edb ]);};goto _ebg ;_ebg :_gge =0;if _gafc ++;_gafc ==_eec {goto _effe ;};_gcb :_gge =_gafc ;switch _gda [_gafc ]{case 34:goto _gbd ;case 35:goto _fdb ;case 36:goto _daga ;case 37:goto _ccc ;case 44:goto _cab ;case 46:goto _gea ;case 47:goto _bbda ;case 48:goto _dfda ;case 58:goto _bge ;case 59:goto _eeaf ;case 63:goto _cfdg ;case 64:goto _aga ;case 65:goto _gfc ;case 69:goto _ffd ;case 71:goto _ggb ;case 91:goto _cbcg ;case 92:goto _eefb ;case 95:goto _cfe ;case 100:goto _bbda ;case 104:goto _bge ;case 109:goto _dadgf ;case 115:goto _aee ;case 121:goto _fcde ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _eff ;};goto _cae ;_gbd :_edb =_gafc +1;_efab =20;goto _agd ;_agd :if _gafc ++;_gafc ==_eec {goto _aedf ;};_eab :if _gda [_gafc ]==34{goto _eecf ;};goto _cac ;_cac :if _gafc ++;_gafc ==_eec {goto _gad ;};_bda :if _gda [_gafc ]==34{goto _eecf ;};goto _cac ;_eecf :_edb =_gafc +1;_efab =21;goto _bea ;_bea :if _gafc ++;_gafc ==_eec {goto _ddga ;};_agee :if _gda [_gafc ]==34{goto _cac ;};goto _gafe ;_fdb :_edb =_gafc +1;_efab =3;goto _gdg ;_gdg :if _gafc ++;_gafc ==_eec {goto _bcfbd ;};_aagf :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fdef ;case 44:goto _afegb ;case 47:goto _feda ;case 48:goto _fdef ;case 63:goto _fdef ;};goto _fbb ;_fdef :if _gafc ++;_gafc ==_eec {goto _acfe ;};_cedad :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fdef ;case 47:goto _feda ;case 48:goto _fdef ;case 63:goto _fdef ;};goto _edd ;_feda :if _gafc ++;_gafc ==_eec {goto _gfag ;};_aagfd :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _cgf ;case 48:goto _abd ;case 63:goto _aega ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _bdaf ;};goto _edd ;_aega :_edb =_gafc +1;goto _afdg ;_afdg :if _gafc ++;_gafc ==_eec {goto _acfc ;};_agag :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _aega ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _aega ;case 63:goto _aega ;case 65:goto _fefc ;};goto _acb ;_fefc :if _gafc ++;_gafc ==_eec {goto _fdg ;};_eeag :switch _gda [_gafc ]{case 47:goto _dfe ;case 77:goto _dab ;};goto _gcf ;_dfe :if _gafc ++;_gafc ==_eec {goto _ffdc ;};_aae :if _gda [_gafc ]==80{goto _ffa ;};goto _gcf ;_ffa :_edb =_gafc +1;goto _fdd ;_fdd :if _gafc ++;_gafc ==_eec {goto _bddc ;};_fgbc :if _gda [_gafc ]==65{goto _fefc ;};goto _acb ;_dab :if _gafc ++;_gafc ==_eec {goto _fcfb ;};_dbd :if _gda [_gafc ]==47{goto _dec ;};goto _gcf ;_dec :if _gafc ++;_gafc ==_eec {goto _aaae ;};_fbaa :if _gda [_gafc ]==80{goto _acde ;};goto _gcf ;_acde :if _gafc ++;_gafc ==_eec {goto _dcd ;};_bcfb :if _gda [_gafc ]==77{goto _ffa ;};goto _gcf ;_cgf :if _gafc ++;_gafc ==_eec {goto _bfb ;};_eaae :switch _gda [_gafc ]{case 35:goto _abecf ;case 37:goto _agb ;case 63:goto _abecf ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _cggc ;};goto _edd ;_abecf :_edb =_gafc +1;goto _ebb ;_ebb :if _gafc ++;_gafc ==_eec {goto _adb ;};_cdcb :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _dbfgf ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _aega ;case 63:goto _aega ;case 65:goto _fefc ;};goto _acb ;_dbfgf :if _gafc ++;_gafc ==_eec {goto _aecc ;};_fff :switch _gda [_gafc ]{case 35:goto _adff ;case 44:goto _adff ;case 46:goto _adff ;case 48:goto _adff ;case 63:goto _adff ;};goto _gcf ;_adff :_edb =_gafc +1;goto _bce ;_bce :if _gafc ++;_gafc ==_eec {goto _fagg ;};_afag :switch _gda [_gafc ]{case 35:goto _adff ;case 44:goto _adff ;case 46:goto _adff ;case 48:goto _adff ;case 63:goto _adff ;case 65:goto _fefc ;};goto _acb ;_agb :if _gafc ++;_gafc ==_eec {goto _cdb ;};_dagf :if _gda [_gafc ]==37{goto _agb ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _cggc ;};goto _edd ;_cggc :_edb =_gafc +1;_efab =13;goto _efd ;_efd :if _gafc ++;_gafc ==_eec {goto _gfg ;};_ffbb :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _abc ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _acc ;case 63:goto _aega ;case 65:goto _fefc ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _cggc ;};goto _acb ;_abc :if _gafc ++;_gafc ==_eec {goto _bfaa ;};_edf :switch _gda [_gafc ]{case 35:goto _adff ;case 37:goto _agb ;case 44:goto _adff ;case 46:goto _adff ;case 63:goto _adff ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _cggc ;};goto _gcf ;_acc :_edb =_gafc +1;goto _ddcb ;_ddcb :if _gafc ++;_gafc ==_eec {goto _cbcgc ;};_daaa :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _acc ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _acc ;case 63:goto _aega ;case 65:goto _fefc ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _cggc ;};goto _acb ;_abd :_edb =_gafc +1;goto _ffe ;_ffe :if _gafc ++;_gafc ==_eec {goto _cdf ;};_dee :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _acc ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _abd ;case 63:goto _aega ;case 65:goto _fefc ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _bdaf ;};goto _acb ;_bdaf :_edb =_gafc +1;goto _gdca ;_gdca :if _gafc ++;_gafc ==_eec {goto _cbda ;};_gcc :switch _gda [_gafc ]{case 35:goto _aega ;case 37:goto _cggc ;case 44:goto _aega ;case 46:goto _aega ;case 48:goto _abd ;case 63:goto _aega ;case 65:goto _fefc ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _bdaf ;};goto _acb ;_afegb :if _gafc ++;_gafc ==_eec {goto _gadb ;};_dga :if _gda [_gafc ]==35{goto _faa ;};goto _cbgf ;_ccc :_edb =_gafc +1;_efab =8;goto _fcge ;_fcge :if _gafc ++;_gafc ==_eec {goto _deee ;};_bec :switch _gda [_gafc ]{case 35:goto _cbd ;case 37:goto _ggdd ;case 48:goto _ccf ;case 63:goto _cbd ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _abce ;};goto _fcg ;_cbd :if _gafc ++;_gafc ==_eec {goto _ccg ;};_fge :switch _gda [_gafc ]{case 35:goto _cbd ;case 47:goto _feda ;case 48:goto _cbd ;case 63:goto _cbd ;};goto _dad ;_ggdd :if _gafc ++;_gafc ==_eec {goto _gdce ;};_agad :if _gda [_gafc ]==37{goto _ggdd ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _abce ;};goto _edd ;_abce :if _gafc ++;_gafc ==_eec {goto _cdd ;};_bgf :switch _gda [_gafc ]{case 37:goto _ggdd ;case 47:goto _feda ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _abce ;};goto _edd ;_ccf :if _gafc ++;_gafc ==_eec {goto _cga ;};_fdcb :switch _gda [_gafc ]{case 35:goto _cbd ;case 37:goto _ggdd ;case 47:goto _feda ;case 48:goto _ccf ;case 63:goto _cbd ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _abce ;};goto _dad ;_bbda :_edb =_gafc +1;goto _gcfb ;_gcfb :if _gafc ++;_gafc ==_eec {goto _fbbg ;};_dgc :switch _gda [_gafc ]{case 47:goto _bbda ;case 100:goto _bbda ;case 109:goto _bbda ;case 121:goto _ggag ;};goto _gcg ;_ggag :if _gafc ++;_gafc ==_eec {goto _fcdgb ;};_ddcbe :if _gda [_gafc ]==121{goto _bbda ;};goto _bef ;_dfda :_edb =_gafc +1;_efab =2;goto _aaee ;_aaee :if _gafc ++;_gafc ==_eec {goto _deac ;};_aaga :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fbd ;case 47:goto _feda ;case 48:goto _fgfc ;case 63:goto _fdef ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _dbe ;};goto _aag ;_fbd :if _gafc ++;_gafc ==_eec {goto _faec ;};_bgfd :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fbd ;case 47:goto _feda ;case 48:goto _fbd ;case 63:goto _fdef ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _abce ;};goto _dbf ;_fgfc :if _gafc ++;_gafc ==_eec {goto _daeb ;};_fbe :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fbd ;case 47:goto _feda ;case 48:goto _fgfc ;case 63:goto _fdef ;};if 49<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _dbe ;};goto _dbf ;_dbe :if _gafc ++;_gafc ==_eec {goto _fbg ;};_faaf :switch _gda [_gafc ]{case 37:goto _abce ;case 47:goto _feda ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _dbe ;};goto _edd ;_eff :_edb =_gafc +1;_efab =20;goto _gdd ;_gdd :if _gafc ++;_gafc ==_eec {goto _beeg ;};_ddg :switch _gda [_gafc ]{case 37:goto _abce ;case 47:goto _feda ;};if 48<=_gda [_gafc ]&&_gda [_gafc ]<=57{goto _dbe ;};goto _afd ;_bge :_edb =_gafc +1;_efab =15;goto _ffce ;_ffce :if _gafc ++;_gafc ==_eec {goto _aac ;};_ffed :switch _gda [_gafc ]{case 58:goto _bge ;case 65:goto _edgf ;case 104:goto _bge ;case 109:goto _bge ;case 115:goto _aee ;};goto _bdf ;_edgf :if _gafc ++;_gafc ==_eec {goto _gfagf ;};_fgac :switch _gda [_gafc ]{case 47:goto _agagg ;case 77:goto _gbf ;};goto _edd ;_agagg :if _gafc ++;_gafc ==_eec {goto _eaf ;};_dadg :if _gda [_gafc ]==80{goto _bge ;};goto _edd ;_gbf :if _gafc ++;_gafc ==_eec {goto _agfg ;};_ebd :if _gda [_gafc ]==47{goto _gee ;};goto _edd ;_gee :if _gafc ++;_gafc ==_eec {goto _dcb ;};_feeg :if _gda [_gafc ]==80{goto _caee ;};goto _edd ;_caee :if _gafc ++;_gafc ==_eec {goto _ggbg ;};_cfc :if _gda [_gafc ]==77{goto _bge ;};goto _edd ;_aee :_edb =_gafc +1;_efab =15;goto _daed ;_daed :if _gafc ++;_gafc ==_eec {goto _bcgg ;};_gce :switch _gda [_gafc ]{case 46:goto _deg ;case 58:goto _bge ;case 65:goto _edgf ;case 104:goto _bge ;case 109:goto _bge ;case 115:goto _aee ;};goto _bdf ;_deg :if _gafc ++;_gafc ==_eec {goto _adc ;};_gdf :if _gda [_gafc ]==48{goto _gdaa ;};goto _cba ;_gdaa :_edb =_gafc +1;_efab =15;goto _fca ;_fca :if _gafc ++;_gafc ==_eec {goto _gcfa ;};_caf :switch _gda [_gafc ]{case 48:goto _fcb ;case 58:goto _bge ;case 65:goto _edgf ;case 104:goto _bge ;case 109:goto _bge ;case 115:goto _aee ;};goto _bdf ;_fcb :_edb =_gafc +1;_efab =15;goto _gdgg ;_gdgg :if _gafc ++;_gafc ==_eec {goto _dfdf ;};_gdde :switch _gda [_gafc ]{case 48:goto _bge ;case 58:goto _bge ;case 65:goto _edgf ;case 104:goto _bge ;case 109:goto _bge ;case 115:goto _aee ;};goto _bdf ;_cfdg :_edb =_gafc +1;_efab =5;goto _egb ;_egb :if _gafc ++;_gafc ==_eec {goto _cfgd ;};_bfd :switch _gda [_gafc ]{case 35:goto _fdef ;case 37:goto _fdef ;case 47:goto _feda ;case 48:goto _fdef ;case 63:goto _fdef ;};goto _dbfg ;_gfc :_edb =_gafc +1;_efab =20;goto _edba ;_edba :if _gafc ++;_gafc ==_eec {goto _geeb ;};_bcg :switch _gda [_gafc ]{case 47:goto _agagg ;case 77:goto _gbf ;};goto _afd ;_ffd :if _gafc ++;_gafc ==_eec {goto _dfdab ;};_egf :switch _gda [_gafc ]{case 43:goto _agf ;case 45:goto _agf ;};goto _afd ;_ggb :_edb =_gafc +1;goto _gdgf ;_gdgf :if _gafc ++;_gafc ==_eec {goto _eeafc ;};_cfa :if _gda [_gafc ]==101{goto _aaaf ;};goto _afd ;_aaaf :if _gafc ++;_gafc ==_eec {goto _egg ;};_bgab :if _gda [_gafc ]==110{goto _fcbb ;};goto _ecb ;_fcbb :if _gafc ++;_gafc ==_eec {goto _dgcf ;};_dea :if _gda [_gafc ]==101{goto _cdab ;};goto _ecb ;_cdab :if _gafc ++;_gafc ==_eec {goto _gbba ;};_ecbc :if _gda [_gafc ]==114{goto _afb ;};goto _ecb ;_afb :if _gafc ++;_gafc ==_eec {goto _dfec ;};_cbe :if _gda [_gafc ]==97{goto _ebde ;};goto _ecb ;_ebde :if _gafc ++;_gafc ==_eec {goto _bcac ;};_dfce :if _gda [_gafc ]==108{goto _cecf ;};goto _ecb ;_cbcg :_edb =_gafc +1;_efab =20;goto _eee ;_eee :if _gafc ++;_gafc ==_eec {goto _aafb ;};_eace :switch _gda [_gafc ]{case 104:goto _bcc ;case 109:goto _bcc ;case 115:goto _bcc ;};goto _aca ;_aca :if _gafc ++;_gafc ==_eec {goto _begf ;};_bgfc :if _gda [_gafc ]==93{goto _abfd ;};goto _aca ;_abfd :_edb =_gafc +1;_efab =18;goto _aagfa ;_gde :_edb =_gafc +1;_efab =16;goto _aagfa ;_aagfa :if _gafc ++;_gafc ==_eec {goto _cedg ;};_bfa :if _gda [_gafc ]==93{goto _abfd ;};goto _aca ;_bcc :if _gafc ++;_gafc ==_eec {goto _gcdc ;};_bgg :if _gda [_gafc ]==93{goto _gde ;};goto _aca ;_eefb :if _gafc ++;_gafc ==_eec {goto _gcgg ;};_cgbg :goto _bcd ;_dadgf :_edb =_gafc +1;_efab =14;goto _bafe ;_bafe :if _gafc ++;_gafc ==_eec {goto _bafg ;};_dgae :switch _gda [_gafc ]{case 47:goto _bbda ;case 58:goto _bge ;case 65:goto _edgf ;case 100:goto _bbda ;case 104:goto _bge ;case 109:goto _dadgf ;case 115:goto _aee ;case 121:goto _ggag ;};goto _gcg ;_fcde :if _gafc ++;_gafc ==_eec {goto _abg ;};_fgfcc :if _gda [_gafc ]==121{goto _bbda ;};goto _afd ;_faed :_effe :_afa =34;goto _gbc ;_aedf :_afa =35;goto _gbc ;_gad :_afa =0;goto _gbc ;_ddga :_afa =36;goto _gbc ;_bcfbd :_afa =37;goto _gbc ;_acfe :_afa =1;goto _gbc ;_gfag :_afa =2;goto _gbc ;_acfc :_afa =38;goto _gbc ;_fdg :_afa =3;goto _gbc ;_ffdc :_afa =4;goto _gbc ;_bddc :_afa =39;goto _gbc ;_fcfb :_afa =5;goto _gbc ;_aaae :_afa =6;goto _gbc ;_dcd :_afa =7;goto _gbc ;_bfb :_afa =8;goto _gbc ;_adb :_afa =40;goto _gbc ;_aecc :_afa =9;goto _gbc ;_fagg :_afa =41;goto _gbc ;_cdb :_afa =10;goto _gbc ;_gfg :_afa =42;goto _gbc ;_bfaa :_afa =11;goto _gbc ;_cbcgc :_afa =43;goto _gbc ;_cdf :_afa =44;goto _gbc ;_cbda :_afa =45;goto _gbc ;_gadb :_afa =12;goto _gbc ;_deee :_afa =46;goto _gbc ;_ccg :_afa =13;goto _gbc ;_gdce :_afa =14;goto _gbc ;_cdd :_afa =15;goto _gbc ;_cga :_afa =16;goto _gbc ;_fbbg :_afa =47;goto _gbc ;_fcdgb :_afa =17;goto _gbc ;_deac :_afa =48;goto _gbc ;_faec :_afa =18;goto _gbc ;_daeb :_afa =19;goto _gbc ;_fbg :_afa =20;goto _gbc ;_beeg :_afa =49;goto _gbc ;_aac :_afa =50;goto _gbc ;_gfagf :_afa =21;goto _gbc ;_eaf :_afa =22;goto _gbc ;_agfg :_afa =23;goto _gbc ;_dcb :_afa =24;goto _gbc ;_ggbg :_afa =25;goto _gbc ;_bcgg :_afa =51;goto _gbc ;_adc :_afa =26;goto _gbc ;_gcfa :_afa =52;goto _gbc ;_dfdf :_afa =53;goto _gbc ;_cfgd :_afa =54;goto _gbc ;_geeb :_afa =55;goto _gbc ;_dfdab :_afa =56;goto _gbc ;_eeafc :_afa =57;goto _gbc ;_egg :_afa =27;goto _gbc ;_dgcf :_afa =28;goto _gbc ;_gbba :_afa =29;goto _gbc ;_dfec :_afa =30;goto _gbc ;_bcac :_afa =31;goto _gbc ;_aafb :_afa =58;goto _gbc ;_begf :_afa =32;goto _gbc ;_cedg :_afa =59;goto _gbc ;_gcdc :_afa =33;goto _gbc ;_gcgg :_afa =60;goto _gbc ;_bafg :_afa =61;goto _gbc ;_abg :_afa =62;goto _gbc ;_gbc :{};if _gafc ==_aeag {switch _afa {case 35:goto _afd ;case 0:goto _edd ;case 36:goto _gafe ;case 37:goto _fbb ;case 1:goto _edd ;case 2:goto _edd ;case 38:goto _acb ;case 3:goto _gcf ;case 4:goto _gcf ;case 39:goto _acb ;case 5:goto _gcf ;case 6:goto _gcf ;case 7:goto _gcf ;case 8:goto _edd ;case 40:goto _acb ;case 9:goto _gcf ;case 41:goto _acb ;case 10:goto _edd ;case 42:goto _acb ;case 11:goto _gcf ;case 43:goto _acb ;case 44:goto _acb ;case 45:goto _acb ;case 12:goto _cbgf ;case 46:goto _fcg ;case 13:goto _dad ;case 14:goto _edd ;case 15:goto _edd ;case 16:goto _dad ;case 47:goto _gcg ;case 17:goto _bef ;case 48:goto _aag ;case 18:goto _dbf ;case 19:goto _dbf ;case 20:goto _edd ;case 49:goto _afd ;case 50:goto _bdf ;case 21:goto _edd ;case 22:goto _edd ;case 23:goto _edd ;case 24:goto _edd ;case 25:goto _edd ;case 51:goto _bdf ;case 26:goto _cba ;case 52:goto _bdf ;case 53:goto _bdf ;case 54:goto _dbfg ;case 55:goto _afd ;case 56:goto _afd ;case 57:goto _afd ;case 27:goto _ecb ;case 28:goto _ecb ;case 29:goto _ecb ;case 30:goto _ecb ;case 31:goto _ecb ;case 58:goto _afd ;case 32:goto _edd ;case 59:goto _edd ;case 33:goto _ecb ;case 60:goto _afd ;case 61:goto _gcg ;case 62:goto _afd ;};};};if _gge > 0{copy (_gda [0:],_gda [_gge :]);};};_ =_aeag ;if _afa ==_bdge {_eb .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_ce bool ;_ceg bool ;_bee bool ;_beg bool ;_bd bool ;_bb bool ;_cg int64 ;_dc int ;};func _ge (_ggf []byte )[]byte {_add :=len (_ggf );_daf :=false ;_fcc :=false ;for _ecad :=len (_ggf )-1;_ecad >=0;_ecad --{if _ggf [_ecad ]=='0'&&!_fcc &&!_daf {_add =_ecad ;}else if _ggf [_ecad ]=='.'{_daf =true ;}else {_fcc =true ;};};if _daf &&_fcc {if _ggf [_add -1]=='.'{_add --;};return _ggf [0:_add ];};return _ggf ;};func _fdf (_ffc int64 )int64 {if _ffc < 0{return -_ffc ;};return _ffc ;};const _d =1e-10;