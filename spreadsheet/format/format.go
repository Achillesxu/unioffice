//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_af "bytes";_a "fmt";_ga "github.com/unidoc/unioffice/common/logger";_ac "io";_ge "math";_c "strconv";_gg "strings";_g "time";);const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);const _d ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";func _fc (_deb []byte )[]byte {for _fae :=0;_fae < len (_deb )/2;_fae ++{_dc :=len (_deb )-1-_fae ;_deb [_fae ],_deb [_dc ]=_deb [_dc ],_deb [_fae ];};return _deb ;};type Lexer struct{_gfb Format ;_dgcd []Format ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_gb bool ;_gf bool ;_acb bool ;_ed bool ;_bd bool ;_be bool ;_de int64 ;_cba int ;};func _gbb (_bgaf float64 )string {_cced :=_c .FormatFloat (_bgaf ,'E',-1,64);_bbe :=_c .FormatFloat (_bgaf ,'E',5,64);if len (_cced )< len (_bbe ){return _c .FormatFloat (_bgaf ,'E',2,64);};return _bbe ;};const _eggg int =0;func _cdf (_gba _g .Time ,_eab float64 ,_dcde string )[]byte {_cfc :=[]byte {};_dba :=0;for _bbd :=0;_bbd < len (_dcde );_bbd ++{var _gbbc string ;if _dcde [_bbd ]==':'{_gbbc =string (_dcde [_dba :_bbd ]);_dba =_bbd +1;}else if _bbd ==len (_dcde )-1{_gbbc =string (_dcde [_dba :_bbd +1]);}else {continue ;};switch _gbbc {case "\u0064":_cfc =_gba .AppendFormat (_cfc ,"\u0032");case "\u0068":_cfc =_gba .AppendFormat (_cfc ,"\u0033");case "\u0068\u0068":_cfc =_gba .AppendFormat (_cfc ,"\u0031\u0035");case "\u006d":_cfc =_gba .AppendFormat (_cfc ,"\u0034");case "\u006d\u006d":_cfc =_gba .AppendFormat (_cfc ,"\u0030\u0034");case "\u0073":_cfc =_gba .Round (_g .Second ).AppendFormat (_cfc ,"\u0035");case "\u0073\u002e\u0030":_cfc =_gba .Round (_g .Second /10).AppendFormat (_cfc ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_cfc =_gba .Round (_g .Second /100).AppendFormat (_cfc ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_cfc =_gba .Round (_g .Second /1000).AppendFormat (_cfc ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_cfc =_gba .Round (_g .Second ).AppendFormat (_cfc ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_cfc =_gba .Round (_g .Second /10).AppendFormat (_cfc ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_cfc =_gba .Round (_g .Second /100).AppendFormat (_cfc ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_cfc =_gba .Round (_g .Second /1000).AppendFormat (_cfc ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_cfc =_gba .AppendFormat (_cfc ,"\u0050\u004d");case "\u005b\u0068\u005d":_cfc =_c .AppendInt (_cfc ,int64 (_eab *24),10);case "\u005b\u006d\u005d":_cfc =_c .AppendInt (_cfc ,int64 (_eab *24*60),10);case "\u005b\u0073\u005d":_cfc =_c .AppendInt (_cfc ,int64 (_eab *24*60*60),10);case "":default:_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_gbbc );};if _dcde [_bbd ]==':'{_cfc =append (_cfc ,':');};};return _cfc ;};func _ega (_gad ,_db float64 ,_cdec Format )[]byte {if len (_cdec .Fractional )==0{return nil ;};_gca :=_c .AppendFloat (nil ,_gad ,'f',-1,64);if len (_gca )> 2{_gca =_gca [2:];}else {_gca =nil ;};_ae :=make ([]byte ,0,len (_gca ));_ae =append (_ae ,'.');_dcg :=0;_ec :for _bga :=0;_bga < len (_cdec .Fractional );_bga ++{_gfc :=_bga ;_ggbg :=_cdec .Fractional [_bga ];switch _ggbg .Type {case FmtTypeDigit :if _gfc < len (_gca ){_ae =append (_ae ,_gca [_gfc ]);_dcg ++;}else {_ae =append (_ae ,'0');};case FmtTypeDigitOpt :if _gfc >=0{_ae =append (_ae ,_gca [_gfc ]);_dcg ++;}else {break _ec ;};case FmtTypeLiteral :_ae =append (_ae ,_ggbg .Literal );default:_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_ggbg );};};return _ae ;};func _edcd (_def int64 )int64 {if _def < 0{return -_def ;};return _def ;};func Parse (s string )[]Format {_cbaa :=Lexer {};_cbaa .Lex (_gg .NewReader (s ));_cbaa ._dgcd =append (_cbaa ._dgcd ,_cbaa ._gfb );return _cbaa ._dgcd ;};func _dcgf (_dge []byte )[]byte {for _afa :=len (_dge )-1;_afa > 0;_afa --{if _dge [_afa ]=='9'+1{_dge [_afa ]='0';if _dge [_afa -1]=='.'{_afa --;};_dge [_afa -1]++;};};if _dge [0]=='9'+1{_dge [0]='0';copy (_dge [1:],_dge [0:]);_dge [0]='1';};return _dge ;};const _cdd int =0;func _cbe (_ce ,_ccg float64 ,_cde Format )[]byte {if len (_cde .Whole )==0{return nil ;};_gcdg :=_g .Date (1899,12,30,0,0,0,0,_g .UTC );_bb :=_gcdg .Add (_g .Duration (_ccg *float64 (24*_g .Hour )));_bb =_faeb (_bb );_cg :=_c .AppendFloat (nil ,_ce ,'f',-1,64);_fg :=make ([]byte ,0,len (_cg ));_ggd :=0;_fab :=1;_cgc :for _cce :=len (_cde .Whole )-1;_cce >=0;_cce --{_bfa :=len (_cg )-1-_ggd ;_fe :=_cde .Whole [_cce ];switch _fe .Type {case FmtTypeDigit :if _bfa >=0{_fg =append (_fg ,_cg [_bfa ]);_ggd ++;_fab =_cce ;}else {_fg =append (_fg ,'0');};case FmtTypeDigitOpt :if _bfa >=0{_fg =append (_fg ,_cg [_bfa ]);_ggd ++;_fab =_cce ;}else {for _ccef :=_cce ;_ccef >=0;_ccef --{_ddd :=_cde .Whole [_ccef ];if _ddd .Type ==FmtTypeLiteral {_fg =append (_fg ,_ddd .Literal );};};break _cgc ;};case FmtTypeDollar :for _egg :=_ggd ;_egg < len (_cg );_egg ++{_fg =append (_fg ,_cg [len (_cg )-1-_egg ]);_ggd ++;};_fg =append (_fg ,'$');case FmtTypeComma :if !_cde ._ed {_fg =append (_fg ,',');};case FmtTypeLiteral :_fg =append (_fg ,_fe .Literal );case FmtTypeDate :_fg =append (_fg ,_fc (_ggf (_bb ,_fe .DateTime ))...);case FmtTypeTime :_fg =append (_fg ,_fc (_cdf (_bb ,_ccg ,_fe .DateTime ))...);default:_ga .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_fe );};};_aafc :=_fc (_fg );if _ggd < len (_cg )&&(_ggd !=0||_cde ._be ){_fdd :=len (_cg )-_ggd ;_dcd :=make ([]byte ,len (_aafc )+_fdd );copy (_dcd ,_aafc [0:_fab ]);copy (_dcd [_fab :],_cg [0:]);copy (_dcd [_fab +_fdd :],_aafc [_fab :]);_aafc =_dcd ;};if _cde ._ed {_dac :=_af .Buffer {};_daa :=0;for _beca :=len (_aafc )-1;_beca >=0;_beca --{if !(_aafc [_beca ]>='0'&&_aafc [_beca ]<='9'){_daa ++;}else {break ;};};for _gbd :=0;_gbd < len (_aafc );_gbd ++{_cea :=(len (_aafc )-_gbd -_daa );if _cea %3==0&&_cea !=0&&_gbd !=0{_dac .WriteByte (',');};_dac .WriteByte (_aafc [_gbd ]);};_aafc =_dac .Bytes ();};return _aafc ;};var _cb =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};const _bcg int =-1;func (_ceb *Lexer )nextFmt (){_ceb ._dgcd =append (_ceb ._dgcd ,_ceb ._gfb );_ceb ._gfb =Format {}};const _dcb int =34;const _faa int =0;const _dg =1e-10;

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_aaf :=Parse (f );if len (_aaf )==1{return _ag (v ,_aaf [0],false );}else if len (_aaf )> 1&&v < 0{return _ag (v ,_aaf [1],true );}else if len (_aaf )> 2&&v ==0{return _ag (v ,_aaf [2],false );};return _ag (v ,_aaf [0],false );};const _baa int =34;func _ag (_bfg float64 ,_ba Format ,_ef bool )string {if _ba ._acb {return NumberGeneric (_bfg );};_bdf :=make ([]byte ,0,20);_bg :=_ge .Signbit (_bfg );_bge :=_ge .Abs (_bfg );_bece :=int64 (0);_gbg :=int64 (0);if _ba .IsExponential {for _bge >=10{_gbg ++;_bge /=10;};for _bge < 1{_gbg --;_bge *=10;};}else if _ba ._gf {_bge *=100;}else if _ba ._gb {if _ba ._de ==0{_ca :=_ge .Pow (10,float64 (_ba ._cba ));_gcd ,_gcdd :=1.0,1.0;_ =_gcd ;for _bc :=1.0;_bc < _ca ;_bc ++{_ ,_age :=_ge .Modf (_bge *float64 (_bc ));if _age < _gcdd {_gcdd =_age ;_gcd =_bc ;if _age ==0{break ;};};};_ba ._de =int64 (_gcd );};_bece =int64 (_bge *float64 (_ba ._de )+0.5);if len (_ba .Whole )> 0&&_bece > _ba ._de {_bece =int64 (_bge *float64 (_ba ._de ))%_ba ._de ;_bge -=float64 (_bece )/float64 (_ba ._de );}else {_bge -=float64 (_bece )/float64 (_ba ._de );if _ge .Abs (_bge )< 1{_aafb :=true ;for _ ,_cd :=range _ba .Whole {if _cd .Type ==FmtTypeDigitOpt {continue ;};if _cd .Type ==FmtTypeLiteral &&_cd .Literal ==' '{continue ;};_aafb =false ;};if _aafb {_ba .Whole =nil ;};};};};_cag :=1;for _ ,_cdg :=range _ba .Fractional {if _cdg .Type ==FmtTypeDigit ||_cdg .Type ==FmtTypeDigitOpt {_cag ++;};};_bge +=5*_ge .Pow10 (-_cag );_edc ,_gec :=_ge .Modf (_bge );_bdf =append (_bdf ,_cbe (_edc ,_bfg ,_ba )...);_bdf =append (_bdf ,_ega (_gec ,_bfg ,_ba )...);_bdf =append (_bdf ,_abe (_gbg ,_ba )...);if _ba ._gb {_bdf =_c .AppendInt (_bdf ,_bece ,10);_bdf =append (_bdf ,'/');_bdf =_c .AppendInt (_bdf ,_ba ._de ,10);};if !_ef &&_bg {return "\u002d"+string (_bdf );};return string (_bdf );};func _abe (_ad int64 ,_aab Format )[]byte {if !_aab .IsExponential ||len (_aab .Exponent )==0{return nil ;};_bff :=_c .AppendInt (nil ,_edcd (_ad ),10);_cf :=make ([]byte ,0,len (_bff )+2);_cf =append (_cf ,'E');if _ad >=0{_cf =append (_cf ,'+');}else {_cf =append (_cf ,'-');_ad *=-1;};_fb :=0;_aec :for _dcgc :=len (_aab .Exponent )-1;_dcgc >=0;_dcgc --{_fca :=len (_bff )-1-_fb ;_dgf :=_aab .Exponent [_dcgc ];switch _dgf .Type {case FmtTypeDigit :if _fca >=0{_cf =append (_cf ,_bff [_fca ]);_fb ++;}else {_cf =append (_cf ,'0');};case FmtTypeDigitOpt :if _fca >=0{_cf =append (_cf ,_bff [_fca ]);_fb ++;}else {for _eb :=_dcgc ;_eb >=0;_eb --{_gd :=_aab .Exponent [_eb ];if _gd .Type ==FmtTypeLiteral {_cf =append (_cf ,_gd .Literal );};};break _aec ;};case FmtTypeLiteral :_cf =append (_cf ,_dgf .Literal );default:_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_dgf );};};if _fb < len (_bff ){_cf =append (_cf ,_bff [len (_bff )-_fb -1:_fb -1]...);};_fc (_cf [2:]);return _cf ;};func (_aa FmtType )String ()string {if _aa >=FmtType (len (_cb )-1){return _a .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_aa );};return _d [_cb [_aa ]:_cb [_aa +1]];};const _efc int =-1;const _fbc int =34;

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_ccd :=Parse (f );var _eg Format ;if len (_ccd )==1{_eg =_ccd [0];}else if len (_ccd )==4{_eg =_ccd [3];};_da :=false ;for _ ,_ea :=range _eg .Whole {if _ea .Type ==FmtTypeText {_da =true ;};};if !_da {return v ;};_bee :=_af .Buffer {};for _ ,_bec :=range _eg .Whole {switch _bec .Type {case FmtTypeLiteral :_bee .WriteByte (_bec .Literal );case FmtTypeText :_bee .WriteString (v );};};return _bee .String ();};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ge .Abs (v )>=_b ||_ge .Abs (v )<=_dg &&v !=0{return _gbb (v );};_fag :=make ([]byte ,0,15);_fag =_c .AppendFloat (_fag ,v ,'f',-1,64);if len (_fag )> 11{_edb :=_fag [11]-'0';if _edb >=5&&_edb <=9{_fag [10]++;_fag =_fag [0:11];_fag =_dcgf (_fag );};_fag =_fag [0:11];}else if len (_fag )==11{if _fag [len (_fag )-1]=='9'{_fag [len (_fag )-1]++;_fag =_dcgf (_fag );};};_fag =_aeb (_fag );return string (_fag );};

// AddToken adds a format token to the format.
func (_gc *Format )AddToken (t FmtType ,l []byte ){if _gc ._bd {_gc ._bd =false ;return ;};switch t {case FmtTypeDecimal :_gc ._be =true ;case FmtTypeUnderscore :_gc ._bd =true ;case FmtTypeText :_gc .Whole =append (_gc .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_gc .Whole =append (_gc .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_gc ._gf =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_cc :=range l {if _gc .IsExponential {_gc .Exponent =append (_gc .Exponent ,Token {Type :t ,Literal :_cc });}else if !_gc ._be {_gc .Whole =append (_gc .Whole ,Token {Type :t ,Literal :_cc });}else {_gc .Fractional =append (_gc .Fractional ,Token {Type :t ,Literal :_cc });};};case FmtTypeDigitOptThousands :_gc ._ed =true ;case FmtTypeFraction :_bed :=_gg .Split (string (l ),"\u002f");if len (_bed )==2{_gc ._gb =true ;_gc ._de ,_ =_c .ParseInt (_bed [1],10,64);for _ ,_fa :=range _bed [1]{if _fa =='?'||_fa =='0'{_gc ._cba ++;};};};default:_ga .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};func _aeb (_adf []byte )[]byte {_ece :=len (_adf );_ffe :=false ;_efe :=false ;for _bgafe :=len (_adf )-1;_bgafe >=0;_bgafe --{if _adf [_bgafe ]=='0'&&!_efe &&!_ffe {_ece =_bgafe ;}else if _adf [_bgafe ]=='.'{_ffe =true ;}else {_efe =true ;};};if _ffe &&_efe {if _adf [_ece -1]=='.'{_ece --;};return _adf [0:_ece ];};return _adf ;};func _faeb (_cafd _g .Time )_g .Time {_cafd =_cafd .UTC ();return _g .Date (_cafd .Year (),_cafd .Month (),_cafd .Day (),_cafd .Hour (),_cafd .Minute (),_cafd .Second (),_cafd .Nanosecond (),_g .Local );};func (_eba *Lexer )Lex (r _ac .Reader ){_ceag ,_geca ,_dbf :=0,0,0;_gdc :=-1;_ecg ,_cdff ,_aeeg :=0,0,0;_ =_cdff ;_ =_aeeg ;_bda :=1;_ =_bda ;_bgef :=make ([]byte ,4096);_aga :=false ;for !_aga {_eag :=0;if _ecg > 0{_eag =_geca -_ecg ;};_geca =0;_feb ,_daag :=r .Read (_bgef [_eag :]);if _feb ==0||_daag !=nil {_aga =true ;};_dbf =_feb +_eag ;if _dbf < len (_bgef ){_gdc =_dbf ;};{_ceag =_fbc ;_ecg =0;_cdff =0;_aeeg =0;};{if _geca ==_dbf {goto _acg ;};switch _ceag {case 34:goto _gcdc ;case 35:goto _feba ;case 0:goto _egc ;case 36:goto _ddac ;case 37:goto _faea ;case 1:goto _fdb ;case 2:goto _ggfge ;case 38:goto _efeg ;case 3:goto _ffb ;case 4:goto _gadd ;case 39:goto _gag ;case 5:goto _ead ;case 6:goto _aafe ;case 7:goto _ffc ;case 8:goto _gdeg ;case 40:goto _fabae ;case 9:goto _ffca ;case 41:goto _bgg ;case 10:goto _aeea ;case 42:goto _abd ;case 11:goto _badd ;case 43:goto _ccb ;case 44:goto _agc ;case 45:goto _edg ;case 12:goto _bfag ;case 46:goto _bag ;case 13:goto _fdag ;case 14:goto _cagc ;case 15:goto _cbaae ;case 16:goto _acad ;case 47:goto _cbad ;case 17:goto _bcge ;case 48:goto _ddb ;case 18:goto _fcb ;case 19:goto _ded ;case 20:goto _ffcf ;case 49:goto _abbe ;case 50:goto _adb ;case 21:goto _efcc ;case 22:goto _afcg ;case 23:goto _agad ;case 24:goto _ecag ;case 25:goto _edeb ;case 51:goto _baf ;case 26:goto _bbcc ;case 52:goto _fde ;case 53:goto _edge ;case 54:goto _ecdd ;case 55:goto _acf ;case 56:goto _bcc ;case 57:goto _afaf ;case 27:goto _cac ;case 28:goto _fgb ;case 29:goto _fec ;case 30:goto _agdg ;case 31:goto _ceg ;case 58:goto _cca ;case 32:goto _ebbg ;case 59:goto _gfa ;case 33:goto _ccec ;case 60:goto _fee ;case 61:goto _egd ;case 62:goto _gaa ;};goto _afba ;_dfd :switch _aeeg {case 2:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeDigit ,nil );};case 3:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_geca =(_cdff )-1;};case 8:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypePercent ,nil );};case 13:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeFraction ,_bgef [_ecg :_cdff ]);};case 14:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeDate ,_bgef [_ecg :_cdff ]);};case 15:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeTime ,_bgef [_ecg :_cdff ]);};case 16:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeTime ,_bgef [_ecg :_cdff ]);};case 18:{_geca =(_cdff )-1;};case 20:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg :_cdff ]);};case 21:{_geca =(_cdff )-1;_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg +1:_cdff -1]);};};goto _ggfg ;_dfg :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeFraction ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_ddfe :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeDigitOpt ,nil );};goto _ggfg ;_cgd :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeDigitOptThousands ,nil );};goto _ggfg ;_ffa :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypePercent ,nil );};goto _ggfg ;_dce :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeDate ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_aad :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeDigit ,nil );};goto _ggfg ;_cdc :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeTime ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_bbg :_geca =(_cdff )-1;{_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_bef :_cdff =_geca +1;{_eba ._gfb ._acb =true ;};goto _ggfg ;_fedc :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_fgd :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeDollar ,nil );};goto _ggfg ;_fda :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeComma ,nil );};goto _ggfg ;_afg :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeDecimal ,nil );};goto _ggfg ;_dbg :_cdff =_geca +1;{_eba .nextFmt ();};goto _ggfg ;_cgdc :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeText ,nil );};goto _ggfg ;_fdf :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeUnderscore ,nil );};goto _ggfg ;_aba :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_bad :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg +1:_cdff -1]);};goto _ggfg ;_ccf :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeDigitOpt ,nil );};goto _ggfg ;_eage :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeFraction ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_gdf :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypePercent ,nil );};goto _ggfg ;_afad :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeDate ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_bfc :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeDigit ,nil );};goto _ggfg ;_afgf :_cdff =_geca ;_geca --;{_eba ._gfb .AddToken (FmtTypeTime ,_bgef [_ecg :_cdff ]);};goto _ggfg ;_eec :_cdff =_geca ;_geca --;{};goto _ggfg ;_ada :_cdff =_geca +1;{_eba ._gfb .IsExponential =true ;};goto _ggfg ;_cbag :_cdff =_geca +1;{_eba ._gfb .AddToken (FmtTypeLiteral ,_bgef [_ecg +1:_cdff ]);};goto _ggfg ;_ggfg :_ecg =0;if _geca ++;_geca ==_dbf {goto _dde ;};_gcdc :_ecg =_geca ;switch _bgef [_geca ]{case 34:goto _afbg ;case 35:goto _dceg ;case 36:goto _fgd ;case 37:goto _bdag ;case 44:goto _fda ;case 46:goto _afg ;case 47:goto _dae ;case 48:goto _ebb ;case 58:goto _dfcc ;case 59:goto _dbg ;case 63:goto _befg ;case 64:goto _cgdc ;case 65:goto _ccea ;case 69:goto _bedf ;case 71:goto _fgg ;case 91:goto _dddd ;case 92:goto _fcg ;case 95:goto _fdf ;case 100:goto _dae ;case 104:goto _dfcc ;case 109:goto _dga ;case 115:goto _aebg ;case 121:goto _ced ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _bfef ;};goto _fedc ;_afbg :_cdff =_geca +1;_aeeg =20;goto _bcgd ;_bcgd :if _geca ++;_geca ==_dbf {goto _aaab ;};_feba :if _bgef [_geca ]==34{goto _gda ;};goto _cfa ;_cfa :if _geca ++;_geca ==_dbf {goto _ebda ;};_egc :if _bgef [_geca ]==34{goto _gda ;};goto _cfa ;_gda :_cdff =_geca +1;_aeeg =21;goto _dgcc ;_dgcc :if _geca ++;_geca ==_dbf {goto _febe ;};_ddac :if _bgef [_geca ]==34{goto _cfa ;};goto _bad ;_dceg :_cdff =_geca +1;_aeeg =3;goto _cab ;_cab :if _geca ++;_geca ==_dbf {goto _bfff ;};_faea :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _ged ;case 44:goto _cadf ;case 47:goto _beb ;case 48:goto _ged ;case 63:goto _ged ;};goto _ccf ;_ged :if _geca ++;_geca ==_dbf {goto _ccbb ;};_fdb :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _ged ;case 47:goto _beb ;case 48:goto _ged ;case 63:goto _ged ;};goto _dfd ;_beb :if _geca ++;_geca ==_dbf {goto _aac ;};_ggfge :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _gdac ;case 48:goto _eac ;case 63:goto _fbg ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _deff ;};goto _dfd ;_fbg :_cdff =_geca +1;goto _gcbe ;_gcbe :if _geca ++;_geca ==_dbf {goto _gdgd ;};_efeg :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _fbg ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _fbg ;case 63:goto _fbg ;case 65:goto _cgg ;};goto _eage ;_cgg :if _geca ++;_geca ==_dbf {goto _ecfe ;};_ffb :switch _bgef [_geca ]{case 47:goto _ggbd ;case 77:goto _bgeb ;};goto _dfg ;_ggbd :if _geca ++;_geca ==_dbf {goto _gdd ;};_gadd :if _bgef [_geca ]==80{goto _bedg ;};goto _dfg ;_bedg :_cdff =_geca +1;goto _ddc ;_ddc :if _geca ++;_geca ==_dbf {goto _caf ;};_gag :if _bgef [_geca ]==65{goto _cgg ;};goto _eage ;_bgeb :if _geca ++;_geca ==_dbf {goto _dcc ;};_ead :if _bgef [_geca ]==47{goto _faba ;};goto _dfg ;_faba :if _geca ++;_geca ==_dbf {goto _afd ;};_aafe :if _bgef [_geca ]==80{goto _cbc ;};goto _dfg ;_cbc :if _geca ++;_geca ==_dbf {goto _fge ;};_ffc :if _bgef [_geca ]==77{goto _bedg ;};goto _dfg ;_gdac :if _geca ++;_geca ==_dbf {goto _abeg ;};_gdeg :switch _bgef [_geca ]{case 35:goto _ecf ;case 37:goto _bdad ;case 63:goto _ecf ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _gbbg ;};goto _dfd ;_ecf :_cdff =_geca +1;goto _aada ;_aada :if _geca ++;_geca ==_dbf {goto _eceg ;};_fabae :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _egf ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _fbg ;case 63:goto _fbg ;case 65:goto _cgg ;};goto _eage ;_egf :if _geca ++;_geca ==_dbf {goto _bgec ;};_ffca :switch _bgef [_geca ]{case 35:goto _efcg ;case 44:goto _efcg ;case 46:goto _efcg ;case 48:goto _efcg ;case 63:goto _efcg ;};goto _dfg ;_efcg :_cdff =_geca +1;goto _aca ;_aca :if _geca ++;_geca ==_dbf {goto _cgf ;};_bgg :switch _bgef [_geca ]{case 35:goto _efcg ;case 44:goto _efcg ;case 46:goto _efcg ;case 48:goto _efcg ;case 63:goto _efcg ;case 65:goto _cgg ;};goto _eage ;_bdad :if _geca ++;_geca ==_dbf {goto _gecc ;};_aeea :if _bgef [_geca ]==37{goto _bdad ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _gbbg ;};goto _dfd ;_gbbg :_cdff =_geca +1;_aeeg =13;goto _dffc ;_dffc :if _geca ++;_geca ==_dbf {goto _gae ;};_abd :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _aebe ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _fcc ;case 63:goto _fbg ;case 65:goto _cgg ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _gbbg ;};goto _eage ;_aebe :if _geca ++;_geca ==_dbf {goto _fbb ;};_badd :switch _bgef [_geca ]{case 35:goto _efcg ;case 37:goto _bdad ;case 44:goto _efcg ;case 46:goto _efcg ;case 63:goto _efcg ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _gbbg ;};goto _dfg ;_fcc :_cdff =_geca +1;goto _efg ;_efg :if _geca ++;_geca ==_dbf {goto _ege ;};_ccb :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _fcc ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _fcc ;case 63:goto _fbg ;case 65:goto _cgg ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _gbbg ;};goto _eage ;_eac :_cdff =_geca +1;goto _dfc ;_dfc :if _geca ++;_geca ==_dbf {goto _gfcd ;};_agc :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _fcc ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _eac ;case 63:goto _fbg ;case 65:goto _cgg ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _deff ;};goto _eage ;_deff :_cdff =_geca +1;goto _ffbe ;_ffbe :if _geca ++;_geca ==_dbf {goto _fddd ;};_edg :switch _bgef [_geca ]{case 35:goto _fbg ;case 37:goto _gbbg ;case 44:goto _fbg ;case 46:goto _fbg ;case 48:goto _eac ;case 63:goto _fbg ;case 65:goto _cgg ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _deff ;};goto _eage ;_cadf :if _geca ++;_geca ==_dbf {goto _dad ;};_bfag :if _bgef [_geca ]==35{goto _cgd ;};goto _ddfe ;_bdag :_cdff =_geca +1;_aeeg =8;goto _edd ;_edd :if _geca ++;_geca ==_dbf {goto _dceb ;};_bag :switch _bgef [_geca ]{case 35:goto _fbgc ;case 37:goto _eea ;case 48:goto _aaa ;case 63:goto _fbgc ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _cee ;};goto _gdf ;_fbgc :if _geca ++;_geca ==_dbf {goto _ecdc ;};_fdag :switch _bgef [_geca ]{case 35:goto _fbgc ;case 47:goto _beb ;case 48:goto _fbgc ;case 63:goto _fbgc ;};goto _ffa ;_eea :if _geca ++;_geca ==_dbf {goto _gged ;};_cagc :if _bgef [_geca ]==37{goto _eea ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _cee ;};goto _dfd ;_cee :if _geca ++;_geca ==_dbf {goto _bac ;};_cbaae :switch _bgef [_geca ]{case 37:goto _eea ;case 47:goto _beb ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _cee ;};goto _dfd ;_aaa :if _geca ++;_geca ==_dbf {goto _ddg ;};_acad :switch _bgef [_geca ]{case 35:goto _fbgc ;case 37:goto _eea ;case 47:goto _beb ;case 48:goto _aaa ;case 63:goto _fbgc ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _cee ;};goto _ffa ;_dae :_cdff =_geca +1;goto _adfd ;_adfd :if _geca ++;_geca ==_dbf {goto _egac ;};_cbad :switch _bgef [_geca ]{case 47:goto _dae ;case 100:goto _dae ;case 109:goto _dae ;case 121:goto _dfga ;};goto _afad ;_dfga :if _geca ++;_geca ==_dbf {goto _gdaa ;};_bcge :if _bgef [_geca ]==121{goto _dae ;};goto _dce ;_ebb :_cdff =_geca +1;_aeeg =2;goto _faab ;_faab :if _geca ++;_geca ==_dbf {goto _beed ;};_ddb :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _adg ;case 47:goto _beb ;case 48:goto _bfca ;case 63:goto _ged ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _bfe ;};goto _bfc ;_adg :if _geca ++;_geca ==_dbf {goto _cfab ;};_fcb :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _adg ;case 47:goto _beb ;case 48:goto _adg ;case 63:goto _ged ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _cee ;};goto _aad ;_bfca :if _geca ++;_geca ==_dbf {goto _cbea ;};_ded :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _adg ;case 47:goto _beb ;case 48:goto _bfca ;case 63:goto _ged ;};if 49<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _bfe ;};goto _aad ;_bfe :if _geca ++;_geca ==_dbf {goto _ggdd ;};_ffcf :switch _bgef [_geca ]{case 37:goto _cee ;case 47:goto _beb ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _bfe ;};goto _dfd ;_bfef :_cdff =_geca +1;_aeeg =20;goto _cdce ;_cdce :if _geca ++;_geca ==_dbf {goto _fdbe ;};_abbe :switch _bgef [_geca ]{case 37:goto _cee ;case 47:goto _beb ;};if 48<=_bgef [_geca ]&&_bgef [_geca ]<=57{goto _bfe ;};goto _aba ;_dfcc :_cdff =_geca +1;_aeeg =15;goto _cfe ;_cfe :if _geca ++;_geca ==_dbf {goto _efea ;};_adb :switch _bgef [_geca ]{case 58:goto _dfcc ;case 65:goto _gcba ;case 104:goto _dfcc ;case 109:goto _dfcc ;case 115:goto _aebg ;};goto _afgf ;_gcba :if _geca ++;_geca ==_dbf {goto _eae ;};_efcc :switch _bgef [_geca ]{case 47:goto _gcf ;case 77:goto _gcc ;};goto _dfd ;_gcf :if _geca ++;_geca ==_dbf {goto _ffd ;};_afcg :if _bgef [_geca ]==80{goto _dfcc ;};goto _dfd ;_gcc :if _geca ++;_geca ==_dbf {goto _afdb ;};_agad :if _bgef [_geca ]==47{goto _aadb ;};goto _dfd ;_aadb :if _geca ++;_geca ==_dbf {goto _dgac ;};_ecag :if _bgef [_geca ]==80{goto _fdfb ;};goto _dfd ;_fdfb :if _geca ++;_geca ==_dbf {goto _dfda ;};_edeb :if _bgef [_geca ]==77{goto _dfcc ;};goto _dfd ;_aebg :_cdff =_geca +1;_aeeg =15;goto _dgeb ;_dgeb :if _geca ++;_geca ==_dbf {goto _gfbd ;};_baf :switch _bgef [_geca ]{case 46:goto _dfgf ;case 58:goto _dfcc ;case 65:goto _gcba ;case 104:goto _dfcc ;case 109:goto _dfcc ;case 115:goto _aebg ;};goto _afgf ;_dfgf :if _geca ++;_geca ==_dbf {goto _aaabe ;};_bbcc :if _bgef [_geca ]==48{goto _eageg ;};goto _cdc ;_eageg :_cdff =_geca +1;_aeeg =15;goto _aeeb ;_aeeb :if _geca ++;_geca ==_dbf {goto _ccba ;};_fde :switch _bgef [_geca ]{case 48:goto _afgff ;case 58:goto _dfcc ;case 65:goto _gcba ;case 104:goto _dfcc ;case 109:goto _dfcc ;case 115:goto _aebg ;};goto _afgf ;_afgff :_cdff =_geca +1;_aeeg =15;goto _bebe ;_bebe :if _geca ++;_geca ==_dbf {goto _gcdga ;};_edge :switch _bgef [_geca ]{case 48:goto _dfcc ;case 58:goto _dfcc ;case 65:goto _gcba ;case 104:goto _dfcc ;case 109:goto _dfcc ;case 115:goto _aebg ;};goto _afgf ;_befg :_cdff =_geca +1;_aeeg =5;goto _bde ;_bde :if _geca ++;_geca ==_dbf {goto _bacf ;};_ecdd :switch _bgef [_geca ]{case 35:goto _ged ;case 37:goto _ged ;case 47:goto _beb ;case 48:goto _ged ;case 63:goto _ged ;};goto _eec ;_ccea :_cdff =_geca +1;_aeeg =20;goto _fgf ;_fgf :if _geca ++;_geca ==_dbf {goto _egca ;};_acf :switch _bgef [_geca ]{case 47:goto _gcf ;case 77:goto _gcc ;};goto _aba ;_bedf :if _geca ++;_geca ==_dbf {goto _cabd ;};_bcc :switch _bgef [_geca ]{case 43:goto _ada ;case 45:goto _ada ;};goto _aba ;_fgg :_cdff =_geca +1;goto _cfag ;_cfag :if _geca ++;_geca ==_dbf {goto _fagf ;};_afaf :if _bgef [_geca ]==101{goto _agd ;};goto _aba ;_agd :if _geca ++;_geca ==_dbf {goto _dag ;};_cac :if _bgef [_geca ]==110{goto _egae ;};goto _bbg ;_egae :if _geca ++;_geca ==_dbf {goto _gdec ;};_fgb :if _bgef [_geca ]==101{goto _dgfd ;};goto _bbg ;_dgfd :if _geca ++;_geca ==_dbf {goto _dee ;};_fec :if _bgef [_geca ]==114{goto _ccgf ;};goto _bbg ;_ccgf :if _geca ++;_geca ==_dbf {goto _gcbd ;};_agdg :if _bgef [_geca ]==97{goto _cbcc ;};goto _bbg ;_cbcc :if _geca ++;_geca ==_dbf {goto _feca ;};_ceg :if _bgef [_geca ]==108{goto _bef ;};goto _bbg ;_dddd :_cdff =_geca +1;_aeeg =20;goto _aag ;_aag :if _geca ++;_geca ==_dbf {goto _ceeg ;};_cca :switch _bgef [_geca ]{case 104:goto _bage ;case 109:goto _bage ;case 115:goto _bage ;};goto _aagd ;_aagd :if _geca ++;_geca ==_dbf {goto _cdfc ;};_ebbg :if _bgef [_geca ]==93{goto _ebdb ;};goto _aagd ;_ebdb :_cdff =_geca +1;_aeeg =18;goto _cdfg ;_gecd :_cdff =_geca +1;_aeeg =16;goto _cdfg ;_cdfg :if _geca ++;_geca ==_dbf {goto _aabc ;};_gfa :if _bgef [_geca ]==93{goto _ebdb ;};goto _aagd ;_bage :if _geca ++;_geca ==_dbf {goto _cead ;};_ccec :if _bgef [_geca ]==93{goto _gecd ;};goto _aagd ;_fcg :if _geca ++;_geca ==_dbf {goto _ebc ;};_fee :goto _cbag ;_dga :_cdff =_geca +1;_aeeg =14;goto _bged ;_bged :if _geca ++;_geca ==_dbf {goto _feab ;};_egd :switch _bgef [_geca ]{case 47:goto _dae ;case 58:goto _dfcc ;case 65:goto _gcba ;case 100:goto _dae ;case 104:goto _dfcc ;case 109:goto _dga ;case 115:goto _aebg ;case 121:goto _dfga ;};goto _afad ;_ced :if _geca ++;_geca ==_dbf {goto _bebg ;};_gaa :if _bgef [_geca ]==121{goto _dae ;};goto _aba ;_afba :_dde :_ceag =34;goto _acg ;_aaab :_ceag =35;goto _acg ;_ebda :_ceag =0;goto _acg ;_febe :_ceag =36;goto _acg ;_bfff :_ceag =37;goto _acg ;_ccbb :_ceag =1;goto _acg ;_aac :_ceag =2;goto _acg ;_gdgd :_ceag =38;goto _acg ;_ecfe :_ceag =3;goto _acg ;_gdd :_ceag =4;goto _acg ;_caf :_ceag =39;goto _acg ;_dcc :_ceag =5;goto _acg ;_afd :_ceag =6;goto _acg ;_fge :_ceag =7;goto _acg ;_abeg :_ceag =8;goto _acg ;_eceg :_ceag =40;goto _acg ;_bgec :_ceag =9;goto _acg ;_cgf :_ceag =41;goto _acg ;_gecc :_ceag =10;goto _acg ;_gae :_ceag =42;goto _acg ;_fbb :_ceag =11;goto _acg ;_ege :_ceag =43;goto _acg ;_gfcd :_ceag =44;goto _acg ;_fddd :_ceag =45;goto _acg ;_dad :_ceag =12;goto _acg ;_dceb :_ceag =46;goto _acg ;_ecdc :_ceag =13;goto _acg ;_gged :_ceag =14;goto _acg ;_bac :_ceag =15;goto _acg ;_ddg :_ceag =16;goto _acg ;_egac :_ceag =47;goto _acg ;_gdaa :_ceag =17;goto _acg ;_beed :_ceag =48;goto _acg ;_cfab :_ceag =18;goto _acg ;_cbea :_ceag =19;goto _acg ;_ggdd :_ceag =20;goto _acg ;_fdbe :_ceag =49;goto _acg ;_efea :_ceag =50;goto _acg ;_eae :_ceag =21;goto _acg ;_ffd :_ceag =22;goto _acg ;_afdb :_ceag =23;goto _acg ;_dgac :_ceag =24;goto _acg ;_dfda :_ceag =25;goto _acg ;_gfbd :_ceag =51;goto _acg ;_aaabe :_ceag =26;goto _acg ;_ccba :_ceag =52;goto _acg ;_gcdga :_ceag =53;goto _acg ;_bacf :_ceag =54;goto _acg ;_egca :_ceag =55;goto _acg ;_cabd :_ceag =56;goto _acg ;_fagf :_ceag =57;goto _acg ;_dag :_ceag =27;goto _acg ;_gdec :_ceag =28;goto _acg ;_dee :_ceag =29;goto _acg ;_gcbd :_ceag =30;goto _acg ;_feca :_ceag =31;goto _acg ;_ceeg :_ceag =58;goto _acg ;_cdfc :_ceag =32;goto _acg ;_aabc :_ceag =59;goto _acg ;_cead :_ceag =33;goto _acg ;_ebc :_ceag =60;goto _acg ;_feab :_ceag =61;goto _acg ;_bebg :_ceag =62;goto _acg ;_acg :{};if _geca ==_gdc {switch _ceag {case 35:goto _aba ;case 0:goto _dfd ;case 36:goto _bad ;case 37:goto _ccf ;case 1:goto _dfd ;case 2:goto _dfd ;case 38:goto _eage ;case 3:goto _dfg ;case 4:goto _dfg ;case 39:goto _eage ;case 5:goto _dfg ;case 6:goto _dfg ;case 7:goto _dfg ;case 8:goto _dfd ;case 40:goto _eage ;case 9:goto _dfg ;case 41:goto _eage ;case 10:goto _dfd ;case 42:goto _eage ;case 11:goto _dfg ;case 43:goto _eage ;case 44:goto _eage ;case 45:goto _eage ;case 12:goto _ddfe ;case 46:goto _gdf ;case 13:goto _ffa ;case 14:goto _dfd ;case 15:goto _dfd ;case 16:goto _ffa ;case 47:goto _afad ;case 17:goto _dce ;case 48:goto _bfc ;case 18:goto _aad ;case 19:goto _aad ;case 20:goto _dfd ;case 49:goto _aba ;case 50:goto _afgf ;case 21:goto _dfd ;case 22:goto _dfd ;case 23:goto _dfd ;case 24:goto _dfd ;case 25:goto _dfd ;case 51:goto _afgf ;case 26:goto _cdc ;case 52:goto _afgf ;case 53:goto _afgf ;case 54:goto _eec ;case 55:goto _aba ;case 56:goto _aba ;case 57:goto _aba ;case 27:goto _bbg ;case 28:goto _bbg ;case 29:goto _bbg ;case 30:goto _bbg ;case 31:goto _bbg ;case 58:goto _aba ;case 32:goto _dfd ;case 59:goto _dfd ;case 33:goto _bbg ;case 60:goto _aba ;case 61:goto _afad ;case 62:goto _aba ;};};};if _ecg > 0{copy (_bgef [0:],_bgef [_ecg :]);};};_ =_gdc ;if _ceag ==_bcg {_ga .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};func IsNumber (data string )(_gge bool ){_gbad ,_aeca ,_ecd :=0,0,len (data );_df :=len (data );_fef ,_ddf ,_dfe :=0,0,0;_ =_ddf ;_ =_dfe ;_ =_fef ;{_gbad =_faa ;_fef =0;_ddf =0;_dfe =0;};{if _aeca ==_ecd {goto _fcag ;};switch _gbad {case 0:goto _ccdc ;case 1:goto _aafca ;case 2:goto _dda ;case 3:goto _feg ;case 4:goto _dgbe ;case 5:goto _bgag ;case 6:goto _dff ;case 7:goto _ggdb ;};goto _ccge ;_aae :_ddf =_aeca ;_aeca --;{_gge =false ;};goto _ggdc ;_eca :_ddf =_aeca ;_aeca --;{_gge =_ddf ==len (data );};goto _ggdc ;_abb :_ddf =_aeca ;_aeca --;{_gge =_ddf ==len (data );};goto _ggdc ;_fea :switch _dfe {case 2:{_aeca =(_ddf )-1;_gge =_ddf ==len (data );};case 3:{_aeca =(_ddf )-1;_gge =false ;};};goto _ggdc ;_ggdc :_fef =0;if _aeca ++;_aeca ==_ecd {goto _fddg ;};_ccdc :_fef =_aeca ;switch data [_aeca ]{case 43:goto _bdc ;case 45:goto _bdc ;};if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _aee ;};goto _dgb ;_dgb :if _aeca ++;_aeca ==_ecd {goto _aeee ;};_aafca :goto _dgb ;_bdc :if _aeca ++;_aeca ==_ecd {goto _fefd ;};_dda :if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _aee ;};goto _dgb ;_aee :if _aeca ++;_aeca ==_ecd {goto _abbb ;};_feg :if data [_aeca ]==46{goto _ee ;};if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _aee ;};goto _dgb ;_ee :if _aeca ++;_aeca ==_ecd {goto _cad ;};_dgbe :if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _geg ;};goto _dgb ;_geg :if _aeca ++;_aeca ==_ecd {goto _bbc ;};_bgag :if data [_aeca ]==69{goto _afbf ;};if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _geg ;};goto _dgb ;_afbf :if _aeca ++;_aeca ==_ecd {goto _gcb ;};_dff :switch data [_aeca ]{case 43:goto _gdg ;case 45:goto _gdg ;};goto _dgb ;_gdg :_ddf =_aeca +1;_dfe =3;goto _ebd ;_gde :_ddf =_aeca +1;_dfe =2;goto _ebd ;_ebd :if _aeca ++;_aeca ==_ecd {goto _cfcb ;};_ggdb :if 48<=data [_aeca ]&&data [_aeca ]<=57{goto _gde ;};goto _dgb ;_ccge :_fddg :_gbad =0;goto _fcag ;_aeee :_gbad =1;goto _fcag ;_fefd :_gbad =2;goto _fcag ;_abbb :_gbad =3;goto _fcag ;_cad :_gbad =4;goto _fcag ;_bbc :_gbad =5;goto _fcag ;_gcb :_gbad =6;goto _fcag ;_cfcb :_gbad =7;goto _fcag ;_fcag :{};if _aeca ==_df {switch _gbad {case 1:goto _aae ;case 2:goto _aae ;case 3:goto _eca ;case 4:goto _aae ;case 5:goto _abb ;case 6:goto _aae ;case 7:goto _fea ;};};};if _gbad ==_bcg {return false ;};return ;};const _b =1e11;

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_bdg ,_ :=_c .ParseFloat (v ,64);return Number (_bdg ,f );};return String (v ,f );};func _ggf (_bdgc _g .Time ,_bdb string )[]byte {_egb :=[]byte {};_ede :=0;for _afc :=0;_afc < len (_bdb );_afc ++{var _fed string ;if _bdb [_afc ]=='/'{_fed =string (_bdb [_ede :_afc ]);_ede =_afc +1;}else if _afc ==len (_bdb )-1{_fed =string (_bdb [_ede :_afc +1]);}else {continue ;};switch _fed {case "\u0079\u0079":_egb =_bdgc .AppendFormat (_egb ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_egb =_bdgc .AppendFormat (_egb ,"\u0032\u0030\u0030\u0036");case "\u006d":_egb =_bdgc .AppendFormat (_egb ,"\u0031");case "\u006d\u006d":_egb =_bdgc .AppendFormat (_egb ,"\u0030\u0031");case "\u006d\u006d\u006d":_egb =_bdgc .AppendFormat (_egb ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_egb =_bdgc .AppendFormat (_egb ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _bdgc .Month (){case _g .January ,_g .July ,_g .June :_egb =append (_egb ,'J');case _g .February :_egb =append (_egb ,'M');case _g .March ,_g .May :_egb =append (_egb ,'M');case _g .April ,_g .August :_egb =append (_egb ,'A');case _g .September :_egb =append (_egb ,'S');case _g .October :_egb =append (_egb ,'O');case _g .November :_egb =append (_egb ,'N');case _g .December :_egb =append (_egb ,'D');};case "\u0064":_egb =_bdgc .AppendFormat (_egb ,"\u0032");case "\u0064\u0064":_egb =_bdgc .AppendFormat (_egb ,"\u0030\u0032");case "\u0064\u0064\u0064":_egb =_bdgc .AppendFormat (_egb ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_egb =_bdgc .AppendFormat (_egb ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_ga .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_fed );};if _bdb [_afc ]=='/'{_egb =append (_egb ,'/');};};return _egb ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;