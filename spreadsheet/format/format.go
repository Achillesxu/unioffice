//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_fg "bytes";_d "fmt";_de "github.com/unidoc/unioffice";_b "io";_be "math";_a "strconv";_ba "strings";_c "time";);func _beae (_adgd int64 ,_dec Format )[]byte {if !_dec .IsExponential ||len (_dec .Exponent )==0{return nil ;};_eca :=_a .AppendInt (nil ,_abbd (_adgd ),10);_deg :=make ([]byte ,0,len (_eca )+2);_deg =append (_deg ,'E');if _adgd >=0{_deg =append (_deg ,'+');}else {_deg =append (_deg ,'-');_adgd *=-1;};_fbe :=0;_bdg :for _bcd :=len (_dec .Exponent )-1;_bcd >=0;_bcd --{_ade :=len (_eca )-1-_fbe ;_fee :=_dec .Exponent [_bcd ];switch _fee .Type {case FmtTypeDigit :if _ade >=0{_deg =append (_deg ,_eca [_ade ]);_fbe ++;}else {_deg =append (_deg ,'0');};case FmtTypeDigitOpt :if _ade >=0{_deg =append (_deg ,_eca [_ade ]);_fbe ++;}else {for _egf :=_bcd ;_egf >=0;_egf --{_aag :=_dec .Exponent [_egf ];if _aag .Type ==FmtTypeLiteral {_deg =append (_deg ,_aag .Literal );};};break _bdg ;};case FmtTypeLiteral :_deg =append (_deg ,_fee .Literal );default:_de .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_fee );};};if _fbe < len (_eca ){_deg =append (_deg ,_eca [len (_eca )-_fbe -1:_fbe -1]...);};_ff (_deg [2:]);return _deg ;};const _gdd int =0;func _dac (_fgb _c .Time ,_ead float64 ,_adb string )[]byte {_fge :=[]byte {};_eadc :=0;for _ccg :=0;_ccg < len (_adb );_ccg ++{var _bgac string ;if _adb [_ccg ]==':'{_bgac =string (_adb [_eadc :_ccg ]);_eadc =_ccg +1;}else if _ccg ==len (_adb )-1{_bgac =string (_adb [_eadc :_ccg +1]);}else {continue ;};switch _bgac {case "\u0064":_fge =_fgb .AppendFormat (_fge ,"\u0032");case "\u0068":_fge =_fgb .AppendFormat (_fge ,"\u0033");case "\u0068\u0068":_fge =_fgb .AppendFormat (_fge ,"\u0031\u0035");case "\u006d":_fge =_fgb .AppendFormat (_fge ,"\u0034");case "\u006d\u006d":_fge =_fgb .AppendFormat (_fge ,"\u0030\u0034");case "\u0073":_fge =_fgb .Round (_c .Second ).AppendFormat (_fge ,"\u0035");case "\u0073\u002e\u0030":_fge =_fgb .Round (_c .Second /10).AppendFormat (_fge ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_fge =_fgb .Round (_c .Second /100).AppendFormat (_fge ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_fge =_fgb .Round (_c .Second /1000).AppendFormat (_fge ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_fge =_fgb .Round (_c .Second ).AppendFormat (_fge ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_fge =_fgb .Round (_c .Second /10).AppendFormat (_fge ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_fge =_fgb .Round (_c .Second /100).AppendFormat (_fge ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_fge =_fgb .Round (_c .Second /1000).AppendFormat (_fge ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_fge =_fgb .AppendFormat (_fge ,"\u0050\u004d");case "\u005b\u0068\u005d":_fge =_a .AppendInt (_fge ,int64 (_ead *24),10);case "\u005b\u006d\u005d":_fge =_a .AppendInt (_fge ,int64 (_ead *24*60),10);case "\u005b\u0073\u005d":_fge =_a .AppendInt (_fge ,int64 (_ead *24*60*60),10);case "":default:_de .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bgac );};if _adb [_ccg ]==':'{_fge =append (_fge ,':');};};return _fge ;};func _gcge (_bdb float64 )string {_beec :=_a .FormatFloat (_bdb ,'E',-1,64);_bab :=_a .FormatFloat (_bdb ,'E',5,64);if len (_beec )< len (_bab ){return _a .FormatFloat (_bdb ,'E',2,64);};return _bab ;};const _fcc int =0;func (_e FmtType )String ()string {if _e >=FmtType (len (_bb )-1){return _d .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_e );};return _cf [_bb [_e ]:_bb [_e +1]];};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_cb :=Parse (f );var _fb Format ;if len (_cb )==1{_fb =_cb [0];}else if len (_cb )==4{_fb =_cb [3];};_bg :=false ;for _ ,_cd :=range _fb .Whole {if _cd .Type ==FmtTypeText {_bg =true ;};};if !_bg {return v ;};_egc :=_fg .Buffer {};for _ ,_ca :=range _fb .Whole {switch _ca .Type {case FmtTypeLiteral :_egc .WriteByte (_ca .Literal );case FmtTypeText :_egc .WriteString (v );};};return _egc .String ();};func _daf (_ga []byte )[]byte {_gdb :=len (_ga );_bbg :=false ;_acd :=false ;for _ecc :=len (_ga )-1;_ecc >=0;_ecc --{if _ga [_ecc ]=='0'&&!_acd &&!_bbg {_gdb =_ecc ;}else if _ga [_ecc ]=='.'{_bbg =true ;}else {_acd =true ;};};if _bbg &&_acd {if _ga [_gdb -1]=='.'{_gdb --;};return _ga [0:_gdb ];};return _ga ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func _dbf (_bbc []byte )[]byte {for _egb :=len (_bbc )-1;_egb > 0;_egb --{if _bbc [_egb ]=='9'+1{_bbc [_egb ]='0';if _bbc [_egb -1]=='.'{_egb --;};_bbc [_egb -1]++;};};if _bbc [0]=='9'+1{_bbc [0]='0';copy (_bbc [1:],_bbc [0:]);_bbc [0]='1';};return _bbc ;};const _gdg int =0;func _ff (_ag []byte )[]byte {for _ggg :=0;_ggg < len (_ag )/2;_ggg ++{_fgcg :=len (_ag )-1-_ggg ;_ag [_ggg ],_ag [_fgcg ]=_ag [_fgcg ],_ag [_ggg ];};return _ag ;};func _abbd (_beag int64 )int64 {if _beag < 0{return -_beag ;};return _beag ;};func _aabc (_fec _c .Time ,_cdf string )[]byte {_ddd :=[]byte {};_fcdc :=0;for _fga :=0;_fga < len (_cdf );_fga ++{var _cfg string ;if _cdf [_fga ]=='/'{_cfg =string (_cdf [_fcdc :_fga ]);_fcdc =_fga +1;}else if _fga ==len (_cdf )-1{_cfg =string (_cdf [_fcdc :_fga +1]);}else {continue ;};switch _cfg {case "\u0079\u0079":_ddd =_fec .AppendFormat (_ddd ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_ddd =_fec .AppendFormat (_ddd ,"\u0032\u0030\u0030\u0036");case "\u006d":_ddd =_fec .AppendFormat (_ddd ,"\u0031");case "\u006d\u006d":_ddd =_fec .AppendFormat (_ddd ,"\u0030\u0031");case "\u006d\u006d\u006d":_ddd =_fec .AppendFormat (_ddd ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_ddd =_fec .AppendFormat (_ddd ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _fec .Month (){case _c .January ,_c .July ,_c .June :_ddd =append (_ddd ,'J');case _c .February :_ddd =append (_ddd ,'M');case _c .March ,_c .May :_ddd =append (_ddd ,'M');case _c .April ,_c .August :_ddd =append (_ddd ,'A');case _c .September :_ddd =append (_ddd ,'S');case _c .October :_ddd =append (_ddd ,'O');case _c .November :_ddd =append (_ddd ,'N');case _c .December :_ddd =append (_ddd ,'D');};case "\u0064":_ddd =_fec .AppendFormat (_ddd ,"\u0032");case "\u0064\u0064":_ddd =_fec .AppendFormat (_ddd ,"\u0030\u0032");case "\u0064\u0064\u0064":_ddd =_fec .AppendFormat (_ddd ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_ddd =_fec .AppendFormat (_ddd ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_de .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_cfg );};if _cdf [_fga ]=='/'{_ddd =append (_ddd ,'/');};};return _ddd ;};

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_aae :=Parse (f );if len (_aae )==1{return _adg (v ,_aae [0],false );}else if len (_aae )> 1&&v < 0{return _adg (v ,_aae [1],true );}else if len (_aae )> 2&&v ==0{return _adg (v ,_aae [2],false );};return _adg (v ,_aae [0],false );};func (_geb *Lexer )Lex (r _b .Reader ){_bad ,_dg ,_bafg :=0,0,0;_bag :=-1;_efb ,_dfb ,_beca :=0,0,0;_ =_dfb ;_ =_beca ;_ede :=1;_ =_ede ;_aca :=make ([]byte ,4096);_bfg :=false ;for !_bfg {_gfb :=0;if _efb > 0{_gfb =_dg -_efb ;};_dg =0;_aed ,_deeb :=r .Read (_aca [_gfb :]);if _aed ==0||_deeb !=nil {_bfg =true ;};_bafg =_aed +_gfb ;if _bafg < len (_aca ){_bag =_bafg ;};{_bad =_ebc ;_efb =0;_dfb =0;_beca =0;};{if _dg ==_bafg {goto _fce ;};switch _bad {case 34:goto _eccd ;case 35:goto _cgfc ;case 0:goto _bffg ;case 36:goto _dcge ;case 37:goto _deea ;case 1:goto _bfca ;case 2:goto _aee ;case 38:goto _bffe ;case 3:goto _bbad ;case 4:goto _fae ;case 39:goto _bcfb ;case 5:goto _gggc ;case 6:goto _bdgg ;case 7:goto _ffee ;case 8:goto _ebb ;case 40:goto _fddd ;case 9:goto _bfe ;case 41:goto _cacf ;case 10:goto _ffgg ;case 42:goto _feg ;case 11:goto _afbb ;case 43:goto _aga ;case 44:goto _fagc ;case 45:goto _fffe ;case 12:goto _agba ;case 46:goto _dea ;case 13:goto _edee ;case 14:goto _bfd ;case 15:goto _gcbf ;case 16:goto _gbe ;case 47:goto _ebg ;case 17:goto _cge ;case 48:goto _fcdca ;case 18:goto _bfaf ;case 19:goto _aabe ;case 20:goto _bbe ;case 49:goto _gbdc ;case 50:goto _decg ;case 21:goto _ffaa ;case 22:goto _aaf ;case 23:goto _efe ;case 24:goto _gebf ;case 25:goto _dfce ;case 51:goto _ace ;case 26:goto _eec ;case 52:goto _bfdb ;case 53:goto _aeef ;case 54:goto _def ;case 55:goto _ffc ;case 56:goto _ceg ;case 57:goto _bcbf ;case 27:goto _ecbf ;case 28:goto _ffcf ;case 29:goto _ggc ;case 30:goto _fgee ;case 31:goto _abef ;case 58:goto _deed ;case 32:goto _dbge ;case 59:goto _dgdg ;case 33:goto _dfea ;case 60:goto _fcde ;case 61:goto _dcf ;case 62:goto _gac ;};goto _caf ;_fdd :switch _beca {case 2:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeDigit ,nil );};case 3:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_dg =(_dfb )-1;};case 8:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypePercent ,nil );};case 13:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeFraction ,_aca [_efb :_dfb ]);};case 14:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeDate ,_aca [_efb :_dfb ]);};case 15:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeTime ,_aca [_efb :_dfb ]);};case 16:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeTime ,_aca [_efb :_dfb ]);};case 18:{_dg =(_dfb )-1;};case 20:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb :_dfb ]);};case 21:{_dg =(_dfb )-1;_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb +1:_dfb -1]);};};goto _gbf ;_bba :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeFraction ,_aca [_efb :_dfb ]);};goto _gbf ;_aagf :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeDigitOpt ,nil );};goto _gbf ;_fgg :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeDigitOptThousands ,nil );};goto _gbf ;_dgg :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypePercent ,nil );};goto _gbf ;_cff :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeDate ,_aca [_efb :_dfb ]);};goto _gbf ;_dde :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeDigit ,nil );};goto _gbf ;_bgg :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeTime ,_aca [_efb :_dfb ]);};goto _gbf ;_gdba :_dg =(_dfb )-1;{_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb :_dfb ]);};goto _gbf ;_afa :_dfb =_dg +1;{_geb ._ccgb ._bff =true ;};goto _gbf ;_cacg :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb :_dfb ]);};goto _gbf ;_aeb :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeDollar ,nil );};goto _gbf ;_ggae :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeComma ,nil );};goto _gbf ;_age :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeDecimal ,nil );};goto _gbf ;_gcf :_dfb =_dg +1;{_geb .nextFmt ();};goto _gbf ;_fgea :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeText ,nil );};goto _gbf ;_eeeb :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeUnderscore ,nil );};goto _gbf ;_adbb :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb :_dfb ]);};goto _gbf ;_gcba :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb +1:_dfb -1]);};goto _gbf ;_gbd :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeDigitOpt ,nil );};goto _gbf ;_dgd :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeFraction ,_aca [_efb :_dfb ]);};goto _gbf ;_acbe :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypePercent ,nil );};goto _gbf ;_gdcc :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeDate ,_aca [_efb :_dfb ]);};goto _gbf ;_egaf :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeDigit ,nil );};goto _gbf ;_ded :_dfb =_dg ;_dg --;{_geb ._ccgb .AddToken (FmtTypeTime ,_aca [_efb :_dfb ]);};goto _gbf ;_eff :_dfb =_dg ;_dg --;{};goto _gbf ;_gdf :_dfb =_dg +1;{_geb ._ccgb .IsExponential =true ;};goto _gbf ;_cebf :_dfb =_dg +1;{_geb ._ccgb .AddToken (FmtTypeLiteral ,_aca [_efb +1:_dfb ]);};goto _gbf ;_gbf :_efb =0;if _dg ++;_dg ==_bafg {goto _acba ;};_eccd :_efb =_dg ;switch _aca [_dg ]{case 34:goto _cgfa ;case 35:goto _gddd ;case 36:goto _aeb ;case 37:goto _gcfe ;case 44:goto _ggae ;case 46:goto _age ;case 47:goto _cgc ;case 48:goto _fgaa ;case 58:goto _efc ;case 59:goto _gcf ;case 63:goto _ddc ;case 64:goto _fgea ;case 65:goto _cag ;case 69:goto _dgde ;case 71:goto _egfg ;case 91:goto _cfd ;case 92:goto _cfdg ;case 95:goto _eeeb ;case 100:goto _cgc ;case 104:goto _efc ;case 109:goto _eab ;case 115:goto _aabf ;case 121:goto _bddb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _afaae ;};goto _cacg ;_cgfa :_dfb =_dg +1;_beca =20;goto _dcd ;_dcd :if _dg ++;_dg ==_bafg {goto _cbbb ;};_cgfc :if _aca [_dg ]==34{goto _gec ;};goto _afae ;_afae :if _dg ++;_dg ==_bafg {goto _agaf ;};_bffg :if _aca [_dg ]==34{goto _gec ;};goto _afae ;_gec :_dfb =_dg +1;_beca =21;goto _gdgf ;_gdgf :if _dg ++;_dg ==_bafg {goto _cgce ;};_dcge :if _aca [_dg ]==34{goto _afae ;};goto _gcba ;_gddd :_dfb =_dg +1;_beca =3;goto _ccf ;_ccf :if _dg ++;_dg ==_bafg {goto _fedb ;};_deea :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _fag ;case 44:goto _cfbbe ;case 47:goto _dca ;case 48:goto _fag ;case 63:goto _fag ;};goto _gbd ;_fag :if _dg ++;_dg ==_bafg {goto _aeeg ;};_bfca :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _fag ;case 47:goto _dca ;case 48:goto _fag ;case 63:goto _fag ;};goto _fdd ;_dca :if _dg ++;_dg ==_bafg {goto _ddb ;};_aee :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _fbd ;case 48:goto _bfa ;case 63:goto _gfe ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _ddae ;};goto _fdd ;_gfe :_dfb =_dg +1;goto _eef ;_eef :if _dg ++;_dg ==_bafg {goto _agaa ;};_bffe :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _gfe ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _gfe ;case 63:goto _gfe ;case 65:goto _fdb ;};goto _dgd ;_fdb :if _dg ++;_dg ==_bafg {goto _eba ;};_bbad :switch _aca [_dg ]{case 47:goto _dbee ;case 77:goto _cfa ;};goto _bba ;_dbee :if _dg ++;_dg ==_bafg {goto _cgdd ;};_fae :if _aca [_dg ]==80{goto _ccgg ;};goto _bba ;_ccgg :_dfb =_dg +1;goto _bcc ;_bcc :if _dg ++;_dg ==_bafg {goto _fcfa ;};_bcfb :if _aca [_dg ]==65{goto _fdb ;};goto _dgd ;_cfa :if _dg ++;_dg ==_bafg {goto _cfae ;};_gggc :if _aca [_dg ]==47{goto _baa ;};goto _bba ;_baa :if _dg ++;_dg ==_bafg {goto _degb ;};_bdgg :if _aca [_dg ]==80{goto _cab ;};goto _bba ;_cab :if _dg ++;_dg ==_bafg {goto _cgbc ;};_ffee :if _aca [_dg ]==77{goto _ccgg ;};goto _bba ;_fbd :if _dg ++;_dg ==_bafg {goto _cdcg ;};_ebb :switch _aca [_dg ]{case 35:goto _afb ;case 37:goto _ffa ;case 63:goto _afb ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _gfcd ;};goto _fdd ;_afb :_dfb =_dg +1;goto _aedb ;_aedb :if _dg ++;_dg ==_bafg {goto _gef ;};_fddd :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _bgc ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _gfe ;case 63:goto _gfe ;case 65:goto _fdb ;};goto _dgd ;_bgc :if _dg ++;_dg ==_bafg {goto _gee ;};_bfe :switch _aca [_dg ]{case 35:goto _begc ;case 44:goto _begc ;case 46:goto _begc ;case 48:goto _begc ;case 63:goto _begc ;};goto _bba ;_begc :_dfb =_dg +1;goto _gfc ;_gfc :if _dg ++;_dg ==_bafg {goto _efba ;};_cacf :switch _aca [_dg ]{case 35:goto _begc ;case 44:goto _begc ;case 46:goto _begc ;case 48:goto _begc ;case 63:goto _begc ;case 65:goto _fdb ;};goto _dgd ;_ffa :if _dg ++;_dg ==_bafg {goto _ecba ;};_ffgg :if _aca [_dg ]==37{goto _ffa ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _gfcd ;};goto _fdd ;_gfcd :_dfb =_dg +1;_beca =13;goto _ege ;_ege :if _dg ++;_dg ==_bafg {goto _efg ;};_feg :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _cbb ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _cgb ;case 63:goto _gfe ;case 65:goto _fdb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _gfcd ;};goto _dgd ;_cbb :if _dg ++;_dg ==_bafg {goto _cdgb ;};_afbb :switch _aca [_dg ]{case 35:goto _begc ;case 37:goto _ffa ;case 44:goto _begc ;case 46:goto _begc ;case 63:goto _begc ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _gfcd ;};goto _bba ;_cgb :_dfb =_dg +1;goto _bfgf ;_bfgf :if _dg ++;_dg ==_bafg {goto _bead ;};_aga :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _cgb ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _cgb ;case 63:goto _gfe ;case 65:goto _fdb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _gfcd ;};goto _dgd ;_bfa :_dfb =_dg +1;goto _babc ;_babc :if _dg ++;_dg ==_bafg {goto _dbc ;};_fagc :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _cgb ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _bfa ;case 63:goto _gfe ;case 65:goto _fdb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _ddae ;};goto _dgd ;_ddae :_dfb =_dg +1;goto _abe ;_abe :if _dg ++;_dg ==_bafg {goto _fgf ;};_fffe :switch _aca [_dg ]{case 35:goto _gfe ;case 37:goto _gfcd ;case 44:goto _gfe ;case 46:goto _gfe ;case 48:goto _bfa ;case 63:goto _gfe ;case 65:goto _fdb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _ddae ;};goto _dgd ;_cfbbe :if _dg ++;_dg ==_bafg {goto _eedf ;};_agba :if _aca [_dg ]==35{goto _fgg ;};goto _aagf ;_gcfe :_dfb =_dg +1;_beca =8;goto _dafe ;_dafe :if _dg ++;_dg ==_bafg {goto _bcfe ;};_dea :switch _aca [_dg ]{case 35:goto _bcb ;case 37:goto _gbdd ;case 48:goto _cbbf ;case 63:goto _bcb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _edef ;};goto _acbe ;_bcb :if _dg ++;_dg ==_bafg {goto _eae ;};_edee :switch _aca [_dg ]{case 35:goto _bcb ;case 47:goto _dca ;case 48:goto _bcb ;case 63:goto _bcb ;};goto _dgg ;_gbdd :if _dg ++;_dg ==_bafg {goto _egab ;};_bfd :if _aca [_dg ]==37{goto _gbdd ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _edef ;};goto _fdd ;_edef :if _dg ++;_dg ==_bafg {goto _bgb ;};_gcbf :switch _aca [_dg ]{case 37:goto _gbdd ;case 47:goto _dca ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _edef ;};goto _fdd ;_cbbf :if _dg ++;_dg ==_bafg {goto _adef ;};_gbe :switch _aca [_dg ]{case 35:goto _bcb ;case 37:goto _gbdd ;case 47:goto _dca ;case 48:goto _cbbf ;case 63:goto _bcb ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _edef ;};goto _dgg ;_cgc :_dfb =_dg +1;goto _cef ;_cef :if _dg ++;_dg ==_bafg {goto _gea ;};_ebg :switch _aca [_dg ]{case 47:goto _cgc ;case 100:goto _cgc ;case 109:goto _cgc ;case 121:goto _cfad ;};goto _gdcc ;_cfad :if _dg ++;_dg ==_bafg {goto _aadg ;};_cge :if _aca [_dg ]==121{goto _cgc ;};goto _cff ;_fgaa :_dfb =_dg +1;_beca =2;goto _bada ;_bada :if _dg ++;_dg ==_bafg {goto _cfge ;};_fcdca :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _cebd ;case 47:goto _dca ;case 48:goto _dfg ;case 63:goto _fag ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _afaa ;};goto _egaf ;_cebd :if _dg ++;_dg ==_bafg {goto _ccgc ;};_bfaf :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _cebd ;case 47:goto _dca ;case 48:goto _cebd ;case 63:goto _fag ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _edef ;};goto _dde ;_dfg :if _dg ++;_dg ==_bafg {goto _bgea ;};_aabe :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _cebd ;case 47:goto _dca ;case 48:goto _dfg ;case 63:goto _fag ;};if 49<=_aca [_dg ]&&_aca [_dg ]<=57{goto _afaa ;};goto _dde ;_afaa :if _dg ++;_dg ==_bafg {goto _bade ;};_bbe :switch _aca [_dg ]{case 37:goto _edef ;case 47:goto _dca ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _afaa ;};goto _fdd ;_afaae :_dfb =_dg +1;_beca =20;goto _cdb ;_cdb :if _dg ++;_dg ==_bafg {goto _cbca ;};_gbdc :switch _aca [_dg ]{case 37:goto _edef ;case 47:goto _dca ;};if 48<=_aca [_dg ]&&_aca [_dg ]<=57{goto _afaa ;};goto _adbb ;_efc :_dfb =_dg +1;_beca =15;goto _dge ;_dge :if _dg ++;_dg ==_bafg {goto _cbcc ;};_decg :switch _aca [_dg ]{case 58:goto _efc ;case 65:goto _fgde ;case 104:goto _efc ;case 109:goto _efc ;case 115:goto _aabf ;};goto _ded ;_fgde :if _dg ++;_dg ==_bafg {goto _fccd ;};_ffaa :switch _aca [_dg ]{case 47:goto _cce ;case 77:goto _gbdcc ;};goto _fdd ;_cce :if _dg ++;_dg ==_bafg {goto _aea ;};_aaf :if _aca [_dg ]==80{goto _efc ;};goto _fdd ;_gbdcc :if _dg ++;_dg ==_bafg {goto _egd ;};_efe :if _aca [_dg ]==47{goto _fde ;};goto _fdd ;_fde :if _dg ++;_dg ==_bafg {goto _ffca ;};_gebf :if _aca [_dg ]==80{goto _ecad ;};goto _fdd ;_ecad :if _dg ++;_dg ==_bafg {goto _acee ;};_dfce :if _aca [_dg ]==77{goto _efc ;};goto _fdd ;_aabf :_dfb =_dg +1;_beca =15;goto _gff ;_gff :if _dg ++;_dg ==_bafg {goto _abed ;};_ace :switch _aca [_dg ]{case 46:goto _adf ;case 58:goto _efc ;case 65:goto _fgde ;case 104:goto _efc ;case 109:goto _efc ;case 115:goto _aabf ;};goto _ded ;_adf :if _dg ++;_dg ==_bafg {goto _aaa ;};_eec :if _aca [_dg ]==48{goto _edb ;};goto _bgg ;_edb :_dfb =_dg +1;_beca =15;goto _eaa ;_eaa :if _dg ++;_dg ==_bafg {goto _gfd ;};_bfdb :switch _aca [_dg ]{case 48:goto _cdc ;case 58:goto _efc ;case 65:goto _fgde ;case 104:goto _efc ;case 109:goto _efc ;case 115:goto _aabf ;};goto _ded ;_cdc :_dfb =_dg +1;_beca =15;goto _aded ;_aded :if _dg ++;_dg ==_bafg {goto _agd ;};_aeef :switch _aca [_dg ]{case 48:goto _efc ;case 58:goto _efc ;case 65:goto _fgde ;case 104:goto _efc ;case 109:goto _efc ;case 115:goto _aabf ;};goto _ded ;_ddc :_dfb =_dg +1;_beca =5;goto _cebc ;_cebc :if _dg ++;_dg ==_bafg {goto _bgab ;};_def :switch _aca [_dg ]{case 35:goto _fag ;case 37:goto _fag ;case 47:goto _dca ;case 48:goto _fag ;case 63:goto _fag ;};goto _eff ;_cag :_dfb =_dg +1;_beca =20;goto _gbab ;_gbab :if _dg ++;_dg ==_bafg {goto _dbad ;};_ffc :switch _aca [_dg ]{case 47:goto _cce ;case 77:goto _gbdcc ;};goto _adbb ;_dgde :if _dg ++;_dg ==_bafg {goto _bae ;};_ceg :switch _aca [_dg ]{case 43:goto _gdf ;case 45:goto _gdf ;};goto _adbb ;_egfg :_dfb =_dg +1;goto _dedd ;_dedd :if _dg ++;_dg ==_bafg {goto _agfe ;};_bcbf :if _aca [_dg ]==101{goto _ffeg ;};goto _adbb ;_ffeg :if _dg ++;_dg ==_bafg {goto _feec ;};_ecbf :if _aca [_dg ]==110{goto _feb ;};goto _gdba ;_feb :if _dg ++;_dg ==_bafg {goto _bggd ;};_ffcf :if _aca [_dg ]==101{goto _geg ;};goto _gdba ;_geg :if _dg ++;_dg ==_bafg {goto _egfe ;};_ggc :if _aca [_dg ]==114{goto _egfa ;};goto _gdba ;_egfa :if _dg ++;_dg ==_bafg {goto _bfaff ;};_fgee :if _aca [_dg ]==97{goto _gbgb ;};goto _gdba ;_gbgb :if _dg ++;_dg ==_bafg {goto _ffea ;};_abef :if _aca [_dg ]==108{goto _afa ;};goto _gdba ;_cfd :_dfb =_dg +1;_beca =20;goto _cdge ;_cdge :if _dg ++;_dg ==_bafg {goto _gfbc ;};_deed :switch _aca [_dg ]{case 104:goto _cgd ;case 109:goto _cgd ;case 115:goto _cgd ;};goto _fcg ;_fcg :if _dg ++;_dg ==_bafg {goto _cdbd ;};_dbge :if _aca [_dg ]==93{goto _bge ;};goto _fcg ;_bge :_dfb =_dg +1;_beca =18;goto _dbga ;_bafe :_dfb =_dg +1;_beca =16;goto _dbga ;_dbga :if _dg ++;_dg ==_bafg {goto _aebd ;};_dgdg :if _aca [_dg ]==93{goto _bge ;};goto _fcg ;_cgd :if _dg ++;_dg ==_bafg {goto _bggb ;};_dfea :if _aca [_dg ]==93{goto _bafe ;};goto _fcg ;_cfdg :if _dg ++;_dg ==_bafg {goto _bgga ;};_fcde :goto _cebf ;_eab :_dfb =_dg +1;_beca =14;goto _adfe ;_adfe :if _dg ++;_dg ==_bafg {goto _dfae ;};_dcf :switch _aca [_dg ]{case 47:goto _cgc ;case 58:goto _efc ;case 65:goto _fgde ;case 100:goto _cgc ;case 104:goto _efc ;case 109:goto _eab ;case 115:goto _aabf ;case 121:goto _cfad ;};goto _gdcc ;_bddb :if _dg ++;_dg ==_bafg {goto _bcba ;};_gac :if _aca [_dg ]==121{goto _cgc ;};goto _adbb ;_caf :_acba :_bad =34;goto _fce ;_cbbb :_bad =35;goto _fce ;_agaf :_bad =0;goto _fce ;_cgce :_bad =36;goto _fce ;_fedb :_bad =37;goto _fce ;_aeeg :_bad =1;goto _fce ;_ddb :_bad =2;goto _fce ;_agaa :_bad =38;goto _fce ;_eba :_bad =3;goto _fce ;_cgdd :_bad =4;goto _fce ;_fcfa :_bad =39;goto _fce ;_cfae :_bad =5;goto _fce ;_degb :_bad =6;goto _fce ;_cgbc :_bad =7;goto _fce ;_cdcg :_bad =8;goto _fce ;_gef :_bad =40;goto _fce ;_gee :_bad =9;goto _fce ;_efba :_bad =41;goto _fce ;_ecba :_bad =10;goto _fce ;_efg :_bad =42;goto _fce ;_cdgb :_bad =11;goto _fce ;_bead :_bad =43;goto _fce ;_dbc :_bad =44;goto _fce ;_fgf :_bad =45;goto _fce ;_eedf :_bad =12;goto _fce ;_bcfe :_bad =46;goto _fce ;_eae :_bad =13;goto _fce ;_egab :_bad =14;goto _fce ;_bgb :_bad =15;goto _fce ;_adef :_bad =16;goto _fce ;_gea :_bad =47;goto _fce ;_aadg :_bad =17;goto _fce ;_cfge :_bad =48;goto _fce ;_ccgc :_bad =18;goto _fce ;_bgea :_bad =19;goto _fce ;_bade :_bad =20;goto _fce ;_cbca :_bad =49;goto _fce ;_cbcc :_bad =50;goto _fce ;_fccd :_bad =21;goto _fce ;_aea :_bad =22;goto _fce ;_egd :_bad =23;goto _fce ;_ffca :_bad =24;goto _fce ;_acee :_bad =25;goto _fce ;_abed :_bad =51;goto _fce ;_aaa :_bad =26;goto _fce ;_gfd :_bad =52;goto _fce ;_agd :_bad =53;goto _fce ;_bgab :_bad =54;goto _fce ;_dbad :_bad =55;goto _fce ;_bae :_bad =56;goto _fce ;_agfe :_bad =57;goto _fce ;_feec :_bad =27;goto _fce ;_bggd :_bad =28;goto _fce ;_egfe :_bad =29;goto _fce ;_bfaff :_bad =30;goto _fce ;_ffea :_bad =31;goto _fce ;_gfbc :_bad =58;goto _fce ;_cdbd :_bad =32;goto _fce ;_aebd :_bad =59;goto _fce ;_bggb :_bad =33;goto _fce ;_bgga :_bad =60;goto _fce ;_dfae :_bad =61;goto _fce ;_bcba :_bad =62;goto _fce ;_fce :{};if _dg ==_bag {switch _bad {case 35:goto _adbb ;case 0:goto _fdd ;case 36:goto _gcba ;case 37:goto _gbd ;case 1:goto _fdd ;case 2:goto _fdd ;case 38:goto _dgd ;case 3:goto _bba ;case 4:goto _bba ;case 39:goto _dgd ;case 5:goto _bba ;case 6:goto _bba ;case 7:goto _bba ;case 8:goto _fdd ;case 40:goto _dgd ;case 9:goto _bba ;case 41:goto _dgd ;case 10:goto _fdd ;case 42:goto _dgd ;case 11:goto _bba ;case 43:goto _dgd ;case 44:goto _dgd ;case 45:goto _dgd ;case 12:goto _aagf ;case 46:goto _acbe ;case 13:goto _dgg ;case 14:goto _fdd ;case 15:goto _fdd ;case 16:goto _dgg ;case 47:goto _gdcc ;case 17:goto _cff ;case 48:goto _egaf ;case 18:goto _dde ;case 19:goto _dde ;case 20:goto _fdd ;case 49:goto _adbb ;case 50:goto _ded ;case 21:goto _fdd ;case 22:goto _fdd ;case 23:goto _fdd ;case 24:goto _fdd ;case 25:goto _fdd ;case 51:goto _ded ;case 26:goto _bgg ;case 52:goto _ded ;case 53:goto _ded ;case 54:goto _eff ;case 55:goto _adbb ;case 56:goto _adbb ;case 57:goto _adbb ;case 27:goto _gdba ;case 28:goto _gdba ;case 29:goto _gdba ;case 30:goto _gdba ;case 31:goto _gdba ;case 58:goto _adbb ;case 32:goto _fdd ;case 59:goto _fdd ;case 33:goto _gdba ;case 60:goto _adbb ;case 61:goto _gdcc ;case 62:goto _adbb ;};};};if _efb > 0{copy (_aca [0:],_aca [_efb :]);};};_ =_bag ;if _bad ==_edg {_de .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};const _edg int =-1;type Lexer struct{_ccgb Format ;_agf []Format ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_db bool ;_bf bool ;_bff bool ;_df bool ;_ef bool ;_aa bool ;_gg int64 ;_eg int ;};func (_ceb *Lexer )nextFmt (){_ceb ._agf =append (_ceb ._agf ,_ceb ._ccgb );_ceb ._ccgb =Format {}};const _g =1e-10;func _bbb (_dbag _c .Time )_c .Time {_dbag =_dbag .UTC ();return _c .Date (_dbag .Year (),_dbag .Month (),_dbag .Day (),_dbag .Hour (),_dbag .Minute (),_dbag .Second (),_dbag .Nanosecond (),_c .Local );};const _dbae int =34;const _abg int =-1;const _ae =1e11;

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _be .Abs (v )>=_ae ||_be .Abs (v )<=_g &&v !=0{return _gcge (v );};_cbc :=make ([]byte ,0,15);_cbc =_a .AppendFloat (_cbc ,v ,'f',-1,64);if len (_cbc )> 11{_da :=_cbc [11]-'0';if _da >=5&&_da <=9{_cbc [10]++;_cbc =_cbc [0:11];_cbc =_dbf (_cbc );};_cbc =_cbc [0:11];}else if len (_cbc )==11{if _cbc [len (_cbc )-1]=='9'{_cbc [len (_cbc )-1]++;_cbc =_dbf (_cbc );};};_cbc =_daf (_cbc );return string (_cbc );};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_cg ,_ :=_a .ParseFloat (v ,64);return Number (_cg ,f );};return String (v ,f );};

// AddToken adds a format token to the format.
func (_dd *Format )AddToken (t FmtType ,l []byte ){if _dd ._ef {_dd ._ef =false ;return ;};switch t {case FmtTypeDecimal :_dd ._aa =true ;case FmtTypeUnderscore :_dd ._ef =true ;case FmtTypeText :_dd .Whole =append (_dd .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_dd .Whole =append (_dd .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_dd ._bf =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ec :=range l {if _dd .IsExponential {_dd .Exponent =append (_dd .Exponent ,Token {Type :t ,Literal :_ec });}else if !_dd ._aa {_dd .Whole =append (_dd .Whole ,Token {Type :t ,Literal :_ec });}else {_dd .Fractional =append (_dd .Fractional ,Token {Type :t ,Literal :_ec });};};case FmtTypeDigitOptThousands :_dd ._df =true ;case FmtTypeFraction :_ad :=_ba .Split (string (l ),"\u002f");if len (_ad )==2{_dd ._db =true ;_dd ._gg ,_ =_a .ParseInt (_ad [1],10,64);for _ ,_dc :=range _ad [1]{if _dc =='?'||_dc =='0'{_dd ._eg ++;};};};default:_de .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};func _cbe (_bca ,_ffb float64 ,_gdc Format )[]byte {if len (_gdc .Fractional )==0{return nil ;};_dfe :=_a .AppendFloat (nil ,_bca ,'f',-1,64);if len (_dfe )> 2{_dfe =_dfe [2:];}else {_dfe =nil ;};_cfbb :=make ([]byte ,0,len (_dfe ));_cfbb =append (_cfbb ,'.');_agb :=0;_gba :for _fed :=0;_fed < len (_gdc .Fractional );_fed ++{_eee :=_fed ;_bdd :=_gdc .Fractional [_fed ];switch _bdd .Type {case FmtTypeDigit :if _eee < len (_dfe ){_cfbb =append (_cfbb ,_dfe [_eee ]);_agb ++;}else {_cfbb =append (_cfbb ,'0');};case FmtTypeDigitOpt :if _eee >=0{_cfbb =append (_cfbb ,_dfe [_eee ]);_agb ++;}else {break _gba ;};case FmtTypeLiteral :_cfbb =append (_cfbb ,_bdd .Literal );default:_de .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_bdd );};};return _cfbb ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const _cdg int =34;func IsNumber (data string )(_bcf bool ){_dee ,_bdgd ,_dbfb :=0,0,len (data );_dba :=len (data );_gcd ,_agcg ,_ed :=0,0,0;_ =_agcg ;_ =_ed ;_ =_gcd ;{_dee =_gdd ;_gcd =0;_agcg =0;_ed =0;};{if _bdgd ==_dbfb {goto _fbg ;};switch _dee {case 0:goto _ffbg ;case 1:goto _cdfg ;case 2:goto _aeg ;case 3:goto _cbeb ;case 4:goto _cac ;case 5:goto _ddf ;case 6:goto _dcg ;case 7:goto _fcfe ;};goto _beg ;_ge :_agcg =_bdgd ;_bdgd --;{_bcf =false ;};goto _cga ;_bec :_agcg =_bdgd ;_bdgd --;{_bcf =_agcg ==len (data );};goto _cga ;_bdc :_agcg =_bdgd ;_bdgd --;{_bcf =_agcg ==len (data );};goto _cga ;_dbb :switch _ed {case 2:{_bdgd =(_agcg )-1;_bcf =_agcg ==len (data );};case 3:{_bdgd =(_agcg )-1;_bcf =false ;};};goto _cga ;_cga :_gcd =0;if _bdgd ++;_bdgd ==_dbfb {goto _gbg ;};_ffbg :_gcd =_bdgd ;switch data [_bdgd ]{case 43:goto _acb ;case 45:goto _acb ;};if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _adc ;};goto _dcc ;_dcc :if _bdgd ++;_bdgd ==_dbfb {goto _fgab ;};_cdfg :goto _dcc ;_acb :if _bdgd ++;_bdgd ==_dbfb {goto _ccc ;};_aeg :if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _adc ;};goto _dcc ;_adc :if _bdgd ++;_bdgd ==_dbfb {goto _bfbc ;};_cbeb :if data [_bdgd ]==46{goto _ecce ;};if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _adc ;};goto _dcc ;_ecce :if _bdgd ++;_bdgd ==_dbfb {goto _cgg ;};_cac :if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _bgfd ;};goto _dcc ;_bgfd :if _bdgd ++;_bdgd ==_dbfb {goto _eda ;};_ddf :if data [_bdgd ]==69{goto _cad ;};if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _bgfd ;};goto _dcc ;_cad :if _bdgd ++;_bdgd ==_dbfb {goto _faag ;};_dcg :switch data [_bdgd ]{case 43:goto _baf ;case 45:goto _baf ;};goto _dcc ;_baf :_agcg =_bdgd +1;_ed =3;goto _ega ;_cbea :_agcg =_bdgd +1;_ed =2;goto _ega ;_ega :if _bdgd ++;_bdgd ==_dbfb {goto _beed ;};_fcfe :if 48<=data [_bdgd ]&&data [_bdgd ]<=57{goto _cbea ;};goto _dcc ;_beg :_gbg :_dee =0;goto _fbg ;_fgab :_dee =1;goto _fbg ;_ccc :_dee =2;goto _fbg ;_bfbc :_dee =3;goto _fbg ;_cgg :_dee =4;goto _fbg ;_eda :_dee =5;goto _fbg ;_faag :_dee =6;goto _fbg ;_beed :_dee =7;goto _fbg ;_fbg :{};if _bdgd ==_dba {switch _dee {case 1:goto _ge ;case 2:goto _ge ;case 3:goto _bec ;case 4:goto _ge ;case 5:goto _bdc ;case 6:goto _ge ;case 7:goto _dbb ;};};};if _dee ==_edg {return false ;};return ;};func Parse (s string )[]Format {_fgd :=Lexer {};_fgd .Lex (_ba .NewReader (s ));_fgd ._agf =append (_fgd ._agf ,_fgd ._ccgb );return _fgd ._agf ;};const _ebc int =34;const _cf ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _adg (_fa float64 ,_ac Format ,_fff bool )string {if _ac ._bff {return NumberGeneric (_fa );};_eb :=make ([]byte ,0,20);_gb :=_be .Signbit (_fa );_agc :=_be .Abs (_fa );_ab :=int64 (0);_bga :=int64 (0);if _ac .IsExponential {for _agc >=10{_bga ++;_agc /=10;};for _agc < 1{_bga --;_agc *=10;};}else if _ac ._bf {_agc *=100;}else if _ac ._db {if _ac ._gg ==0{_aaec :=_be .Pow (10,float64 (_ac ._eg ));_dbe ,_fcd :=1.0,1.0;_ =_dbe ;for _fcb :=1.0;_fcb < _aaec ;_fcb ++{_ ,_ccb :=_be .Modf (_agc *float64 (_fcb ));if _ccb < _fcd {_fcd =_ccb ;_dbe =_fcb ;if _ccb ==0{break ;};};};_ac ._gg =int64 (_dbe );};_ab =int64 (_agc *float64 (_ac ._gg )+0.5);if len (_ac .Whole )> 0&&_ab > _ac ._gg {_ab =int64 (_agc *float64 (_ac ._gg ))%_ac ._gg ;_agc -=float64 (_ab )/float64 (_ac ._gg );}else {_agc -=float64 (_ab )/float64 (_ac ._gg );if _be .Abs (_agc )< 1{_faa :=true ;for _ ,_dfa :=range _ac .Whole {if _dfa .Type ==FmtTypeDigitOpt {continue ;};if _dfa .Type ==FmtTypeLiteral &&_dfa .Literal ==' '{continue ;};_faa =false ;};if _faa {_ac .Whole =nil ;};};};};_bd :=1;for _ ,_aab :=range _ac .Fractional {if _aab .Type ==FmtTypeDigit ||_aab .Type ==FmtTypeDigitOpt {_bd ++;};};_agc +=5*_be .Pow10 (-_bd );_dfc ,_cbf :=_be .Modf (_agc );_eb =append (_eb ,_dbg (_dfc ,_fa ,_ac )...);_eb =append (_eb ,_cbe (_cbf ,_fa ,_ac )...);_eb =append (_eb ,_beae (_bga ,_ac )...);if _ac ._db {_eb =_a .AppendInt (_eb ,_ab ,10);_eb =append (_eb ,'/');_eb =_a .AppendInt (_eb ,_ac ._gg ,10);};if !_fff &&_gb {return "\u002d"+string (_eb );};return string (_eb );};var _bb =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};func _dbg (_gga ,_dff float64 ,_acg Format )[]byte {if len (_acg .Whole )==0{return nil ;};_bbf :=_c .Date (1899,12,30,0,0,0,0,_c .UTC );_dda :=_bbf .Add (_c .Duration (_dff *float64 (24*_c .Hour )));_dda =_bbb (_dda );_fd :=_a .AppendFloat (nil ,_gga ,'f',-1,64);_ea :=make ([]byte ,0,len (_fd ));_bfb :=0;_bc :=1;_fcf :for _gcb :=len (_acg .Whole )-1;_gcb >=0;_gcb --{_af :=len (_fd )-1-_bfb ;_gcg :=_acg .Whole [_gcb ];switch _gcg .Type {case FmtTypeDigit :if _af >=0{_ea =append (_ea ,_fd [_af ]);_bfb ++;_bc =_gcb ;}else {_ea =append (_ea ,'0');};case FmtTypeDigitOpt :if _af >=0{_ea =append (_ea ,_fd [_af ]);_bfb ++;_bc =_gcb ;}else {for _faf :=_gcb ;_faf >=0;_faf --{_fe :=_acg .Whole [_faf ];if _fe .Type ==FmtTypeLiteral {_ea =append (_ea ,_fe .Literal );};};break _fcf ;};case FmtTypeDollar :for _bee :=_bfb ;_bee < len (_fd );_bee ++{_ea =append (_ea ,_fd [len (_fd )-1-_bee ]);_bfb ++;};_ea =append (_ea ,'$');case FmtTypeComma :if !_acg ._df {_ea =append (_ea ,',');};case FmtTypeLiteral :_ea =append (_ea ,_gcg .Literal );case FmtTypeDate :_ea =append (_ea ,_ff (_aabc (_dda ,_gcg .DateTime ))...);case FmtTypeTime :_ea =append (_ea ,_ff (_dac (_dda ,_dff ,_gcg .DateTime ))...);default:_de .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_gcg );};};_bfc :=_ff (_ea );if _bfb < len (_fd )&&(_bfb !=0||_acg ._aa ){_bea :=len (_fd )-_bfb ;_beb :=make ([]byte ,len (_bfc )+_bea );copy (_beb ,_bfc [0:_bc ]);copy (_beb [_bc :],_fd [0:]);copy (_beb [_bc +_bea :],_bfc [_bc :]);_bfc =_beb ;};if _acg ._df {_gd :=_fg .Buffer {};_abb :=0;for _ffg :=len (_bfc )-1;_ffg >=0;_ffg --{if !(_bfc [_ffg ]>='0'&&_bfc [_ffg ]<='9'){_abb ++;}else {break ;};};for _cfb :=0;_cfb < len (_bfc );_cfb ++{_ffe :=(len (_bfc )-_cfb -_abb );if _ffe %3==0&&_ffe !=0&&_cfb !=0{_gd .WriteByte (',');};_gd .WriteByte (_bfc [_cfb ]);};_bfc =_gd .Bytes ();};return _bfc ;};