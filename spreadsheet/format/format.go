//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_b "bytes";_g "fmt";_dc "github.com/unidoc/unioffice";_f "io";_ec "math";_df "strconv";_d "strings";_c "time";);

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_bdg :=Parse (f );if len (_bdg )==1{return _gd (v ,_bdg [0],false );}else if len (_bdg )> 1&&v < 0{return _gd (v ,_bdg [1],true );}else if len (_bdg )> 2&&v ==0{return _gd (v ,_bdg [2],false );};return _gd (v ,_bdg [0],false );};func _fac (_cac _c .Time ,_baa float64 ,_adb string )[]byte {_age :=[]byte {};_ecfc :=0;for _dgf :=0;_dgf < len (_adb );_dgf ++{var _geb string ;if _adb [_dgf ]==':'{_geb =string (_adb [_ecfc :_dgf ]);_ecfc =_dgf +1;}else if _dgf ==len (_adb )-1{_geb =string (_adb [_ecfc :_dgf +1]);}else {continue ;};switch _geb {case "\u0064":_age =_cac .AppendFormat (_age ,"\u0032");case "\u0068":_age =_cac .AppendFormat (_age ,"\u0033");case "\u0068\u0068":_age =_cac .AppendFormat (_age ,"\u0031\u0035");case "\u006d":_age =_cac .AppendFormat (_age ,"\u0034");case "\u006d\u006d":_age =_cac .AppendFormat (_age ,"\u0030\u0034");case "\u0073":_age =_cac .Round (_c .Second ).AppendFormat (_age ,"\u0035");case "\u0073\u002e\u0030":_age =_cac .Round (_c .Second /10).AppendFormat (_age ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_age =_cac .Round (_c .Second /100).AppendFormat (_age ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_age =_cac .Round (_c .Second /1000).AppendFormat (_age ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_age =_cac .Round (_c .Second ).AppendFormat (_age ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_age =_cac .Round (_c .Second /10).AppendFormat (_age ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_age =_cac .Round (_c .Second /100).AppendFormat (_age ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_age =_cac .Round (_c .Second /1000).AppendFormat (_age ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_age =_cac .AppendFormat (_age ,"\u0050\u004d");case "\u005b\u0068\u005d":_age =_df .AppendInt (_age ,int64 (_baa *24),10);case "\u005b\u006d\u005d":_age =_df .AppendInt (_age ,int64 (_baa *24*60),10);case "\u005b\u0073\u005d":_age =_df .AppendInt (_age ,int64 (_baa *24*60*60),10);case "":default:_dc .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_geb );};if _adb [_dgf ]==':'{_age =append (_age ,':');};};return _age ;};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const _ecf ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";func (_fg FmtType )String ()string {if _fg >=FmtType (len (_dfe )-1){return _g .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_fg );};return _ecf [_dfe [_fg ]:_dfe [_fg +1]];};func _eea (_bdda ,_ebg float64 ,_aba Format )[]byte {if len (_aba .Fractional )==0{return nil ;};_eed :=_df .AppendFloat (nil ,_bdda ,'f',-1,64);if len (_eed )> 2{_eed =_eed [2:];}else {_eed =nil ;};_cb :=make ([]byte ,0,len (_eed ));_cb =append (_cb ,'.');_efg :=0;_fbf :for _aa :=0;_aa < len (_aba .Fractional );_aa ++{_fa :=_aa ;_dded :=_aba .Fractional [_aa ];switch _dded .Type {case FmtTypeDigit :if _fa < len (_eed ){_cb =append (_cb ,_eed [_fa ]);_efg ++;}else {_cb =append (_cb ,'0');};case FmtTypeDigitOpt :if _fa >=0{_cb =append (_cb ,_eed [_fa ]);_efg ++;}else {break _fbf ;};case FmtTypeLiteral :_cb =append (_cb ,_dded .Literal );default:_dc .Log ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_dded );};};return _cb ;};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);var _dfe =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};const _gag int =0;func Parse (s string )[]Format {_dfbe :=Lexer {};_dfbe .Lex (_d .NewReader (s ));_dfbe ._efdg =append (_dfbe ._efdg ,_dfbe ._dfbf );return _dfbe ._efdg ;};const _baee int =0;func _gd (_abf float64 ,_cg Format ,_dcc bool )string {if _cg ._ecff {return NumberGeneric (_abf );};_bc :=make ([]byte ,0,20);_ff :=_ec .Signbit (_abf );_dff :=_ec .Abs (_abf );_gedbf :=int64 (0);_bb :=int64 (0);if _cg .IsExponential {for _dff >=10{_bb ++;_dff /=10;};for _dff < 1{_bb --;_dff *=10;};}else if _cg ._bg {_dff *=100;}else if _cg ._fe {if _cg ._ece ==0{_fc :=_ec .Pow (10,float64 (_cg ._gg ));_bcf ,_ad :=1.0,1.0;_ =_bcf ;for _dfb :=1.0;_dfb < _fc ;_dfb ++{_ ,_bgc :=_ec .Modf (_dff *float64 (_dfb ));if _bgc < _ad {_ad =_bgc ;_bcf =_dfb ;if _bgc ==0{break ;};};};_cg ._ece =int64 (_bcf );};_gedbf =int64 (_dff *float64 (_cg ._ece )+0.5);if len (_cg .Whole )> 0&&_gedbf > _cg ._ece {_gedbf =int64 (_dff *float64 (_cg ._ece ))%_cg ._ece ;_dff -=float64 (_gedbf )/float64 (_cg ._ece );}else {_dff -=float64 (_gedbf )/float64 (_cg ._ece );if _ec .Abs (_dff )< 1{_ba :=true ;for _ ,_fee :=range _cg .Whole {if _fee .Type ==FmtTypeDigitOpt {continue ;};if _fee .Type ==FmtTypeLiteral &&_fee .Literal ==' '{continue ;};_ba =false ;};if _ba {_cg .Whole =nil ;};};};};_eeg :=1;for _ ,_dfc :=range _cg .Fractional {if _dfc .Type ==FmtTypeDigit ||_dfc .Type ==FmtTypeDigitOpt {_eeg ++;};};_dff +=5*_ec .Pow10 (-_eeg );_dab ,_ed :=_ec .Modf (_dff );_bc =append (_bc ,_dde (_dab ,_abf ,_cg )...);_bc =append (_bc ,_eea (_ed ,_abf ,_cg )...);_bc =append (_bc ,_gbd (_bb ,_cg )...);if _cg ._fe {_bc =_df .AppendInt (_bc ,_gedbf ,10);_bc =append (_bc ,'/');_bc =_df .AppendInt (_bc ,_cg ._ece ,10);};if !_dcc &&_ff {return "\u002d"+string (_bc );};return string (_bc );};func _gbd (_gdff int64 ,_bed Format )[]byte {if !_bed .IsExponential ||len (_bed .Exponent )==0{return nil ;};_ffa :=_df .AppendInt (nil ,_dg (_gdff ),10);_ebb :=make ([]byte ,0,len (_ffa )+2);_ebb =append (_ebb ,'E');if _gdff >=0{_ebb =append (_ebb ,'+');}else {_ebb =append (_ebb ,'-');_gdff *=-1;};_fcc :=0;_ac :for _ecec :=len (_bed .Exponent )-1;_ecec >=0;_ecec --{_aad :=len (_ffa )-1-_fcc ;_dcag :=_bed .Exponent [_ecec ];switch _dcag .Type {case FmtTypeDigit :if _aad >=0{_ebb =append (_ebb ,_ffa [_aad ]);_fcc ++;}else {_ebb =append (_ebb ,'0');};case FmtTypeDigitOpt :if _aad >=0{_ebb =append (_ebb ,_ffa [_aad ]);_fcc ++;}else {for _eag :=_ecec ;_eag >=0;_eag --{_gc :=_bed .Exponent [_eag ];if _gc .Type ==FmtTypeLiteral {_ebb =append (_ebb ,_gc .Literal );};};break _ac ;};case FmtTypeLiteral :_ebb =append (_ebb ,_dcag .Literal );default:_dc .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_dcag );};};if _fcc < len (_ffa ){_ebb =append (_ebb ,_ffa [len (_ffa )-_fcc -1:_fcc -1]...);};_gedb (_ebb [2:]);return _ebb ;};const _bfa int =34;

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ec .Abs (v )>=_a ||_ec .Abs (v )<=_ge &&v !=0{return _efe (v );};_ddd :=make ([]byte ,0,15);_ddd =_df .AppendFloat (_ddd ,v ,'f',-1,64);if len (_ddd )> 11{_fd :=_ddd [11]-'0';if _fd >=5&&_fd <=9{_ddd [10]++;_ddd =_ddd [0:11];_ddd =_fca (_ddd );};_ddd =_ddd [0:11];}else if len (_ddd )==11{if _ddd [len (_ddd )-1]=='9'{_ddd [len (_ddd )-1]++;_ddd =_fca (_ddd );};};_ddd =_fbc (_ddd );return string (_ddd );};const _ffc int =34;func _fca (_daa []byte )[]byte {for _ebef :=len (_daa )-1;_ebef > 0;_ebef --{if _daa [_ebef ]=='9'+1{_daa [_ebef ]='0';if _daa [_ebef -1]=='.'{_ebef --;};_daa [_ebef -1]++;};};if _daa [0]=='9'+1{_daa [0]='0';copy (_daa [1:],_daa [0:]);_daa [0]='1';};return _daa ;};func _bcg (_ceg _c .Time )_c .Time {_ceg =_ceg .UTC ();return _c .Date (_ceg .Year (),_ceg .Month (),_ceg .Day (),_ceg .Hour (),_ceg .Minute (),_ceg .Second (),_ceg .Nanosecond (),_c .Local );};func _dde (_dcd ,_ecfe float64 ,_af Format )[]byte {if len (_af .Whole )==0{return nil ;};_ebe :=_c .Date (1899,12,30,0,0,0,0,_c .UTC );_ce :=_ebe .Add (_c .Duration (_ecfe *float64 (24*_c .Hour )));_ce =_bcg (_ce );_gb :=_df .AppendFloat (nil ,_dcd ,'f',-1,64);_egb :=make ([]byte ,0,len (_gb ));_ecd :=0;_dfd :=1;_gdf :for _bgd :=len (_af .Whole )-1;_bgd >=0;_bgd --{_fga :=len (_gb )-1-_ecd ;_cef :=_af .Whole [_bgd ];switch _cef .Type {case FmtTypeDigit :if _fga >=0{_egb =append (_egb ,_gb [_fga ]);_ecd ++;_dfd =_bgd ;}else {_egb =append (_egb ,'0');};case FmtTypeDigitOpt :if _fga >=0{_egb =append (_egb ,_gb [_fga ]);_ecd ++;_dfd =_bgd ;}else {for _bcb :=_bgd ;_bcb >=0;_bcb --{_gef :=_af .Whole [_bcb ];if _gef .Type ==FmtTypeLiteral {_egb =append (_egb ,_gef .Literal );};};break _gdf ;};case FmtTypeDollar :for _be :=_ecd ;_be < len (_gb );_be ++{_egb =append (_egb ,_gb [len (_gb )-1-_be ]);_ecd ++;};_egb =append (_egb ,'$');case FmtTypeComma :if !_af ._ab {_egb =append (_egb ,',');};case FmtTypeLiteral :_egb =append (_egb ,_cef .Literal );case FmtTypeDate :_egb =append (_egb ,_gedb (_gdg (_ce ,_cef .DateTime ))...);case FmtTypeTime :_egb =append (_egb ,_gedb (_fac (_ce ,_ecfe ,_cef .DateTime ))...);default:_dc .Log ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_cef );};};_gee :=_gedb (_egb );if _ecd < len (_gb )&&(_ecd !=0||_af ._geg ){_ef :=len (_gb )-_ecd ;_add :=make ([]byte ,len (_gee )+_ef );copy (_add ,_gee [0:_dfd ]);copy (_add [_dfd :],_gb [0:]);copy (_add [_dfd +_ef :],_gee [_dfd :]);_gee =_add ;};if _af ._ab {_bba :=_b .Buffer {};_fb :=0;for _bbe :=len (_gee )-1;_bbe >=0;_bbe --{if !(_gee [_bbe ]>='0'&&_gee [_bbe ]<='9'){_fb ++;}else {break ;};};for _ggd :=0;_ggd < len (_gee );_ggd ++{_bbef :=(len (_gee )-_ggd -_fb );if _bbef %3==0&&_bbef !=0&&_ggd !=0{_bba .WriteByte (',');};_bba .WriteByte (_gee [_ggd ]);};_gee =_bba .Bytes ();};return _gee ;};func _efe (_egf float64 )string {_bfc :=_df .FormatFloat (_egf ,'E',-1,64);_ga :=_df .FormatFloat (_egf ,'E',5,64);if len (_bfc )< len (_ga ){return _df .FormatFloat (_egf ,'E',2,64);};return _ga ;};const _dea int =34;

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_dcg ,_ :=_df .ParseFloat (v ,64);return Number (_dcg ,f );};return String (v ,f );};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};const _a =1e11;func IsNumber (data string )(_fda bool ){_bbeg ,_baag ,_daac :=0,0,len (data );_dee :=len (data );_gagd ,_caa ,_bec :=0,0,0;_ =_caa ;_ =_bec ;_ =_gagd ;{_bbeg =_gag ;_gagd =0;_caa =0;_bec =0;};{if _baag ==_daac {goto _cca ;};switch _bbeg {case 0:goto _dbe ;case 1:goto _agc ;case 2:goto _dge ;case 3:goto _cbc ;case 4:goto _gcb ;case 5:goto _cbg ;case 6:goto _afc ;case 7:goto _edg ;};goto _egff ;_gda :_caa =_baag ;_baag --;{_fda =false ;};goto _gdc ;_cdc :_caa =_baag ;_baag --;{_fda =_caa ==len (data );};goto _gdc ;_bfb :_caa =_baag ;_baag --;{_fda =_caa ==len (data );};goto _gdc ;_dbga :switch _bec {case 2:{_baag =(_caa )-1;_fda =_caa ==len (data );};case 3:{_baag =(_caa )-1;_fda =false ;};};goto _gdc ;_gdc :_gagd =0;if _baag ++;_baag ==_daac {goto _bbg ;};_dbe :_gagd =_baag ;switch data [_baag ]{case 43:goto _bdc ;case 45:goto _bdc ;};if 48<=data [_baag ]&&data [_baag ]<=57{goto _bfd ;};goto _ddedg ;_ddedg :if _baag ++;_baag ==_daac {goto _fdf ;};_agc :goto _ddedg ;_bdc :if _baag ++;_baag ==_daac {goto _edc ;};_dge :if 48<=data [_baag ]&&data [_baag ]<=57{goto _bfd ;};goto _ddedg ;_bfd :if _baag ++;_baag ==_daac {goto _fff ;};_cbc :if data [_baag ]==46{goto _edd ;};if 48<=data [_baag ]&&data [_baag ]<=57{goto _bfd ;};goto _ddedg ;_edd :if _baag ++;_baag ==_daac {goto _ddec ;};_gcb :if 48<=data [_baag ]&&data [_baag ]<=57{goto _beb ;};goto _ddedg ;_beb :if _baag ++;_baag ==_daac {goto _afa ;};_cbg :if data [_baag ]==69{goto _bca ;};if 48<=data [_baag ]&&data [_baag ]<=57{goto _beb ;};goto _ddedg ;_bca :if _baag ++;_baag ==_daac {goto _cgc ;};_afc :switch data [_baag ]{case 43:goto _efd ;case 45:goto _efd ;};goto _ddedg ;_efd :_caa =_baag +1;_bec =3;goto _acd ;_ccd :_caa =_baag +1;_bec =2;goto _acd ;_acd :if _baag ++;_baag ==_daac {goto _fdb ;};_edg :if 48<=data [_baag ]&&data [_baag ]<=57{goto _ccd ;};goto _ddedg ;_egff :_bbg :_bbeg =0;goto _cca ;_fdf :_bbeg =1;goto _cca ;_edc :_bbeg =2;goto _cca ;_fff :_bbeg =3;goto _cca ;_ddec :_bbeg =4;goto _cca ;_afa :_bbeg =5;goto _cca ;_cgc :_bbeg =6;goto _cca ;_fdb :_bbeg =7;goto _cca ;_cca :{};if _baag ==_dee {switch _bbeg {case 1:goto _gda ;case 2:goto _gda ;case 3:goto _cdc ;case 4:goto _gda ;case 5:goto _bfb ;case 6:goto _gda ;case 7:goto _dbga ;};};};if _bbeg ==_aeb {return false ;};return ;};func (_dce *Lexer )Lex (r _f .Reader ){_aec ,_eeb ,_eef :=0,0,0;_beda :=-1;_ecg ,_ede ,_gbc :=0,0,0;_ =_ede ;_ =_gbc ;_acc :=1;_ =_acc ;_bdcf :=make ([]byte ,4096);_bcae :=false ;for !_bcae {_bdcc :=0;if _ecg > 0{_bdcc =_eeb -_ecg ;};_eeb =0;_fad ,_eec :=r .Read (_bdcf [_bdcc :]);if _fad ==0||_eec !=nil {_bcae =true ;};_eef =_fad +_bdcc ;if _eef < len (_bdcf ){_beda =_eef ;};{_aec =_dea ;_ecg =0;_ede =0;_gbc =0;};{if _eeb ==_eef {goto _fefb ;};switch _aec {case 34:goto _ccc ;case 35:goto _fcf ;case 0:goto _afbc ;case 36:goto _bfga ;case 37:goto _acdg ;case 1:goto _debb ;case 2:goto _ebbf ;case 38:goto _acg ;case 3:goto _bgbf ;case 4:goto _bcdd ;case 39:goto _gae ;case 5:goto _fge ;case 6:goto _bdb ;case 7:goto _cea ;case 8:goto _aeg ;case 40:goto _gcf ;case 9:goto _bea ;case 41:goto _accd ;case 10:goto _bad ;case 42:goto _ccg ;case 11:goto _bcdf ;case 43:goto _gff ;case 44:goto _ecgeg ;case 45:goto _fde ;case 12:goto _egffg ;case 46:goto _gad ;case 13:goto _ceac ;case 14:goto _dffa ;case 15:goto _ege ;case 16:goto _bbefg ;case 47:goto _fefc ;case 17:goto _daae ;case 48:goto _gbg ;case 18:goto _gbfe ;case 19:goto _agec ;case 20:goto _dcdd ;case 49:goto _gffd ;case 50:goto _eged ;case 21:goto _cdca ;case 22:goto _cfd ;case 23:goto _egbb ;case 24:goto _gcd ;case 25:goto _cde ;case 51:goto _deec ;case 26:goto _addb ;case 52:goto _ggg ;case 53:goto _eeaa ;case 54:goto _bfab ;case 55:goto _cgcg ;case 56:goto _dda ;case 57:goto _abcd ;case 27:goto _gagdc ;case 28:goto _badg ;case 29:goto _gcfa ;case 30:goto _aac ;case 31:goto _acb ;case 58:goto _ggdb ;case 32:goto _adcg ;case 59:goto _feb ;case 33:goto _eafe ;case 60:goto _cdfd ;case 61:goto _edff ;case 62:goto _ffe ;};goto _bcdde ;_bge :switch _gbc {case 2:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeDigit ,nil );};case 3:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_eeb =(_ede )-1;};case 8:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypePercent ,nil );};case 13:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeFraction ,_bdcf [_ecg :_ede ]);};case 14:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeDate ,_bdcf [_ecg :_ede ]);};case 15:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeTime ,_bdcf [_ecg :_ede ]);};case 16:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeTime ,_bdcf [_ecg :_ede ]);};case 18:{_eeb =(_ede )-1;};case 20:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg :_ede ]);};case 21:{_eeb =(_ede )-1;_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg +1:_ede -1]);};};goto _gdd ;_ecge :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeFraction ,_bdcf [_ecg :_ede ]);};goto _gdd ;_cga :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeDigitOpt ,nil );};goto _gdd ;_ecgf :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeDigitOptThousands ,nil );};goto _gdd ;_aea :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypePercent ,nil );};goto _gdd ;_cgae :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeDate ,_bdcf [_ecg :_ede ]);};goto _gdd ;_bfg :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeDigit ,nil );};goto _gdd ;_dbd :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeTime ,_bdcf [_ecg :_ede ]);};goto _gdd ;_dag :_eeb =(_ede )-1;{_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg :_ede ]);};goto _gdd ;_dbf :_ede =_eeb +1;{_dce ._dfbf ._ecff =true ;};goto _gdd ;_eaf :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg :_ede ]);};goto _gdd ;_bcd :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeDollar ,nil );};goto _gdd ;_cgb :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeComma ,nil );};goto _gdd ;_deb :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeDecimal ,nil );};goto _gdd ;_cefd :_ede =_eeb +1;{_dce .nextFmt ();};goto _gdd ;_bgbd :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeText ,nil );};goto _gdd ;_bbb :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeUnderscore ,nil );};goto _gdd ;_aag :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg :_ede ]);};goto _gdd ;_ced :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg +1:_ede -1]);};goto _gdd ;_fbb :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeDigitOpt ,nil );};goto _gdd ;_agb :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeFraction ,_bdcf [_ecg :_ede ]);};goto _gdd ;_dec :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypePercent ,nil );};goto _gdd ;_daf :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeDate ,_bdcf [_ecg :_ede ]);};goto _gdd ;_baeea :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeDigit ,nil );};goto _gdd ;_fbd :_ede =_eeb ;_eeb --;{_dce ._dfbf .AddToken (FmtTypeTime ,_bdcf [_ecg :_ede ]);};goto _gdd ;_ddc :_ede =_eeb ;_eeb --;{};goto _gdd ;_ecde :_ede =_eeb +1;{_dce ._dfbf .IsExponential =true ;};goto _gdd ;_ebed :_ede =_eeb +1;{_dce ._dfbf .AddToken (FmtTypeLiteral ,_bdcf [_ecg +1:_ede ]);};goto _gdd ;_gdd :_ecg =0;if _eeb ++;_eeb ==_eef {goto _fecg ;};_ccc :_ecg =_eeb ;switch _bdcf [_eeb ]{case 34:goto _bfgd ;case 35:goto _baec ;case 36:goto _bcd ;case 37:goto _aaf ;case 44:goto _cgb ;case 46:goto _deb ;case 47:goto _adf ;case 48:goto _bebe ;case 58:goto _cbcf ;case 59:goto _cefd ;case 63:goto _facb ;case 64:goto _bgbd ;case 65:goto _cbcb ;case 69:goto _eefg ;case 71:goto _ccb ;case 91:goto _fba ;case 92:goto _dage ;case 95:goto _bbb ;case 100:goto _adf ;case 104:goto _cbcf ;case 109:goto _adcd ;case 115:goto _cdae ;case 121:goto _baeb ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _befa ;};goto _eaf ;_bfgd :_ede =_eeb +1;_gbc =20;goto _ade ;_ade :if _eeb ++;_eeb ==_eef {goto _gcfe ;};_fcf :if _bdcf [_eeb ]==34{goto _gfb ;};goto _acce ;_acce :if _eeb ++;_eeb ==_eef {goto _deg ;};_afbc :if _bdcf [_eeb ]==34{goto _gfb ;};goto _acce ;_gfb :_ede =_eeb +1;_gbc =21;goto _cce ;_cce :if _eeb ++;_eeb ==_eef {goto _eeff ;};_bfga :if _bdcf [_eeb ]==34{goto _acce ;};goto _ced ;_baec :_ede =_eeb +1;_gbc =3;goto _gfg ;_gfg :if _eeb ++;_eeb ==_eef {goto _cbge ;};_acdg :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _fcfc ;case 44:goto _afd ;case 47:goto _agbg ;case 48:goto _fcfc ;case 63:goto _fcfc ;};goto _fbb ;_fcfc :if _eeb ++;_eeb ==_eef {goto _cfa ;};_debb :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _fcfc ;case 47:goto _agbg ;case 48:goto _fcfc ;case 63:goto _fcfc ;};goto _bge ;_agbg :if _eeb ++;_eeb ==_eef {goto _fdfg ;};_ebbf :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _cdb ;case 48:goto _eebc ;case 63:goto _dfg ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _gdgc ;};goto _bge ;_dfg :_ede =_eeb +1;goto _edca ;_edca :if _eeb ++;_eeb ==_eef {goto _abed ;};_acg :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _dfg ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _dfg ;case 63:goto _dfg ;case 65:goto _aff ;};goto _agb ;_aff :if _eeb ++;_eeb ==_eef {goto _efb ;};_bgbf :switch _bdcf [_eeb ]{case 47:goto _eedd ;case 77:goto _gdae ;};goto _ecge ;_eedd :if _eeb ++;_eeb ==_eef {goto _cgac ;};_bcdd :if _bdcf [_eeb ]==80{goto _gga ;};goto _ecge ;_gga :_ede =_eeb +1;goto _ecdb ;_ecdb :if _eeb ++;_eeb ==_eef {goto _cfed ;};_gae :if _bdcf [_eeb ]==65{goto _aff ;};goto _agb ;_gdae :if _eeb ++;_eeb ==_eef {goto _agaa ;};_fge :if _bdcf [_eeb ]==47{goto _gab ;};goto _ecge ;_gab :if _eeb ++;_eeb ==_eef {goto _fed ;};_bdb :if _bdcf [_eeb ]==80{goto _fcfe ;};goto _ecge ;_fcfe :if _eeb ++;_eeb ==_eef {goto _abee ;};_cea :if _bdcf [_eeb ]==77{goto _gga ;};goto _ecge ;_cdb :if _eeb ++;_eeb ==_eef {goto _ecc ;};_aeg :switch _bdcf [_eeb ]{case 35:goto _cgd ;case 37:goto _ggc ;case 63:goto _cgd ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _eab ;};goto _bge ;_cgd :_ede =_eeb +1;goto _cf ;_cf :if _eeb ++;_eeb ==_eef {goto _fcd ;};_gcf :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _bfcg ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _dfg ;case 63:goto _dfg ;case 65:goto _aff ;};goto _agb ;_bfcg :if _eeb ++;_eeb ==_eef {goto _affe ;};_bea :switch _bdcf [_eeb ]{case 35:goto _fgf ;case 44:goto _fgf ;case 46:goto _fgf ;case 48:goto _fgf ;case 63:goto _fgf ;};goto _ecge ;_fgf :_ede =_eeb +1;goto _fgfg ;_fgfg :if _eeb ++;_eeb ==_eef {goto _dfcc ;};_accd :switch _bdcf [_eeb ]{case 35:goto _fgf ;case 44:goto _fgf ;case 46:goto _fgf ;case 48:goto _fgf ;case 63:goto _fgf ;case 65:goto _aff ;};goto _agb ;_ggc :if _eeb ++;_eeb ==_eef {goto _gge ;};_bad :if _bdcf [_eeb ]==37{goto _ggc ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _eab ;};goto _bge ;_eab :_ede =_eeb +1;_gbc =13;goto _gfd ;_gfd :if _eeb ++;_eeb ==_eef {goto _bfag ;};_ccg :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _adc ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _bce ;case 63:goto _dfg ;case 65:goto _aff ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _eab ;};goto _agb ;_adc :if _eeb ++;_eeb ==_eef {goto _gddf ;};_bcdf :switch _bdcf [_eeb ]{case 35:goto _fgf ;case 37:goto _ggc ;case 44:goto _fgf ;case 46:goto _fgf ;case 63:goto _fgf ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _eab ;};goto _ecge ;_bce :_ede =_eeb +1;goto _ebc ;_ebc :if _eeb ++;_eeb ==_eef {goto _dege ;};_gff :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _bce ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _bce ;case 63:goto _dfg ;case 65:goto _aff ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _eab ;};goto _agb ;_eebc :_ede =_eeb +1;goto _bff ;_bff :if _eeb ++;_eeb ==_eef {goto _fcab ;};_ecgeg :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _bce ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _eebc ;case 63:goto _dfg ;case 65:goto _aff ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _gdgc ;};goto _agb ;_gdgc :_ede =_eeb +1;goto _ace ;_ace :if _eeb ++;_eeb ==_eef {goto _cgg ;};_fde :switch _bdcf [_eeb ]{case 35:goto _dfg ;case 37:goto _eab ;case 44:goto _dfg ;case 46:goto _dfg ;case 48:goto _eebc ;case 63:goto _dfg ;case 65:goto _aff ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _gdgc ;};goto _agb ;_afd :if _eeb ++;_eeb ==_eef {goto _gbca ;};_egffg :if _bdcf [_eeb ]==35{goto _ecgf ;};goto _cga ;_aaf :_ede =_eeb +1;_gbc =8;goto _cfe ;_cfe :if _eeb ++;_eeb ==_eef {goto _cgf ;};_gad :switch _bdcf [_eeb ]{case 35:goto _bbf ;case 37:goto _bgee ;case 48:goto _cdf ;case 63:goto _bbf ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _bfaf ;};goto _dec ;_bbf :if _eeb ++;_eeb ==_eef {goto _dccc ;};_ceac :switch _bdcf [_eeb ]{case 35:goto _bbf ;case 47:goto _agbg ;case 48:goto _bbf ;case 63:goto _bbf ;};goto _aea ;_bgee :if _eeb ++;_eeb ==_eef {goto _gdaa ;};_dffa :if _bdcf [_eeb ]==37{goto _bgee ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _bfaf ;};goto _bge ;_bfaf :if _eeb ++;_eeb ==_eef {goto _ggcf ;};_ege :switch _bdcf [_eeb ]{case 37:goto _bgee ;case 47:goto _agbg ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _bfaf ;};goto _bge ;_cdf :if _eeb ++;_eeb ==_eef {goto _gdb ;};_bbefg :switch _bdcf [_eeb ]{case 35:goto _bbf ;case 37:goto _bgee ;case 47:goto _agbg ;case 48:goto _cdf ;case 63:goto _bbf ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _bfaf ;};goto _aea ;_adf :_ede =_eeb +1;goto _bbfa ;_bbfa :if _eeb ++;_eeb ==_eef {goto _fgb ;};_fefc :switch _bdcf [_eeb ]{case 47:goto _adf ;case 100:goto _adf ;case 109:goto _adf ;case 121:goto _dddb ;};goto _daf ;_dddb :if _eeb ++;_eeb ==_eef {goto _efab ;};_daae :if _bdcf [_eeb ]==121{goto _adf ;};goto _cgae ;_bebe :_ede =_eeb +1;_gbc =2;goto _aga ;_aga :if _eeb ++;_eeb ==_eef {goto _bee ;};_gbg :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _baaf ;case 47:goto _agbg ;case 48:goto _cebe ;case 63:goto _fcfc ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _debbb ;};goto _baeea ;_baaf :if _eeb ++;_eeb ==_eef {goto _fgc ;};_gbfe :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _baaf ;case 47:goto _agbg ;case 48:goto _baaf ;case 63:goto _fcfc ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _bfaf ;};goto _bfg ;_cebe :if _eeb ++;_eeb ==_eef {goto _edcg ;};_agec :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _baaf ;case 47:goto _agbg ;case 48:goto _cebe ;case 63:goto _fcfc ;};if 49<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _debbb ;};goto _bfg ;_debbb :if _eeb ++;_eeb ==_eef {goto _abcg ;};_dcdd :switch _bdcf [_eeb ]{case 37:goto _bfaf ;case 47:goto _agbg ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _debbb ;};goto _bge ;_befa :_ede =_eeb +1;_gbc =20;goto _bceg ;_bceg :if _eeb ++;_eeb ==_eef {goto _fgef ;};_gffd :switch _bdcf [_eeb ]{case 37:goto _bfaf ;case 47:goto _agbg ;};if 48<=_bdcf [_eeb ]&&_bdcf [_eeb ]<=57{goto _debbb ;};goto _aag ;_cbcf :_ede =_eeb +1;_gbc =15;goto _aeab ;_aeab :if _eeb ++;_eeb ==_eef {goto _ecdg ;};_eged :switch _bdcf [_eeb ]{case 58:goto _cbcf ;case 65:goto _aagf ;case 104:goto _cbcf ;case 109:goto _cbcf ;case 115:goto _cdae ;};goto _fbd ;_aagf :if _eeb ++;_eeb ==_eef {goto _fag ;};_cdca :switch _bdcf [_eeb ]{case 47:goto _eba ;case 77:goto _ggdd ;};goto _bge ;_eba :if _eeb ++;_eeb ==_eef {goto _abeg ;};_cfd :if _bdcf [_eeb ]==80{goto _cbcf ;};goto _bge ;_ggdd :if _eeb ++;_eeb ==_eef {goto _gdcb ;};_egbb :if _bdcf [_eeb ]==47{goto _bcag ;};goto _bge ;_bcag :if _eeb ++;_eeb ==_eef {goto _adde ;};_gcd :if _bdcf [_eeb ]==80{goto _gdcg ;};goto _bge ;_gdcg :if _eeb ++;_eeb ==_eef {goto _ebbd ;};_cde :if _bdcf [_eeb ]==77{goto _cbcf ;};goto _bge ;_cdae :_ede =_eeb +1;_gbc =15;goto _gaa ;_gaa :if _eeb ++;_eeb ==_eef {goto _fbda ;};_deec :switch _bdcf [_eeb ]{case 46:goto _afdc ;case 58:goto _cbcf ;case 65:goto _aagf ;case 104:goto _cbcf ;case 109:goto _cbcf ;case 115:goto _cdae ;};goto _fbd ;_afdc :if _eeb ++;_eeb ==_eef {goto _dfcd ;};_addb :if _bdcf [_eeb ]==48{goto _cad ;};goto _dbd ;_cad :_ede =_eeb +1;_gbc =15;goto _edf ;_edf :if _eeb ++;_eeb ==_eef {goto _dagb ;};_ggg :switch _bdcf [_eeb ]{case 48:goto _fec ;case 58:goto _cbcf ;case 65:goto _aagf ;case 104:goto _cbcf ;case 109:goto _cbcf ;case 115:goto _cdae ;};goto _fbd ;_fec :_ede =_eeb +1;_gbc =15;goto _fcg ;_fcg :if _eeb ++;_eeb ==_eef {goto _ecgfd ;};_eeaa :switch _bdcf [_eeb ]{case 48:goto _cbcf ;case 58:goto _cbcf ;case 65:goto _aagf ;case 104:goto _cbcf ;case 109:goto _cbcf ;case 115:goto _cdae ;};goto _fbd ;_facb :_ede =_eeb +1;_gbc =5;goto _gbde ;_gbde :if _eeb ++;_eeb ==_eef {goto _bbd ;};_bfab :switch _bdcf [_eeb ]{case 35:goto _fcfc ;case 37:goto _fcfc ;case 47:goto _agbg ;case 48:goto _fcfc ;case 63:goto _fcfc ;};goto _ddc ;_cbcb :_ede =_eeb +1;_gbc =20;goto _dccb ;_dccb :if _eeb ++;_eeb ==_eef {goto _aade ;};_cgcg :switch _bdcf [_eeb ]{case 47:goto _eba ;case 77:goto _ggdd ;};goto _aag ;_eefg :if _eeb ++;_eeb ==_eef {goto _adcdb ;};_dda :switch _bdcf [_eeb ]{case 43:goto _ecde ;case 45:goto _ecde ;};goto _aag ;_ccb :_ede =_eeb +1;goto _gege ;_gege :if _eeb ++;_eeb ==_eef {goto _ded ;};_abcd :if _bdcf [_eeb ]==101{goto _cab ;};goto _aag ;_cab :if _eeb ++;_eeb ==_eef {goto _eeag ;};_gagdc :if _bdcf [_eeb ]==110{goto _bbegb ;};goto _dag ;_bbegb :if _eeb ++;_eeb ==_eef {goto _aef ;};_badg :if _bdcf [_eeb ]==101{goto _agea ;};goto _dag ;_agea :if _eeb ++;_eeb ==_eef {goto _eabg ;};_gcfa :if _bdcf [_eeb ]==114{goto _fdfd ;};goto _dag ;_fdfd :if _eeb ++;_eeb ==_eef {goto _fgad ;};_aac :if _bdcf [_eeb ]==97{goto _efa ;};goto _dag ;_efa :if _eeb ++;_eeb ==_eef {goto _gedba ;};_acb :if _bdcf [_eeb ]==108{goto _dbf ;};goto _dag ;_fba :_ede =_eeb +1;_gbc =20;goto _bde ;_bde :if _eeb ++;_eeb ==_eef {goto _dcce ;};_ggdb :switch _bdcf [_eeb ]{case 104:goto _fded ;case 109:goto _fded ;case 115:goto _fded ;};goto _bcda ;_bcda :if _eeb ++;_eeb ==_eef {goto _agbf ;};_adcg :if _bdcf [_eeb ]==93{goto _deea ;};goto _bcda ;_deea :_ede =_eeb +1;_gbc =18;goto _dfgd ;_ddeb :_ede =_eeb +1;_gbc =16;goto _dfgd ;_dfgd :if _eeb ++;_eeb ==_eef {goto _ead ;};_feb :if _bdcf [_eeb ]==93{goto _deea ;};goto _bcda ;_fded :if _eeb ++;_eeb ==_eef {goto _cfc ;};_eafe :if _bdcf [_eeb ]==93{goto _ddeb ;};goto _bcda ;_dage :if _eeb ++;_eeb ==_eef {goto _gbfa ;};_cdfd :goto _ebed ;_adcd :_ede =_eeb +1;_gbc =14;goto _cbca ;_cbca :if _eeb ++;_eeb ==_eef {goto _ggca ;};_edff :switch _bdcf [_eeb ]{case 47:goto _adf ;case 58:goto _cbcf ;case 65:goto _aagf ;case 100:goto _adf ;case 104:goto _cbcf ;case 109:goto _adcd ;case 115:goto _cdae ;case 121:goto _dddb ;};goto _daf ;_baeb :if _eeb ++;_eeb ==_eef {goto _fcae ;};_ffe :if _bdcf [_eeb ]==121{goto _adf ;};goto _aag ;_bcdde :_fecg :_aec =34;goto _fefb ;_gcfe :_aec =35;goto _fefb ;_deg :_aec =0;goto _fefb ;_eeff :_aec =36;goto _fefb ;_cbge :_aec =37;goto _fefb ;_cfa :_aec =1;goto _fefb ;_fdfg :_aec =2;goto _fefb ;_abed :_aec =38;goto _fefb ;_efb :_aec =3;goto _fefb ;_cgac :_aec =4;goto _fefb ;_cfed :_aec =39;goto _fefb ;_agaa :_aec =5;goto _fefb ;_fed :_aec =6;goto _fefb ;_abee :_aec =7;goto _fefb ;_ecc :_aec =8;goto _fefb ;_fcd :_aec =40;goto _fefb ;_affe :_aec =9;goto _fefb ;_dfcc :_aec =41;goto _fefb ;_gge :_aec =10;goto _fefb ;_bfag :_aec =42;goto _fefb ;_gddf :_aec =11;goto _fefb ;_dege :_aec =43;goto _fefb ;_fcab :_aec =44;goto _fefb ;_cgg :_aec =45;goto _fefb ;_gbca :_aec =12;goto _fefb ;_cgf :_aec =46;goto _fefb ;_dccc :_aec =13;goto _fefb ;_gdaa :_aec =14;goto _fefb ;_ggcf :_aec =15;goto _fefb ;_gdb :_aec =16;goto _fefb ;_fgb :_aec =47;goto _fefb ;_efab :_aec =17;goto _fefb ;_bee :_aec =48;goto _fefb ;_fgc :_aec =18;goto _fefb ;_edcg :_aec =19;goto _fefb ;_abcg :_aec =20;goto _fefb ;_fgef :_aec =49;goto _fefb ;_ecdg :_aec =50;goto _fefb ;_fag :_aec =21;goto _fefb ;_abeg :_aec =22;goto _fefb ;_gdcb :_aec =23;goto _fefb ;_adde :_aec =24;goto _fefb ;_ebbd :_aec =25;goto _fefb ;_fbda :_aec =51;goto _fefb ;_dfcd :_aec =26;goto _fefb ;_dagb :_aec =52;goto _fefb ;_ecgfd :_aec =53;goto _fefb ;_bbd :_aec =54;goto _fefb ;_aade :_aec =55;goto _fefb ;_adcdb :_aec =56;goto _fefb ;_ded :_aec =57;goto _fefb ;_eeag :_aec =27;goto _fefb ;_aef :_aec =28;goto _fefb ;_eabg :_aec =29;goto _fefb ;_fgad :_aec =30;goto _fefb ;_gedba :_aec =31;goto _fefb ;_dcce :_aec =58;goto _fefb ;_agbf :_aec =32;goto _fefb ;_ead :_aec =59;goto _fefb ;_cfc :_aec =33;goto _fefb ;_gbfa :_aec =60;goto _fefb ;_ggca :_aec =61;goto _fefb ;_fcae :_aec =62;goto _fefb ;_fefb :{};if _eeb ==_beda {switch _aec {case 35:goto _aag ;case 0:goto _bge ;case 36:goto _ced ;case 37:goto _fbb ;case 1:goto _bge ;case 2:goto _bge ;case 38:goto _agb ;case 3:goto _ecge ;case 4:goto _ecge ;case 39:goto _agb ;case 5:goto _ecge ;case 6:goto _ecge ;case 7:goto _ecge ;case 8:goto _bge ;case 40:goto _agb ;case 9:goto _ecge ;case 41:goto _agb ;case 10:goto _bge ;case 42:goto _agb ;case 11:goto _ecge ;case 43:goto _agb ;case 44:goto _agb ;case 45:goto _agb ;case 12:goto _cga ;case 46:goto _dec ;case 13:goto _aea ;case 14:goto _bge ;case 15:goto _bge ;case 16:goto _aea ;case 47:goto _daf ;case 17:goto _cgae ;case 48:goto _baeea ;case 18:goto _bfg ;case 19:goto _bfg ;case 20:goto _bge ;case 49:goto _aag ;case 50:goto _fbd ;case 21:goto _bge ;case 22:goto _bge ;case 23:goto _bge ;case 24:goto _bge ;case 25:goto _bge ;case 51:goto _fbd ;case 26:goto _dbd ;case 52:goto _fbd ;case 53:goto _fbd ;case 54:goto _ddc ;case 55:goto _aag ;case 56:goto _aag ;case 57:goto _aag ;case 27:goto _dag ;case 28:goto _dag ;case 29:goto _dag ;case 30:goto _dag ;case 31:goto _dag ;case 58:goto _aag ;case 32:goto _bge ;case 59:goto _bge ;case 33:goto _dag ;case 60:goto _aag ;case 61:goto _daf ;case 62:goto _aag ;};};};if _ecg > 0{copy (_bdcf [0:],_bdcf [_ecg :]);};};_ =_beda ;if _aec ==_aeb {_dc .Log ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_dd :=Parse (f );var _ged Format ;if len (_dd )==1{_ged =_dd [0];}else if len (_dd )==4{_ged =_dd [3];};_de :=false ;for _ ,_db :=range _ged .Whole {if _db .Type ==FmtTypeText {_de =true ;};};if !_de {return v ;};_bf :=_b .Buffer {};for _ ,_cd :=range _ged .Whole {switch _cd .Type {case FmtTypeLiteral :_bf .WriteByte (_cd .Literal );case FmtTypeText :_bf .WriteString (v );};};return _bf .String ();};

// AddToken adds a format token to the format.
func (_gec *Format )AddToken (t FmtType ,l []byte ){if _gec ._cc {_gec ._cc =false ;return ;};switch t {case FmtTypeDecimal :_gec ._geg =true ;case FmtTypeUnderscore :_gec ._cc =true ;case FmtTypeText :_gec .Whole =append (_gec .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_gec .Whole =append (_gec .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_gec ._bg =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_ca :=range l {if _gec .IsExponential {_gec .Exponent =append (_gec .Exponent ,Token {Type :t ,Literal :_ca });}else if !_gec ._geg {_gec .Whole =append (_gec .Whole ,Token {Type :t ,Literal :_ca });}else {_gec .Fractional =append (_gec .Fractional ,Token {Type :t ,Literal :_ca });};};case FmtTypeDigitOptThousands :_gec ._ab =true ;case FmtTypeFraction :_fgd :=_d .Split (string (l ),"\u002f");if len (_fgd )==2{_gec ._fe =true ;_gec ._ece ,_ =_df .ParseInt (_fgd [1],10,64);for _ ,_bd :=range _fgd [1]{if _bd =='?'||_bd =='0'{_gec ._gg ++;};};};default:_dc .Log ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};func _dg (_fef int64 )int64 {if _fef < 0{return -_fef ;};return _fef ;};func _gedb (_ae []byte )[]byte {for _eb :=0;_eb < len (_ae )/2;_eb ++{_abe :=len (_ae )-1-_eb ;_ae [_eb ],_ae [_abe ]=_ae [_abe ],_ae [_eb ];};return _ae ;};const _ge =1e-10;type Lexer struct{_dfbf Format ;_efdg []Format ;};

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_fe bool ;_bg bool ;_ecff bool ;_ab bool ;_cc bool ;_geg bool ;_ece int64 ;_gg int ;};const _gf int =-1;func (_aab *Lexer )nextFmt (){_aab ._efdg =append (_aab ._efdg ,_aab ._dfbf );_aab ._dfbf =Format {}};func _fbc (_bae []byte )[]byte {_gea :=len (_bae );_ddf :=false ;_afb :=false ;for _abc :=len (_bae )-1;_abc >=0;_abc --{if _bae [_abc ]=='0'&&!_afb &&!_ddf {_gea =_abc ;}else if _bae [_abc ]=='.'{_ddf =true ;}else {_afb =true ;};};if _ddf &&_afb {if _bae [_gea -1]=='.'{_gea --;};return _bae [0:_gea ];};return _bae ;};const _aeb int =-1;func _gdg (_ada _c .Time ,_bab string )[]byte {_bgb :=[]byte {};_dbg :=0;for _dfff :=0;_dfff < len (_bab );_dfff ++{var _aca string ;if _bab [_dfff ]=='/'{_aca =string (_bab [_dbg :_dfff ]);_dbg =_dfff +1;}else if _dfff ==len (_bab )-1{_aca =string (_bab [_dbg :_dfff +1]);}else {continue ;};switch _aca {case "\u0079\u0079":_bgb =_ada .AppendFormat (_bgb ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_bgb =_ada .AppendFormat (_bgb ,"\u0032\u0030\u0030\u0036");case "\u006d":_bgb =_ada .AppendFormat (_bgb ,"\u0031");case "\u006d\u006d":_bgb =_ada .AppendFormat (_bgb ,"\u0030\u0031");case "\u006d\u006d\u006d":_bgb =_ada .AppendFormat (_bgb ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_bgb =_ada .AppendFormat (_bgb ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _ada .Month (){case _c .January ,_c .July ,_c .June :_bgb =append (_bgb ,'J');case _c .February :_bgb =append (_bgb ,'M');case _c .March ,_c .May :_bgb =append (_bgb ,'M');case _c .April ,_c .August :_bgb =append (_bgb ,'A');case _c .September :_bgb =append (_bgb ,'S');case _c .October :_bgb =append (_bgb ,'O');case _c .November :_bgb =append (_bgb ,'N');case _c .December :_bgb =append (_bgb ,'D');};case "\u0064":_bgb =_ada .AppendFormat (_bgb ,"\u0032");case "\u0064\u0064":_bgb =_ada .AppendFormat (_bgb ,"\u0030\u0032");case "\u0064\u0064\u0064":_bgb =_ada .AppendFormat (_bgb ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_bgb =_ada .AppendFormat (_bgb ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_dc .Log ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_aca );};if _bab [_dfff ]=='/'{_bgb =append (_bgb ,'/');};};return _bgb ;};const _gbf int =0;