//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format ;import (_bc "bytes";_b "fmt";_da "github.com/unidoc/unioffice/common/logger";_c "io";_ca "math";_f "strconv";_a "strings";_bg "time";);const _gae int =34;const _fc ="\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074";

// Format is a parsed number format.
type Format struct{Whole []Token ;Fractional []Token ;Exponent []Token ;IsExponential bool ;_dd bool ;_fd bool ;_fde bool ;_bd bool ;_cf bool ;_g bool ;_db int64 ;_bba int ;};func Parse (s string )[]Format {_cegb :=Lexer {};_cegb .Lex (_a .NewReader (s ));_cegb ._aaa =append (_cegb ._aaa ,_cegb ._ag );return _cegb ._aaa ;};const _aga int =-1;func _ccg (_bde int64 )int64 {if _bde < 0{return -_bde ;};return _bde ;};const _bb =1e11;const _dgc int =0;func _bbd (_gaf int64 ,_gbdfe Format )[]byte {if !_gbdfe .IsExponential ||len (_gbdfe .Exponent )==0{return nil ;};_fdb :=_f .AppendInt (nil ,_ccg (_gaf ),10);_be :=make ([]byte ,0,len (_fdb )+2);_be =append (_be ,'E');if _gaf >=0{_be =append (_be ,'+');}else {_be =append (_be ,'-');_gaf *=-1;};_adbg :=0;_gcc :for _dagb :=len (_gbdfe .Exponent )-1;_dagb >=0;_dagb --{_bf :=len (_fdb )-1-_adbg ;_gfb :=_gbdfe .Exponent [_dagb ];switch _gfb .Type {case FmtTypeDigit :if _bf >=0{_be =append (_be ,_fdb [_bf ]);_adbg ++;}else {_be =append (_be ,'0');};case FmtTypeDigitOpt :if _bf >=0{_be =append (_be ,_fdb [_bf ]);_adbg ++;}else {for _gge :=_dagb ;_gge >=0;_gge --{_bea :=_gbdfe .Exponent [_gge ];if _bea .Type ==FmtTypeLiteral {_be =append (_be ,_bea .Literal );};};break _gcc ;};case FmtTypeLiteral :_be =append (_be ,_gfb .Literal );default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076",_gfb );};};if _adbg < len (_fdb ){_be =append (_be ,_fdb [len (_fdb )-_adbg -1:_adbg -1]...);};_geg (_be [2:]);return _be ;};

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value (v string ,f string )string {if IsNumber (v ){_gg ,_ :=_f .ParseFloat (v ,64);return Number (_gg ,f );};return String (v ,f );};const _aba int =-1;func IsNumber (data string )(_ceg bool ){_dabdf ,_egd ,_cef :=0,0,len (data );_ded :=len (data );_fca ,_ade ,_bccd :=0,0,0;_ =_ade ;_ =_bccd ;_ =_fca ;{_dabdf =_dgc ;_fca =0;_ade =0;_bccd =0;};{if _egd ==_cef {goto _bdac ;};switch _dabdf {case 0:goto _cff ;case 1:goto _gbg ;case 2:goto _efa ;case 3:goto _gda ;case 4:goto _cgd ;case 5:goto _gba ;case 6:goto _cgab ;case 7:goto _dafd ;};goto _bfcg ;_abaf :_ade =_egd ;_egd --;{_ceg =false ;};goto _fdeg ;_aa :_ade =_egd ;_egd --;{_ceg =_ade ==len (data );};goto _fdeg ;_abe :_ade =_egd ;_egd --;{_ceg =_ade ==len (data );};goto _fdeg ;_afb :switch _bccd {case 2:{_egd =(_ade )-1;_ceg =_ade ==len (data );};case 3:{_egd =(_ade )-1;_ceg =false ;};};goto _fdeg ;_fdeg :_fca =0;if _egd ++;_egd ==_cef {goto _cbe ;};_cff :_fca =_egd ;switch data [_egd ]{case 43:goto _dgb ;case 45:goto _dgb ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _ccge ;};goto _gdd ;_gdd :if _egd ++;_egd ==_cef {goto _aab ;};_gbg :goto _gdd ;_dgb :if _egd ++;_egd ==_cef {goto _afe ;};_efa :if 48<=data [_egd ]&&data [_egd ]<=57{goto _ccge ;};goto _gdd ;_ccge :if _egd ++;_egd ==_cef {goto _gaa ;};_gda :if data [_egd ]==46{goto _dfc ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _ccge ;};goto _gdd ;_dfc :if _egd ++;_egd ==_cef {goto _fagc ;};_cgd :if 48<=data [_egd ]&&data [_egd ]<=57{goto _daf ;};goto _gdd ;_daf :if _egd ++;_egd ==_cef {goto _dgbd ;};_gba :if data [_egd ]==69{goto _gbdfc ;};if 48<=data [_egd ]&&data [_egd ]<=57{goto _daf ;};goto _gdd ;_gbdfc :if _egd ++;_egd ==_cef {goto _gdb ;};_cgab :switch data [_egd ]{case 43:goto _edd ;case 45:goto _edd ;};goto _gdd ;_edd :_ade =_egd +1;_bccd =3;goto _fgc ;_acde :_ade =_egd +1;_bccd =2;goto _fgc ;_fgc :if _egd ++;_egd ==_cef {goto _caee ;};_dafd :if 48<=data [_egd ]&&data [_egd ]<=57{goto _acde ;};goto _gdd ;_bfcg :_cbe :_dabdf =0;goto _bdac ;_aab :_dabdf =1;goto _bdac ;_afe :_dabdf =2;goto _bdac ;_gaa :_dabdf =3;goto _bdac ;_fagc :_dabdf =4;goto _bdac ;_dgbd :_dabdf =5;goto _bdac ;_gdb :_dabdf =6;goto _bdac ;_caee :_dabdf =7;goto _bdac ;_bdac :{};if _egd ==_ded {switch _dabdf {case 1:goto _abaf ;case 2:goto _abaf ;case 3:goto _aa ;case 4:goto _abaf ;case 5:goto _abe ;case 6:goto _abaf ;case 7:goto _afb ;};};};if _dabdf ==_aga {return false ;};return ;};func _agcd (_dda _bg .Time )_bg .Time {_dda =_dda .UTC ();return _bg .Date (_dda .Year (),_dda .Month (),_dda .Day (),_dda .Hour (),_dda .Minute (),_dda .Second (),_dda .Nanosecond (),_bg .Local );};func _adg (_gc ,_fagd float64 ,_cdf Format )[]byte {if len (_cdf .Fractional )==0{return nil ;};_ede :=_f .AppendFloat (nil ,_gc ,'f',-1,64);if len (_ede )> 2{_ede =_ede [2:];}else {_ede =nil ;};_eae :=make ([]byte ,0,len (_ede ));_eae =append (_eae ,'.');_cb :=0;_edcc :for _cgg :=0;_cgg < len (_cdf .Fractional );_cgg ++{_fee :=_cgg ;_fea :=_cdf .Fractional [_cgg ];switch _fea .Type {case FmtTypeDigit :if _fee < len (_ede ){_eae =append (_eae ,_ede [_fee ]);_cb ++;}else {_eae =append (_eae ,'0');};case FmtTypeDigitOpt :if _fee >=0{_eae =append (_eae ,_ede [_fee ]);_cb ++;}else {break _edcc ;};case FmtTypeLiteral :_eae =append (_eae ,_fea .Literal );default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076",_fea );};};return _eae ;};const _gead int =0;

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number (v float64 ,f string )string {if f ==""||f =="\u0047e\u006e\u0065\u0072\u0061\u006c"||f =="\u0040"{return NumberGeneric (v );};_ab :=Parse (f );if len (_ab )==1{return _fag (v ,_ab [0],false );}else if len (_ab )> 1&&v < 0{return _fag (v ,_ab [1],true );}else if len (_ab )> 2&&v ==0{return _fag (v ,_ab [2],false );};return _fag (v ,_ab [0],false );};func _eeda (_dg _bg .Time ,_ebc float64 ,_acc string )[]byte {_ccgb :=[]byte {};_faf :=0;for _bgb :=0;_bgb < len (_acc );_bgb ++{var _bge string ;if _acc [_bgb ]==':'{_bge =string (_acc [_faf :_bgb ]);_faf =_bgb +1;}else if _bgb ==len (_acc )-1{_bge =string (_acc [_faf :_bgb +1]);}else {continue ;};switch _bge {case "\u0064":_ccgb =_dg .AppendFormat (_ccgb ,"\u0032");case "\u0068":_ccgb =_dg .AppendFormat (_ccgb ,"\u0033");case "\u0068\u0068":_ccgb =_dg .AppendFormat (_ccgb ,"\u0031\u0035");case "\u006d":_ccgb =_dg .AppendFormat (_ccgb ,"\u0034");case "\u006d\u006d":_ccgb =_dg .AppendFormat (_ccgb ,"\u0030\u0034");case "\u0073":_ccgb =_dg .Round (_bg .Second ).AppendFormat (_ccgb ,"\u0035");case "\u0073\u002e\u0030":_ccgb =_dg .Round (_bg .Second /10).AppendFormat (_ccgb ,"\u0035\u002e\u0030");case "\u0073\u002e\u0030\u0030":_ccgb =_dg .Round (_bg .Second /100).AppendFormat (_ccgb ,"\u0035\u002e\u0030\u0030");case "\u0073\u002e\u00300\u0030":_ccgb =_dg .Round (_bg .Second /1000).AppendFormat (_ccgb ,"\u0035\u002e\u00300\u0030");case "\u0073\u0073":_ccgb =_dg .Round (_bg .Second ).AppendFormat (_ccgb ,"\u0030\u0035");case "\u0073\u0073\u002e\u0030":_ccgb =_dg .Round (_bg .Second /10).AppendFormat (_ccgb ,"\u0030\u0035\u002e\u0030");case "\u0073\u0073\u002e0\u0030":_ccgb =_dg .Round (_bg .Second /100).AppendFormat (_ccgb ,"\u0030\u0035\u002e0\u0030");case "\u0073\u0073\u002e\u0030\u0030\u0030":_ccgb =_dg .Round (_bg .Second /1000).AppendFormat (_ccgb ,"\u0030\u0035\u002e\u0030\u0030\u0030");case "\u0041\u004d\u002fP\u004d":_ccgb =_dg .AppendFormat (_ccgb ,"\u0050\u004d");case "\u005b\u0068\u005d":_ccgb =_f .AppendInt (_ccgb ,int64 (_ebc *24),10);case "\u005b\u006d\u005d":_ccgb =_f .AppendInt (_ccgb ,int64 (_ebc *24*60),10);case "\u005b\u0073\u005d":_ccgb =_f .AppendInt (_ccgb ,int64 (_ebc *24*60*60),10);case "":default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_bge );};if _acc [_bgb ]==':'{_ccgb =append (_ccgb ,':');};};return _ccgb ;};

// AddToken adds a format token to the format.
func (_ad *Format )AddToken (t FmtType ,l []byte ){if _ad ._cf {_ad ._cf =false ;return ;};switch t {case FmtTypeDecimal :_ad ._g =true ;case FmtTypeUnderscore :_ad ._cf =true ;case FmtTypeText :_ad .Whole =append (_ad .Whole ,Token {Type :t });case FmtTypeDate ,FmtTypeTime :_ad .Whole =append (_ad .Whole ,Token {Type :t ,DateTime :string (l )});case FmtTypePercent :_ad ._fd =true ;t =FmtTypeLiteral ;l =[]byte {'%'};fallthrough;case FmtTypeDigitOpt :fallthrough;case FmtTypeLiteral ,FmtTypeDigit ,FmtTypeDollar ,FmtTypeComma :if l ==nil {l =[]byte {0};};for _ ,_cg :=range l {if _ad .IsExponential {_ad .Exponent =append (_ad .Exponent ,Token {Type :t ,Literal :_cg });}else if !_ad ._g {_ad .Whole =append (_ad .Whole ,Token {Type :t ,Literal :_cg });}else {_ad .Fractional =append (_ad .Fractional ,Token {Type :t ,Literal :_cg });};};case FmtTypeDigitOptThousands :_ad ._bd =true ;case FmtTypeFraction :_gd :=_a .Split (string (l ),"\u002f");if len (_gd )==2{_ad ._dd =true ;_ad ._db ,_ =_f .ParseInt (_gd [1],10,64);for _ ,_gb :=range _gd [1]{if _gb =='?'||_gb =='0'{_ad ._bba ++;};};};default:_da .Log .Debug ("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076",t );};};const (FmtTypeLiteral FmtType =iota ;FmtTypeDigit ;FmtTypeDigitOpt ;FmtTypeComma ;FmtTypeDecimal ;FmtTypePercent ;FmtTypeDollar ;FmtTypeDigitOptThousands ;FmtTypeUnderscore ;FmtTypeDate ;FmtTypeTime ;FmtTypeFraction ;FmtTypeText ;);func _acf (_egb []byte )[]byte {for _cbd :=len (_egb )-1;_cbd > 0;_cbd --{if _egb [_cbd ]=='9'+1{_egb [_cbd ]='0';if _egb [_cbd -1]=='.'{_cbd --;};_egb [_cbd -1]++;};};if _egb [0]=='9'+1{_egb [0]='0';copy (_egb [1:],_egb [0:]);_egb [0]='1';};return _egb ;};func (_abg *Lexer )Lex (r _c .Reader ){_dcg ,_dge ,_gaef :=0,0,0;_ccged :=-1;_acb ,_aac ,_eef :=0,0,0;_ =_aac ;_ =_eef ;_cce :=1;_ =_cce ;_bec :=make ([]byte ,4096);_bfa :=false ;for !_bfa {_baf :=0;if _acb > 0{_baf =_dge -_acb ;};_dge =0;_gbdcf ,_ddd :=r .Read (_bec [_baf :]);if _gbdcf ==0||_ddd !=nil {_bfa =true ;};_gaef =_gbdcf +_baf ;if _gaef < len (_bec ){_ccged =_gaef ;};{_dcg =_bgc ;_acb =0;_aac =0;_eef =0;};{if _dge ==_gaef {goto _ecafb ;};switch _dcg {case 34:goto _ecd ;case 35:goto _dcf ;case 0:goto _dgd ;case 36:goto _dee ;case 37:goto _ffd ;case 1:goto _gca ;case 2:goto _gdff ;case 38:goto _bage ;case 3:goto _gef ;case 4:goto _gafe ;case 39:goto _eea ;case 5:goto _ggde ;case 6:goto _ceeb ;case 7:goto _dcfa ;case 8:goto _cbeb ;case 40:goto _cfgd ;case 9:goto _gcb ;case 41:goto _aff ;case 10:goto _feea ;case 42:goto _bbaf ;case 11:goto _fef ;case 43:goto _ccgc ;case 44:goto _gafde ;case 45:goto _fbbg ;case 12:goto _gdeg ;case 46:goto _bead ;case 13:goto _aag ;case 14:goto _caea ;case 15:goto _gbfa ;case 16:goto _cgdga ;case 47:goto _aae ;case 17:goto _acee ;case 48:goto _bfab ;case 18:goto _bfe ;case 19:goto _ffbe ;case 20:goto _egf ;case 49:goto _fad ;case 50:goto _feeb ;case 21:goto _dcfd ;case 22:goto _adaa ;case 23:goto _edg ;case 24:goto _gggc ;case 25:goto _dcd ;case 51:goto _ecac ;case 26:goto _fac ;case 52:goto _gac ;case 53:goto _gcba ;case 54:goto _gad ;case 55:goto _ebe ;case 56:goto _afeb ;case 57:goto _adc ;case 27:goto _fgb ;case 28:goto _bgbf ;case 29:goto _fcef ;case 30:goto _bab ;case 31:goto _ecaa ;case 58:goto _cgfc ;case 32:goto _fbc ;case 59:goto _gbac ;case 33:goto _fcgg ;case 60:goto _fdae ;case 61:goto _gcbb ;case 62:goto _bdfg ;};goto _gag ;_dac :switch _eef {case 2:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeDigit ,nil );};case 3:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeDigitOpt ,nil );};case 5:{_dge =(_aac )-1;};case 8:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypePercent ,nil );};case 13:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeFraction ,_bec [_acb :_aac ]);};case 14:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeDate ,_bec [_acb :_aac ]);};case 15:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeTime ,_bec [_acb :_aac ]);};case 16:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeTime ,_bec [_acb :_aac ]);};case 18:{_dge =(_aac )-1;};case 20:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb :_aac ]);};case 21:{_dge =(_aac )-1;_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb +1:_aac -1]);};};goto _cfg ;_cdad :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeFraction ,_bec [_acb :_aac ]);};goto _cfg ;_ege :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeDigitOpt ,nil );};goto _cfg ;_fcc :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeDigitOptThousands ,nil );};goto _cfg ;_ada :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypePercent ,nil );};goto _cfg ;_dbc :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeDate ,_bec [_acb :_aac ]);};goto _cfg ;_gbdfea :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeDigit ,nil );};goto _cfg ;_gfd :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeTime ,_bec [_acb :_aac ]);};goto _cfg ;_agc :_dge =(_aac )-1;{_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb :_aac ]);};goto _cfg ;_gged :_aac =_dge +1;{_abg ._ag ._fde =true ;};goto _cfg ;_ggc :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb :_aac ]);};goto _cfg ;_cgdg :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeDollar ,nil );};goto _cfg ;_ace :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeComma ,nil );};goto _cfg ;_cca :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeDecimal ,nil );};goto _cfg ;_abc :_aac =_dge +1;{_abg .nextFmt ();};goto _cfg ;_edf :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeText ,nil );};goto _cfg ;_cbb :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeUnderscore ,nil );};goto _cfg ;_gafc :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb :_aac ]);};goto _cfg ;_cag :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb +1:_aac -1]);};goto _cfg ;_dcb :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeDigitOpt ,nil );};goto _cfg ;_eaef :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeFraction ,_bec [_acb :_aac ]);};goto _cfg ;_acad :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypePercent ,nil );};goto _cfg ;_gde :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeDate ,_bec [_acb :_aac ]);};goto _cfg ;_fda :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeDigit ,nil );};goto _cfg ;_fffd :_aac =_dge ;_dge --;{_abg ._ag .AddToken (FmtTypeTime ,_bec [_acb :_aac ]);};goto _cfg ;_gfc :_aac =_dge ;_dge --;{};goto _cfg ;_fdbc :_aac =_dge +1;{_abg ._ag .IsExponential =true ;};goto _cfg ;_fdd :_aac =_dge +1;{_abg ._ag .AddToken (FmtTypeLiteral ,_bec [_acb +1:_aac ]);};goto _cfg ;_cfg :_acb =0;if _dge ++;_dge ==_gaef {goto _gab ;};_ecd :_acb =_dge ;switch _bec [_dge ]{case 34:goto _afd ;case 35:goto _bbae ;case 36:goto _cgdg ;case 37:goto _ecbd ;case 44:goto _ace ;case 46:goto _cca ;case 47:goto _ecc ;case 48:goto _beeb ;case 58:goto _bfb ;case 59:goto _abc ;case 63:goto _cdd ;case 64:goto _edf ;case 65:goto _eeae ;case 69:goto _cac ;case 71:goto _ebca ;case 91:goto _beef ;case 92:goto _acadb ;case 95:goto _cbb ;case 100:goto _ecc ;case 104:goto _bfb ;case 109:goto _ddb ;case 115:goto _fba ;case 121:goto _bbaee ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _baaa ;};goto _ggc ;_afd :_aac =_dge +1;_eef =20;goto _bgg ;_bgg :if _dge ++;_dge ==_gaef {goto _feab ;};_dcf :if _bec [_dge ]==34{goto _dba ;};goto _gecc ;_gecc :if _dge ++;_dge ==_gaef {goto _acg ;};_dgd :if _bec [_dge ]==34{goto _dba ;};goto _gecc ;_dba :_aac =_dge +1;_eef =21;goto _afad ;_afad :if _dge ++;_dge ==_gaef {goto _ced ;};_dee :if _bec [_dge ]==34{goto _gecc ;};goto _cag ;_bbae :_aac =_dge +1;_eef =3;goto _gga ;_gga :if _dge ++;_dge ==_gaef {goto _dec ;};_ffd :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _gce ;case 44:goto _eag ;case 47:goto _efd ;case 48:goto _gce ;case 63:goto _gce ;};goto _dcb ;_gce :if _dge ++;_dge ==_gaef {goto _bdb ;};_gca :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _gce ;case 47:goto _efd ;case 48:goto _gce ;case 63:goto _gce ;};goto _dac ;_efd :if _dge ++;_dge ==_gaef {goto _gegf ;};_gdff :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _dafg ;case 48:goto _bff ;case 63:goto _caf ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _fge ;};goto _dac ;_caf :_aac =_dge +1;goto _dgf ;_dgf :if _dge ++;_dge ==_gaef {goto _cad ;};_bage :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _caf ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _caf ;case 63:goto _caf ;case 65:goto _cdaa ;};goto _eaef ;_cdaa :if _dge ++;_dge ==_gaef {goto _dfcb ;};_gef :switch _bec [_dge ]{case 47:goto _feg ;case 77:goto _gafd ;};goto _cdad ;_feg :if _dge ++;_dge ==_gaef {goto _bgfg ;};_gafe :if _bec [_dge ]==80{goto _acbe ;};goto _cdad ;_acbe :_aac =_dge +1;goto _gfca ;_gfca :if _dge ++;_dge ==_gaef {goto _gcf ;};_eea :if _bec [_dge ]==65{goto _cdaa ;};goto _eaef ;_gafd :if _dge ++;_dge ==_gaef {goto _fgd ;};_ggde :if _bec [_dge ]==47{goto _aea ;};goto _cdad ;_aea :if _dge ++;_dge ==_gaef {goto _ffca ;};_ceeb :if _bec [_dge ]==80{goto _bbfc ;};goto _cdad ;_bbfc :if _dge ++;_dge ==_gaef {goto _gabf ;};_dcfa :if _bec [_dge ]==77{goto _acbe ;};goto _cdad ;_dafg :if _dge ++;_dge ==_gaef {goto _dcec ;};_cbeb :switch _bec [_dge ]{case 35:goto _gfcd ;case 37:goto _acfd ;case 63:goto _gfcd ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _dce ;};goto _dac ;_gfcd :_aac =_dge +1;goto _bbbf ;_bbbf :if _dge ++;_dge ==_gaef {goto _bfee ;};_cfgd :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _cgf ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _caf ;case 63:goto _caf ;case 65:goto _cdaa ;};goto _eaef ;_cgf :if _dge ++;_dge ==_gaef {goto _bbfa ;};_gcb :switch _bec [_dge ]{case 35:goto _cab ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cab ;case 63:goto _cab ;};goto _cdad ;_cab :_aac =_dge +1;goto _aedc ;_aedc :if _dge ++;_dge ==_gaef {goto _egc ;};_aff :switch _bec [_dge ]{case 35:goto _cab ;case 44:goto _cab ;case 46:goto _cab ;case 48:goto _cab ;case 63:goto _cab ;case 65:goto _cdaa ;};goto _eaef ;_acfd :if _dge ++;_dge ==_gaef {goto _cec ;};_feea :if _bec [_dge ]==37{goto _acfd ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _dce ;};goto _dac ;_dce :_aac =_dge +1;_eef =13;goto _gbed ;_gbed :if _dge ++;_dge ==_gaef {goto _ccee ;};_bbaf :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _bee ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _gfbe ;case 63:goto _caf ;case 65:goto _cdaa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _dce ;};goto _eaef ;_bee :if _dge ++;_dge ==_gaef {goto _bgca ;};_fef :switch _bec [_dge ]{case 35:goto _cab ;case 37:goto _acfd ;case 44:goto _cab ;case 46:goto _cab ;case 63:goto _cab ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _dce ;};goto _cdad ;_gfbe :_aac =_dge +1;goto _ffe ;_ffe :if _dge ++;_dge ==_gaef {goto _ebf ;};_ccgc :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _gfbe ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _gfbe ;case 63:goto _caf ;case 65:goto _cdaa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _dce ;};goto _eaef ;_bff :_aac =_dge +1;goto _bffb ;_bffb :if _dge ++;_dge ==_gaef {goto _gggcg ;};_gafde :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _gfbe ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _bff ;case 63:goto _caf ;case 65:goto _cdaa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _fge ;};goto _eaef ;_fge :_aac =_dge +1;goto _bcg ;_bcg :if _dge ++;_dge ==_gaef {goto _dbcg ;};_fbbg :switch _bec [_dge ]{case 35:goto _caf ;case 37:goto _dce ;case 44:goto _caf ;case 46:goto _caf ;case 48:goto _bff ;case 63:goto _caf ;case 65:goto _cdaa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _fge ;};goto _eaef ;_eag :if _dge ++;_dge ==_gaef {goto _cfe ;};_gdeg :if _bec [_dge ]==35{goto _fcc ;};goto _ege ;_ecbd :_aac =_dge +1;_eef =8;goto _bbce ;_bbce :if _dge ++;_dge ==_gaef {goto _ggce ;};_bead :switch _bec [_dge ]{case 35:goto _cfa ;case 37:goto _agcb ;case 48:goto _fbbc ;case 63:goto _cfa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _afaf ;};goto _acad ;_cfa :if _dge ++;_dge ==_gaef {goto _bffa ;};_aag :switch _bec [_dge ]{case 35:goto _cfa ;case 47:goto _efd ;case 48:goto _cfa ;case 63:goto _cfa ;};goto _ada ;_agcb :if _dge ++;_dge ==_gaef {goto _dca ;};_caea :if _bec [_dge ]==37{goto _agcb ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _afaf ;};goto _dac ;_afaf :if _dge ++;_dge ==_gaef {goto _eaga ;};_gbfa :switch _bec [_dge ]{case 37:goto _agcb ;case 47:goto _efd ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _afaf ;};goto _dac ;_fbbc :if _dge ++;_dge ==_gaef {goto _dafdd ;};_cgdga :switch _bec [_dge ]{case 35:goto _cfa ;case 37:goto _agcb ;case 47:goto _efd ;case 48:goto _fbbc ;case 63:goto _cfa ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _afaf ;};goto _ada ;_ecc :_aac =_dge +1;goto _gcec ;_gcec :if _dge ++;_dge ==_gaef {goto _bdeee ;};_aae :switch _bec [_dge ]{case 47:goto _ecc ;case 100:goto _ecc ;case 109:goto _ecc ;case 121:goto _ffg ;};goto _gde ;_ffg :if _dge ++;_dge ==_gaef {goto _eda ;};_acee :if _bec [_dge ]==121{goto _ecc ;};goto _dbc ;_beeb :_aac =_dge +1;_eef =2;goto _beb ;_beb :if _dge ++;_dge ==_gaef {goto _gbaf ;};_bfab :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _adea ;case 47:goto _efd ;case 48:goto _ddg ;case 63:goto _gce ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _bdee ;};goto _fda ;_adea :if _dge ++;_dge ==_gaef {goto _aedcd ;};_bfe :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _adea ;case 47:goto _efd ;case 48:goto _adea ;case 63:goto _gce ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _afaf ;};goto _gbdfea ;_ddg :if _dge ++;_dge ==_gaef {goto _cffd ;};_ffbe :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _adea ;case 47:goto _efd ;case 48:goto _ddg ;case 63:goto _gce ;};if 49<=_bec [_dge ]&&_bec [_dge ]<=57{goto _bdee ;};goto _gbdfea ;_bdee :if _dge ++;_dge ==_gaef {goto _aggg ;};_egf :switch _bec [_dge ]{case 37:goto _afaf ;case 47:goto _efd ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _bdee ;};goto _dac ;_baaa :_aac =_dge +1;_eef =20;goto _gefe ;_gefe :if _dge ++;_dge ==_gaef {goto _bcea ;};_fad :switch _bec [_dge ]{case 37:goto _afaf ;case 47:goto _efd ;};if 48<=_bec [_dge ]&&_bec [_dge ]<=57{goto _bdee ;};goto _gafc ;_bfb :_aac =_dge +1;_eef =15;goto _cfdd ;_cfdd :if _dge ++;_dge ==_gaef {goto _ccd ;};_feeb :switch _bec [_dge ]{case 58:goto _bfb ;case 65:goto _bggb ;case 104:goto _bfb ;case 109:goto _bfb ;case 115:goto _fba ;};goto _fffd ;_bggb :if _dge ++;_dge ==_gaef {goto _bdd ;};_dcfd :switch _bec [_dge ]{case 47:goto _eca ;case 77:goto _cgde ;};goto _dac ;_eca :if _dge ++;_dge ==_gaef {goto _cadc ;};_adaa :if _bec [_dge ]==80{goto _bfb ;};goto _dac ;_cgde :if _dge ++;_dge ==_gaef {goto _ggcg ;};_edg :if _bec [_dge ]==47{goto _bggf ;};goto _dac ;_bggf :if _dge ++;_dge ==_gaef {goto _cdg ;};_gggc :if _bec [_dge ]==80{goto _bca ;};goto _dac ;_bca :if _dge ++;_dge ==_gaef {goto _bfff ;};_dcd :if _bec [_dge ]==77{goto _bfb ;};goto _dac ;_fba :_aac =_dge +1;_eef =15;goto _fgcf ;_fgcf :if _dge ++;_dge ==_gaef {goto _beg ;};_ecac :switch _bec [_dge ]{case 46:goto _ecaf ;case 58:goto _bfb ;case 65:goto _bggb ;case 104:goto _bfb ;case 109:goto _bfb ;case 115:goto _fba ;};goto _fffd ;_ecaf :if _dge ++;_dge ==_gaef {goto _ged ;};_fac :if _bec [_dge ]==48{goto _egbg ;};goto _gfd ;_egbg :_aac =_dge +1;_eef =15;goto _cbg ;_cbg :if _dge ++;_dge ==_gaef {goto _ebeb ;};_gac :switch _bec [_dge ]{case 48:goto _dfb ;case 58:goto _bfb ;case 65:goto _bggb ;case 104:goto _bfb ;case 109:goto _bfb ;case 115:goto _fba ;};goto _fffd ;_dfb :_aac =_dge +1;_eef =15;goto _dcc ;_dcc :if _dge ++;_dge ==_gaef {goto _geb ;};_gcba :switch _bec [_dge ]{case 48:goto _bfb ;case 58:goto _bfb ;case 65:goto _bggb ;case 104:goto _bfb ;case 109:goto _bfb ;case 115:goto _fba ;};goto _fffd ;_cdd :_aac =_dge +1;_eef =5;goto _dcfe ;_dcfe :if _dge ++;_dge ==_gaef {goto _ccb ;};_gad :switch _bec [_dge ]{case 35:goto _gce ;case 37:goto _gce ;case 47:goto _efd ;case 48:goto _gce ;case 63:goto _gce ;};goto _gfc ;_eeae :_aac =_dge +1;_eef =20;goto _bebc ;_bebc :if _dge ++;_dge ==_gaef {goto _dga ;};_ebe :switch _bec [_dge ]{case 47:goto _eca ;case 77:goto _cgde ;};goto _gafc ;_cac :if _dge ++;_dge ==_gaef {goto _gaae ;};_afeb :switch _bec [_dge ]{case 43:goto _fdbc ;case 45:goto _fdbc ;};goto _gafc ;_ebca :_aac =_dge +1;goto _agg ;_agg :if _dge ++;_dge ==_gaef {goto _ggag ;};_adc :if _bec [_dge ]==101{goto _dcdd ;};goto _gafc ;_dcdd :if _dge ++;_dge ==_gaef {goto _deg ;};_fgb :if _bec [_dge ]==110{goto _ffc ;};goto _agc ;_ffc :if _dge ++;_dge ==_gaef {goto _cge ;};_bgbf :if _bec [_dge ]==101{goto _cabf ;};goto _agc ;_cabf :if _dge ++;_dge ==_gaef {goto _cfaf ;};_fcef :if _bec [_dge ]==114{goto _ddgf ;};goto _agc ;_ddgf :if _dge ++;_dge ==_gaef {goto _agggf ;};_bab :if _bec [_dge ]==97{goto _bgf ;};goto _agc ;_bgf :if _dge ++;_dge ==_gaef {goto _fgg ;};_ecaa :if _bec [_dge ]==108{goto _gged ;};goto _agc ;_beef :_aac =_dge +1;_eef =20;goto _ebec ;_ebec :if _dge ++;_dge ==_gaef {goto _bfae ;};_cgfc :switch _bec [_dge ]{case 104:goto _age ;case 109:goto _age ;case 115:goto _age ;};goto _dbe ;_dbe :if _dge ++;_dge ==_gaef {goto _fdad ;};_fbc :if _bec [_dge ]==93{goto _bacc ;};goto _dbe ;_bacc :_aac =_dge +1;_eef =18;goto _afg ;_dfg :_aac =_dge +1;_eef =16;goto _afg ;_afg :if _dge ++;_dge ==_gaef {goto _dcaa ;};_gbac :if _bec [_dge ]==93{goto _bacc ;};goto _dbe ;_age :if _dge ++;_dge ==_gaef {goto _geab ;};_fcgg :if _bec [_dge ]==93{goto _dfg ;};goto _dbe ;_acadb :if _dge ++;_dge ==_gaef {goto _fga ;};_fdae :goto _fdd ;_ddb :_aac =_dge +1;_eef =14;goto _cba ;_cba :if _dge ++;_dge ==_gaef {goto _eec ;};_gcbb :switch _bec [_dge ]{case 47:goto _ecc ;case 58:goto _bfb ;case 65:goto _bggb ;case 100:goto _ecc ;case 104:goto _bfb ;case 109:goto _ddb ;case 115:goto _fba ;case 121:goto _ffg ;};goto _gde ;_bbaee :if _dge ++;_dge ==_gaef {goto _afdf ;};_bdfg :if _bec [_dge ]==121{goto _ecc ;};goto _gafc ;_gag :_gab :_dcg =34;goto _ecafb ;_feab :_dcg =35;goto _ecafb ;_acg :_dcg =0;goto _ecafb ;_ced :_dcg =36;goto _ecafb ;_dec :_dcg =37;goto _ecafb ;_bdb :_dcg =1;goto _ecafb ;_gegf :_dcg =2;goto _ecafb ;_cad :_dcg =38;goto _ecafb ;_dfcb :_dcg =3;goto _ecafb ;_bgfg :_dcg =4;goto _ecafb ;_gcf :_dcg =39;goto _ecafb ;_fgd :_dcg =5;goto _ecafb ;_ffca :_dcg =6;goto _ecafb ;_gabf :_dcg =7;goto _ecafb ;_dcec :_dcg =8;goto _ecafb ;_bfee :_dcg =40;goto _ecafb ;_bbfa :_dcg =9;goto _ecafb ;_egc :_dcg =41;goto _ecafb ;_cec :_dcg =10;goto _ecafb ;_ccee :_dcg =42;goto _ecafb ;_bgca :_dcg =11;goto _ecafb ;_ebf :_dcg =43;goto _ecafb ;_gggcg :_dcg =44;goto _ecafb ;_dbcg :_dcg =45;goto _ecafb ;_cfe :_dcg =12;goto _ecafb ;_ggce :_dcg =46;goto _ecafb ;_bffa :_dcg =13;goto _ecafb ;_dca :_dcg =14;goto _ecafb ;_eaga :_dcg =15;goto _ecafb ;_dafdd :_dcg =16;goto _ecafb ;_bdeee :_dcg =47;goto _ecafb ;_eda :_dcg =17;goto _ecafb ;_gbaf :_dcg =48;goto _ecafb ;_aedcd :_dcg =18;goto _ecafb ;_cffd :_dcg =19;goto _ecafb ;_aggg :_dcg =20;goto _ecafb ;_bcea :_dcg =49;goto _ecafb ;_ccd :_dcg =50;goto _ecafb ;_bdd :_dcg =21;goto _ecafb ;_cadc :_dcg =22;goto _ecafb ;_ggcg :_dcg =23;goto _ecafb ;_cdg :_dcg =24;goto _ecafb ;_bfff :_dcg =25;goto _ecafb ;_beg :_dcg =51;goto _ecafb ;_ged :_dcg =26;goto _ecafb ;_ebeb :_dcg =52;goto _ecafb ;_geb :_dcg =53;goto _ecafb ;_ccb :_dcg =54;goto _ecafb ;_dga :_dcg =55;goto _ecafb ;_gaae :_dcg =56;goto _ecafb ;_ggag :_dcg =57;goto _ecafb ;_deg :_dcg =27;goto _ecafb ;_cge :_dcg =28;goto _ecafb ;_cfaf :_dcg =29;goto _ecafb ;_agggf :_dcg =30;goto _ecafb ;_fgg :_dcg =31;goto _ecafb ;_bfae :_dcg =58;goto _ecafb ;_fdad :_dcg =32;goto _ecafb ;_dcaa :_dcg =59;goto _ecafb ;_geab :_dcg =33;goto _ecafb ;_fga :_dcg =60;goto _ecafb ;_eec :_dcg =61;goto _ecafb ;_afdf :_dcg =62;goto _ecafb ;_ecafb :{};if _dge ==_ccged {switch _dcg {case 35:goto _gafc ;case 0:goto _dac ;case 36:goto _cag ;case 37:goto _dcb ;case 1:goto _dac ;case 2:goto _dac ;case 38:goto _eaef ;case 3:goto _cdad ;case 4:goto _cdad ;case 39:goto _eaef ;case 5:goto _cdad ;case 6:goto _cdad ;case 7:goto _cdad ;case 8:goto _dac ;case 40:goto _eaef ;case 9:goto _cdad ;case 41:goto _eaef ;case 10:goto _dac ;case 42:goto _eaef ;case 11:goto _cdad ;case 43:goto _eaef ;case 44:goto _eaef ;case 45:goto _eaef ;case 12:goto _ege ;case 46:goto _acad ;case 13:goto _ada ;case 14:goto _dac ;case 15:goto _dac ;case 16:goto _ada ;case 47:goto _gde ;case 17:goto _dbc ;case 48:goto _fda ;case 18:goto _gbdfea ;case 19:goto _gbdfea ;case 20:goto _dac ;case 49:goto _gafc ;case 50:goto _fffd ;case 21:goto _dac ;case 22:goto _dac ;case 23:goto _dac ;case 24:goto _dac ;case 25:goto _dac ;case 51:goto _fffd ;case 26:goto _gfd ;case 52:goto _fffd ;case 53:goto _fffd ;case 54:goto _gfc ;case 55:goto _gafc ;case 56:goto _gafc ;case 57:goto _gafc ;case 27:goto _agc ;case 28:goto _agc ;case 29:goto _agc ;case 30:goto _agc ;case 31:goto _agc ;case 58:goto _gafc ;case 32:goto _dac ;case 59:goto _dac ;case 33:goto _agc ;case 60:goto _gafc ;case 61:goto _gde ;case 62:goto _gafc ;};};};if _acb > 0{copy (_bec [0:],_bec [_acb :]);};};_ =_ccged ;if _dcg ==_aga {_da .Log .Debug ("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072");};};

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric (v float64 )string {if _ca .Abs (v )>=_bb ||_ca .Abs (v )<=_ee &&v !=0{return _cga (v );};_bfc :=make ([]byte ,0,15);_bfc =_f .AppendFloat (_bfc ,v ,'f',-1,64);if len (_bfc )> 11{_cfd :=_bfc [11]-'0';if _cfd >=5&&_cfd <=9{_bfc [10]++;_bfc =_bfc [0:11];_bfc =_acf (_bfc );};_bfc =_bfc [0:11];}else if len (_bfc )==11{if _bfc [len (_bfc )-1]=='9'{_bfc [len (_bfc )-1]++;_bfc =_acf (_bfc );};};_bfc =_ebd (_bfc );return string (_bfc );};func _dfd (_ceec _bg .Time ,_gdf string )[]byte {_ece :=[]byte {};_ecb :=0;for _fbb :=0;_fbb < len (_gdf );_fbb ++{var _dfe string ;if _gdf [_fbb ]=='/'{_dfe =string (_gdf [_ecb :_fbb ]);_ecb =_fbb +1;}else if _fbb ==len (_gdf )-1{_dfe =string (_gdf [_ecb :_fbb +1]);}else {continue ;};switch _dfe {case "\u0079\u0079":_ece =_ceec .AppendFormat (_ece ,"\u0030\u0036");case "\u0079\u0079\u0079\u0079":_ece =_ceec .AppendFormat (_ece ,"\u0032\u0030\u0030\u0036");case "\u006d":_ece =_ceec .AppendFormat (_ece ,"\u0031");case "\u006d\u006d":_ece =_ceec .AppendFormat (_ece ,"\u0030\u0031");case "\u006d\u006d\u006d":_ece =_ceec .AppendFormat (_ece ,"\u004a\u0061\u006e");case "\u006d\u006d\u006d\u006d":_ece =_ceec .AppendFormat (_ece ,"\u004aa\u006e\u0075\u0061\u0072\u0079");case "\u006d\u006d\u006dm\u006d":switch _ceec .Month (){case _bg .January ,_bg .July ,_bg .June :_ece =append (_ece ,'J');case _bg .February :_ece =append (_ece ,'M');case _bg .March ,_bg .May :_ece =append (_ece ,'M');case _bg .April ,_bg .August :_ece =append (_ece ,'A');case _bg .September :_ece =append (_ece ,'S');case _bg .October :_ece =append (_ece ,'O');case _bg .November :_ece =append (_ece ,'N');case _bg .December :_ece =append (_ece ,'D');};case "\u0064":_ece =_ceec .AppendFormat (_ece ,"\u0032");case "\u0064\u0064":_ece =_ceec .AppendFormat (_ece ,"\u0030\u0032");case "\u0064\u0064\u0064":_ece =_ceec .AppendFormat (_ece ,"\u004d\u006f\u006e");case "\u0064\u0064\u0064\u0064":_ece =_ceec .AppendFormat (_ece ,"\u004d\u006f\u006e\u0064\u0061\u0079");default:_da .Log .Debug ("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073",_dfe );};if _gdf [_fbb ]=='/'{_ece =append (_ece ,'/');};};return _ece ;};const _ee =1e-10;func _eb (_gea ,_gbff float64 ,_dag Format )[]byte {if len (_dag .Whole )==0{return nil ;};_aec :=_bg .Date (1899,12,30,0,0,0,0,_bg .UTC );_edc :=_aec .Add (_bg .Duration (_gbff *float64 (24*_bg .Hour )));_edc =_agcd (_edc );_gbd :=_f .AppendFloat (nil ,_gea ,'f',-1,64);_cdba :=make ([]byte ,0,len (_gbd ));_cda :=0;_aed :=1;_cc :for _bcb :=len (_dag .Whole )-1;_bcb >=0;_bcb --{_df :=len (_gbd )-1-_cda ;_baa :=_dag .Whole [_bcb ];switch _baa .Type {case FmtTypeDigit :if _df >=0{_cdba =append (_cdba ,_gbd [_df ]);_cda ++;_aed =_bcb ;}else {_cdba =append (_cdba ,'0');};case FmtTypeDigitOpt :if _df >=0{_cdba =append (_cdba ,_gbd [_df ]);_cda ++;_aed =_bcb ;}else {for _bbf :=_bcb ;_bbf >=0;_bbf --{_ga :=_dag .Whole [_bbf ];if _ga .Type ==FmtTypeLiteral {_cdba =append (_cdba ,_ga .Literal );};};break _cc ;};case FmtTypeDollar :for _bag :=_cda ;_bag < len (_gbd );_bag ++{_cdba =append (_cdba ,_gbd [len (_gbd )-1-_bag ]);_cda ++;};_cdba =append (_cdba ,'$');case FmtTypeComma :if !_dag ._bd {_cdba =append (_cdba ,',');};case FmtTypeLiteral :_cdba =append (_cdba ,_baa .Literal );case FmtTypeDate :_cdba =append (_cdba ,_geg (_dfd (_edc ,_baa .DateTime ))...);case FmtTypeTime :_cdba =append (_cdba ,_geg (_eeda (_edc ,_gbff ,_baa .DateTime ))...);default:_da .Log .Debug ("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076",_baa );};};_ffb :=_geg (_cdba );if _cda < len (_gbd )&&(_cda !=0||_dag ._g ){_gbdc :=len (_gbd )-_cda ;_dae :=make ([]byte ,len (_ffb )+_gbdc );copy (_dae ,_ffb [0:_aed ]);copy (_dae [_aed :],_gbd [0:]);copy (_dae [_aed +_gbdc :],_ffb [_aed :]);_ffb =_dae ;};if _dag ._bd {_fcg :=_bc .Buffer {};_abb :=0;for _gbe :=len (_ffb )-1;_gbe >=0;_gbe --{if !(_ffb [_gbe ]>='0'&&_ffb [_gbe ]<='9'){_abb ++;}else {break ;};};for _bcc :=0;_bcc < len (_ffb );_bcc ++{_gbdf :=(len (_ffb )-_bcc -_abb );if _gbdf %3==0&&_gbdf !=0&&_bcc !=0{_fcg .WriteByte (',');};_fcg .WriteByte (_ffb [_bcc ]);};_ffb =_fcg .Bytes ();};return _ffb ;};func _geg (_eg []byte )[]byte {for _ba :=0;_ba < len (_eg )/2;_ba ++{_bbb :=len (_eg )-1-_ba ;_eg [_ba ],_eg [_bbb ]=_eg [_bbb ],_eg [_ba ];};return _eg ;};func (_aca *Lexer )nextFmt (){_aca ._aaa =append (_aca ._aaa ,_aca ._ag );_aca ._ag =Format {}};

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String (v string ,f string )string {_cd :=Parse (f );var _de Format ;if len (_cd )==1{_de =_cd [0];}else if len (_cd )==4{_de =_cd [3];};_ge :=false ;for _ ,_dab :=range _de .Whole {if _dab .Type ==FmtTypeText {_ge =true ;};};if !_ge {return v ;};_adb :=_bc .Buffer {};for _ ,_gec :=range _de .Whole {switch _gec .Type {case FmtTypeLiteral :_adb .WriteByte (_gec .Literal );case FmtTypeText :_adb .WriteString (v );};};return _adb .String ();};const _afabf int =34;func _cga (_bda float64 )string {_acd :=_f .FormatFloat (_bda ,'E',-1,64);_ec :=_f .FormatFloat (_bda ,'E',5,64);if len (_acd )< len (_ec ){return _f .FormatFloat (_bda ,'E',2,64);};return _ec ;};

// Token is a format token in the Excel format string.
type Token struct{Type FmtType ;Literal byte ;DateTime string ;};func _fag (_ed float64 ,_dc Format ,_gf bool )string {if _dc ._fde {return NumberGeneric (_ed );};_af :=make ([]byte ,0,20);_cae :=_ca .Signbit (_ed );_dabd :=_ca .Abs (_ed );_afa :=int64 (0);_ce :=int64 (0);if _dc .IsExponential {for _dabd >=10{_ce ++;_dabd /=10;};for _dabd < 1{_ce --;_dabd *=10;};}else if _dc ._fd {_dabd *=100;}else if _dc ._dd {if _dc ._db ==0{_cdb :=_ca .Pow (10,float64 (_dc ._bba ));_ggd ,_ea :=1.0,1.0;_ =_ggd ;for _bce :=1.0;_bce < _cdb ;_bce ++{_ ,_bbc :=_ca .Modf (_dabd *float64 (_bce ));if _bbc < _ea {_ea =_bbc ;_ggd =_bce ;if _bbc ==0{break ;};};};_dc ._db =int64 (_ggd );};_afa =int64 (_dabd *float64 (_dc ._db )+0.5);if len (_dc .Whole )> 0&&_afa > _dc ._db {_afa =int64 (_dabd *float64 (_dc ._db ))%_dc ._db ;_dabd -=float64 (_afa )/float64 (_dc ._db );}else {_dabd -=float64 (_afa )/float64 (_dc ._db );if _ca .Abs (_dabd )< 1{_fb :=true ;for _ ,_ggg :=range _dc .Whole {if _ggg .Type ==FmtTypeDigitOpt {continue ;};if _ggg .Type ==FmtTypeLiteral &&_ggg .Literal ==' '{continue ;};_fb =false ;};if _fb {_dc .Whole =nil ;};};};};_eed :=1;for _ ,_bac :=range _dc .Fractional {if _bac .Type ==FmtTypeDigit ||_bac .Type ==FmtTypeDigitOpt {_eed ++;};};_dabd +=5*_ca .Pow10 (-_eed );_ae ,_bbad :=_ca .Modf (_dabd );_af =append (_af ,_eb (_ae ,_ed ,_dc )...);_af =append (_af ,_adg (_bbad ,_ed ,_dc )...);_af =append (_af ,_bbd (_ce ,_dc )...);if _dc ._dd {_af =_f .AppendInt (_af ,_afa ,10);_af =append (_af ,'/');_af =_f .AppendInt (_af ,_dc ._db ,10);};if !_gf &&_cae {return "\u002d"+string (_af );};return string (_af );};func (_fg FmtType )String ()string {if _fg >=FmtType (len (_e )-1){return _b .Sprintf ("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029",_fg );};return _fc [_e [_fg ]:_e [_fg +1]];};const _eee int =0;func _ebd (_bdfa []byte )[]byte {_cee :=len (_bdfa );_bbcf :=false ;_afab :=false ;for _bbaa :=len (_bdfa )-1;_bbaa >=0;_bbaa --{if _bdfa [_bbaa ]=='0'&&!_afab &&!_bbcf {_cee =_bbaa ;}else if _bdfa [_bbaa ]=='.'{_bbcf =true ;}else {_afab =true ;};};if _bbcf &&_afab {if _bdfa [_cee -1]=='.'{_cee --;};return _bdfa [0:_cee ];};return _bdfa ;};var _e =[...]uint8 {0,14,26,41,53,67,81,94,118,135,146,157,172,183};

// FmtType is the type of a format token.
//go:generate stringer -type=FmtType
type FmtType byte ;const _bgc int =34;type Lexer struct{_ag Format ;_aaa []Format ;};