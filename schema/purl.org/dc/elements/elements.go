//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package elements ;import (_df "encoding/xml";_f "fmt";_fd "github.com/unidoc/unioffice";_g "github.com/unidoc/unioffice/common/logger";);func (_b *ElementContainer )UnmarshalXML (d *_df .Decoder ,start _df .StartElement )error {_ea :for {_ee ,_eb :=d .Token ();
if _eb !=nil {return _eb ;};switch _dfb :=_ee .(type ){case _df .StartElement :switch _dfb .Name {case _df .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_ff :=NewElementsGroupChoice ();
if _cc :=d .DecodeElement (&_ff .Any ,&_dfb );_cc !=nil {return _cc ;};_b .Choice =append (_b .Choice ,_ff );default:_g .Log .Debug ("\u0073\u006b\u0069\u0070\u0070i\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072\u0020\u0025v",_dfb .Name );
if _af :=d .Skip ();_af !=nil {return _af ;};};case _df .EndElement :break _ea ;case _df .CharData :};};return nil ;};

// ValidateWithPath validates the ElementContainer and its children, prefixing error messages with path
func (_fa *ElementContainer )ValidateWithPath (path string )error {for _ce ,_ac :=range _fa .Choice {if _bd :=_ac .ValidateWithPath (_f .Sprintf ("\u0025\u0073\u002f\u0043\u0068\u006f\u0069\u0063\u0065\u005b\u0025\u0064\u005d",path ,_ce ));_bd !=nil {return _bd ;
};};return nil ;};

// Validate validates the ElementsGroup and its children
func (_gef *ElementsGroup )Validate ()error {return _gef .ValidateWithPath ("\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070");};func NewElementsGroup ()*ElementsGroup {_ae :=&ElementsGroup {};return _ae };type ElementsGroupChoice struct{Any []*Any ;
};

// ValidateWithPath validates the ElementsGroup and its children, prefixing error messages with path
func (_bg *ElementsGroup )ValidateWithPath (path string )error {for _eg ,_de :=range _bg .Choice {if _cgb :=_de .ValidateWithPath (_f .Sprintf ("\u0025\u0073\u002f\u0043\u0068\u006f\u0069\u0063\u0065\u005b\u0025\u0064\u005d",path ,_eg ));_cgb !=nil {return _cgb ;
};};return nil ;};type ElementContainer struct{Choice []*ElementsGroupChoice ;};func NewElementContainer ()*ElementContainer {_dac :=&ElementContainer {};return _dac };func (_gcg *ElementsGroupChoice )MarshalXML (e *_df .Encoder ,start _df .StartElement )error {if _gcg .Any !=nil {_afe :=_df .StartElement {Name :_df .Name {Local :"\u0064\u0063\u003a\u0061\u006e\u0079"}};
for _ ,_fbd :=range _gcg .Any {e .EncodeElement (_fbd ,_afe );};};return nil ;};func (_fdd *SimpleLiteral )MarshalXML (e *_df .Encoder ,start _df .StartElement )error {e .EncodeToken (start );e .EncodeToken (_df .EndElement {Name :start .Name });return nil ;
};func (_cdg *ElementsGroupChoice )UnmarshalXML (d *_df .Decoder ,start _df .StartElement )error {_cb :for {_fbf ,_bb :=d .Token ();if _bb !=nil {return _bb ;};switch _afeg :=_fbf .(type ){case _df .StartElement :switch _afeg .Name {case _df .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_gdf :=NewAny ();
if _gda :=d .DecodeElement (_gdf ,&_afeg );_gda !=nil {return _gda ;};_cdg .Any =append (_cdg .Any ,_gdf );default:_g .Log .Debug ("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020o\u006e\u0020\u0045\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072ou\u0070\u0043\u0068\u006f\u0069\u0063\u0065\u0020\u0025\u0076",_afeg .Name );
if _deg :=d .Skip ();_deg !=nil {return _deg ;};};case _df .EndElement :break _cb ;case _df .CharData :};};return nil ;};func (_fe *ElementContainer )MarshalXML (e *_df .Encoder ,start _df .StartElement )error {start .Name .Local ="\u0065\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072";
e .EncodeToken (start );if _fe .Choice !=nil {for _ ,_db :=range _fe .Choice {_db .MarshalXML (e ,_df .StartElement {});};};e .EncodeToken (_df .EndElement {Name :start .Name });return nil ;};func (_fg *Any )UnmarshalXML (d *_df .Decoder ,start _df .StartElement )error {_fg .SimpleLiteral =*NewSimpleLiteral ();
for {_da ,_cg :=d .Token ();if _cg !=nil {return _f .Errorf ("\u0070a\u0072s\u0069\u006e\u0067\u0020\u0041\u006e\u0079\u003a\u0020\u0025\u0073",_cg );};if _gc ,_e :=_da .(_df .EndElement );_e &&_gc .Name ==start .Name {break ;};};return nil ;};func (_aff *ElementsGroup )UnmarshalXML (d *_df .Decoder ,start _df .StartElement )error {_daa :for {_gd ,_cde :=d .Token ();
if _cde !=nil {return _cde ;};switch _gab :=_gd .(type ){case _df .StartElement :switch _gab .Name {case _df .Name {Space :"\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f",Local :"\u0061\u006e\u0079"}:_ef :=NewElementsGroupChoice ();
if _efc :=d .DecodeElement (&_ef .Any ,&_gab );_efc !=nil {return _efc ;};_aff .Choice =append (_aff .Choice ,_ef );default:_g .Log .Debug ("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0045\u006c\u0065\u006de\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070 \u0025\u0076",_gab .Name );
if _ge :=d .Skip ();_ge !=nil {return _ge ;};};case _df .EndElement :break _daa ;case _df .CharData :};};return nil ;};type SimpleLiteral struct{};func NewSimpleLiteral ()*SimpleLiteral {_cdee :=&SimpleLiteral {};return _cdee };

// Validate validates the ElementsGroupChoice and its children
func (_ec *ElementsGroupChoice )Validate ()error {return _ec .ValidateWithPath ("\u0045\u006c\u0065\u006den\u0074\u0073\u0047\u0072\u006f\u0075\u0070\u0043\u0068\u006f\u0069\u0063\u0065");};func NewElementsGroupChoice ()*ElementsGroupChoice {_bf :=&ElementsGroupChoice {};
return _bf };

// Validate validates the Any and its children
func (_ga *Any )Validate ()error {return _ga .ValidateWithPath ("\u0041\u006e\u0079")};func NewAny ()*Any {_c :=&Any {};_c .SimpleLiteral =*NewSimpleLiteral ();return _c };

// ValidateWithPath validates the ElementsGroupChoice and its children, prefixing error messages with path
func (_acc *ElementsGroupChoice )ValidateWithPath (path string )error {for _ed ,_dfg :=range _acc .Any {if _fbg :=_dfg .ValidateWithPath (_f .Sprintf ("\u0025\u0073\u002f\u0041\u006e\u0079\u005b\u0025\u0064\u005d",path ,_ed ));_fbg !=nil {return _fbg ;
};};return nil ;};

// Validate validates the ElementContainer and its children
func (_gf *ElementContainer )Validate ()error {return _gf .ValidateWithPath ("\u0045\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072");};func (_afa *SimpleLiteral )UnmarshalXML (d *_df .Decoder ,start _df .StartElement )error {for {_ag ,_dcc :=d .Token ();
if _dcc !=nil {return _f .Errorf ("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0053\u0069\u006d\u0070l\u0065L\u0069t\u0065\u0072\u0061\u006c\u003a\u0020\u0025s",_dcc );};if _be ,_ace :=_ag .(_df .EndElement );_ace &&_be .Name ==start .Name {break ;};};return nil ;
};func (_a *Any )MarshalXML (e *_df .Encoder ,start _df .StartElement )error {return _a .SimpleLiteral .MarshalXML (e ,start );};

// Validate validates the SimpleLiteral and its children
func (_dfgb *SimpleLiteral )Validate ()error {return _dfgb .ValidateWithPath ("\u0053\u0069\u006d\u0070\u006c\u0065\u004c\u0069\u0074\u0065\u0072\u0061\u006c");};type ElementsGroup struct{Choice []*ElementsGroupChoice ;};

// ValidateWithPath validates the SimpleLiteral and its children, prefixing error messages with path
func (_ba *SimpleLiteral )ValidateWithPath (path string )error {return nil };func (_dc *ElementsGroup )MarshalXML (e *_df .Encoder ,start _df .StartElement )error {if _dc .Choice !=nil {for _ ,_cd :=range _dc .Choice {_cd .MarshalXML (e ,_df .StartElement {});
};};return nil ;};

// ValidateWithPath validates the Any and its children, prefixing error messages with path
func (_fb *Any )ValidateWithPath (path string )error {if _cge :=_fb .SimpleLiteral .ValidateWithPath (path );_cge !=nil {return _cge ;};return nil ;};type Any struct{SimpleLiteral };func init (){_fd .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0053\u0069\u006d\u0070\u006c\u0065\u004c\u0069\u0074\u0065\u0072\u0061\u006c",NewSimpleLiteral );
_fd .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0065\u006ce\u006d\u0065\u006et\u0043\u006f\u006e\u0074\u0061\u0069\u006e\u0065\u0072",NewElementContainer );
_fd .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0061\u006e\u0079",NewAny );_fd .RegisterConstructor ("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0070\u0075\u0072\u006c\u002e\u006f\u0072\u0067/\u0064c\u002f\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u002f\u0031\u002e\u0031\u002f","\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0073\u0047\u0072\u006f\u0075\u0070",NewElementsGroup );
};