//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package rw ;import (_g "bytes";_fa "encoding/binary";_ga "errors";_c "fmt";_fe "io";_d "io/ioutil";_e "reflect";);type Reader struct{*_g .Reader };func (_ff *Reader )skip (_b int )error {_ ,_eg :=_fe .CopyN (_d .Discard ,_ff ,int64 (_b ));if _eg !=nil {return _eg ;
};return nil ;};func (_gff *Writer )Cap ()int {return cap (_gff ._gc )};func (_de *Writer )WritePropertyNoAlign (a interface{})error {if _bga :=_fa .Write (_de ,_fa .LittleEndian ,a );_bga !=nil {return _bga ;};return nil ;};type Writer struct{_gc []byte ;
_dcf int ;};func (_gga *Writer )WriteTo (wTo _fe .Writer )(_ab int64 ,_gdf error ){if _bbc :=_gga .Len ();_bbc > 0{_ce ,_gac :=wTo .Write (_gga ._gc [_gga ._dcf :]);if _ce > _bbc {return 0,_ga .New ("\u0072\u0077\u002e\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f\u003a\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0057\u0072\u0069t\u0065\u0020c\u006f\u0075\u006e\u0074");
};_gga ._dcf +=_ce ;_ab =int64 (_ce );if _gac !=nil {return _ab ,_gac ;};if _ce !=_bbc {return _ab ,_fe .ErrShortWrite ;};};_gga .reset ();return _ab ,nil ;};func (_cc *Writer )Len ()int {return len (_cc ._gc )-_cc ._dcf };func (_bb *Writer )Write (p []byte )(_ebc int ,_bgb error ){_bba ,_gab :=_bb .tryGrowByReslice (len (p ));
if !_gab {var _cde error ;_bba ,_cde =_bb .grow (len (p ));if _cde !=nil {return 0,_cde ;};};return copy (_bb ._gc [_bba :],p ),nil ;};func (_a *Reader )align (_cg int )error {return _a .skip ((_cg -_a .curPos ()%_cg )%_cg )};func (_abe *Writer )tryGrowByReslice (_dda int )(int ,bool ){if _ac :=len (_abe ._gc );
_dda <=cap (_abe ._gc )-_ac {_abe ._gc =_abe ._gc [:_ac +_dda ];return _ac ,true ;};return 0,false ;};const _bd =int (^uint (0)>>1);func (_ggb *Writer )curPos ()int {return int (_ggb .Cap ())-_ggb .Len ()};func (_ed *Writer )WriteByteAt (b byte ,off int )error {if off >=len (_ed ._gc ){return _ga .New ("\u004f\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073");
};_ed ._gc [off ]=b ;return nil ;};func (_ded *Writer )reset (){_ded ._gc =_ded ._gc [:0];_ded ._dcf =0};func (_gb *Writer )align (_ba int )error {return _gb .Skip ((_ba -(_gb .Len ())%_ba )%_ba )};func (_aa *Writer )AlignLength (alignTo int )error {_gfb :=_aa .Len ()%alignTo ;
if _gfb > 0{_ ,_ca :=_aa .Write (make ([]byte ,alignTo -_gfb ));if _ca !=nil {return _ca ;};};return nil ;};func (_cb *Reader )ReadProperty (a interface{})error {_dg :=_e .ValueOf (a );for _dg .Kind ()==_e .Ptr {_dg =_dg .Elem ();};if !_dg .IsValid (){return _c .Errorf ("\u0076a\u006cu\u0065\u0020\u0069\u0073\u0020n\u006f\u0074 \u0076\u0061\u006c\u0069\u0064");
};if _ae :=_cb .align (int (_dg .Type ().Size ()));_ae !=nil {return _ae ;};if _egg :=_fa .Read (_cb ,_fa .LittleEndian ,a );_egg !=nil {return _egg ;};return nil ;};func NewReader (b []byte )(*Reader ,error ){return &Reader {_g .NewReader (b )},nil };
func PushLeftUI32 (v uint32 ,flag bool )uint32 {v >>=1;if flag {v |=1<<31;};return v ;};var _caf =_ga .New ("r\u0077.\u0057\u0072\u0069\u0074\u0065\u0072\u003a\u0020t\u006f\u006f\u0020\u006car\u0067\u0065");func NewWriter ()*Writer {return &Writer {_gc :[]byte {}}};
func (_bg *Reader )ReadStringProperty (n uint32 )(string ,error ){if _egf :=_bg .align (4);_egf !=nil {return "",_egf ;};_ee :=make ([]byte ,n );if _ag :=_fa .Read (_bg ,_fa .LittleEndian ,&_ee );_ag !=nil {return "",_ag ;};return string (_ee ),nil ;};
const _cga =64;func (_dd *Writer )Skip (n int )error {if n ==0{return nil ;};_ ,_af :=_dd .Write (make ([]byte ,n ));return _af ;};func (_cd *Writer )WriteStringProperty (s string )error {_cd .align (4);_eb :=[]byte (s );if _gd :=_fa .Write (_cd ,_fa .LittleEndian ,&_eb );
_gd !=nil {return _gd ;};return nil ;};func PopRightUI64 (v uint64 )(bool ,uint64 ){return (v &uint64 (1))==1,v >>1};func PushLeftUI64 (v uint64 ,flag bool )uint64 {v >>=1;if flag {v |=1<<63;};return v ;};func _fab (_bbd int )[]byte {defer func (){if recover ()!=nil {panic (_caf );
};}();return make ([]byte ,_bbd );};func (_cfd *Writer )WriteProperty (a interface{})error {if _df :=_cfd .align (int (_e .TypeOf (a ).Size ()));_df !=nil {return _df ;};return _cfd .WritePropertyNoAlign (a );};func (_fdf *Writer )grow (_bfe int )(int ,error ){_be :=_fdf .Len ();
if _be ==0&&_fdf ._dcf !=0{_fdf .reset ();};if _def ,_eee :=_fdf .tryGrowByReslice (_bfe );_eee {return _def ,nil ;};if _fdf ._gc ==nil &&_bfe <=_cga {_fdf ._gc =make ([]byte ,_bfe ,_cga );return 0,nil ;};_aae :=cap (_fdf ._gc );if _bfe <=_aae /2-_be {copy (_fdf ._gc ,_fdf ._gc [_fdf ._dcf :]);
}else if _aae > _bd -_aae -_bfe {return 0,_caf ;}else {_ea :=_fab (2*_aae +_bfe );copy (_ea ,_fdf ._gc [_fdf ._dcf :]);_fdf ._gc =_ea ;};_fdf ._dcf =0;_fdf ._gc =_fdf ._gc [:_be +_bfe ];return _be ,nil ;};func (_egc *Writer )FillWithByte (fillSize int ,b byte )error {for _fg :=0;
_fg < fillSize ;_fg ++{if _bfc :=_egc .WritePropertyNoAlign (b );_bfc !=nil {return _bfc ;};};return nil ;};func (_dc *Reader )ReadPairProperty (p interface{})error {if _fb :=_dc .align (4);_fb !=nil {return _fb ;};_cf :=_e .ValueOf (p );for _cf .Kind ()==_e .Ptr {_cf =_cf .Elem ();
};if !_cf .IsValid (){return _c .Errorf ("\u0076a\u006cu\u0065\u0020\u0069\u0073\u0020n\u006f\u0074 \u0076\u0061\u006c\u0069\u0064");};if _bf :=_fa .Read (_dc ,_fa .LittleEndian ,p );_bf !=nil {return _bf ;};return nil ;};func (_bfb *Writer )Bytes ()[]byte {return _bfb ._gc };
func (_gf *Reader )curPos ()int {return int (_gf .Size ())-_gf .Len ()};func PopRightUI32 (v uint32 )(bool ,uint32 ){return (v &uint32 (1))==1,v >>1};