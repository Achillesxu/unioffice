//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_c "encoding/hex";_gf "errors";_gb "fmt";_b "github.com/unidoc/unioffice/common/tempstorage";_g "io";_d "io/ioutil";_e "math/rand";_gg "sync";);

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ce :=memStorage {_ece :_gg .Map {}};_b .SetAsStorage (&_ce )};

// TempDir creates a name for a new temp directory using a pattern argument
func (_ef *memStorage )TempDir (pattern string )(string ,error ){return _fgc (pattern ),nil };type memDataCell struct{_ecd string ;_cb []byte ;_ggb int64 ;};

// Close is not applicable in this implementation
func (_bg *memFile )Close ()error {return nil };

// Name returns the filename of the underlying memDataCell
func (_dac *memFile )Name ()string {return _dac ._bb ._ecd };func _fgc (_ccg string )string {_ffe ,_ :=_dfb (6);return _ccg +_ffe };

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_bf *memFile )Read (p []byte )(int ,error ){_da :=_bf ._dd ;_fd :=_bf ._bb ._ggb ;_bd :=int64 (len (p ));if _bd > _fd {_bd =_fd ;p =p [:_bd ];};if _da >=_fd {return 0,_g .EOF ;};_gd :=_da +_bd ;if _gd >=_fd {_gd =_fd ;};_cc :=copy (p ,_bf ._bb ._cb [_da :_gd ]);_bf ._dd =_gd ;return _cc ,nil ;};

// Open returns tempstorage File object by name
func (_fe *memStorage )Open (path string )(_b .File ,error ){_ba ,_baa :=_fe ._ece .Load (path );if !_baa {return nil ,_gf .New (_gb .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_bb :_ba .(*memDataCell )},nil ;};

// TempFile creates a new empty file in the storage and returns it
func (_ceb *memStorage )TempFile (dir ,pattern string )(_b .File ,error ){_bgc :=dir +"\u002f"+_fgc (pattern );_fg :=&memDataCell {_ecd :_bgc ,_cb :[]byte {}};_ed :=&memFile {_bb :_fg };_ceb ._ece .Store (_bgc ,_fg );return _ed ,nil ;};func _dfb (_ga int )(string ,error ){_db :=make ([]byte ,_ga );if _ ,_ecee :=_e .Read (_db );_ecee !=nil {return "",_ecee ;};return _c .EncodeToString (_db ),nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_ff *memStorage )RemoveAll (dir string )error {_ff ._ece .Range (func (_de ,_a interface{})bool {_ff ._ece .Delete (_de );return true });return nil ;};type memStorage struct{_ece _gg .Map };

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ec *memFile )Write (p []byte )(int ,error ){_ec ._bb ._cb =append (_ec ._bb ._cb ,p ...);_ec ._bb ._ggb +=int64 (len (p ));return len (p ),nil ;};

// Add reads a file from a disk and adds it to the storage
func (_dg *memStorage )Add (path string )error {_ ,_fc :=_dg ._ece .Load (path );if _fc {return nil ;};_ge ,_ea :=_d .ReadFile (path );if _ea !=nil {return _ea ;};_dg ._ece .Store (path ,&memDataCell {_ecd :path ,_cb :_ge ,_ggb :int64 (len (_ge ))});return nil ;};type memFile struct{_bb *memDataCell ;_dd int64 ;};