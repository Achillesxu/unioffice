//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_be "encoding/hex";_a "errors";_fe "fmt";_ad "github.com/unidoc/unioffice/common/tempstorage";_bf "io";_d "io/ioutil";_f "math/rand";_g "sync";);func _gd (_gbf string )string {_dg ,_ :=_dbcg (6);return _gbf +_dg };

// Name returns the filename of the underlying memDataCell
func (_febe *memFile )Name ()string {return _febe ._ae ._ba };

// Close is not applicable in this implementation
func (_e *memFile )Close ()error {return nil };

// TempFile creates a new empty file in the storage and returns it
func (_dc *memStorage )TempFile (dir ,pattern string )(_ad .File ,error ){_ag :=dir +"\u002f"+_gd (pattern );_cg :=&memDataCell {_ba :_ag ,_gf :[]byte {}};_df :=&memFile {_ae :_cg };_dc ._dbc .Store (_ag ,_cg );return _df ,nil ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_bdc *memStorage )TempDir (pattern string )(string ,error ){return _gd (pattern ),nil };

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_cc :=memStorage {_dbc :_g .Map {}};_ad .SetAsStorage (&_cc )};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_fb *memFile )Write (p []byte )(int ,error ){_fb ._ae ._gf =append (_fb ._ae ._gf ,p ...);_fb ._ae ._ab +=int64 (len (p ));return len (p ),nil ;};type memFile struct{_ae *memDataCell ;_ade int64 ;};

// Open returns tempstorage File object by name
func (_ca *memStorage )Open (path string )(_ad .File ,error ){_eg ,_bdb :=_ca ._dbc .Load (path );if !_bdb {return nil ,_a .New (_fe .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_ae :_eg .(*memDataCell )},nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_adb *memStorage )RemoveAll (dir string )error {_adb ._dbc .Range (func (_gb ,_dfc interface{})bool {_adb ._dbc .Delete (_gb );return true });return nil ;};func _dbcg (_ee int )(string ,error ){_fea :=make ([]byte ,_ee );if _ ,_ea :=_f .Read (_fea );_ea !=nil {return "",_ea ;};return _be .EncodeToString (_fea ),nil ;};type memStorage struct{_dbc _g .Map };type memDataCell struct{_ba string ;_gf []byte ;_ab int64 ;};

// Add reads a file from a disk and adds it to the storage
func (_bfa *memStorage )Add (path string )error {_ ,_dfd :=_bfa ._dbc .Load (path );if _dfd {return nil ;};_beg ,_bg :=_d .ReadFile (path );if _bg !=nil {return _bg ;};_bfa ._dbc .Store (path ,&memDataCell {_ba :path ,_gf :_beg ,_ab :int64 (len (_beg ))});return nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_fef *memFile )Read (p []byte )(int ,error ){_de :=_fef ._ade ;_feb :=_fef ._ae ._ab ;_c :=int64 (len (p ));if _c > _feb {_c =_feb ;p =p [:_c ];};if _de >=_feb {return 0,_bf .EOF ;};_bd :=_de +_c ;if _bd >=_feb {_bd =_feb ;};_db :=copy (p ,_fef ._ae ._gf [_de :_bd ]);_fef ._ade =_bd ;return _db ,nil ;};