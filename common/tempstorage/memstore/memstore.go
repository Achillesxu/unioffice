//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_eb "encoding/hex";_d "errors";_be "fmt";_a "github.com/unidoc/unioffice/common/tempstorage";_b "io";_e "io/ioutil";_gb "math/rand";_bf "sync";);func _bb (_ea int )(string ,error ){_fb :=make ([]byte ,_ea );if _ ,_fef :=_gb .Read (_fb );
_fef !=nil {return "",_fef ;};return _eb .EncodeToString (_fb ),nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ca :=memStorage {_cb :_bf .Map {}};_a .SetAsStorage (&_ca )};func _gee (_abe string )string {_bgc ,_ :=_bb (6);return _abe +_bgc };

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_af *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_eg :=_af ._gc ._gf ;_ab :=int64 (len (p ));if _ab > _eg {_ab =_eg ;p =p [:_ab ];};if readOffset >=_eg {return 0,_b .EOF ;};_f :=readOffset +_ab ;if _f >=_eg {_f =_eg ;};_ad :=copy (p ,_af ._gc ._fd [readOffset :_f ]);
return _ad ,nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_cd *memStorage )RemoveAll (dir string )error {_cd ._cb .Range (func (_gd ,_de interface{})bool {_cd ._cb .Delete (_gd );return true });return nil ;};

// Add reads a file from a disk and adds it to the storage
func (_gfe *memStorage )Add (path string )error {_ ,_fe :=_gfe ._cb .Load (path );if _fe {return nil ;};_da ,_cf :=_e .ReadFile (path );if _cf !=nil {return _cf ;};_gfe ._cb .Store (path ,&memDataCell {_bg :path ,_fd :_da ,_gf :int64 (len (_da ))});return nil ;
};

// TempDir creates a name for a new temp directory using a pattern argument
func (_bcb *memStorage )TempDir (pattern string )(string ,error ){return _gee (pattern ),nil };type memStorage struct{_cb _bf .Map };

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_ee *memFile )Write (p []byte )(int ,error ){_ee ._gc ._fd =append (_ee ._gc ._fd ,p ...);_ee ._gc ._gf +=int64 (len (p ));return len (p ),nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_gg *memFile )Read (p []byte )(int ,error ){_ga :=_gg ._dc ;_ac :=_gg ._gc ._gf ;_c :=int64 (len (p ));if _c > _ac {_c =_ac ;p =p [:_c ];};if _ga >=_ac {return 0,_b .EOF ;};_bc :=_ga +_c ;if _bc >=_ac {_bc =_ac ;};_dcg :=copy (p ,_gg ._gc ._fd [_ga :_bc ]);
_gg ._dc =_bc ;return _dcg ,nil ;};

// Close is not applicable in this implementation
func (_ag *memFile )Close ()error {return nil };type memFile struct{_gc *memDataCell ;_dc int64 ;};

// Open returns tempstorage File object by name
func (_fa *memStorage )Open (path string )(_a .File ,error ){_fg ,_bca :=_fa ._cb .Load (path );if !_bca {return nil ,_d .New (_be .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));
};return &memFile {_gc :_fg .(*memDataCell )},nil ;};

// Name returns the filename of the underlying memDataCell
func (_gcd *memFile )Name ()string {return _gcd ._gc ._bg };

// TempFile creates a new empty file in the storage and returns it
func (_ge *memStorage )TempFile (dir ,pattern string )(_a .File ,error ){_cc :=dir +"\u002f"+_gee (pattern );_ae :=&memDataCell {_bg :_cc ,_fd :[]byte {}};_aee :=&memFile {_gc :_ae };_ge ._cb .Store (_cc ,_ae );return _aee ,nil ;};type memDataCell struct{_bg string ;
_fd []byte ;_gf int64 ;};