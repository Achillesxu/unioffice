//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_gc "encoding/hex";_f "errors";_cb "fmt";_fg "github.com/unidoc/unioffice/common/tempstorage";_cd "io";_cdc "io/ioutil";_g "math/rand";_d "sync";);

// TempFile creates a new empty file in the storage and returns it
func (_ba *memStorage )TempFile (dir ,pattern string )(_fg .File ,error ){_bcc :=dir +"\u002f"+_gea (pattern );_db :=&memDataCell {_fgd :_bcc ,_bc :[]byte {}};_af :=&memFile {_a :_db };_ba ._bb .Store (_bcc ,_db );return _af ,nil ;};

// Name returns the filename of the underlying memDataCell
func (_dd *memFile )Name ()string {return _dd ._a ._fgd };func _gea (_ca string )string {_fce ,_ :=_cag (6);return _ca +_fce };

// Open returns tempstorage File object by name
func (_bf *memStorage )Open (path string )(_fg .File ,error ){_be ,_cdb :=_bf ._bb .Load (path );if !_cdb {return nil ,_f .New (_cb .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_a :_be .(*memDataCell )},nil ;};type memStorage struct{_bb _d .Map };type memDataCell struct{_fgd string ;_bc []byte ;_gg int64 ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_cf *memStorage )TempDir (pattern string )(string ,error ){return _gea (pattern ),nil };

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ada :=memStorage {_bb :_d .Map {}};_fg .SetAsStorage (&_ada )};func _cag (_aee int )(string ,error ){_bdb :=make ([]byte ,_aee );if _ ,_caf :=_g .Read (_bdb );_caf !=nil {return "",_caf ;};return _gc .EncodeToString (_bdb ),nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_da *memStorage )RemoveAll (dir string )error {_da ._bb .Range (func (_ggb ,_de interface{})bool {_da ._bb .Delete (_ggb );return true });return nil ;};

// Add reads a file from a disk and adds it to the storage
func (_df *memStorage )Add (path string )error {_ ,_bd :=_df ._bb .Load (path );if _bd {return nil ;};_ed ,_fc :=_cdc .ReadFile (path );if _fc !=nil {return _fc ;};_df ._bb .Store (path ,&memDataCell {_fgd :path ,_bc :_ed ,_gg :int64 (len (_ed ))});return nil ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_b *memFile )Write (p []byte )(int ,error ){_b ._a ._bc =append (_b ._a ._bc ,p ...);_b ._a ._gg +=int64 (len (p ));return len (p ),nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_e *memFile )Read (p []byte )(int ,error ){_ce :=_e ._ae ;_gcc :=_e ._a ._gg ;_ge :=int64 (len (p ));if _ge > _gcc {_ge =_gcc ;p =p [:_ge ];};if _ce >=_gcc {return 0,_cd .EOF ;};_ad :=_ce +_ge ;if _ad >=_gcc {_ad =_gcc ;};_eg :=copy (p ,_e ._a ._bc [_ce :_ad ]);_e ._ae =_ad ;return _eg ,nil ;};

// Close is not applicable in this implementation
func (_ef *memFile )Close ()error {return nil };type memFile struct{_a *memDataCell ;_ae int64 ;};