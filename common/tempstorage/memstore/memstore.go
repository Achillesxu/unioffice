//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore ;import (_f "encoding/hex";_cd "errors";_cg "fmt";_gb "github.com/unidoc/unioffice/common/tempstorage";_b "io";_e "io/ioutil";_c "math/rand";_ga "sync";);

// Open returns tempstorage File object by name
func (_aee *memStorage )Open (path string )(_gb .File ,error ){_cdg ,_gbd :=_aee ._ea .Load (path );if !_gbd {return nil ,_cd .New (_cg .Sprintf ("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073",path ));};return &memFile {_cf :_cdg .(*memDataCell )},nil ;};

// TempDir creates a name for a new temp directory using a pattern argument
func (_aec *memStorage )TempDir (pattern string )(string ,error ){return _afa (pattern ),nil };

// TempFile creates a new empty file in the storage and returns it
func (_ad *memStorage )TempFile (dir ,pattern string )(_gb .File ,error ){_ba :=dir +"\u002f"+_afa (pattern );_cgb :=&memDataCell {_d :_ba ,_de :[]byte {}};_bfb :=&memFile {_cf :_cgb };_ad ._ea .Store (_ba ,_cgb );return _bfb ,nil ;};type memStorage struct{_ea _ga .Map };func _aa (_bb int )(string ,error ){_eee :=make ([]byte ,_bb );if _ ,_df :=_c .Read (_eee );_df !=nil {return "",_df ;};return _f .EncodeToString (_eee ),nil ;};

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_cde *memFile )Read (p []byte )(int ,error ){_cfg :=_cde ._ge ;_ef :=_cde ._cf ._bf ;_ca :=int64 (len (p ));if _ca > _ef {_ca =_ef ;p =p [:_ca ];};if _cfg >=_ef {return 0,_b .EOF ;};_cae :=_cfg +_ca ;if _cae >=_ef {_cae =_ef ;};_a :=copy (p ,_cde ._cf ._de [_cfg :_cae ]);_cde ._ge =_cae ;return _a ,nil ;};

// Add reads a file from a disk and adds it to the storage
func (_cga *memStorage )Add (path string )error {_ ,_af :=_cga ._ea .Load (path );if _af {return nil ;};_ee ,_ebg :=_e .ReadFile (path );if _ebg !=nil {return _ebg ;};_cga ._ea .Store (path ,&memDataCell {_d :path ,_de :_ee ,_bf :int64 (len (_ee ))});return nil ;};

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage (){_ce :=memStorage {_ea :_ga .Map {}};_gb .SetAsStorage (&_ce )};type memDataCell struct{_d string ;_de []byte ;_bf int64 ;};

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_fc *memFile )ReadAt (p []byte ,readOffset int64 )(int ,error ){_cb :=_fc ._cf ._bf ;_eb :=int64 (len (p ));if _eb > _cb {_eb =_cb ;p =p [:_eb ];};if readOffset >=_cb {return 0,_b .EOF ;};_gc :=readOffset +_eb ;if _gc >=_cb {_gc =_cb ;};_gcf :=copy (p ,_fc ._cf ._de [readOffset :_gc ]);return _gcf ,nil ;};

// RemoveAll removes all files according to the dir argument prefix
func (_eg *memStorage )RemoveAll (dir string )error {_eg ._ea .Range (func (_efb ,_bfba interface{})bool {_eg ._ea .Delete (_efb );return true });return nil ;};type memFile struct{_cf *memDataCell ;_ge int64 ;};

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_cag *memFile )Write (p []byte )(int ,error ){_cag ._cf ._de =append (_cag ._cf ._de ,p ...);_cag ._cf ._bf +=int64 (len (p ));return len (p ),nil ;};func _afa (_dg string )string {_aecf ,_ :=_aa (6);return _dg +_aecf };

// Name returns the filename of the underlying memDataCell
func (_ae *memFile )Name ()string {return _ae ._cf ._d };

// Close is not applicable in this implementation
func (_gea *memFile )Close ()error {return nil };