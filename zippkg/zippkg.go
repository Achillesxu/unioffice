//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_dc "archive/zip";_fa "bytes";_a "encoding/xml";_db "fmt";_fc "github.com/unidoc/unioffice";_g "github.com/unidoc/unioffice/algo";_aa "github.com/unidoc/unioffice/common/tempstorage";_cb "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_b "io";_c "path";_f "sort";_de "strings";_e "time";);

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_deg *DecodeMap ,_ga ,_cc string ,_fd []*_dc .File ,_ee *_cb .Relationship ,_bd Target )error ;func (_gfe *DecodeMap )RecordIndex (path string ,idx int ){_gfe ._dcg [path ]=idx };

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_dc .File ,path string )(string ,error ){_ggg ,_afe :=_aa .TempFile (path ,"\u007a\u007a");if _afe !=nil {return "",_afe ;};defer _ggg .Close ();_eea ,_afe :=f .Open ();if _afe !=nil {return "",_afe ;};defer _eea .Close ();_ ,_afe =_b .Copy (_ggg ,_eea );if _afe !=nil {return "",_afe ;};return _ggg .Name (),nil ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_dc .File ,dest interface{})error {_gag ,_af :=f .Open ();if _af !=nil {return _db .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_af );};defer _gag .Close ();_baa :=_a .NewDecoder (_gag );if _ffd :=_baa .Decode (dest );_ffd !=nil {return _db .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_ffd );};if _dd ,_ccc :=dest .(*_cb .Relationships );_ccc {for _ffdb ,_cbg :=range _dd .Relationship {switch _cbg .TypeAttr {case _fc .OfficeDocumentTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .OfficeDocumentType ;case _fc .StylesTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .StylesType ;case _fc .ThemeTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ThemeType ;case _fc .ControlTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ControlType ;case _fc .SettingsTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .SettingsType ;case _fc .ImageTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ImageType ;case _fc .CommentsTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .CommentsType ;case _fc .ThumbnailTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ThumbnailType ;case _fc .DrawingTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .DrawingType ;case _fc .ChartTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ChartType ;case _fc .ExtendedPropertiesTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .ExtendedPropertiesType ;case _fc .CustomXMLTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .CustomXMLType ;case _fc .WorksheetTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .WorksheetType ;case _fc .SharedStringsTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .SharedStringsType ;case _fc .TableTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .TableType ;case _fc .HeaderTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .HeaderType ;case _fc .FooterTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .FooterType ;case _fc .NumberingTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .NumberingType ;case _fc .FontTableTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .FontTableType ;case _fc .WebSettingsTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .WebSettingsType ;case _fc .FootNotesTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .FootNotesType ;case _fc .EndNotesTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .EndNotesType ;case _fc .SlideTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .SlideType ;case _fc .VMLDrawingTypeStrict :_dd .Relationship [_ffdb ].TypeAttr =_fc .VMLDrawingType ;};};_f .Slice (_dd .Relationship ,func (_eae ,_ag int )bool {_ab :=_dd .Relationship [_eae ];_gd :=_dd .Relationship [_ag ];return _g .NaturalLess (_ab .IdAttr ,_gd .IdAttr );});};return nil ;};var _fe =[]byte {'\r','\n'};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_dc .Writer ,filename string ,v interface{})error {_ca :=&_dc .FileHeader {};_ca .Method =_dc .Deflate ;_ca .Name =filename ;_ca .SetModTime (_e .Now ());_aea ,_dad :=z .CreateHeader (_ca );if _dad !=nil {return _db .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_dad );};_ ,_dad =_aea .Write ([]byte (XMLHeader ));if _dad !=nil {return _db .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_dad );};if _dad =_a .NewEncoder (SelfClosingWriter {_aea }).Encode (v );_dad !=nil {return _db .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_dad );};_ ,_dad =_aea .Write (_fe );return _dad ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ea *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ea ._ba ==nil {_ea ._ba =make (map[string ]Target );_ea ._eb =make (map[*_cb .Relationships ]string );_ea ._ded =make (map[string ]struct{});_ea ._dcg =make (map[string ]int );};_bdf :=_c .Clean (filePath );if _ ,_bg :=_ea ._ded [_bdf ];_bg {return false ;};_ea ._ded [_bdf ]=struct{}{};_ea ._ba [_bdf ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};func (_ceg *DecodeMap )IndexFor (path string )int {return _ceg ._dcg [path ]};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_dc .Writer ,zipPath string ,data []byte )error {_bcd ,_aag :=z .Create (zipPath );if _aag !=nil {return _db .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_aag );};_ ,_aag =_b .Copy (_bcd ,_fa .NewReader (data ));return _aag ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_eba :=_de .Split (path ,"\u002f");_daf :=_de .Join (_eba [0:len (_eba )-1],"\u002f");_fdb :=_eba [len (_eba )-1];_daf +="\u002f_\u0072\u0065\u006c\u0073\u002f";_fdb +="\u002e\u0072\u0065l\u0073";return _daf +_fdb ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_dc .Writer ,zipPath ,storagePath string )error {_fb ,_bac :=z .Create (zipPath );if _bac !=nil {return _db .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bac );};_ead ,_bac :=_aa .Open (storagePath );if _bac !=nil {return _db .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_bac );};defer _ead .Close ();_ ,_bac =_b .Copy (_fb ,_ead );return _bac ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_gf *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_gf ._ff =fn };

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _b .Writer ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_da *DecodeMap )Decode (files []*_dc .File )error {_bf :=1;for _bf > 0{for len (_da ._fae )> 0{_ccf :=_da ._fae [0];_da ._fae =_da ._fae [1:];_be :=_ccf .Ifc .(*_cb .Relationships );for _ ,_ae :=range _be .Relationship {_bc ,_ :=_da ._eb [_be ];_da ._ff (_da ,_bc +_ae .TargetAttr ,_ae .TypeAttr ,files ,_ae ,_ccf );};};for _dcgf ,_gg :=range files {if _gg ==nil {continue ;};if _bgd ,_ccb :=_da ._ba [_gg .Name ];_ccb {delete (_da ._ba ,_gg .Name );if _dcc :=Decode (_gg ,_bgd .Ifc );_dcc !=nil {return _dcc ;};files [_dcgf ]=nil ;if _bde ,_cbd :=_bgd .Ifc .(*_cb .Relationships );_cbd {_da ._fae =append (_da ._fae ,_bgd );_cbf ,_ :=_c .Split (_c .Clean (_gg .Name +"\u002f\u002e\u002e\u002f"));_da ._eb [_bde ]=_cbf ;_bf ++;};};};_bf --;};return nil ;};var _abc =[]byte {'/','>'};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";func MarshalXMLByTypeIndex (z *_dc .Writer ,dt _fc .DocType ,typ string ,idx int ,v interface{})error {_dae :=_fc .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_dae ,v );};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ba map[string ]Target ;_eb map[*_cb .Relationships ]string ;_fae []Target ;_ff OnNewRelationshipFunc ;_ded map[string ]struct{};_dcg map[string ]int ;};func MarshalXMLByType (z *_dc .Writer ,dt _fc .DocType ,typ string ,v interface{})error {_cg :=_fc .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_cg ,v );};func (_fde SelfClosingWriter )Write (b []byte )(int ,error ){_fdbe :=0;_gdc :=0;for _eed :=0;_eed < len (b )-2;_eed ++{if b [_eed ]=='>'&&b [_eed +1]=='<'&&b [_eed +2]=='/'{_fdef :=[]byte {};_bcfg :=_eed ;for _gbe :=_eed ;_gbe >=0;_gbe --{if b [_gbe ]==' '{_bcfg =_gbe ;}else if b [_gbe ]=='<'{_fdef =b [_gbe +1:_bcfg ];break ;};};_aab :=[]byte {};for _ebf :=_eed +3;_ebf < len (b );_ebf ++{if b [_ebf ]=='>'{_aab =b [_eed +3:_ebf ];break ;};};if !_fa .Equal (_fdef ,_aab ){continue ;};_fbe ,_ced :=_fde .W .Write (b [_fdbe :_eed ]);if _ced !=nil {return _gdc +_fbe ,_ced ;};_gdc +=_fbe ;_ ,_ced =_fde .W .Write (_abc );if _ced !=nil {return _gdc ,_ced ;};_gdc +=3;for _gac :=_eed +2;_gac < len (b )&&b [_gac ]!='>';_gac ++{_gdc ++;_fdbe =_gac +2;_eed =_fdbe ;};};};_dg ,_abg :=_fde .W .Write (b [_fdbe :]);return _dg +_gdc ,_abg ;};