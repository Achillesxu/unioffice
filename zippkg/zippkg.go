//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_eb "archive/zip";_ag "bytes";_ed "encoding/xml";_g "fmt";_acc "github.com/unidoc/unioffice";_d "github.com/unidoc/unioffice/algo";_ab "github.com/unidoc/unioffice/common/tempstorage";_gf "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ac "io";_bd "path";_b "sort";_a "strings";_ec "time";);

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_gff :=_a .Split (path ,"\u002f");_fb :=_a .Join (_gff [0:len (_gff )-1],"\u002f");_gffb :=_gff [len (_gff )-1];_fb +="\u002f_\u0072\u0065\u006c\u0073\u002f";_gffb +="\u002e\u0072\u0065l\u0073";return _fb +_gffb ;};func (_ge SelfClosingWriter )Write (b []byte )(int ,error ){_efb :=0;_bad :=0;for _abfc :=0;_abfc < len (b )-2;_abfc ++{if b [_abfc ]=='>'&&b [_abfc +1]=='<'&&b [_abfc +2]=='/'{_fab :=[]byte {};_daga :=_abfc ;for _agg :=_abfc ;_agg >=0;_agg --{if b [_agg ]==' '{_daga =_agg ;}else if b [_agg ]=='<'{_fab =b [_agg +1:_daga ];break ;};};_ade :=[]byte {};for _fe :=_abfc +3;_fe < len (b );_fe ++{if b [_fe ]=='>'{_ade =b [_abfc +3:_fe ];break ;};};if !_ag .Equal (_fab ,_ade ){continue ;};_badb ,_gbf :=_ge .W .Write (b [_efb :_abfc ]);if _gbf !=nil {return _bad +_badb ,_gbf ;};_bad +=_badb ;_ ,_gbf =_ge .W .Write (_cf );if _gbf !=nil {return _bad ,_gbf ;};_bad +=3;for _dcb :=_abfc +2;_dcb < len (b )&&b [_dcb ]!='>';_dcb ++{_bad ++;_efb =_dcb +2;_abfc =_efb ;};};};_bgc ,_ebga :=_ge .W .Write (b [_efb :]);return _bgc +_bad ,_ebga ;};func MarshalXMLByType (z *_eb .Writer ,dt _acc .DocType ,typ string ,v interface{})error {_ddf :=_acc .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_ddf ,v );};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func (_ad *DecodeMap )IndexFor (path string )int {return _ad ._ba [path ]};var _gbe =[]byte {'\r','\n'};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_eb .File ,dest interface{})error {_acf ,_ggf :=f .Open ();if _ggf !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_ggf );};defer _acf .Close ();_df :=_ed .NewDecoder (_acf );if _cgc :=_df .Decode (dest );_cgc !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_cgc );};if _ebc ,_bg :=dest .(*_gf .Relationships );_bg {for _bef ,_ee :=range _ebc .Relationship {switch _ee .TypeAttr {case _acc .OfficeDocumentTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .OfficeDocumentType ;case _acc .StylesTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .StylesType ;case _acc .ThemeTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ThemeType ;case _acc .ControlTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ControlType ;case _acc .SettingsTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .SettingsType ;case _acc .ImageTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ImageType ;case _acc .CommentsTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .CommentsType ;case _acc .ThumbnailTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ThumbnailType ;case _acc .DrawingTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .DrawingType ;case _acc .ChartTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ChartType ;case _acc .ExtendedPropertiesTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .ExtendedPropertiesType ;case _acc .CustomXMLTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .CustomXMLType ;case _acc .WorksheetTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .WorksheetType ;case _acc .SharedStringsTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .SharedStringsType ;case _acc .TableTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .TableType ;case _acc .HeaderTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .HeaderType ;case _acc .FooterTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .FooterType ;case _acc .NumberingTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .NumberingType ;case _acc .FontTableTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .FontTableType ;case _acc .WebSettingsTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .WebSettingsType ;case _acc .FootNotesTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .FootNotesType ;case _acc .EndNotesTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .EndNotesType ;case _acc .SlideTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .SlideType ;case _acc .VMLDrawingTypeStrict :_ebc .Relationship [_bef ].TypeAttr =_acc .VMLDrawingType ;};};_b .Slice (_ebc .Relationship ,func (_fbb ,_ecf int )bool {_dfc :=_ebc .Relationship [_fbb ];_dd :=_ebc .Relationship [_ecf ];return _d .NaturalLess (_dfc .IdAttr ,_dd .IdAttr );});};return nil ;};func (_abe *DecodeMap )RecordIndex (path string ,idx int ){_abe ._ba [path ]=idx };func MarshalXMLByTypeIndex (z *_eb .Writer ,dt _acc .DocType ,typ string ,idx int ,v interface{})error {_dab :=_acc .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_dab ,v );};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_eb .Writer ,zipPath ,storagePath string )error {_cdg ,_abf :=z .Create (zipPath );if _abf !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_abf );};_bee ,_abf :=_ab .Open (storagePath );if _abf !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_abf );};defer _bee .Close ();_ ,_abf =_ac .Copy (_cdg ,_bee );return _abf ;};var _cf =[]byte {'/','>'};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ae *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ae ._gc ==nil {_ae ._gc =make (map[string ]Target );_ae ._ga =make (map[*_gf .Relationships ]string );_ae ._fd =make (map[string ]struct{});_ae ._ba =make (map[string ]int );};_ff :=_bd .Clean (filePath );if _ ,_bc :=_ae ._fd [_ff ];_bc {return false ;};_ae ._fd [_ff ]=struct{}{};_ae ._gc [_ff ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _ac .Writer ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_gc map[string ]Target ;_ga map[*_gf .Relationships ]string ;_dg []Target ;_cd OnNewRelationshipFunc ;_fd map[string ]struct{};_ba map[string ]int ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_ef *DecodeMap )Decode (files []*_eb .File )error {_gfe :=1;for _gfe > 0{for len (_ef ._dg )> 0{_gcb :=_ef ._dg [len (_ef ._dg )-1];_ef ._dg =_ef ._dg [0:len (_ef ._dg )-1];_be :=_gcb .Ifc .(*_gf .Relationships );for _ ,_ffe :=range _be .Relationship {_ca ,_ :=_ef ._ga [_be ];_ef ._cd (_ef ,_ca +_ffe .TargetAttr ,_ffe .TypeAttr ,files ,_ffe ,_gcb );};};for _ebg ,_eca :=range files {if _eca ==nil {continue ;};if _dc ,_edc :=_ef ._gc [_eca .Name ];_edc {delete (_ef ._gc ,_eca .Name );if _ffb :=Decode (_eca ,_dc .Ifc );_ffb !=nil {return _ffb ;};files [_ebg ]=nil ;if _gae ,_gab :=_dc .Ifc .(*_gf .Relationships );_gab {_ef ._dg =append (_ef ._dg ,_dc );_gbc ,_ :=_bd .Split (_bd .Clean (_eca .Name +"\u002f\u002e\u002e\u002f"));_ef ._ga [_gae ]=_gbc ;_gfe ++;};};};_gfe --;};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_eb .Writer ,filename string ,v interface{})error {_gabd :=&_eb .FileHeader {};_gabd .Method =_eb .Deflate ;_gabd .Name =filename ;_gabd .SetModTime (_ec .Now ());_gad ,_gbb :=z .CreateHeader (_gabd );if _gbb !=nil {return _g .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_gbb );};_ ,_gbb =_gad .Write ([]byte (XMLHeader ));if _gbb !=nil {return _g .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_gbb );};if _gbb =_ed .NewEncoder (SelfClosingWriter {_gad }).Encode (v );_gbb !=nil {return _g .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_gbb );};_ ,_gbb =_gad .Write (_gbe );return _gbb ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_eg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_eg ._cd =fn };const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_eb .Writer ,zipPath string ,data []byte )error {_aa ,_dde :=z .Create (zipPath );if _dde !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_dde );};_ ,_dde =_ac .Copy (_aa ,_ag .NewReader (data ));return _dde ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_eb .File ,path string )(string ,error ){_dag ,_fbf :=_ab .TempFile (path ,"\u007a\u007a");if _fbf !=nil {return "",_fbf ;};defer _dag .Close ();_fa ,_fbf :=f .Open ();if _fbf !=nil {return "",_fbf ;};defer _fa .Close ();_ ,_fbf =_ac .Copy (_dag ,_fa );if _fbf !=nil {return "",_fbf ;};return _dag .Name (),nil ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_f *DecodeMap ,_fg ,_gb string ,_ebb []*_eb .File ,_c *_gf .Relationship ,_ce Target )error ;