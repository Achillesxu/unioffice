//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_g "archive/zip";_cb "bytes";_ee "encoding/xml";_c "fmt";_f "github.com/unidoc/unioffice";_gd "github.com/unidoc/unioffice/algo";_ad "github.com/unidoc/unioffice/common/tempstorage";_cd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_e "io";_dc "path";_da "path/filepath";_gc "sort";_b "strings";_d "time";);type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_gcg *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_gcg ._fg =fn };

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ae map[string ]Target ;_gg map[*_cd .Relationships ]string ;_db []Target ;_fg OnNewRelationshipFunc ;_fb map[string ]struct{};_bg map[string ]int ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_dcb *DecodeMap )Decode (files []*_g .File )error {_ggf :=1;for _ggf > 0{for len (_dcb ._db )> 0{_ag :=_dcb ._db [0];_dcb ._db =_dcb ._db [1:];_df :=_ag .Ifc .(*_cd .Relationships );for _ ,_fba :=range _df .Relationship {_gda :=_dcb ._gg [_df ];if _da .IsAbs (_fba .TargetAttr ){if _b .HasPrefix (_b .TrimPrefix (_fba .TargetAttr ,"\u002f"),_gda ){_gda ="";};};_dcb ._fg (_dcb ,_gda +_fba .TargetAttr ,_fba .TypeAttr ,files ,_fba ,_ag );};};for _aee ,_aa :=range files {if _aa ==nil {continue ;};if _cg ,_fec :=_dcb ._ae [_aa .Name ];_fec {delete (_dcb ._ae ,_aa .Name );if _eeg :=Decode (_aa ,_cg .Ifc );_eeg !=nil {return _eeg ;};files [_aee ]=nil ;if _gb ,_agd :=_cg .Ifc .(*_cd .Relationships );_agd {_dcb ._db =append (_dcb ._db ,_cg );_ea ,_ :=_dc .Split (_dc .Clean (_aa .Name +"\u002f\u002e\u002e\u002f"));_dcb ._gg [_gb ]=_ea ;_ggf ++;};};};_ggf --;};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_g .Writer ,filename string ,v interface{})error {_dde :=&_g .FileHeader {};_dde .Method =_g .Deflate ;_dde .Name =filename ;_dde .SetModTime (_d .Now ());_bad ,_fae :=z .CreateHeader (_dde );if _fae !=nil {return _c .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_fae );};_ ,_fae =_bad .Write ([]byte (XMLHeader ));if _fae !=nil {return _c .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_fae );};if _fae =_ee .NewEncoder (SelfClosingWriter {_bad }).Encode (v );_fae !=nil {return _c .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_fae );};_ ,_fae =_bad .Write (_efe );return _fae ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _e .Writer ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_g .File ,path string )(string ,error ){_dgg ,_bba :=_ad .TempFile (path ,"\u007a\u007a");if _bba !=nil {return "",_bba ;};defer _dgg .Close ();_fgf ,_bba :=f .Open ();if _bba !=nil {return "",_bba ;};defer _fgf .Close ();_ ,_bba =_e .Copy (_dgg ,_fgf );if _bba !=nil {return "",_bba ;};return _dgg .Name (),nil ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_g .Writer ,zipPath ,storagePath string )error {_dg ,_bbb :=z .Create (zipPath );if _bbb !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bbb );};_eb ,_bbb :=_ad .Open (storagePath );if _bbb !=nil {return _c .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_bbb );};defer _eb .Close ();_ ,_bbb =_e .Copy (_dg ,_eb );return _bbb ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ec *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ec ._ae ==nil {_ec ._ae =make (map[string ]Target );_ec ._gg =make (map[*_cd .Relationships ]string );_ec ._fb =make (map[string ]struct{});_ec ._bg =make (map[string ]int );};if _dc .IsAbs (filePath ){filePath =_b .TrimPrefix (filePath ,"\u002f");};_bgd :=_dc .Clean (filePath );if _ ,_gfc :=_ec ._fb [_bgd ];_gfc {return false ;};_ec ._fb [_bgd ]=struct{}{};_ec ._ae [_bgd ]=Target {Path :_bgd ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};func MarshalXMLByType (z *_g .Writer ,dt _f .DocType ,typ string ,v interface{})error {_eae :=_f .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_eae ,v );};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_g .Writer ,zipPath string ,data []byte )error {_adc ,_cc :=z .Create (zipPath );if _cc !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cc );};_ ,_cc =_e .Copy (_adc ,_cb .NewReader (data ));return _cc ;};var _efe =[]byte {'\r','\n'};func MarshalXMLByTypeIndex (z *_g .Writer ,dt _f .DocType ,typ string ,idx int ,v interface{})error {_cf :=_f .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_cf ,v );};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_g .File ,dest interface{})error {_eef ,_dff :=f .Open ();if _dff !=nil {return _c .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_dff );};defer _eef .Close ();_fc :=_ee .NewDecoder (_eef );if _bb :=_fc .Decode (dest );_bb !=nil {return _c .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_bb );};if _bc ,_fbaa :=dest .(*_cd .Relationships );_fbaa {for _ce ,_eac :=range _bc .Relationship {switch _eac .TypeAttr {case _f .OfficeDocumentTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .OfficeDocumentType ;case _f .StylesTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .StylesType ;case _f .ThemeTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ThemeType ;case _f .ControlTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ControlType ;case _f .SettingsTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .SettingsType ;case _f .ImageTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ImageType ;case _f .CommentsTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .CommentsType ;case _f .ThumbnailTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ThumbnailType ;case _f .DrawingTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .DrawingType ;case _f .ChartTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ChartType ;case _f .ExtendedPropertiesTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .ExtendedPropertiesType ;case _f .CustomXMLTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .CustomXMLType ;case _f .WorksheetTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .WorksheetType ;case _f .SharedStringsTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .SharedStringsType ;case _f .TableTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .TableType ;case _f .HeaderTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .HeaderType ;case _f .FooterTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .FooterType ;case _f .NumberingTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .NumberingType ;case _f .FontTableTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .FontTableType ;case _f .WebSettingsTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .WebSettingsType ;case _f .FootNotesTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .FootNotesType ;case _f .EndNotesTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .EndNotesType ;case _f .SlideTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .SlideType ;case _f .VMLDrawingTypeStrict :_bc .Relationship [_ce ].TypeAttr =_f .VMLDrawingType ;};};_gc .Slice (_bc .Relationship ,func (_bbe ,_bae int )bool {_feg :=_bc .Relationship [_bbe ];_ga :=_bc .Relationship [_bae ];return _gd .NaturalLess (_feg .IdAttr ,_ga .IdAttr );});};return nil ;};func (_fa *DecodeMap )RecordIndex (path string ,idx int ){_fa ._bg [path ]=idx };func (_dd *DecodeMap )IndexFor (path string )int {return _dd ._bg [path ]};func (_gbb SelfClosingWriter )Write (b []byte )(int ,error ){_fbaaa :=0;_dac :=0;for _ceb :=0;_ceb < len (b )-2;_ceb ++{if b [_ceb ]=='>'&&b [_ceb +1]=='<'&&b [_ceb +2]=='/'{_caf :=[]byte {};_fgfe :=_ceb ;for _bcd :=_ceb ;_bcd >=0;_bcd --{if b [_bcd ]==' '{_fgfe =_bcd ;}else if b [_bcd ]=='<'{_caf =b [_bcd +1:_fgfe ];break ;};};_eaa :=[]byte {};for _fd :=_ceb +3;_fd < len (b );_fd ++{if b [_fd ]=='>'{_eaa =b [_ceb +3:_fd ];break ;};};if !_cb .Equal (_caf ,_eaa ){continue ;};_fbf ,_cda :=_gbb .W .Write (b [_fbaaa :_ceb ]);if _cda !=nil {return _dac +_fbf ,_cda ;};_dac +=_fbf ;_ ,_cda =_gbb .W .Write (_egd );if _cda !=nil {return _dac ,_cda ;};_dac +=3;for _abd :=_ceb +2;_abd < len (b )&&b [_abd ]!='>';_abd ++{_dac ++;_fbaaa =_abd +2;_ceb =_fbaaa ;};};};_ac ,_ebf :=_gbb .W .Write (b [_fbaaa :]);return _ac +_dac ,_ebf ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_dcg *DecodeMap ,_eg ,_gf string ,_ca []*_g .File ,_fe *_cd .Relationship ,_de Target )error ;

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ecd :=_b .Split (path ,"\u002f");_ba :=_b .Join (_ecd [0:len (_ecd )-1],"\u002f");_fbe :=_ecd [len (_ecd )-1];_ba +="\u002f_\u0072\u0065\u006c\u0073\u002f";_fbe +="\u002e\u0072\u0065l\u0073";return _ba +_fbe ;};var _egd =[]byte {'/','>'};