//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_f "archive/zip";_fe "bytes";_ea "encoding/xml";_g "fmt";_bc "github.com/unidoc/unioffice";_dff "github.com/unidoc/unioffice/algo";_gg "github.com/unidoc/unioffice/common/tempstorage";_df "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_d "io";_bg "path";_e "sort";_fed "strings";_b "time";);

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_f .File ,dest interface{})error {_de ,_bdc :=f .Open ();if _bdc !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_bdc );};defer _de .Close ();_ggg :=_ea .NewDecoder (_de );if _gdb :=_ggg .Decode (dest );_gdb !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_gdb );};if _cbg ,_ba :=dest .(*_df .Relationships );_ba {for _efe ,_be :=range _cbg .Relationship {switch _be .TypeAttr {case _bc .OfficeDocumentTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .OfficeDocumentType ;case _bc .StylesTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .StylesType ;case _bc .ThemeTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ThemeType ;case _bc .ControlTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ControlType ;case _bc .SettingsTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .SettingsType ;case _bc .ImageTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ImageType ;case _bc .CommentsTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .CommentsType ;case _bc .ThumbnailTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ThumbnailType ;case _bc .DrawingTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .DrawingType ;case _bc .ChartTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ChartType ;case _bc .ExtendedPropertiesTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .ExtendedPropertiesType ;case _bc .CustomXMLTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .CustomXMLType ;case _bc .WorksheetTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .WorksheetType ;case _bc .SharedStringsTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .SharedStringsType ;case _bc .TableTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .TableType ;case _bc .HeaderTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .HeaderType ;case _bc .FooterTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .FooterType ;case _bc .NumberingTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .NumberingType ;case _bc .FontTableTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .FontTableType ;case _bc .WebSettingsTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .WebSettingsType ;case _bc .FootNotesTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .FootNotesType ;case _bc .EndNotesTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .EndNotesType ;case _bc .SlideTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .SlideType ;case _bc .VMLDrawingTypeStrict :_cbg .Relationship [_efe ].TypeAttr =_bc .VMLDrawingType ;};};_e .Slice (_cbg .Relationship ,func (_egc ,_fa int )bool {_dbg :=_cbg .Relationship [_egc ];_ce :=_cbg .Relationship [_fa ];return _dff .NaturalLess (_dbg .IdAttr ,_ce .IdAttr );});};return nil ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ae map[string ]Target ;_eg map[*_df .Relationships ]string ;_dg []Target ;_fg OnNewRelationshipFunc ;_fef map[string ]struct{};_cb map[string ]int ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _d .Writer ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_ga *DecodeMap ,_af ,_c string ,_ec []*_f .File ,_cc *_df .Relationship ,_ca Target )error ;

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ffc :=_fed .Split (path ,"\u002f");_efg :=_fed .Join (_ffc [0:len (_ffc )-1],"\u002f");_eaf :=_ffc [len (_ffc )-1];_efg +="\u002f_\u0072\u0065\u006c\u0073\u002f";_eaf +="\u002e\u0072\u0065l\u0073";return _efg +_eaf ;};var _gff =[]byte {'/','>'};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_gb *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_gb ._fg =fn };var _da =[]byte {'\r','\n'};func (_eaa *DecodeMap )RecordIndex (path string ,idx int ){_eaa ._cb [path ]=idx };

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_f .File ,path string )(string ,error ){_dfb ,_ac :=_gg .TempFile (path ,"\u007a\u007a");if _ac !=nil {return "",_ac ;};defer _dfb .Close ();_caf ,_ac :=f .Open ();if _ac !=nil {return "",_ac ;};defer _caf .Close ();_ ,_ac =_d .Copy (_dfb ,_caf );if _ac !=nil {return "",_ac ;};return _dfb .Name (),nil ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_cg *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _cg ._ae ==nil {_cg ._ae =make (map[string ]Target );_cg ._eg =make (map[*_df .Relationships ]string );_cg ._fef =make (map[string ]struct{});_cg ._cb =make (map[string ]int );};if _bg .IsAbs (filePath ){filePath =_fed .TrimPrefix (filePath ,"\u002f");};_bd :=_bg .Clean (filePath );if _ ,_bf :=_cg ._fef [_bd ];_bf {return false ;};_cg ._fef [_bd ]=struct{}{};_cg ._ae [_bd ]=Target {Path :_bd ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};func MarshalXMLByTypeIndex (z *_f .Writer ,dt _bc .DocType ,typ string ,idx int ,v interface{})error {_agg :=_bc .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_agg ,v );};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_f .Writer ,filename string ,v interface{})error {_fff :=&_f .FileHeader {};_fff .Method =_f .Deflate ;_fff .Name =filename ;_fff .SetModTime (_b .Now ());_dfd ,_caee :=z .CreateHeader (_fff );if _caee !=nil {return _g .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_caee );};_ ,_caee =_dfd .Write ([]byte (XMLHeader ));if _caee !=nil {return _g .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_caee );};if _caee =_ea .NewEncoder (SelfClosingWriter {_dfd }).Encode (v );_caee !=nil {return _g .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_caee );};_ ,_caee =_dfd .Write (_da );return _caee ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_f .Writer ,zipPath string ,data []byte )error {_ggf ,_bb :=z .Create (zipPath );if _bb !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bb );};_ ,_bb =_d .Copy (_ggf ,_fe .NewReader (data ));return _bb ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_agd *DecodeMap )Decode (files []*_f .File )error {_ef :=1;for _ef > 0{for len (_agd ._dg )> 0{_afe :=_agd ._dg [0];_agd ._dg =_agd ._dg [1:];_fec :=_afe .Ifc .(*_df .Relationships );for _ ,_eef :=range _fec .Relationship {_gd ,_ :=_agd ._eg [_fec ];_agd ._fg (_agd ,_gd +_eef .TargetAttr ,_eef .TypeAttr ,files ,_eef ,_afe );};};for _ff ,_ed :=range files {if _ed ==nil {continue ;};if _gf ,_ab :=_agd ._ae [_ed .Name ];_ab {delete (_agd ._ae ,_ed .Name );if _db :=Decode (_ed ,_gf .Ifc );_db !=nil {return _db ;};files [_ff ]=nil ;if _gdf ,_ggb :=_gf .Ifc .(*_df .Relationships );_ggb {_agd ._dg =append (_agd ._dg ,_gf );_dd ,_ :=_bg .Split (_bg .Clean (_ed .Name +"\u002f\u002e\u002e\u002f"));_agd ._eg [_gdf ]=_dd ;_ef ++;};};};_ef --;};return nil ;};func (_ag *DecodeMap )IndexFor (path string )int {return _ag ._cb [path ]};func (_gfc SelfClosingWriter )Write (b []byte )(int ,error ){_dab :=0;_cee :=0;for _ge :=0;_ge < len (b )-2;_ge ++{if b [_ge ]=='>'&&b [_ge +1]=='<'&&b [_ge +2]=='/'{_dfdg :=[]byte {};_cafa :=_ge ;for _bfe :=_ge ;_bfe >=0;_bfe --{if b [_bfe ]==' '{_cafa =_bfe ;}else if b [_bfe ]=='<'{_dfdg =b [_bfe +1:_cafa ];break ;};};_fc :=[]byte {};for _ced :=_ge +3;_ced < len (b );_ced ++{if b [_ced ]=='>'{_fc =b [_ge +3:_ced ];break ;};};if !_fe .Equal (_dfdg ,_fc ){continue ;};_bgc ,_afeb :=_gfc .W .Write (b [_dab :_ge ]);if _afeb !=nil {return _cee +_bgc ,_afeb ;};_cee +=_bgc ;_ ,_afeb =_gfc .W .Write (_gff );if _afeb !=nil {return _cee ,_afeb ;};_cee +=3;for _fag :=_ge +2;_fag < len (b )&&b [_fag ]!='>';_fag ++{_cee ++;_dab =_fag +2;_ge =_dab ;};};};_ace ,_fcf :=_gfc .W .Write (b [_dab :]);return _ace +_cee ,_fcf ;};func MarshalXMLByType (z *_f .Writer ,dt _bc .DocType ,typ string ,v interface{})error {_bac :=_bc .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_bac ,v );};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_f .Writer ,zipPath ,storagePath string )error {_fea ,_gbf :=z .Create (zipPath );if _gbf !=nil {return _g .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_gbf );};_aeg ,_gbf :=_gg .Open (storagePath );if _gbf !=nil {return _g .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_gbf );};defer _aeg .Close ();_ ,_gbf =_d .Copy (_fea ,_aeg );return _gbf ;};