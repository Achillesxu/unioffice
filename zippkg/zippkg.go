//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_b "archive/zip";_bd "bytes";_d "encoding/xml";_ba "fmt";_gfc "github.com/unidoc/unioffice";_gf "github.com/unidoc/unioffice/algo";_baa "github.com/unidoc/unioffice/common/tempstorage";_df "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_f "io";_a "path";_bb "sort";_e "strings";_bc "time";);

// Decode loops decoding targets registered with AddTarget and calling th
func (_ec *DecodeMap )Decode (files []*_b .File )error {_gg :=1;for _gg > 0{for len (_ec ._ab )> 0{_fa :=_ec ._ab [0];_ec ._ab =_ec ._ab [1:];_cf :=_fa .Ifc .(*_df .Relationships );for _ ,_be :=range _cf .Relationship {_fcb ,_ :=_ec ._dg [_cf ];_ec ._eg (_ec ,_fcb +_be .TargetAttr ,_be .TypeAttr ,files ,_be ,_fa );};};for _ge ,_fcf :=range files {if _fcf ==nil {continue ;};if _ade ,_bea :=_ec ._ad [_fcf .Name ];_bea {delete (_ec ._ad ,_fcf .Name );if _abb :=Decode (_fcf ,_ade .Ifc );_abb !=nil {return _abb ;};files [_ge ]=nil ;if _cb ,_fdf :=_ade .Ifc .(*_df .Relationships );_fdf {_ec ._ab =append (_ec ._ab ,_ade );_cg ,_ :=_a .Split (_a .Clean (_fcf .Name +"\u002f\u002e\u002e\u002f"));_ec ._dg [_cb ]=_cg ;_gg ++;};};};_gg --;};return nil ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _f .Writer ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_b .Writer ,filename string ,v interface{})error {_fb :=&_b .FileHeader {};_fb .Method =_b .Deflate ;_fb .Name =filename ;_fb .SetModTime (_bc .Now ());_dd ,_bcd :=z .CreateHeader (_fb );if _bcd !=nil {return _ba .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_bcd );};_ ,_bcd =_dd .Write ([]byte (XMLHeader ));if _bcd !=nil {return _ba .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_bcd );};if _bcd =_d .NewEncoder (SelfClosingWriter {_dd }).Encode (v );_bcd !=nil {return _ba .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_bcd );};_ ,_bcd =_dd .Write (_bcc );return _bcd ;};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_b .Writer ,zipPath string ,data []byte )error {_gfg ,_geee :=z .Create (zipPath );if _geee !=nil {return _ba .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_geee );};_ ,_geee =_f .Copy (_gfg ,_bd .NewReader (data ));return _geee ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ff :=_e .Split (path ,"\u002f");_fgd :=_e .Join (_ff [0:len (_ff )-1],"\u002f");_aeg :=_ff [len (_ff )-1];_fgd +="\u002f_\u0072\u0065\u006c\u0073\u002f";_aeg +="\u002e\u0072\u0065l\u0073";return _fgd +_aeg ;};var _aab =[]byte {'/','>'};func MarshalXMLByType (z *_b .Writer ,dt _gfc .DocType ,typ string ,v interface{})error {_abbf :=_gfc .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_abbf ,v );};func (_ag *DecodeMap )RecordIndex (path string ,idx int ){_ag ._fg [path ]=idx };func (_cbg SelfClosingWriter )Write (b []byte )(int ,error ){_aec :=0;_gaa :=0;for _fcbf :=0;_fcbf < len (b )-2;_fcbf ++{if b [_fcbf ]=='>'&&b [_fcbf +1]=='<'&&b [_fcbf +2]=='/'{_ega :=[]byte {};_acb :=_fcbf ;for _ged :=_fcbf ;_ged >=0;_ged --{if b [_ged ]==' '{_acb =_ged ;}else if b [_ged ]=='<'{_ega =b [_ged +1:_acb ];break ;};};_bcf :=[]byte {};for _dcc :=_fcbf +3;_dcc < len (b );_dcc ++{if b [_dcc ]=='>'{_bcf =b [_fcbf +3:_dcc ];break ;};};if !_bd .Equal (_ega ,_bcf ){continue ;};_ddf ,_cdc :=_cbg .W .Write (b [_aec :_fcbf ]);if _cdc !=nil {return _gaa +_ddf ,_cdc ;};_gaa +=_ddf ;_ ,_cdc =_cbg .W .Write (_aab );if _cdc !=nil {return _gaa ,_cdc ;};_gaa +=3;for _def :=_fcbf +2;_def < len (b )&&b [_def ]!='>';_def ++{_gaa ++;_aec =_def +2;_fcbf =_aec ;};};};_ea ,_eea :=_cbg .W .Write (b [_aec :]);return _ea +_gaa ,_eea ;};var _bcc =[]byte {'\r','\n'};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_b .Writer ,zipPath ,storagePath string )error {_db ,_eeg :=z .Create (zipPath );if _eeg !=nil {return _ba .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_eeg );};_ceg ,_eeg :=_baa .Open (storagePath );if _eeg !=nil {return _ba .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_eeg );};defer _ceg .Close ();_ ,_eeg =_f .Copy (_db ,_ceg );return _eeg ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_fd *DecodeMap ,_ac ,_ee string ,_gc []*_b .File ,_ae *_df .Relationship ,_eb Target )error ;

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_b .File ,dest interface{})error {_gb ,_fag :=f .Open ();if _fag !=nil {return _ba .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_fag );};defer _gb .Close ();_fdg :=_d .NewDecoder (_gb );if _dca :=_fdg .Decode (dest );_dca !=nil {return _ba .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_dca );};if _faf ,_de :=dest .(*_df .Relationships );_de {for _bg ,_gae :=range _faf .Relationship {switch _gae .TypeAttr {case _gfc .OfficeDocumentTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .OfficeDocumentType ;case _gfc .StylesTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .StylesType ;case _gfc .ThemeTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ThemeType ;case _gfc .ControlTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ControlType ;case _gfc .SettingsTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .SettingsType ;case _gfc .ImageTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ImageType ;case _gfc .CommentsTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .CommentsType ;case _gfc .ThumbnailTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ThumbnailType ;case _gfc .DrawingTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .DrawingType ;case _gfc .ChartTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ChartType ;case _gfc .ExtendedPropertiesTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .ExtendedPropertiesType ;case _gfc .CustomXMLTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .CustomXMLType ;case _gfc .WorksheetTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .WorksheetType ;case _gfc .SharedStringsTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .SharedStringsType ;case _gfc .TableTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .TableType ;case _gfc .HeaderTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .HeaderType ;case _gfc .FooterTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .FooterType ;case _gfc .NumberingTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .NumberingType ;case _gfc .FontTableTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .FontTableType ;case _gfc .WebSettingsTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .WebSettingsType ;case _gfc .FootNotesTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .FootNotesType ;case _gfc .EndNotesTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .EndNotesType ;case _gfc .SlideTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .SlideType ;case _gfc .VMLDrawingTypeStrict :_faf .Relationship [_bg ].TypeAttr =_gfc .VMLDrawingType ;};};_bb .Slice (_faf .Relationship ,func (_acf ,_bdaf int )bool {_deb :=_faf .Relationship [_acf ];_gee :=_faf .Relationship [_bdaf ];return _gf .NaturalLess (_deb .IdAttr ,_gee .IdAttr );});};return nil ;};func (_cd *DecodeMap )IndexFor (path string )int {return _cd ._fg [path ]};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_c *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_c ._eg =fn };

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_b .File ,path string )(string ,error ){_ded ,_gac :=_baa .TempFile (path ,"\u007a\u007a");if _gac !=nil {return "",_gac ;};defer _ded .Close ();_ecd ,_gac :=f .Open ();if _gac !=nil {return "",_gac ;};defer _ecd .Close ();_ ,_gac =_f .Copy (_ded ,_ecd );if _gac !=nil {return "",_gac ;};return _ded .Name (),nil ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_da *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _da ._ad ==nil {_da ._ad =make (map[string ]Target );_da ._dg =make (map[*_df .Relationships ]string );_da ._aca =make (map[string ]struct{});_da ._fg =make (map[string ]int );};if _a .IsAbs (filePath ){filePath =_e .TrimPrefix (filePath ,"\u002f");};_fc :=_a .Clean (filePath );if _ ,_dc :=_da ._aca [_fc ];_dc {return false ;};_da ._aca [_fc ]=struct{}{};_da ._ad [_fc ]=Target {Path :_fc ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ad map[string ]Target ;_dg map[*_df .Relationships ]string ;_ab []Target ;_eg OnNewRelationshipFunc ;_aca map[string ]struct{};_fg map[string ]int ;};func MarshalXMLByTypeIndex (z *_b .Writer ,dt _gfc .DocType ,typ string ,idx int ,v interface{})error {_dfc :=_gfc .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_dfc ,v );};