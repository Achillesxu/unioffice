//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_f "archive/zip";_deb "bytes";_adb "encoding/xml";_fa "fmt";_aab "github.com/unidoc/unioffice";_cd "github.com/unidoc/unioffice/algo";_ace "github.com/unidoc/unioffice/common/tempstorage";_ga "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_gc "io";_fd "path";_c "sort";_fdd "strings";_cg "time";);

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_f .File ,path string )(string ,error ){_af ,_ff :=_ace .TempFile (path ,"\u007a\u007a");if _ff !=nil {return "",_ff ;};defer _af .Close ();_be ,_ff :=f .Open ();if _ff !=nil {return "",_ff ;};defer _be .Close ();_ ,_ff =_gc .Copy (_af ,_be );if _ff !=nil {return "",_ff ;};return _af .Name (),nil ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _gc .Writer ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_f .File ,dest interface{})error {_bb ,_eg :=f .Open ();if _eg !=nil {return _fa .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_eg );};defer _bb .Close ();_efe :=_adb .NewDecoder (_bb );if _gga :=_efe .Decode (dest );_gga !=nil {return _fa .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_gga );};if _dae ,_ac :=dest .(*_ga .Relationships );_ac {for _dd ,_dag :=range _dae .Relationship {switch _dag .TypeAttr {case _aab .OfficeDocumentTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .OfficeDocumentType ;case _aab .StylesTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .StylesType ;case _aab .ThemeTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .ThemeType ;case _aab .SettingsTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .SettingsType ;case _aab .ImageTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .ImageType ;case _aab .CommentsTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .CommentsType ;case _aab .ThumbnailTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .ThumbnailType ;case _aab .DrawingTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .DrawingType ;case _aab .ChartTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .ChartType ;case _aab .ExtendedPropertiesTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .ExtendedPropertiesType ;case _aab .CustomXMLTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .CustomXMLType ;case _aab .WorksheetTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .WorksheetType ;case _aab .SharedStringsTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .SharedStringsType ;case _aab .TableTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .TableType ;case _aab .HeaderTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .HeaderType ;case _aab .FooterTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .FooterType ;case _aab .NumberingTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .NumberingType ;case _aab .FontTableTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .FontTableType ;case _aab .WebSettingsTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .WebSettingsType ;case _aab .FootNotesTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .FootNotesType ;case _aab .EndNotesTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .EndNotesType ;case _aab .SlideTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .SlideType ;case _aab .VMLDrawingTypeStrict :_dae .Relationship [_dd ].TypeAttr =_aab .VMLDrawingType ;};};_c .Slice (_dae .Relationship ,func (_ag ,_ea int )bool {_bgb :=_dae .Relationship [_ag ];_bcd :=_dae .Relationship [_ea ];return _cd .NaturalLess (_bgb .IdAttr ,_bcd .IdAttr );});};return nil ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_cdg *DecodeMap )Decode (files []*_f .File )error {_bdc :=1;for _bdc > 0{for len (_cdg ._adgd )> 0{_ae :=_cdg ._adgd [len (_cdg ._adgd )-1];_cdg ._adgd =_cdg ._adgd [0:len (_cdg ._adgd )-1];_cae :=_ae .Ifc .(*_ga .Relationships );for _ ,_ggbg :=range _cae .Relationship {_bcf ,_ :=_cdg ._fdff [_cae ];_cdg ._bc (_cdg ,_bcf +_ggbg .TargetAttr ,_ggbg .TypeAttr ,files ,_ggbg ,_ae );};};for _ade ,_cad :=range files {if _cad ==nil {continue ;};if _ecg ,_ece :=_cdg ._gb [_cad .Name ];_ece {delete (_cdg ._gb ,_cad .Name );if _ca :=Decode (_cad ,_ecg .Ifc );_ca !=nil {return _ca ;};files [_ade ]=nil ;if _cf ,_ad :=_ecg .Ifc .(*_ga .Relationships );_ad {_cdg ._adgd =append (_cdg ._adgd ,_ecg );_ef ,_ :=_fd .Split (_fd .Clean (_cad .Name +"\u002f\u002e\u002e\u002f"));_cdg ._fdff [_cf ]=_ef ;_bdc ++;};};};_bdc --;};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_f .Writer ,filename string ,v interface{})error {_fe :=&_f .FileHeader {};_fe .Method =_f .Deflate ;_fe .Name =filename ;_fe .SetModTime (_cg .Now ());_fff ,_bge :=z .CreateHeader (_fe );if _bge !=nil {return _fa .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_bge );};_ ,_bge =_fff .Write ([]byte (XMLHeader ));if _bge !=nil {return _fa .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_bge );};if _bge =_adb .NewEncoder (SelfClosingWriter {_fff }).Encode (v );_bge !=nil {return _fa .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_bge );};_ ,_bge =_fff .Write (_g );return _bge ;};func (_dec SelfClosingWriter )Write (b []byte )(int ,error ){_bf :=0;_egf :=0;for _ceb :=0;_ceb < len (b )-2;_ceb ++{if b [_ceb ]=='>'&&b [_ceb +1]=='<'&&b [_ceb +2]=='/'{_ega :=[]byte {};_beb :=_ceb ;for _egb :=_ceb ;_egb >=0;_egb --{if b [_egb ]==' '{_beb =_egb ;}else if b [_egb ]=='<'{_ega =b [_egb +1:_beb ];break ;};};_eb :=[]byte {};for _b :=_ceb +3;_b < len (b );_b ++{if b [_b ]=='>'{_eb =b [_ceb +3:_b ];break ;};};if !_deb .Equal (_ega ,_eb ){continue ;};_aed ,_deaf :=_dec .W .Write (b [_bf :_ceb ]);if _deaf !=nil {return _egf +_aed ,_deaf ;};_egf +=_aed ;_ ,_deaf =_dec .W .Write (_ce );if _deaf !=nil {return _egf ,_deaf ;};_egf +=3;for _cb :=_ceb +2;_cb < len (b )&&b [_cb ]!='>';_cb ++{_egf ++;_bf =_cb +2;_ceb =_bf ;};};};_afe ,_ffd :=_dec .W .Write (b [_bf :]);return _afe +_egf ,_ffd ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_cc *DecodeMap ,_ec ,_efd string ,_fg []*_f .File ,_gg *_ga .Relationship ,_d Target )error ;func MarshalXMLByTypeIndex (z *_f .Writer ,dt _aab .DocType ,typ string ,idx int ,v interface{})error {_bba :=_aab .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_bba ,v );};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ed *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ed ._bc =fn };func (_fc *DecodeMap )IndexFor (path string )int {return _fc ._afg [path ]};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ba :=_fdd .Split (path ,"\u002f");_fdf :=_fdd .Join (_ba [0:len (_ba )-1],"\u002f");_afb :=_ba [len (_ba )-1];_fdf +="\u002f_\u0072\u0065\u006c\u0073\u002f";_afb +="\u002e\u0072\u0065l\u0073";return _fdf +_afb ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_gcg *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _gcg ._gb ==nil {_gcg ._gb =make (map[string ]Target );_gcg ._fdff =make (map[*_ga .Relationships ]string );_gcg ._eag =make (map[string ]struct{});_gcg ._afg =make (map[string ]int );};_adg :=_fd .Clean (filePath );if _ ,_e :=_gcg ._eag [_adg ];_e {return false ;};_gcg ._eag [_adg ]=struct{}{};_gcg ._gb [_adg ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_f .Writer ,zipPath ,storagePath string )error {_bcg ,_aa :=z .Create (zipPath );if _aa !=nil {return _fa .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_aa );};_gf ,_aa :=_ace .Open (storagePath );if _aa !=nil {return _fa .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_aa );};defer _gf .Close ();_ ,_aa =_gc .Copy (_bcg ,_gf );return _aa ;};var _ce =[]byte {'/','>'};func (_a *DecodeMap )RecordIndex (path string ,idx int ){_a ._afg [path ]=idx };

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_f .Writer ,zipPath string ,data []byte )error {_fda ,_df :=z .Create (zipPath );if _df !=nil {return _fa .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_df );};_ ,_df =_gc .Copy (_fda ,_deb .NewReader (data ));return _df ;};var _g =[]byte {'\r','\n'};func MarshalXMLByType (z *_f .Writer ,dt _aab .DocType ,typ string ,v interface{})error {_egd :=_aab .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_egd ,v );};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_gb map[string ]Target ;_fdff map[*_ga .Relationships ]string ;_adgd []Target ;_bc OnNewRelationshipFunc ;_eag map[string ]struct{};_afg map[string ]int ;};