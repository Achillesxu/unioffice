//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_c "archive/zip";_d "bytes";_aa "encoding/xml";_bc "fmt";_ab "github.com/unidoc/unioffice";_gc "github.com/unidoc/unioffice/algo";_cf "github.com/unidoc/unioffice/common/tempstorage";_f "github.com/unidoc/unioffice/schema/soo/pkg/relationships";
_b "io";_bd "path";_da "path/filepath";_cg "sort";_g "strings";_a "time";);

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_c .Writer ,zipPath string ,data []byte )error {_ec ,_bcd :=z .Create (zipPath );if _bcd !=nil {return _bc .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bcd );
};_ ,_bcd =_b .Copy (_ec ,_d .NewReader (data ));return _bcd ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _b .Writer ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_c .File ,path string )(string ,error ){_dcac ,_eab :=_cf .TempFile (path ,"\u007a\u007a");if _eab !=nil {return "",_eab ;};defer _dcac .Close ();_be ,_eab :=f .Open ();if _eab !=nil {return "",_eab ;};defer _be .Close ();_ ,_eab =_b .Copy (_dcac ,_be );
if _eab !=nil {return "",_eab ;};return _dcac .Name (),nil ;};func (_bcb *DecodeMap )IndexFor (path string )int {return _bcb ._ce [path ]};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_ca *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _ca ._bf ==nil {_ca ._bf =make (map[string ]Target );_ca ._fa =make (map[*_f .Relationships ]string );_ca ._eg =make (map[string ]struct{});_ca ._ce =make (map[string ]int );
};if _bd .IsAbs (filePath ){filePath =_g .TrimPrefix (filePath ,"\u002f");};_db :=_bd .Clean (filePath );if _ ,_dg :=_ca ._eg [_db ];_dg {return false ;};_ca ._eg [_db ]=struct{}{};_ca ._bf [_db ]=Target {Path :_db ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };
return true ;};func (_dd *DecodeMap )RecordIndex (path string ,idx int ){_dd ._ce [path ]=idx };var _gedd =[]byte {'/','>'};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_c .File ,dest interface{})error {_bb ,_fab :=f .Open ();if _fab !=nil {return _bc .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_fab );};defer _bb .Close ();_fcd :=_aa .NewDecoder (_bb );
if _bcbd :=_fcd .Decode (dest );_bcbd !=nil {return _bc .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_bcbd );};if _adc ,_dfb :=dest .(*_f .Relationships );_dfb {for _dca ,_cff :=range _adc .Relationship {switch _cff .TypeAttr {case _ab .OfficeDocumentTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .OfficeDocumentType ;
case _ab .StylesTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .StylesType ;case _ab .ThemeTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ThemeType ;case _ab .ControlTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ControlType ;case _ab .SettingsTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .SettingsType ;
case _ab .ImageTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ImageType ;case _ab .CommentsTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .CommentsType ;case _ab .ThumbnailTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ThumbnailType ;
case _ab .DrawingTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .DrawingType ;case _ab .ChartTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ChartType ;case _ab .ExtendedPropertiesTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .ExtendedPropertiesType ;
case _ab .CustomXMLTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .CustomXMLType ;case _ab .WorksheetTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .WorksheetType ;case _ab .SharedStringsTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .SharedStringsType ;
case _ab .TableTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .TableType ;case _ab .HeaderTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .HeaderType ;case _ab .FooterTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .FooterType ;case _ab .NumberingTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .NumberingType ;
case _ab .FontTableTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .FontTableType ;case _ab .WebSettingsTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .WebSettingsType ;case _ab .FootNotesTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .FootNotesType ;
case _ab .EndNotesTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .EndNotesType ;case _ab .SlideTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .SlideType ;case _ab .VMLDrawingTypeStrict :_adc .Relationship [_dca ].TypeAttr =_ab .VMLDrawingType ;
};};_cg .Slice (_adc .Relationship ,func (_ddg ,_fdb int )bool {_ag :=_adc .Relationship [_ddg ];_eag :=_adc .Relationship [_fdb ];return _gc .NaturalLess (_ag .IdAttr ,_eag .IdAttr );});};return nil ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_c .Writer ,filename string ,v interface{})error {_fdd :=&_c .FileHeader {};_fdd .Method =_c .Deflate ;_fdd .Name =filename ;_fdd .SetModTime (_a .Now ());_eaa ,_bga :=z .CreateHeader (_fdd );if _bga !=nil {return _bc .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_bga );
};_ ,_bga =_eaa .Write ([]byte (XMLHeader ));if _bga !=nil {return _bc .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_bga );
};if _bga =_aa .NewEncoder (SelfClosingWriter {_eaa }).Encode (v );_bga !=nil {return _bc .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_bga );};_ ,_bga =_eaa .Write (_ffe );return _bga ;
};var _ffe =[]byte {'\r','\n'};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_bf map[string ]Target ;_fa map[*_f .Relationships ]string ;_gd []Target ;_dad OnNewRelationshipFunc ;_eg map[string ]struct{};_ce map[string ]int ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ea :=_g .Split (path ,"\u002f");_df :=_g .Join (_ea [0:len (_ea )-1],"\u002f");_dfd :=_ea [len (_ea )-1];_df +="\u002f_\u0072\u0065\u006c\u0073\u002f";_dfd +="\u002e\u0072\u0065l\u0073";return _df +_dfd ;};func (_bbb SelfClosingWriter )Write (b []byte )(int ,error ){_adf :=0;
_ebe :=0;for _dag :=0;_dag < len (b )-2;_dag ++{if b [_dag ]=='>'&&b [_dag +1]=='<'&&b [_dag +2]=='/'{_ef :=[]byte {};_cgc :=_dag ;for _fge :=_dag ;_fge >=0;_fge --{if b [_fge ]==' '{_cgc =_fge ;}else if b [_fge ]=='<'{_ef =b [_fge +1:_cgc ];break ;};};
_bbg :=[]byte {};for _abg :=_dag +3;_abg < len (b );_abg ++{if b [_abg ]=='>'{_bbg =b [_dag +3:_abg ];break ;};};if !_d .Equal (_ef ,_bbg ){continue ;};_cgb ,_de :=_bbb .W .Write (b [_adf :_dag ]);if _de !=nil {return _ebe +_cgb ,_de ;};_ebe +=_cgb ;_ ,_de =_bbb .W .Write (_gedd );
if _de !=nil {return _ebe ,_de ;};_ebe +=3;for _ee :=_dag +2;_ee < len (b )&&b [_ee ]!='>';_ee ++{_ebe ++;_adf =_ee +2;_dag =_adf ;};};};_gee ,_bec :=_bbb .W .Write (b [_adf :]);return _gee +_ebe ,_bec ;};type Target struct{Path string ;Typ string ;Ifc interface{};
Index uint32 ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";
func MarshalXMLByTypeIndex (z *_c .Writer ,dt _ab .DocType ,typ string ,idx int ,v interface{})error {_bdc :=_ab .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_bdc ,v );};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_ge *DecodeMap ,_bce ,_gf string ,_cd []*_c .File ,_fe *_f .Relationship ,_dc Target )error ;func MarshalXMLByType (z *_c .Writer ,dt _ab .DocType ,typ string ,v interface{})error {_agc :=_ab .AbsoluteFilename (dt ,typ ,0);
return MarshalXML (z ,_agc ,v );};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_c .Writer ,zipPath ,storagePath string )error {_bbe ,_cdgb :=z .Create (zipPath );if _cdgb !=nil {return _bc .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_cdgb );
};_cb ,_cdgb :=_cf .Open (storagePath );if _cdgb !=nil {return _bc .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_cdgb );};defer _cb .Close ();_ ,_cdgb =_b .Copy (_bbe ,_cb );return _cdgb ;
};

// Decode loops decoding targets registered with AddTarget and calling th
func (_ged *DecodeMap )Decode (files []*_c .File )error {_ff :=1;for _ff > 0{for len (_ged ._gd )> 0{_ad :=_ged ._gd [0];_ged ._gd =_ged ._gd [1:];_eb :=_ad .Ifc .(*_f .Relationships );for _ ,_gcd :=range _eb .Relationship {_aae :=_ged ._fa [_eb ];if _da .IsAbs (_gcd .TargetAttr ){_gcd .TargetAttr =_g .TrimPrefix (_gcd .TargetAttr ,"\u002f");
if _g .HasPrefix (_gcd .TargetAttr ,_aae ){_aae ="";};};_ged ._dad (_ged ,_aae +_gcd .TargetAttr ,_gcd .TypeAttr ,files ,_gcd ,_ad );};};for _cge ,_cdg :=range files {if _cdg ==nil {continue ;};if _bfa ,_bg :=_ged ._bf [_cdg .Name ];_bg {delete (_ged ._bf ,_cdg .Name );
if _ga :=Decode (_cdg ,_bfa .Ifc );_ga !=nil {return _ga ;};files [_cge ]=nil ;if _fc ,_ege :=_bfa .Ifc .(*_f .Relationships );_ege {_ged ._gd =append (_ged ._gd ,_bfa );_egee ,_ :=_bd .Split (_bd .Clean (_cdg .Name +"\u002f\u002e\u002e\u002f"));_ged ._fa [_fc ]=_egee ;
_ff ++;};};};_ff --;};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_bfc *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_bfc ._dad =fn };