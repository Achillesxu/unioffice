//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_c "archive/zip";_ae "bytes";_de "encoding/xml";_a "fmt";_bd "github.com/unidoc/unioffice";_gb "github.com/unidoc/unioffice/algo";_fa "github.com/unidoc/unioffice/common/tempstorage";_ba "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_f "io";_e "path";_db "sort";_g "strings";_b "time";);

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_ef *DecodeMap ,_efb ,_ea string ,_gbf []*_c .File ,_gc *_ba .Relationship ,_gd Target )error ;func MarshalXMLByType (z *_c .Writer ,dt _bd .DocType ,typ string ,v interface{})error {_cff :=_bd .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_cff ,v );};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_c .File ,dest interface{})error {_agf ,_dg :=f .Open ();if _dg !=nil {return _a .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_dg );};defer _agf .Close ();_dd :=_de .NewDecoder (_agf );if _fgc :=_dd .Decode (dest );_fgc !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_fgc );};if _baeb ,_dcd :=dest .(*_ba .Relationships );_dcd {for _ff ,_cc :=range _baeb .Relationship {switch _cc .TypeAttr {case _bd .OfficeDocumentTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .OfficeDocumentType ;case _bd .StylesTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .StylesType ;case _bd .ThemeTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ThemeType ;case _bd .ControlTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ControlType ;case _bd .SettingsTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .SettingsType ;case _bd .ImageTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ImageType ;case _bd .CommentsTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .CommentsType ;case _bd .ThumbnailTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ThumbnailType ;case _bd .DrawingTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .DrawingType ;case _bd .ChartTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ChartType ;case _bd .ExtendedPropertiesTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .ExtendedPropertiesType ;case _bd .CustomXMLTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .CustomXMLType ;case _bd .WorksheetTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .WorksheetType ;case _bd .SharedStringsTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .SharedStringsType ;case _bd .TableTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .TableType ;case _bd .HeaderTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .HeaderType ;case _bd .FooterTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .FooterType ;case _bd .NumberingTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .NumberingType ;case _bd .FontTableTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .FontTableType ;case _bd .WebSettingsTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .WebSettingsType ;case _bd .FootNotesTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .FootNotesType ;case _bd .EndNotesTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .EndNotesType ;case _bd .SlideTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .SlideType ;case _bd .VMLDrawingTypeStrict :_baeb .Relationship [_ff ].TypeAttr =_bd .VMLDrawingType ;};};_db .Slice (_baeb .Relationship ,func (_fcf ,_ec int )bool {_fdb :=_baeb .Relationship [_fcf ];_eee :=_baeb .Relationship [_ec ];return _gb .NaturalLess (_fdb .IdAttr ,_eee .IdAttr );});};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_dbf *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_dbf ._ga =fn };const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_c .Writer ,filename string ,v interface{})error {_eaf :=&_c .FileHeader {};_eaf .Method =_c .Deflate ;_eaf .Name =filename ;_eaf .SetModTime (_b .Now ());_bf ,_gbc :=z .CreateHeader (_eaf );if _gbc !=nil {return _a .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_gbc );};_ ,_gbc =_bf .Write ([]byte (XMLHeader ));if _gbc !=nil {return _a .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_gbc );};if _gbc =_de .NewEncoder (SelfClosingWriter {_bf }).Encode (v );_gbc !=nil {return _a .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_gbc );};_ ,_gbc =_bf .Write (_cb );return _gbc ;};var _cb =[]byte {'\r','\n'};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_fg *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _fg ._gf ==nil {_fg ._gf =make (map[string ]Target );_fg ._bb =make (map[*_ba .Relationships ]string );_fg ._cg =make (map[string ]struct{});_fg ._ee =make (map[string ]int );};_fc :=_e .Clean (filePath );if _ ,_bbd :=_fg ._cg [_fc ];_bbd {return false ;};_fg ._cg [_fc ]=struct{}{};_fg ._gf [_fc ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_baa :=_g .Split (path ,"\u002f");_dac :=_g .Join (_baa [0:len (_baa )-1],"\u002f");_ac :=_baa [len (_baa )-1];_dac +="\u002f_\u0072\u0065\u006c\u0073\u002f";_ac +="\u002e\u0072\u0065l\u0073";return _dac +_ac ;};func (_ded *DecodeMap )RecordIndex (path string ,idx int ){_ded ._ee [path ]=idx };

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_gf map[string ]Target ;_bb map[*_ba .Relationships ]string ;_ed []Target ;_ga OnNewRelationshipFunc ;_cg map[string ]struct{};_ee map[string ]int ;};func (_aed *DecodeMap )IndexFor (path string )int {return _aed ._ee [path ]};

// Decode loops decoding targets registered with AddTarget and calling th
func (_dc *DecodeMap )Decode (files []*_c .File )error {_gab :=1;for _gab > 0{for len (_dc ._ed )> 0{_da :=_dc ._ed [0];_dc ._ed =_dc ._ed [1:];_fb :=_da .Ifc .(*_ba .Relationships );for _ ,_bc :=range _fb .Relationship {_ede ,_ :=_dc ._bb [_fb ];_dc ._ga (_dc ,_ede +_bc .TargetAttr ,_bc .TypeAttr ,files ,_bc ,_da );};};for _fe ,_bbf :=range files {if _bbf ==nil {continue ;};if _bae ,_bdg :=_dc ._gf [_bbf .Name ];_bdg {delete (_dc ._gf ,_bbf .Name );if _eb :=Decode (_bbf ,_bae .Ifc );_eb !=nil {return _eb ;};files [_fe ]=nil ;if _bdd ,_ca :=_bae .Ifc .(*_ba .Relationships );_ca {_dc ._ed =append (_dc ._ed ,_bae );_cf ,_ :=_e .Split (_e .Clean (_bbf .Name +"\u002f\u002e\u002e\u002f"));_dc ._bb [_bdd ]=_cf ;_gab ++;};};};_gab --;};return nil ;};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func MarshalXMLByTypeIndex (z *_c .Writer ,dt _bd .DocType ,typ string ,idx int ,v interface{})error {_bdc :=_bd .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_bdc ,v );};func (_eab SelfClosingWriter )Write (b []byte )(int ,error ){_dcg :=0;_fcfc :=0;for _cgc :=0;_cgc < len (b )-2;_cgc ++{if b [_cgc ]=='>'&&b [_cgc +1]=='<'&&b [_cgc +2]=='/'{_faea :=[]byte {};_fgb :=_cgc ;for _ece :=_cgc ;_ece >=0;_ece --{if b [_ece ]==' '{_fgb =_ece ;}else if b [_ece ]=='<'{_faea =b [_ece +1:_fgb ];break ;};};_adc :=[]byte {};for _bg :=_cgc +3;_bg < len (b );_bg ++{if b [_bg ]=='>'{_adc =b [_cgc +3:_bg ];break ;};};if !_ae .Equal (_faea ,_adc ){continue ;};_ddg ,_cd :=_eab .W .Write (b [_dcg :_cgc ]);if _cd !=nil {return _fcfc +_ddg ,_cd ;};_fcfc +=_ddg ;_ ,_cd =_eab .W .Write (_fac );if _cd !=nil {return _fcfc ,_cd ;};_fcfc +=3;for _edd :=_cgc +2;_edd < len (b )&&b [_edd ]!='>';_edd ++{_fcfc ++;_dcg =_edd +2;_cgc =_dcg ;};};};_fdc ,_df :=_eab .W .Write (b [_dcg :]);return _fdc +_fcfc ,_df ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_c .Writer ,zipPath ,storagePath string )error {_bdga ,_ffa :=z .Create (zipPath );if _ffa !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_ffa );};_gda ,_ffa :=_fa .Open (storagePath );if _ffa !=nil {return _a .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_ffa );};defer _gda .Close ();_ ,_ffa =_f .Copy (_bdga ,_gda );return _ffa ;};var _fac =[]byte {'/','>'};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_c .Writer ,zipPath string ,data []byte )error {_bda ,_dcc :=z .Create (zipPath );if _dcc !=nil {return _a .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_dcc );};_ ,_dcc =_f .Copy (_bda ,_ae .NewReader (data ));return _dcc ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _f .Writer ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_c .File ,path string )(string ,error ){_def ,_gec :=_fa .TempFile (path ,"\u007a\u007a");if _gec !=nil {return "",_gec ;};defer _def .Close ();_ad ,_gec :=f .Open ();if _gec !=nil {return "",_gec ;};defer _ad .Close ();_ ,_gec =_f .Copy (_def ,_ad );if _gec !=nil {return "",_gec ;};return _def .Name (),nil ;};