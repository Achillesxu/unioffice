//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_b "archive/zip";_f "bytes";_de "encoding/xml";_ac "fmt";_ca "github.com/unidoc/unioffice";_c "github.com/unidoc/unioffice/algo";_dd "github.com/unidoc/unioffice/common/tempstorage";_bc "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ae "io";_ag "path";_d "sort";_g "strings";_a "time";);const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";func (_cdc SelfClosingWriter )Write (b []byte )(int ,error ){_bbb :=0;_fbg :=0;for _dga :=0;_dga < len (b )-2;_dga ++{if b [_dga ]=='>'&&b [_dga +1]=='<'&&b [_dga +2]=='/'{_ffc :=[]byte {};_baf :=_dga ;for _cac :=_dga ;_cac >=0;_cac --{if b [_cac ]==' '{_baf =_cac ;}else if b [_cac ]=='<'{_ffc =b [_cac +1:_baf ];break ;};};_cae :=[]byte {};for _ebe :=_dga +3;_ebe < len (b );_ebe ++{if b [_ebe ]=='>'{_cae =b [_dga +3:_ebe ];break ;};};if !_f .Equal (_ffc ,_cae ){continue ;};_adf ,_caf :=_cdc .W .Write (b [_bbb :_dga ]);if _caf !=nil {return _fbg +_adf ,_caf ;};_fbg +=_adf ;_ ,_caf =_cdc .W .Write (_feg );if _caf !=nil {return _fbg ,_caf ;};_fbg +=3;for _bdd :=_dga +2;_bdd < len (b )&&b [_bdd ]!='>';_bdd ++{_fbg ++;_bbb =_bdd +2;_dga =_bbb ;};};};_fce ,_eda :=_cdc .W .Write (b [_bbb :]);return _fce +_fbg ,_eda ;};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_b .File ,dest interface{})error {_ed ,_cff :=f .Open ();if _cff !=nil {return _ac .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_cff );};defer _ed .Close ();_bca :=_de .NewDecoder (_ed );if _edb :=_bca .Decode (dest );_edb !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_edb );};if _ebb ,_aeg :=dest .(*_bc .Relationships );_aeg {for _fc ,_agef :=range _ebb .Relationship {switch _agef .TypeAttr {case _ca .OfficeDocumentTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .OfficeDocumentType ;case _ca .StylesTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .StylesType ;case _ca .ThemeTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ThemeType ;case _ca .ControlTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ControlType ;case _ca .SettingsTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .SettingsType ;case _ca .ImageTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ImageType ;case _ca .CommentsTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .CommentsType ;case _ca .ThumbnailTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ThumbnailType ;case _ca .DrawingTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .DrawingType ;case _ca .ChartTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ChartType ;case _ca .ExtendedPropertiesTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .ExtendedPropertiesType ;case _ca .CustomXMLTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .CustomXMLType ;case _ca .WorksheetTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .WorksheetType ;case _ca .SharedStringsTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .SharedStringsType ;case _ca .TableTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .TableType ;case _ca .HeaderTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .HeaderType ;case _ca .FooterTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .FooterType ;case _ca .NumberingTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .NumberingType ;case _ca .FontTableTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .FontTableType ;case _ca .WebSettingsTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .WebSettingsType ;case _ca .FootNotesTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .FootNotesType ;case _ca .EndNotesTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .EndNotesType ;case _ca .SlideTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .SlideType ;case _ca .VMLDrawingTypeStrict :_ebb .Relationship [_fc ].TypeAttr =_ca .VMLDrawingType ;};};_d .Slice (_ebb .Relationship ,func (_bcce ,_bcg int )bool {_bad :=_ebb .Relationship [_bcce ];_efb :=_ebb .Relationship [_bcg ];return _c .NaturalLess (_bad .IdAttr ,_efb .IdAttr );});};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_ab *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_ab ._dg =fn };

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_b .Writer ,zipPath string ,data []byte )error {_be ,_bg :=z .Create (zipPath );if _bg !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_bg );};_ ,_bg =_ae .Copy (_be ,_f .NewReader (data ));return _bg ;};func MarshalXMLByType (z *_b .Writer ,dt _ca .DocType ,typ string ,v interface{})error {_agf :=_ca .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_agf ,v );};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_b .File ,path string )(string ,error ){_afg ,_acd :=_dd .TempFile (path ,"\u007a\u007a");if _acd !=nil {return "",_acd ;};defer _afg .Close ();_agc ,_acd :=f .Open ();if _acd !=nil {return "",_acd ;};defer _agc .Close ();_ ,_acd =_ae .Copy (_afg ,_agc );if _acd !=nil {return "",_acd ;};return _afg .Name (),nil ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_da *DecodeMap )Decode (files []*_b .File )error {_dgb :=1;for _dgb > 0{for len (_da ._gf )> 0{_fe :=_da ._gf [0];_da ._gf =_da ._gf [1:];_aed :=_fe .Ifc .(*_bc .Relationships );for _ ,_fed :=range _aed .Relationship {_ffa ,_ :=_da ._ad [_aed ];_da ._dg (_da ,_ffa +_fed .TargetAttr ,_fed .TypeAttr ,files ,_fed ,_fe );};};for _efd ,_bfc :=range files {if _bfc ==nil {continue ;};if _bcc ,_af :=_da ._gg [_bfc .Name ];_af {delete (_da ._gg ,_bfc .Name );if _age :=Decode (_bfc ,_bcc .Ifc );_age !=nil {return _age ;};files [_efd ]=nil ;if _acg ,_cf :=_bcc .Ifc .(*_bc .Relationships );_cf {_da ._gf =append (_da ._gf ,_bcc );_deb ,_ :=_ag .Split (_ag .Clean (_bfc .Name +"\u002f\u002e\u002e\u002f"));_da ._ad [_acg ]=_deb ;_dgb ++;};};};_dgb --;};return nil ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_ea :=_g .Split (path ,"\u002f");_eg :=_g .Join (_ea [0:len (_ea )-1],"\u002f");_daa :=_ea [len (_ea )-1];_eg +="\u002f_\u0072\u0065\u006c\u0073\u002f";_daa +="\u002e\u0072\u0065l\u0073";return _eg +_daa ;};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_b .Writer ,zipPath ,storagePath string )error {_ce ,_gdg :=z .Create (zipPath );if _gdg !=nil {return _ac .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_gdg );};_bdb ,_gdg :=_dd .Open (storagePath );if _gdg !=nil {return _ac .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_gdg );};defer _bdb .Close ();_ ,_gdg =_ae .Copy (_ce ,_bdb );return _gdg ;};func (_ba *DecodeMap )IndexFor (path string )int {return _ba ._eb [path ]};func (_cg *DecodeMap )RecordIndex (path string ,idx int ){_cg ._eb [path ]=idx };

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_b .Writer ,filename string ,v interface{})error {_ageg :=&_b .FileHeader {};_ageg .Method =_b .Deflate ;_ageg .Name =filename ;_ageg .SetModTime (_a .Now ());_fa ,_fb :=z .CreateHeader (_ageg );if _fb !=nil {return _ac .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_fb );};_ ,_fb =_fa .Write ([]byte (XMLHeader ));if _fb !=nil {return _ac .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_fb );};if _fb =_de .NewEncoder (SelfClosingWriter {_fa }).Encode (v );_fb !=nil {return _ac .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_fb );};_ ,_fb =_fa .Write (_bag );return _fb ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_gd *DecodeMap ,_ef ,_aea string ,_bf []*_b .File ,_bff *_bc .Relationship ,_cd Target )error ;func MarshalXMLByTypeIndex (z *_b .Writer ,dt _ca .DocType ,typ string ,idx int ,v interface{})error {_cc :=_ca .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_cc ,v );};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_fdf *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _fdf ._gg ==nil {_fdf ._gg =make (map[string ]Target );_fdf ._ad =make (map[*_bc .Relationships ]string );_fdf ._fd =make (map[string ]struct{});_fdf ._eb =make (map[string ]int );};_bd :=_ag .Clean (filePath );if _ ,_ff :=_fdf ._fd [_bd ];_ff {return false ;};_fdf ._fd [_bd ]=struct{}{};_fdf ._gg [_bd ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _ae .Writer ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_gg map[string ]Target ;_ad map[*_bc .Relationships ]string ;_gf []Target ;_dg OnNewRelationshipFunc ;_fd map[string ]struct{};_eb map[string ]int ;};var _feg =[]byte {'/','>'};var _bag =[]byte {'\r','\n'};type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};