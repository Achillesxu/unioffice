//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_e "archive/zip";_cf "bytes";_dd "encoding/xml";_ca "fmt";_cfg "github.com/unidoc/unioffice";_ge "github.com/unidoc/unioffice/algo";_cfa "github.com/unidoc/unioffice/common/tempstorage";_g "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_b "io";_ee "path";_cd "sort";_c "strings";_f "time";);

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _b .Writer ;};func MarshalXMLByType (z *_e .Writer ,dt _cfg .DocType ,typ string ,v interface{})error {_gfd :=_cfg .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_gfd ,v );};func MarshalXMLByTypeIndex (z *_e .Writer ,dt _cfg .DocType ,typ string ,idx int ,v interface{})error {_gf :=_cfg .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_gf ,v );};func (_df *DecodeMap )IndexFor (path string )int {return _df ._db [path ]};var _bbc =[]byte {'\r','\n'};

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_e .Writer ,zipPath ,storagePath string )error {_bdc ,_dca :=z .Create (zipPath );if _dca !=nil {return _ca .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_dca );};_ac ,_dca :=_cfa .Open (storagePath );if _dca !=nil {return _ca .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_dca );};defer _ac .Close ();_ ,_dca =_b .Copy (_bdc ,_ac );return _dca ;};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_dcf :=_c .Split (path ,"\u002f");_cg :=_c .Join (_dcf [0:len (_dcf )-1],"\u002f");_cea :=_dcf [len (_dcf )-1];_cg +="\u002f_\u0072\u0065\u006c\u0073\u002f";_cea +="\u002e\u0072\u0065l\u0073";return _cg +_cea ;};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_e .File ,path string )(string ,error ){_ffg ,_agdf :=_cfa .TempFile (path ,"\u007a\u007a");if _agdf !=nil {return "",_agdf ;};defer _ffg .Close ();_cef ,_agdf :=f .Open ();if _agdf !=nil {return "",_agdf ;};defer _cef .Close ();_ ,_agdf =_b .Copy (_ffg ,_cef );if _agdf !=nil {return "",_agdf ;};return _ffg .Name (),nil ;};func (_ab *DecodeMap )RecordIndex (path string ,idx int ){_ab ._db [path ]=idx };

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_ga *DecodeMap ,_eeb ,_fe string ,_gea []*_e .File ,_cb *_g .Relationship ,_gg Target )error ;

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_e .Writer ,filename string ,v interface{})error {_ada :=&_e .FileHeader {};_ada .Method =_e .Deflate ;_ada .Name =filename ;_ada .SetModTime (_f .Now ());_ffb ,_aag :=z .CreateHeader (_ada );if _aag !=nil {return _ca .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_aag );};_ ,_aag =_ffb .Write ([]byte (XMLHeader ));if _aag !=nil {return _ca .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_aag );};if _aag =_dd .NewEncoder (SelfClosingWriter {_ffb }).Encode (v );_aag !=nil {return _ca .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_aag );};_ ,_aag =_ffb .Write (_bbc );return _aag ;};

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_gb *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _gb ._ed ==nil {_gb ._ed =make (map[string ]Target );_gb ._a =make (map[*_g .Relationships ]string );_gb ._gc =make (map[string ]struct{});_gb ._db =make (map[string ]int );};_gd :=_ee .Clean (filePath );if _ ,_af :=_gb ._gc [_gd ];_af {return false ;};_gb ._gc [_gd ]=struct{}{};_gb ._ed [_gd ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_ed map[string ]Target ;_a map[*_g .Relationships ]string ;_bd []Target ;_ggb OnNewRelationshipFunc ;_gc map[string ]struct{};_db map[string ]int ;};var _cae =[]byte {'/','>'};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_e .File ,dest interface{})error {_ff ,_aa :=f .Open ();if _aa !=nil {return _ca .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_aa );};defer _ff .Close ();_agd :=_dd .NewDecoder (_ff );if _dg :=_agd .Decode (dest );_dg !=nil {return _ca .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_dg );};if _gdd ,_ddc :=dest .(*_g .Relationships );_ddc {for _fde ,_ae :=range _gdd .Relationship {switch _ae .TypeAttr {case _cfg .OfficeDocumentTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .OfficeDocumentType ;case _cfg .StylesTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .StylesType ;case _cfg .ThemeTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ThemeType ;case _cfg .ControlTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ControlType ;case _cfg .SettingsTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .SettingsType ;case _cfg .ImageTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ImageType ;case _cfg .CommentsTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .CommentsType ;case _cfg .ThumbnailTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ThumbnailType ;case _cfg .DrawingTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .DrawingType ;case _cfg .ChartTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ChartType ;case _cfg .ExtendedPropertiesTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .ExtendedPropertiesType ;case _cfg .CustomXMLTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .CustomXMLType ;case _cfg .WorksheetTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .WorksheetType ;case _cfg .SharedStringsTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .SharedStringsType ;case _cfg .TableTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .TableType ;case _cfg .HeaderTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .HeaderType ;case _cfg .FooterTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .FooterType ;case _cfg .NumberingTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .NumberingType ;case _cfg .FontTableTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .FontTableType ;case _cfg .WebSettingsTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .WebSettingsType ;case _cfg .FootNotesTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .FootNotesType ;case _cfg .EndNotesTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .EndNotesType ;case _cfg .SlideTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .SlideType ;case _cfg .VMLDrawingTypeStrict :_gdd .Relationship [_fde ].TypeAttr =_cfg .VMLDrawingType ;};};_cd .Slice (_gdd .Relationship ,func (_ebc ,_ad int )bool {_dda :=_gdd .Relationship [_ebc ];_ddd :=_gdd .Relationship [_ad ];return _ge .NaturalLess (_dda .IdAttr ,_ddd .IdAttr );});};return nil ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_dbd *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_dbd ._ggb =fn };const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};func (_ddde SelfClosingWriter )Write (b []byte )(int ,error ){_gfe :=0;_dfc :=0;for _ede :=0;_ede < len (b )-2;_ede ++{if b [_ede ]=='>'&&b [_ede +1]=='<'&&b [_ede +2]=='/'{_cdeg :=[]byte {};_cc :=_ede ;for _afg :=_ede ;_afg >=0;_afg --{if b [_afg ]==' '{_cc =_afg ;}else if b [_afg ]=='<'{_cdeg =b [_afg +1:_cc ];break ;};};_adf :=[]byte {};for _ced :=_ede +3;_ced < len (b );_ced ++{if b [_ced ]=='>'{_adf =b [_ede +3:_ced ];break ;};};if !_cf .Equal (_cdeg ,_adf ){continue ;};_aab ,_eede :=_ddde .W .Write (b [_gfe :_ede ]);if _eede !=nil {return _dfc +_aab ,_eede ;};_dfc +=_aab ;_ ,_eede =_ddde .W .Write (_cae );if _eede !=nil {return _dfc ,_eede ;};_dfc +=3;for _dbc :=_ede +2;_dbc < len (b )&&b [_dbc ]!='>';_dbc ++{_dfc ++;_gfe =_dbc +2;_ede =_gfe ;};};};_gfdf ,_dfe :=_ddde .W .Write (b [_gfe :]);return _gfdf +_dfc ,_dfe ;};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_e .Writer ,zipPath string ,data []byte )error {_bca ,_fcb :=z .Create (zipPath );if _fcb !=nil {return _ca .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_fcb );};_ ,_fcb =_b .Copy (_bca ,_cf .NewReader (data ));return _fcb ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_cde *DecodeMap )Decode (files []*_e .File )error {_bb :=1;for _bb > 0{for len (_cde ._bd )> 0{_dbda :=_cde ._bd [0];_cde ._bd =_cde ._bd [1:];_bde :=_dbda .Ifc .(*_g .Relationships );for _ ,_dbdf :=range _bde .Relationship {_eb ,_ :=_cde ._a [_bde ];_cde ._ggb (_cde ,_eb +_dbdf .TargetAttr ,_dbdf .TypeAttr ,files ,_dbdf ,_dbda );};};for _dfb ,_fb :=range files {if _fb ==nil {continue ;};if _afd ,_ce :=_cde ._ed [_fb .Name ];_ce {delete (_cde ._ed ,_fb .Name );if _fcd :=Decode (_fb ,_afd .Ifc );_fcd !=nil {return _fcd ;};files [_dfb ]=nil ;if _geaa ,_ea :=_afd .Ifc .(*_g .Relationships );_ea {_cde ._bd =append (_cde ._bd ,_afd );_dc ,_ :=_ee .Split (_ee .Clean (_fb .Name +"\u002f\u002e\u002e\u002f"));_cde ._a [_geaa ]=_dc ;_bb ++;};};};_bb --;};return nil ;};