//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg ;import (_g "archive/zip";_db "bytes";_f "encoding/xml";_gc "fmt";_be "github.com/unidoc/unioffice";_cf "github.com/unidoc/unioffice/algo";_e "github.com/unidoc/unioffice/common/tempstorage";_fd "github.com/unidoc/unioffice/schema/soo/pkg/relationships";_ce "io";_df "path";_dd "sort";_c "strings";_d "time";);

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_geg *DecodeMap )AddTarget (filePath string ,ifc interface{},sourceFileType string ,idx uint32 )bool {if _geg ._bb ==nil {_geg ._bb =make (map[string ]Target );_geg ._eb =make (map[*_fd .Relationships ]string );_geg ._edd =make (map[string ]struct{});_geg ._eed =make (map[string ]int );};_ea :=_df .Clean (filePath );if _ ,_dag :=_geg ._edd [_ea ];_dag {return false ;};_geg ._edd [_ea ]=struct{}{};_geg ._bb [_ea ]=Target {Path :filePath ,Typ :sourceFileType ,Ifc :ifc ,Index :idx };return true ;};var _agg =[]byte {'\r','\n'};func (_ab *DecodeMap )IndexFor (path string )int {return _ab ._eed [path ]};

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode (f *_g .File ,dest interface{})error {_beg ,_gf :=f .Open ();if _gf !=nil {return _gc .Errorf ("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",f .Name ,_gf );};defer _beg .Close ();_cea :=_f .NewDecoder (_beg );if _cgb :=_cea .Decode (dest );_cgb !=nil {return _gc .Errorf ("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",f .Name ,_cgb );};if _ccc ,_fb :=dest .(*_fd .Relationships );_fb {for _ba ,_def :=range _ccc .Relationship {switch _def .TypeAttr {case _be .OfficeDocumentTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .OfficeDocumentType ;case _be .StylesTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .StylesType ;case _be .ThemeTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ThemeType ;case _be .ControlTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ControlType ;case _be .SettingsTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .SettingsType ;case _be .ImageTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ImageType ;case _be .CommentsTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .CommentsType ;case _be .ThumbnailTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ThumbnailType ;case _be .DrawingTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .DrawingType ;case _be .ChartTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ChartType ;case _be .ExtendedPropertiesTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .ExtendedPropertiesType ;case _be .CustomXMLTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .CustomXMLType ;case _be .WorksheetTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .WorksheetType ;case _be .SharedStringsTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .SharedStringsType ;case _be .TableTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .TableType ;case _be .HeaderTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .HeaderType ;case _be .FooterTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .FooterType ;case _be .NumberingTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .NumberingType ;case _be .FontTableTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .FontTableType ;case _be .WebSettingsTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .WebSettingsType ;case _be .FootNotesTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .FootNotesType ;case _be .EndNotesTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .EndNotesType ;case _be .SlideTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .SlideType ;case _be .VMLDrawingTypeStrict :_ccc .Relationship [_ba ].TypeAttr =_be .VMLDrawingType ;};};_dd .Slice (_ccc .Relationship ,func (_dee ,_ddg int )bool {_daf :=_ccc .Relationship [_dee ];_fc :=_ccc .Relationship [_ddg ];return _cf .NaturalLess (_daf .IdAttr ,_fc .IdAttr );});};return nil ;};

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct{_bb map[string ]Target ;_eb map[*_fd .Relationships ]string ;_a []Target ;_ed OnNewRelationshipFunc ;_edd map[string ]struct{};_eed map[string ]int ;};

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func (_ge *DecodeMap ,_ee ,_gd string ,_cb []*_g .File ,_da *_fd .Relationship ,_fe Target )error ;func (_deg SelfClosingWriter )Write (b []byte )(int ,error ){_aff :=0;_feg :=0;for _gdf :=0;_gdf < len (b )-2;_gdf ++{if b [_gdf ]=='>'&&b [_gdf +1]=='<'&&b [_gdf +2]=='/'{_bae :=[]byte {};_fg :=_gdf ;for _bd :=_gdf ;_bd >=0;_bd --{if b [_bd ]==' '{_fg =_bd ;}else if b [_bd ]=='<'{_bae =b [_bd +1:_fg ];break ;};};_ef :=[]byte {};for _gg :=_gdf +3;_gg < len (b );_gg ++{if b [_gg ]=='>'{_ef =b [_gdf +3:_gg ];break ;};};if !_db .Equal (_bae ,_ef ){continue ;};_bfa ,_bga :=_deg .W .Write (b [_aff :_gdf ]);if _bga !=nil {return _feg +_bfa ,_bga ;};_feg +=_bfa ;_ ,_bga =_deg .W .Write (_bgb );if _bga !=nil {return _feg ,_bga ;};_feg +=3;for _bfad :=_gdf +2;_bfad < len (b )&&b [_bfad ]!='>';_bfad ++{_feg ++;_aff =_bfad +2;_gdf =_aff ;};};};_egdf ,_ca :=_deg .W .Write (b [_aff :]);return _egdf +_feg ,_ca ;};const XMLHeader ="\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e"+"\u000a";

// AddFileFromDisk reads a file from internal storage and adds it at a given path to a zip file.
// TODO: Rename to AddFileFromStorage in next major version release (v2).
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromDisk (z *_g .Writer ,zipPath ,storagePath string )error {_fcb ,_egc :=z .Create (zipPath );if _egc !=nil {return _gc .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_egc );};_dbb ,_egc :=_e .Open (storagePath );if _egc !=nil {return _gc .Errorf ("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073",storagePath ,_egc );};defer _dbb .Close ();_ ,_egc =_ce .Copy (_fcb ,_dbb );return _egc ;};func MarshalXMLByType (z *_g .Writer ,dt _be .DocType ,typ string ,v interface{})error {_ebd :=_be .AbsoluteFilename (dt ,typ ,0);return MarshalXML (z ,_ebd ,v );};

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes (z *_g .Writer ,zipPath string ,data []byte )error {_eaf ,_fce :=z .Create (zipPath );if _fce !=nil {return _gc .Errorf ("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073",zipPath ,_fce );};_ ,_fce =_ce .Copy (_eaf ,_db .NewReader (data ));return _fce ;};func (_ff *DecodeMap )RecordIndex (path string ,idx int ){_ff ._eed [path ]=idx };var _bgb =[]byte {'/','>'};

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp (f *_g .File ,path string )(string ,error ){_egd ,_gfe :=_e .TempFile (path ,"\u007a\u007a");if _gfe !=nil {return "",_gfe ;};defer _egd .Close ();_cec ,_gfe :=f .Open ();if _gfe !=nil {return "",_gfe ;};defer _cec .Close ();_ ,_gfe =_ce .Copy (_egd ,_cec );if _gfe !=nil {return "",_gfe ;};return _egd .Name (),nil ;};func MarshalXMLByTypeIndex (z *_g .Writer ,dt _be .DocType ,typ string ,idx int ,v interface{})error {_faa :=_be .AbsoluteFilename (dt ,typ ,idx );return MarshalXML (z ,_faa ,v );};

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor (path string )string {_cd :=_c .Split (path ,"\u002f");_gdg :=_c .Join (_cd [0:len (_cd )-1],"\u002f");_ffc :=_cd [len (_cd )-1];_gdg +="\u002f_\u0072\u0065\u006c\u0073\u002f";_ffc +="\u002e\u0072\u0065l\u0073";return _gdg +_ffc ;};

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML (z *_g .Writer ,filename string ,v interface{})error {_bc :=&_g .FileHeader {};_bc .Method =_g .Deflate ;_bc .Name =filename ;_bc .SetModTime (_d .Now ());_cbg ,_agd :=z .CreateHeader (_bc );if _agd !=nil {return _gc .Errorf ("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073",filename ,_agd );};_ ,_agd =_cbg .Write ([]byte (XMLHeader ));if _agd !=nil {return _gc .Errorf ("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073",filename ,_agd );};if _agd =_f .NewEncoder (SelfClosingWriter {_cbg }).Encode (v );_agd !=nil {return _gc .Errorf ("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073",filename ,_agd );};_ ,_agd =_cbg .Write (_agg );return _agd ;};

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_fa *DecodeMap )SetOnNewRelationshipFunc (fn OnNewRelationshipFunc ){_fa ._ed =fn };type Target struct{Path string ;Typ string ;Ifc interface{};Index uint32 ;};

// Decode loops decoding targets registered with AddTarget and calling th
func (_af *DecodeMap )Decode (files []*_g .File )error {_bg :=1;for _bg > 0{for len (_af ._a )> 0{_bbe :=_af ._a [0];_af ._a =_af ._a [1:];_ad :=_bbe .Ifc .(*_fd .Relationships );for _ ,_de :=range _ad .Relationship {_eg ,_ :=_af ._eb [_ad ];_af ._ed (_af ,_eg +_de .TargetAttr ,_de .TypeAttr ,files ,_de ,_bbe );};};for _dac ,_gdc :=range files {if _gdc ==nil {continue ;};if _cc ,_ag :=_af ._bb [_gdc .Name ];_ag {delete (_af ._bb ,_gdc .Name );if _fdb :=Decode (_gdc ,_cc .Ifc );_fdb !=nil {return _fdb ;};files [_dac ]=nil ;if _ec ,_cg :=_cc .Ifc .(*_fd .Relationships );_cg {_af ._a =append (_af ._a ,_cc );_ede ,_ :=_df .Split (_df .Clean (_gdc .Name +"\u002f\u002e\u002e\u002f"));_af ._eb [_ec ]=_ede ;_bg ++;};};};_bg --;};return nil ;};

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{W _ce .Writer ;};